var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);

// node_modules/maplibre-gl/dist/maplibre-gl.js
var require_maplibre_gl = __commonJS((exports, module) => {
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.maplibregl = factory());
  })(exports, function() {
    var maplibregl = {};
    var modules = {};
    function define2(moduleName, _dependencies, moduleFactory) {
      modules[moduleName] = moduleFactory;
      if (moduleName !== "index") {
        return;
      }
      var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
      var sharedModule = {};
      modules.shared(sharedModule);
      modules.index(maplibregl, sharedModule);
      if (typeof window !== "undefined") {
        maplibregl.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
      }
      return maplibregl;
    }
    define2("shared", ["exports"], function(t) {
      function e(t2, e2, r2, n2) {
        return new (r2 || (r2 = Promise))(function(i2, s2) {
          function a2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              s2(t4);
            }
          }
          function o2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              s2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? i2(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
              t4(e3);
            })).then(a2, o2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      }
      function r(t2) {
        return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
      }
      typeof SuppressedError == "function" && SuppressedError;
      var n = i;
      function i(t2, e2) {
        this.x = t2, this.y = e2;
      }
      i.prototype = { clone: function() {
        return new i(this.x, this.y);
      }, add: function(t2) {
        return this.clone()._add(t2);
      }, sub: function(t2) {
        return this.clone()._sub(t2);
      }, multByPoint: function(t2) {
        return this.clone()._multByPoint(t2);
      }, divByPoint: function(t2) {
        return this.clone()._divByPoint(t2);
      }, mult: function(t2) {
        return this.clone()._mult(t2);
      }, div: function(t2) {
        return this.clone()._div(t2);
      }, rotate: function(t2) {
        return this.clone()._rotate(t2);
      }, rotateAround: function(t2, e2) {
        return this.clone()._rotateAround(t2, e2);
      }, matMult: function(t2) {
        return this.clone()._matMult(t2);
      }, unit: function() {
        return this.clone()._unit();
      }, perp: function() {
        return this.clone()._perp();
      }, round: function() {
        return this.clone()._round();
      }, mag: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }, equals: function(t2) {
        return this.x === t2.x && this.y === t2.y;
      }, dist: function(t2) {
        return Math.sqrt(this.distSqr(t2));
      }, distSqr: function(t2) {
        var e2 = t2.x - this.x, r2 = t2.y - this.y;
        return e2 * e2 + r2 * r2;
      }, angle: function() {
        return Math.atan2(this.y, this.x);
      }, angleTo: function(t2) {
        return Math.atan2(this.y - t2.y, this.x - t2.x);
      }, angleWith: function(t2) {
        return this.angleWithSep(t2.x, t2.y);
      }, angleWithSep: function(t2, e2) {
        return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
      }, _matMult: function(t2) {
        var e2 = t2[2] * this.x + t2[3] * this.y;
        return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
      }, _add: function(t2) {
        return this.x += t2.x, this.y += t2.y, this;
      }, _sub: function(t2) {
        return this.x -= t2.x, this.y -= t2.y, this;
      }, _mult: function(t2) {
        return this.x *= t2, this.y *= t2, this;
      }, _div: function(t2) {
        return this.x /= t2, this.y /= t2, this;
      }, _multByPoint: function(t2) {
        return this.x *= t2.x, this.y *= t2.y, this;
      }, _divByPoint: function(t2) {
        return this.x /= t2.x, this.y /= t2.y, this;
      }, _unit: function() {
        return this._div(this.mag()), this;
      }, _perp: function() {
        var t2 = this.y;
        return this.y = this.x, this.x = -t2, this;
      }, _rotate: function(t2) {
        var e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e2 * this.y;
        return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
      }, _rotateAround: function(t2, e2) {
        var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
        return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
      }, _round: function() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      } }, i.convert = function(t2) {
        return t2 instanceof i ? t2 : Array.isArray(t2) ? new i(t2[0], t2[1]) : t2;
      };
      var s = r(n), a = o;
      function o(t2, e2, r2, n2) {
        this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r2, this.p2y = n2;
      }
      o.prototype = { sampleCurveX: function(t2) {
        return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
      }, sampleCurveY: function(t2) {
        return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
      }, sampleCurveDerivativeX: function(t2) {
        return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
      }, solveCurveX: function(t2, e2) {
        if (e2 === undefined && (e2 = 0.000001), t2 < 0)
          return 0;
        if (t2 > 1)
          return 1;
        for (var r2 = t2, n2 = 0;n2 < 8; n2++) {
          var i2 = this.sampleCurveX(r2) - t2;
          if (Math.abs(i2) < e2)
            return r2;
          var s2 = this.sampleCurveDerivativeX(r2);
          if (Math.abs(s2) < 0.000001)
            break;
          r2 -= i2 / s2;
        }
        var a2 = 0, o2 = 1;
        for (r2 = t2, n2 = 0;n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e2)); n2++)
          t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
        return r2;
      }, solve: function(t2, e2) {
        return this.sampleCurveY(this.solveCurveX(t2, e2));
      } };
      var l = r(a);
      let u4, c;
      function h() {
        return u4 == null && (u4 = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), u4;
      }
      function p() {
        if (c == null && (c = false, h())) {
          const t2 = 5, e2 = new OffscreenCanvas(t2, t2).getContext("2d", { willReadFrequently: true });
          if (e2) {
            for (let r3 = 0;r3 < t2 * t2; r3++) {
              const n2 = 4 * r3;
              e2.fillStyle = `rgb(${n2},${n2 + 1},${n2 + 2})`, e2.fillRect(r3 % t2, Math.floor(r3 / t2), 1, 1);
            }
            const r2 = e2.getImageData(0, 0, t2, t2).data;
            for (let e3 = 0;e3 < t2 * t2 * 4; e3++)
              if (e3 % 4 != 3 && r2[e3] !== e3) {
                c = true;
                break;
              }
          }
        }
        return c || false;
      }
      function f(t2, e2, r2, n2) {
        const i2 = new l(t2, e2, r2, n2);
        return (t3) => i2.solve(t3);
      }
      const d = f(0.25, 0.1, 0.25, 1);
      function y(t2, e2, r2) {
        return Math.min(r2, Math.max(e2, t2));
      }
      function m(t2, e2, r2) {
        const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
        return i2 === e2 ? r2 : i2;
      }
      function g(t2, ...e2) {
        for (const r2 of e2)
          for (const e3 in r2)
            t2[e3] = r2[e3];
        return t2;
      }
      let x = 1;
      function v2(t2, e2, r2) {
        const n2 = {};
        for (const r3 in t2)
          n2[r3] = e2.call(this, t2[r3], r3, t2);
        return n2;
      }
      function b(t2, e2, r2) {
        const n2 = {};
        for (const r3 in t2)
          e2.call(this, t2[r3], r3, t2) && (n2[r3] = t2[r3]);
        return n2;
      }
      function w(t2) {
        return Array.isArray(t2) ? t2.map(w) : typeof t2 == "object" && t2 ? v2(t2, w) : t2;
      }
      const _ = {};
      function A(t2) {
        _[t2] || (typeof console != "undefined" && console.warn(t2), _[t2] = true);
      }
      function S(t2, e2, r2) {
        return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
      }
      function k(t2) {
        return typeof WorkerGlobalScope != "undefined" && t2 !== undefined && t2 instanceof WorkerGlobalScope;
      }
      let M = null;
      function I(t2) {
        return typeof ImageBitmap != "undefined" && t2 instanceof ImageBitmap;
      }
      const z = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function P(t2, r2, n2, i2, s2) {
        return e(this, undefined, undefined, function* () {
          if (typeof VideoFrame == "undefined")
            throw new Error("VideoFrame not supported");
          const e2 = new VideoFrame(t2, { timestamp: 0 });
          try {
            const a2 = e2 == null ? undefined : e2.format;
            if (!a2 || !a2.startsWith("BGR") && !a2.startsWith("RGB"))
              throw new Error(`Unrecognized format ${a2}`);
            const o2 = a2.startsWith("BGR"), l2 = new Uint8ClampedArray(i2 * s2 * 4);
            if (yield e2.copyTo(l2, function(t3, e3, r3, n3, i3) {
              const s3 = 4 * Math.max(-e3, 0), a3 = (Math.max(0, r3) - r3) * n3 * 4 + s3, o3 = 4 * n3, l3 = Math.max(0, e3), u5 = Math.max(0, r3);
              return { rect: { x: l3, y: u5, width: Math.min(t3.width, e3 + n3) - l3, height: Math.min(t3.height, r3 + i3) - u5 }, layout: [{ offset: a3, stride: o3 }] };
            }(t2, r2, n2, i2, s2)), o2)
              for (let t3 = 0;t3 < l2.length; t3 += 4) {
                const e3 = l2[t3];
                l2[t3] = l2[t3 + 2], l2[t3 + 2] = e3;
              }
            return l2;
          } finally {
            e2.close();
          }
        });
      }
      let C, B2;
      const V = "AbortError";
      function E() {
        return new Error(V);
      }
      const F = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
      function T(t2) {
        return F.REGISTERED_PROTOCOLS[t2.substring(0, t2.indexOf("://"))];
      }
      const $ = "global-dispatcher";

      class L extends Error {
        constructor(t2, e2, r2, n2) {
          super(`AJAXError: ${e2} (${t2}): ${r2}`), this.status = t2, this.statusText = e2, this.url = r2, this.body = n2;
        }
      }
      const D2 = () => k(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, O = function(t2, r2) {
        if (/:\/\//.test(t2.url) && !/^https?:|^file:/.test(t2.url)) {
          const e2 = T(t2.url);
          if (e2)
            return e2(t2, r2);
          if (k(self) && self.worker && self.worker.actor)
            return self.worker.actor.sendAsync({ type: "GR", data: t2, targetMapId: $ }, r2);
        }
        if (!(/^file:/.test(n2 = t2.url) || /^file:/.test(D2()) && !/^\w+:/.test(n2))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
            return function(t3, r3) {
              return e(this, undefined, undefined, function* () {
                const e2 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, cache: t3.cache, referrer: D2(), signal: r3.signal });
                t3.type !== "json" || e2.headers.has("Accept") || e2.headers.set("Accept", "application/json");
                const n3 = yield fetch(e2);
                if (!n3.ok) {
                  const e3 = yield n3.blob();
                  throw new L(n3.status, n3.statusText, t3.url, e3);
                }
                let i2;
                i2 = t3.type === "arrayBuffer" || t3.type === "image" ? n3.arrayBuffer() : t3.type === "json" ? n3.json() : n3.text();
                const s2 = yield i2;
                if (r3.signal.aborted)
                  throw E();
                return { data: s2, cacheControl: n3.headers.get("Cache-Control"), expires: n3.headers.get("Expires") };
              });
            }(t2, r2);
          if (k(self) && self.worker && self.worker.actor)
            return self.worker.actor.sendAsync({ type: "GR", data: t2, mustQueue: true, targetMapId: $ }, r2);
        }
        var n2;
        return function(t3, e2) {
          return new Promise((r3, n3) => {
            var i2;
            const s2 = new XMLHttpRequest;
            s2.open(t3.method || "GET", t3.url, true), t3.type !== "arrayBuffer" && t3.type !== "image" || (s2.responseType = "arraybuffer");
            for (const e3 in t3.headers)
              s2.setRequestHeader(e3, t3.headers[e3]);
            t3.type === "json" && (s2.responseType = "text", ((i2 = t3.headers) === null || i2 === undefined ? undefined : i2.Accept) || s2.setRequestHeader("Accept", "application/json")), s2.withCredentials = t3.credentials === "include", s2.onerror = () => {
              n3(new Error(s2.statusText));
            }, s2.onload = () => {
              if (!e2.signal.aborted)
                if ((s2.status >= 200 && s2.status < 300 || s2.status === 0) && s2.response !== null) {
                  let e3 = s2.response;
                  if (t3.type === "json")
                    try {
                      e3 = JSON.parse(s2.response);
                    } catch (t4) {
                      return void n3(t4);
                    }
                  r3({ data: e3, cacheControl: s2.getResponseHeader("Cache-Control"), expires: s2.getResponseHeader("Expires") });
                } else {
                  const e3 = new Blob([s2.response], { type: s2.getResponseHeader("Content-Type") });
                  n3(new L(s2.status, s2.statusText, t3.url, e3));
                }
            }, e2.signal.addEventListener("abort", () => {
              s2.abort(), n3(E());
            }), s2.send(t3.body);
          });
        }(t2, r2);
      };
      function j(t2) {
        if (!t2 || t2.indexOf("://") <= 0 || t2.indexOf("data:image/") === 0 || t2.indexOf("blob:") === 0)
          return true;
        const e2 = new URL(t2), r2 = window.location;
        return e2.protocol === r2.protocol && e2.host === r2.host;
      }
      function R(t2, e2, r2) {
        r2[t2] && r2[t2].indexOf(e2) !== -1 || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
      }
      function U(t2, e2, r2) {
        if (r2 && r2[t2]) {
          const n2 = r2[t2].indexOf(e2);
          n2 !== -1 && r2[t2].splice(n2, 1);
        }
      }

      class q {
        constructor(t2, e2 = {}) {
          g(this, e2), this.type = t2;
        }
      }

      class N extends q {
        constructor(t2, e2 = {}) {
          super("error", g({ error: t2 }, e2));
        }
      }

      class Z {
        on(t2, e2) {
          return this._listeners = this._listeners || {}, R(t2, e2, this._listeners), this;
        }
        off(t2, e2) {
          return U(t2, e2, this._listeners), U(t2, e2, this._oneTimeListeners), this;
        }
        once(t2, e2) {
          return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, R(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
        }
        fire(t2, e2) {
          typeof t2 == "string" && (t2 = new q(t2, e2 || {}));
          const r2 = t2.type;
          if (this.listens(r2)) {
            t2.target = this;
            const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
            for (const r3 of e3)
              r3.call(this, t2);
            const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
            for (const e4 of n2)
              U(r2, e4, this._oneTimeListeners), e4.call(this, t2);
            const i2 = this._eventedParent;
            i2 && (g(t2, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
          } else
            t2 instanceof N && console.error(t2.error);
          return this;
        }
        listens(t2) {
          return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
        }
        setEventedParent(t2, e2) {
          return this._eventedParent = t2, this._eventedParentData = e2, this;
        }
      }
      var G = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "enum", default: "mercator", values: { mercator: {}, globe: {} } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      const K = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function X(t2, e2) {
        const r2 = {};
        for (const e3 in t2)
          e3 !== "ref" && (r2[e3] = t2[e3]);
        return K.forEach((t3) => {
          t3 in e2 && (r2[t3] = e2[t3]);
        }), r2;
      }
      function H(t2, e2) {
        if (Array.isArray(t2)) {
          if (!Array.isArray(e2) || t2.length !== e2.length)
            return false;
          for (let r2 = 0;r2 < t2.length; r2++)
            if (!H(t2[r2], e2[r2]))
              return false;
          return true;
        }
        if (typeof t2 == "object" && t2 !== null && e2 !== null) {
          if (typeof e2 != "object")
            return false;
          if (Object.keys(t2).length !== Object.keys(e2).length)
            return false;
          for (const r2 in t2)
            if (!H(t2[r2], e2[r2]))
              return false;
          return true;
        }
        return t2 === e2;
      }
      function Y(t2, e2) {
        t2.push(e2);
      }
      function J(t2, e2, r2) {
        Y(r2, { command: "addSource", args: [t2, e2[t2]] });
      }
      function W(t2, e2, r2) {
        Y(e2, { command: "removeSource", args: [t2] }), r2[t2] = true;
      }
      function Q(t2, e2, r2, n2) {
        W(t2, r2, n2), J(t2, e2, r2);
      }
      function tt(t2, e2, r2) {
        let n2;
        for (n2 in t2[r2])
          if (Object.prototype.hasOwnProperty.call(t2[r2], n2) && n2 !== "data" && !H(t2[r2][n2], e2[r2][n2]))
            return false;
        for (n2 in e2[r2])
          if (Object.prototype.hasOwnProperty.call(e2[r2], n2) && n2 !== "data" && !H(t2[r2][n2], e2[r2][n2]))
            return false;
        return true;
      }
      function et(t2, e2, r2, n2, i2, s2) {
        t2 = t2 || {}, e2 = e2 || {};
        for (const a2 in t2)
          Object.prototype.hasOwnProperty.call(t2, a2) && (H(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
        for (const a2 in e2)
          Object.prototype.hasOwnProperty.call(e2, a2) && !Object.prototype.hasOwnProperty.call(t2, a2) && (H(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
      }
      function rt(t2) {
        return t2.id;
      }
      function nt(t2, e2) {
        return t2[e2.id] = e2, t2;
      }

      class it {
        constructor(t2, e2, r2, n2) {
          this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), e2 != null && e2.__line__ && (this.line = e2.__line__);
        }
      }
      function st(t2, ...e2) {
        for (const r2 of e2)
          for (const e3 in r2)
            t2[e3] = r2[e3];
        return t2;
      }

      class at extends Error {
        constructor(t2, e2) {
          super(e2), this.message = e2, this.key = t2;
        }
      }

      class ot {
        constructor(t2, e2 = []) {
          this.parent = t2, this.bindings = {};
          for (const [t3, r2] of e2)
            this.bindings[t3] = r2;
        }
        concat(t2) {
          return new ot(this, t2);
        }
        get(t2) {
          if (this.bindings[t2])
            return this.bindings[t2];
          if (this.parent)
            return this.parent.get(t2);
          throw new Error(`${t2} not found in scope.`);
        }
        has(t2) {
          return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
        }
      }
      const lt = { kind: "null" }, ut = { kind: "number" }, ct = { kind: "string" }, ht = { kind: "boolean" }, pt = { kind: "color" }, ft = { kind: "object" }, dt = { kind: "value" }, yt = { kind: "collator" }, mt = { kind: "formatted" }, gt = { kind: "padding" }, xt = { kind: "resolvedImage" }, vt = { kind: "variableAnchorOffsetCollection" };
      function bt(t2, e2) {
        return { kind: "array", itemType: t2, N: e2 };
      }
      function wt(t2) {
        if (t2.kind === "array") {
          const e2 = wt(t2.itemType);
          return typeof t2.N == "number" ? `array<${e2}, ${t2.N}>` : t2.itemType.kind === "value" ? "array" : `array<${e2}>`;
        }
        return t2.kind;
      }
      const _t = [lt, ut, ct, ht, pt, mt, ft, bt(dt), gt, xt, vt];
      function At(t2, e2) {
        if (e2.kind === "error")
          return null;
        if (t2.kind === "array") {
          if (e2.kind === "array" && (e2.N === 0 && e2.itemType.kind === "value" || !At(t2.itemType, e2.itemType)) && (typeof t2.N != "number" || t2.N === e2.N))
            return null;
        } else {
          if (t2.kind === e2.kind)
            return null;
          if (t2.kind === "value") {
            for (const t3 of _t)
              if (!At(t3, e2))
                return null;
          }
        }
        return `Expected ${wt(t2)} but found ${wt(e2)} instead.`;
      }
      function St(t2, e2) {
        return e2.some((e3) => e3.kind === t2.kind);
      }
      function kt(t2, e2) {
        return e2.some((e3) => e3 === "null" ? t2 === null : e3 === "array" ? Array.isArray(t2) : e3 === "object" ? t2 && !Array.isArray(t2) && typeof t2 == "object" : e3 === typeof t2);
      }
      function Mt(t2, e2) {
        return t2.kind === "array" && e2.kind === "array" ? t2.itemType.kind === e2.itemType.kind && typeof t2.N == "number" : t2.kind === e2.kind;
      }
      const It = 0.96422, zt = 0.82521, Pt = 4 / 29, Ct = 6 / 29, Bt = 3 * Ct * Ct, Vt = Ct * Ct * Ct, Et = Math.PI / 180, Ft = 180 / Math.PI;
      function Tt(t2) {
        return (t2 %= 360) < 0 && (t2 += 360), t2;
      }
      function $t([t2, e2, r2, n2]) {
        let i2, s2;
        const a2 = Dt((0.2225045 * (t2 = Lt(t2)) + 0.7168786 * (e2 = Lt(e2)) + 0.0606169 * (r2 = Lt(r2))) / 1);
        t2 === e2 && e2 === r2 ? i2 = s2 = a2 : (i2 = Dt((0.4360747 * t2 + 0.3850649 * e2 + 0.1430804 * r2) / It), s2 = Dt((0.0139322 * t2 + 0.0971045 * e2 + 0.7141733 * r2) / zt));
        const o2 = 116 * a2 - 16;
        return [o2 < 0 ? 0 : o2, 500 * (i2 - a2), 200 * (a2 - s2), n2];
      }
      function Lt(t2) {
        return t2 <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
      }
      function Dt(t2) {
        return t2 > Vt ? Math.pow(t2, 1 / 3) : t2 / Bt + Pt;
      }
      function Ot([t2, e2, r2, n2]) {
        let i2 = (t2 + 16) / 116, s2 = isNaN(e2) ? i2 : i2 + e2 / 500, a2 = isNaN(r2) ? i2 : i2 - r2 / 200;
        return i2 = 1 * Rt(i2), s2 = It * Rt(s2), a2 = zt * Rt(a2), [jt(3.1338561 * s2 - 1.6168667 * i2 - 0.4906146 * a2), jt(-0.9787684 * s2 + 1.9161415 * i2 + 0.033454 * a2), jt(0.0719453 * s2 - 0.2289914 * i2 + 1.4052427 * a2), n2];
      }
      function jt(t2) {
        return (t2 = t2 <= 0.00304 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055) < 0 ? 0 : t2 > 1 ? 1 : t2;
      }
      function Rt(t2) {
        return t2 > Ct ? t2 * t2 * t2 : Bt * (t2 - Pt);
      }
      function Ut(t2) {
        return parseInt(t2.padEnd(2, t2), 16) / 255;
      }
      function qt(t2, e2) {
        return Nt(e2 ? t2 / 100 : t2, 0, 1);
      }
      function Nt(t2, e2, r2) {
        return Math.min(Math.max(e2, t2), r2);
      }
      function Zt(t2) {
        return !t2.some(Number.isNaN);
      }
      const Gt = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };

      class Kt {
        constructor(t2, e2, r2, n2 = 1, i2 = true) {
          this.r = t2, this.g = e2, this.b = r2, this.a = n2, i2 || (this.r *= n2, this.g *= n2, this.b *= n2, n2 || this.overwriteGetter("rgb", [t2, e2, r2, n2]));
        }
        static parse(t2) {
          if (t2 instanceof Kt)
            return t2;
          if (typeof t2 != "string")
            return;
          const e2 = function(t3) {
            if ((t3 = t3.toLowerCase().trim()) === "transparent")
              return [0, 0, 0, 0];
            const e3 = Gt[t3];
            if (e3) {
              const [t4, r3, n2] = e3;
              return [t4 / 255, r3 / 255, n2 / 255, 1];
            }
            if (t3.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t3)) {
              const e4 = t3.length < 6 ? 1 : 2;
              let r3 = 1;
              return [Ut(t3.slice(r3, r3 += e4)), Ut(t3.slice(r3, r3 += e4)), Ut(t3.slice(r3, r3 += e4)), Ut(t3.slice(r3, r3 + e4) || "ff")];
            }
            if (t3.startsWith("rgb")) {
              const e4 = t3.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (e4) {
                const [t4, r3, n2, i2, s2, a2, o2, l2, u5, c2, h2, p2] = e4, f2 = [i2 || " ", o2 || " ", c2].join("");
                if (f2 === "  " || f2 === "  /" || f2 === ",," || f2 === ",,,") {
                  const t5 = [n2, a2, u5].join(""), e5 = t5 === "%%%" ? 100 : t5 === "" ? 255 : 0;
                  if (e5) {
                    const t6 = [Nt(+r3 / e5, 0, 1), Nt(+s2 / e5, 0, 1), Nt(+l2 / e5, 0, 1), h2 ? qt(+h2, p2) : 1];
                    if (Zt(t6))
                      return t6;
                  }
                }
                return;
              }
            }
            const r2 = t3.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (r2) {
              const [t4, e4, n2, i2, s2, a2, o2, l2, u5] = r2, c2 = [n2 || " ", s2 || " ", o2].join("");
              if (c2 === "  " || c2 === "  /" || c2 === ",," || c2 === ",,,") {
                const t5 = [+e4, Nt(+i2, 0, 100), Nt(+a2, 0, 100), l2 ? qt(+l2, u5) : 1];
                if (Zt(t5))
                  return function([t6, e5, r3, n3]) {
                    function i3(n4) {
                      const i4 = (n4 + t6 / 30) % 12, s3 = e5 * Math.min(r3, 1 - r3);
                      return r3 - s3 * Math.max(-1, Math.min(i4 - 3, 9 - i4, 1));
                    }
                    return t6 = Tt(t6), e5 /= 100, r3 /= 100, [i3(0), i3(8), i3(4), n3];
                  }(t5);
              }
            }
          }(t2);
          return e2 ? new Kt(...e2, false) : undefined;
        }
        get rgb() {
          const { r: t2, g: e2, b: r2, a: n2 } = this, i2 = n2 || 1 / 0;
          return this.overwriteGetter("rgb", [t2 / i2, e2 / i2, r2 / i2, n2]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(t2) {
            const [e2, r2, n2, i2] = $t(t2), s2 = Math.sqrt(r2 * r2 + n2 * n2);
            return [Math.round(1e4 * s2) ? Tt(Math.atan2(n2, r2) * Ft) : NaN, s2, e2, i2];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", $t(this.rgb));
        }
        overwriteGetter(t2, e2) {
          return Object.defineProperty(this, t2, { value: e2 }), e2;
        }
        toString() {
          const [t2, e2, r2, n2] = this.rgb;
          return `rgba(${[t2, e2, r2].map((t3) => Math.round(255 * t3)).join(",")},${n2})`;
        }
      }
      Kt.black = new Kt(0, 0, 0, 1), Kt.white = new Kt(1, 1, 1, 1), Kt.transparent = new Kt(0, 0, 0, 0), Kt.red = new Kt(1, 0, 0, 1);

      class Xt {
        constructor(t2, e2, r2) {
          this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(t2, e2) {
          return this.collator.compare(t2, e2);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }

      class Ht {
        constructor(t2, e2, r2, n2, i2) {
          this.text = t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
        }
      }

      class Yt {
        constructor(t2) {
          this.sections = t2;
        }
        static fromString(t2) {
          return new Yt([new Ht(t2, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((t2) => t2.text.length !== 0 || t2.image && t2.image.name.length !== 0);
        }
        static factory(t2) {
          return t2 instanceof Yt ? t2 : Yt.fromString(t2);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((t2) => t2.text).join("");
        }
      }

      class Jt {
        constructor(t2) {
          this.values = t2.slice();
        }
        static parse(t2) {
          if (t2 instanceof Jt)
            return t2;
          if (typeof t2 == "number")
            return new Jt([t2, t2, t2, t2]);
          if (Array.isArray(t2) && !(t2.length < 1 || t2.length > 4)) {
            for (const e2 of t2)
              if (typeof e2 != "number")
                return;
            switch (t2.length) {
              case 1:
                t2 = [t2[0], t2[0], t2[0], t2[0]];
                break;
              case 2:
                t2 = [t2[0], t2[1], t2[0], t2[1]];
                break;
              case 3:
                t2 = [t2[0], t2[1], t2[2], t2[1]];
            }
            return new Jt(t2);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      const Wt = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);

      class Qt {
        constructor(t2) {
          this.values = t2.slice();
        }
        static parse(t2) {
          if (t2 instanceof Qt)
            return t2;
          if (Array.isArray(t2) && !(t2.length < 1) && t2.length % 2 == 0) {
            for (let e2 = 0;e2 < t2.length; e2 += 2) {
              const r2 = t2[e2], n2 = t2[e2 + 1];
              if (typeof r2 != "string" || !Wt.has(r2))
                return;
              if (!Array.isArray(n2) || n2.length !== 2 || typeof n2[0] != "number" || typeof n2[1] != "number")
                return;
            }
            return new Qt(t2);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }

      class te {
        constructor(t2) {
          this.name = t2.name, this.available = t2.available;
        }
        toString() {
          return this.name;
        }
        static fromString(t2) {
          return t2 ? new te({ name: t2, available: false }) : null;
        }
      }
      function ee(t2, e2, r2, n2) {
        return typeof t2 == "number" && t2 >= 0 && t2 <= 255 && typeof e2 == "number" && e2 >= 0 && e2 <= 255 && typeof r2 == "number" && r2 >= 0 && r2 <= 255 ? n2 === undefined || typeof n2 == "number" && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n2 == "number" ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function re(t2) {
        if (t2 === null || typeof t2 == "string" || typeof t2 == "boolean" || typeof t2 == "number" || t2 instanceof Kt || t2 instanceof Xt || t2 instanceof Yt || t2 instanceof Jt || t2 instanceof Qt || t2 instanceof te)
          return true;
        if (Array.isArray(t2)) {
          for (const e2 of t2)
            if (!re(e2))
              return false;
          return true;
        }
        if (typeof t2 == "object") {
          for (const e2 in t2)
            if (!re(t2[e2]))
              return false;
          return true;
        }
        return false;
      }
      function ne(t2) {
        if (t2 === null)
          return lt;
        if (typeof t2 == "string")
          return ct;
        if (typeof t2 == "boolean")
          return ht;
        if (typeof t2 == "number")
          return ut;
        if (t2 instanceof Kt)
          return pt;
        if (t2 instanceof Xt)
          return yt;
        if (t2 instanceof Yt)
          return mt;
        if (t2 instanceof Jt)
          return gt;
        if (t2 instanceof Qt)
          return vt;
        if (t2 instanceof te)
          return xt;
        if (Array.isArray(t2)) {
          const e2 = t2.length;
          let r2;
          for (const e3 of t2) {
            const t3 = ne(e3);
            if (r2) {
              if (r2 === t3)
                continue;
              r2 = dt;
              break;
            }
            r2 = t3;
          }
          return bt(r2 || dt, e2);
        }
        return ft;
      }
      function ie(t2) {
        const e2 = typeof t2;
        return t2 === null ? "" : e2 === "string" || e2 === "number" || e2 === "boolean" ? String(t2) : t2 instanceof Kt || t2 instanceof Yt || t2 instanceof Jt || t2 instanceof Qt || t2 instanceof te ? t2.toString() : JSON.stringify(t2);
      }

      class se {
        constructor(t2, e2) {
          this.type = t2, this.value = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (!re(t2[1]))
            return e2.error("invalid value");
          const r2 = t2[1];
          let n2 = ne(r2);
          const i2 = e2.expectedType;
          return n2.kind !== "array" || n2.N !== 0 || !i2 || i2.kind !== "array" || typeof i2.N == "number" && i2.N !== 0 || (n2 = i2), new se(n2, r2);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }

      class ae {
        constructor(t2) {
          this.name = "ExpressionEvaluationError", this.message = t2;
        }
        toJSON() {
          return this.message;
        }
      }
      const oe = { string: ct, number: ut, boolean: ht, object: ft };

      class le {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          let r2, n2 = 1;
          const i2 = t2[0];
          if (i2 === "array") {
            let i3, s3;
            if (t2.length > 2) {
              const r3 = t2[1];
              if (typeof r3 != "string" || !(r3 in oe) || r3 === "object")
                return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
              i3 = oe[r3], n2++;
            } else
              i3 = dt;
            if (t2.length > 3) {
              if (t2[2] !== null && (typeof t2[2] != "number" || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                return e2.error('The length argument to "array" must be a positive integer literal', 2);
              s3 = t2[2], n2++;
            }
            r2 = bt(i3, s3);
          } else {
            if (!oe[i2])
              throw new Error(`Types doesn't contain name = ${i2}`);
            r2 = oe[i2];
          }
          const s2 = [];
          for (;n2 < t2.length; n2++) {
            const r3 = e2.parse(t2[n2], n2, dt);
            if (!r3)
              return null;
            s2.push(r3);
          }
          return new le(r2, s2);
        }
        evaluate(t2) {
          for (let e2 = 0;e2 < this.args.length; e2++) {
            const r2 = this.args[e2].evaluate(t2);
            if (!At(this.type, ne(r2)))
              return r2;
            if (e2 === this.args.length - 1)
              throw new ae(`Expected value to be of type ${wt(this.type)}, but found ${wt(ne(r2))} instead.`);
          }
          throw new Error;
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
      }
      const ue = { "to-boolean": ht, "to-color": pt, "to-number": ut, "to-string": ct };

      class ce2 {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          const r2 = t2[0];
          if (!ue[r2])
            throw new Error(`Can't parse ${r2} as it is not part of the known types`);
          if ((r2 === "to-boolean" || r2 === "to-string") && t2.length !== 2)
            return e2.error("Expected one argument.");
          const n2 = ue[r2], i2 = [];
          for (let r3 = 1;r3 < t2.length; r3++) {
            const n3 = e2.parse(t2[r3], r3, dt);
            if (!n3)
              return null;
            i2.push(n3);
          }
          return new ce2(n2, i2);
        }
        evaluate(t2) {
          switch (this.type.kind) {
            case "boolean":
              return Boolean(this.args[0].evaluate(t2));
            case "color": {
              let e2, r2;
              for (const n2 of this.args) {
                if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof Kt)
                  return e2;
                if (typeof e2 == "string") {
                  const r3 = t2.parseColor(e2);
                  if (r3)
                    return r3;
                } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : ee(e2[0], e2[1], e2[2], e2[3]), !r2))
                  return new Kt(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
              }
              throw new ae(r2 || `Could not parse color from value '${typeof e2 == "string" ? e2 : JSON.stringify(e2)}'`);
            }
            case "padding": {
              let e2;
              for (const r2 of this.args) {
                e2 = r2.evaluate(t2);
                const n2 = Jt.parse(e2);
                if (n2)
                  return n2;
              }
              throw new ae(`Could not parse padding from value '${typeof e2 == "string" ? e2 : JSON.stringify(e2)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let e2;
              for (const r2 of this.args) {
                e2 = r2.evaluate(t2);
                const n2 = Qt.parse(e2);
                if (n2)
                  return n2;
              }
              throw new ae(`Could not parse variableAnchorOffsetCollection from value '${typeof e2 == "string" ? e2 : JSON.stringify(e2)}'`);
            }
            case "number": {
              let e2 = null;
              for (const r2 of this.args) {
                if (e2 = r2.evaluate(t2), e2 === null)
                  return 0;
                const n2 = Number(e2);
                if (!isNaN(n2))
                  return n2;
              }
              throw new ae(`Could not convert ${JSON.stringify(e2)} to number.`);
            }
            case "formatted":
              return Yt.fromString(ie(this.args[0].evaluate(t2)));
            case "resolvedImage":
              return te.fromString(ie(this.args[0].evaluate(t2)));
            default:
              return ie(this.args[0].evaluate(t2));
          }
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
      }
      const he = ["Unknown", "Point", "LineString", "Polygon"];

      class pe {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? he[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(t2) {
          let e2 = this._parseColorCache[t2];
          return e2 || (e2 = this._parseColorCache[t2] = Kt.parse(t2)), e2;
        }
      }

      class fe {
        constructor(t2, e2, r2 = [], n2, i2 = new ot, s2 = []) {
          this.registry = t2, this.path = r2, this.key = r2.map((t3) => `[${t3}]`).join(""), this.scope = i2, this.errors = s2, this.expectedType = n2, this._isConstant = e2;
        }
        parse(t2, e2, r2, n2, i2 = {}) {
          return e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
        }
        _parse(t2, e2) {
          function r2(t3, e3, r3) {
            return r3 === "assert" ? new le(e3, [t3]) : r3 === "coerce" ? new ce2(e3, [t3]) : t3;
          }
          if (t2 !== null && typeof t2 != "string" && typeof t2 != "boolean" && typeof t2 != "number" || (t2 = ["literal", t2]), Array.isArray(t2)) {
            if (t2.length === 0)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const n2 = t2[0];
            if (typeof n2 != "string")
              return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const i2 = this.registry[n2];
            if (i2) {
              let n3 = i2.parse(t2, this);
              if (!n3)
                return null;
              if (this.expectedType) {
                const t3 = this.expectedType, i3 = n3.type;
                if (t3.kind !== "string" && t3.kind !== "number" && t3.kind !== "boolean" && t3.kind !== "object" && t3.kind !== "array" || i3.kind !== "value")
                  if (t3.kind !== "color" && t3.kind !== "formatted" && t3.kind !== "resolvedImage" || i3.kind !== "value" && i3.kind !== "string")
                    if (t3.kind !== "padding" || i3.kind !== "value" && i3.kind !== "number" && i3.kind !== "array")
                      if (t3.kind !== "variableAnchorOffsetCollection" || i3.kind !== "value" && i3.kind !== "array") {
                        if (this.checkSubtype(t3, i3))
                          return null;
                      } else
                        n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                    else
                      n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                  else
                    n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                else
                  n3 = r2(n3, t3, e2.typeAnnotation || "assert");
              }
              if (!(n3 instanceof se) && n3.type.kind !== "resolvedImage" && this._isConstant(n3)) {
                const t3 = new pe;
                try {
                  n3 = new se(n3.type, n3.evaluate(t3));
                } catch (t4) {
                  return this.error(t4.message), null;
                }
              }
              return n3;
            }
            return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(t2 === undefined ? "'undefined' value invalid. Use null instead." : typeof t2 == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
        }
        concat(t2, e2, r2) {
          const n2 = typeof t2 == "number" ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
          return new fe(this.registry, this._isConstant, n2, e2 || null, i2, this.errors);
        }
        error(t2, ...e2) {
          const r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
          this.errors.push(new at(r2, t2));
        }
        checkSubtype(t2, e2) {
          const r2 = At(t2, e2);
          return r2 && this.error(r2), r2;
        }
      }

      class de2 {
        constructor(t2, e2) {
          this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
        }
        evaluate(t2) {
          return this.result.evaluate(t2);
        }
        eachChild(t2) {
          for (const e2 of this.bindings)
            t2(e2[1]);
          t2(this.result);
        }
        static parse(t2, e2) {
          if (t2.length < 4)
            return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
          const r2 = [];
          for (let n3 = 1;n3 < t2.length - 1; n3 += 2) {
            const i2 = t2[n3];
            if (typeof i2 != "string")
              return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
            if (/[^a-zA-Z0-9_]/.test(i2))
              return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
            const s2 = e2.parse(t2[n3 + 1], n3 + 1);
            if (!s2)
              return null;
            r2.push([i2, s2]);
          }
          const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
          return n2 ? new de2(r2, n2) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }

      class ye {
        constructor(t2, e2) {
          this.type = e2.type, this.name = t2, this.boundExpression = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2 || typeof t2[1] != "string")
            return e2.error("'var' expression requires exactly one string literal argument.");
          const r2 = t2[1];
          return e2.scope.has(r2) ? new ye(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(t2) {
          return this.boundExpression.evaluate(t2);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
      }

      class me {
        constructor(t2, e2, r2) {
          this.type = t2, this.index = e2, this.input = r2;
        }
        static parse(t2, e2) {
          if (t2.length !== 3)
            return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, ut), n2 = e2.parse(t2[2], 2, bt(e2.expectedType || dt));
          return r2 && n2 ? new me(n2.type.itemType, r2, n2) : null;
        }
        evaluate(t2) {
          const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
          if (e2 < 0)
            throw new ae(`Array index out of bounds: ${e2} < 0.`);
          if (e2 >= r2.length)
            throw new ae(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
          if (e2 !== Math.floor(e2))
            throw new ae(`Array index must be an integer, but found ${e2} instead.`);
          return r2[e2];
        }
        eachChild(t2) {
          t2(this.index), t2(this.input);
        }
        outputDefined() {
          return false;
        }
      }

      class ge {
        constructor(t2, e2) {
          this.type = ht, this.needle = t2, this.haystack = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 3)
            return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, dt), n2 = e2.parse(t2[2], 2, dt);
          return r2 && n2 ? St(r2.type, [ht, ct, ut, lt, dt]) ? new ge(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${wt(r2.type)} instead`) : null;
        }
        evaluate(t2) {
          const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
          if (!r2)
            return false;
          if (!kt(e2, ["boolean", "string", "number", "null"]))
            throw new ae(`Expected first argument to be of type boolean, string, number or null, but found ${wt(ne(e2))} instead.`);
          if (!kt(r2, ["string", "array"]))
            throw new ae(`Expected second argument to be of type array or string, but found ${wt(ne(r2))} instead.`);
          return r2.indexOf(e2) >= 0;
        }
        eachChild(t2) {
          t2(this.needle), t2(this.haystack);
        }
        outputDefined() {
          return true;
        }
      }

      class xe {
        constructor(t2, e2, r2) {
          this.type = ut, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
        }
        static parse(t2, e2) {
          if (t2.length <= 2 || t2.length >= 5)
            return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, dt), n2 = e2.parse(t2[2], 2, dt);
          if (!r2 || !n2)
            return null;
          if (!St(r2.type, [ht, ct, ut, lt, dt]))
            return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${wt(r2.type)} instead`);
          if (t2.length === 4) {
            const i2 = e2.parse(t2[3], 3, ut);
            return i2 ? new xe(r2, n2, i2) : null;
          }
          return new xe(r2, n2);
        }
        evaluate(t2) {
          const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
          if (!kt(e2, ["boolean", "string", "number", "null"]))
            throw new ae(`Expected first argument to be of type boolean, string, number or null, but found ${wt(ne(e2))} instead.`);
          let n2;
          if (this.fromIndex && (n2 = this.fromIndex.evaluate(t2)), kt(r2, ["string"])) {
            const t3 = r2.indexOf(e2, n2);
            return t3 === -1 ? -1 : [...r2.slice(0, t3)].length;
          }
          if (kt(r2, ["array"]))
            return r2.indexOf(e2, n2);
          throw new ae(`Expected second argument to be of type array or string, but found ${wt(ne(r2))} instead.`);
        }
        eachChild(t2) {
          t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
      }

      class ve {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
        }
        static parse(t2, e2) {
          if (t2.length < 5)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if (t2.length % 2 != 1)
            return e2.error("Expected an even number of arguments.");
          let r2, n2;
          e2.expectedType && e2.expectedType.kind !== "value" && (n2 = e2.expectedType);
          const i2 = {}, s2 = [];
          for (let a3 = 2;a3 < t2.length - 1; a3 += 2) {
            let o3 = t2[a3];
            const l2 = t2[a3 + 1];
            Array.isArray(o3) || (o3 = [o3]);
            const u5 = e2.concat(a3);
            if (o3.length === 0)
              return u5.error("Expected at least one branch label.");
            for (const t3 of o3) {
              if (typeof t3 != "number" && typeof t3 != "string")
                return u5.error("Branch labels must be numbers or strings.");
              if (typeof t3 == "number" && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                return u5.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof t3 == "number" && Math.floor(t3) !== t3)
                return u5.error("Numeric branch labels must be integer values.");
              if (r2) {
                if (u5.checkSubtype(r2, ne(t3)))
                  return null;
              } else
                r2 = ne(t3);
              if (i2[String(t3)] !== undefined)
                return u5.error("Branch labels must be unique.");
              i2[String(t3)] = s2.length;
            }
            const c2 = e2.parse(l2, a3, n2);
            if (!c2)
              return null;
            n2 = n2 || c2.type, s2.push(c2);
          }
          const a2 = e2.parse(t2[1], 1, dt);
          if (!a2)
            return null;
          const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
          return o2 ? a2.type.kind !== "value" && e2.concat(1).checkSubtype(r2, a2.type) ? null : new ve(r2, n2, a2, i2, s2, o2) : null;
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2);
          return (ne(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
        }
        eachChild(t2) {
          t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
        }
      }

      class be {
        constructor(t2, e2, r2) {
          this.type = t2, this.branches = e2, this.otherwise = r2;
        }
        static parse(t2, e2) {
          if (t2.length < 4)
            return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
          if (t2.length % 2 != 0)
            return e2.error("Expected an odd number of arguments.");
          let r2;
          e2.expectedType && e2.expectedType.kind !== "value" && (r2 = e2.expectedType);
          const n2 = [];
          for (let i3 = 1;i3 < t2.length - 1; i3 += 2) {
            const s2 = e2.parse(t2[i3], i3, ht);
            if (!s2)
              return null;
            const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
            if (!a2)
              return null;
            n2.push([s2, a2]), r2 = r2 || a2.type;
          }
          const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
          if (!i2)
            return null;
          if (!r2)
            throw new Error("Can't infer output type");
          return new be(r2, n2, i2);
        }
        evaluate(t2) {
          for (const [e2, r2] of this.branches)
            if (e2.evaluate(t2))
              return r2.evaluate(t2);
          return this.otherwise.evaluate(t2);
        }
        eachChild(t2) {
          for (const [e2, r2] of this.branches)
            t2(e2), t2(r2);
          t2(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
        }
      }

      class we {
        constructor(t2, e2, r2, n2) {
          this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
        }
        static parse(t2, e2) {
          if (t2.length <= 2 || t2.length >= 5)
            return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, dt), n2 = e2.parse(t2[2], 2, ut);
          if (!r2 || !n2)
            return null;
          if (!St(r2.type, [bt(dt), ct, dt]))
            return e2.error(`Expected first argument to be of type array or string, but found ${wt(r2.type)} instead`);
          if (t2.length === 4) {
            const i2 = e2.parse(t2[3], 3, ut);
            return i2 ? new we(r2.type, r2, n2, i2) : null;
          }
          return new we(r2.type, r2, n2);
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
          let n2;
          if (this.endIndex && (n2 = this.endIndex.evaluate(t2)), kt(e2, ["string"]))
            return [...e2].slice(r2, n2).join("");
          if (kt(e2, ["array"]))
            return e2.slice(r2, n2);
          throw new ae(`Expected first argument to be of type array or string, but found ${wt(ne(e2))} instead.`);
        }
        eachChild(t2) {
          t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
        }
        outputDefined() {
          return false;
        }
      }
      function _e(t2, e2) {
        const r2 = t2.length - 1;
        let n2, i2, s2 = 0, a2 = r2, o2 = 0;
        for (;s2 <= a2; )
          if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
            if (o2 === r2 || e2 < i2)
              return o2;
            s2 = o2 + 1;
          } else {
            if (!(n2 > e2))
              throw new ae("Input is not a number.");
            a2 = o2 - 1;
          }
        return 0;
      }

      class Ae {
        constructor(t2, e2, r2) {
          this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
          for (const [t3, e3] of r2)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static parse(t2, e2) {
          if (t2.length - 1 < 4)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if ((t2.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          const r2 = e2.parse(t2[1], 1, ut);
          if (!r2)
            return null;
          const n2 = [];
          let i2 = null;
          e2.expectedType && e2.expectedType.kind !== "value" && (i2 = e2.expectedType);
          for (let r3 = 1;r3 < t2.length; r3 += 2) {
            const s2 = r3 === 1 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
            if (typeof s2 != "number")
              return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
            if (n2.length && n2[n2.length - 1][0] >= s2)
              return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
            const u5 = e2.parse(a2, l2, i2);
            if (!u5)
              return null;
            i2 = i2 || u5.type, n2.push([s2, u5]);
          }
          return new Ae(i2, r2, n2);
        }
        evaluate(t2) {
          const e2 = this.labels, r2 = this.outputs;
          if (e2.length === 1)
            return r2[0].evaluate(t2);
          const n2 = this.input.evaluate(t2);
          if (n2 <= e2[0])
            return r2[0].evaluate(t2);
          const i2 = e2.length;
          return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[_e(e2, n2)].evaluate(t2);
        }
        eachChild(t2) {
          t2(this.input);
          for (const e2 of this.outputs)
            t2(e2);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined());
        }
      }
      function Se(t2) {
        return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
      }
      var ke = Me;
      function Me(t2, e2, r2, n2) {
        this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r2, this.p2y = n2;
      }
      Me.prototype = { sampleCurveX: function(t2) {
        return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
      }, sampleCurveY: function(t2) {
        return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
      }, sampleCurveDerivativeX: function(t2) {
        return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
      }, solveCurveX: function(t2, e2) {
        if (e2 === undefined && (e2 = 0.000001), t2 < 0)
          return 0;
        if (t2 > 1)
          return 1;
        for (var r2 = t2, n2 = 0;n2 < 8; n2++) {
          var i2 = this.sampleCurveX(r2) - t2;
          if (Math.abs(i2) < e2)
            return r2;
          var s2 = this.sampleCurveDerivativeX(r2);
          if (Math.abs(s2) < 0.000001)
            break;
          r2 -= i2 / s2;
        }
        var a2 = 0, o2 = 1;
        for (r2 = t2, n2 = 0;n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e2)); n2++)
          t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
        return r2;
      }, solve: function(t2, e2) {
        return this.sampleCurveY(this.solveCurveX(t2, e2));
      } };
      var Ie = Se(ke);
      function ze(t2, e2, r2) {
        return t2 + r2 * (e2 - t2);
      }
      function Pe(t2, e2, r2) {
        return t2.map((t3, n2) => ze(t3, e2[n2], r2));
      }
      const Ce = { number: ze, color: function(t2, e2, r2, n2 = "rgb") {
        switch (n2) {
          case "rgb": {
            const [n3, i2, s2, a2] = Pe(t2.rgb, e2.rgb, r2);
            return new Kt(n3, i2, s2, a2, false);
          }
          case "hcl": {
            const [n3, i2, s2, a2] = t2.hcl, [o2, l2, u5, c2] = e2.hcl;
            let h2, p2;
            if (isNaN(n3) || isNaN(o2))
              isNaN(n3) ? isNaN(o2) ? h2 = NaN : (h2 = o2, s2 !== 1 && s2 !== 0 || (p2 = l2)) : (h2 = n3, u5 !== 1 && u5 !== 0 || (p2 = i2));
            else {
              let t3 = o2 - n3;
              o2 > n3 && t3 > 180 ? t3 -= 360 : o2 < n3 && n3 - o2 > 180 && (t3 += 360), h2 = n3 + r2 * t3;
            }
            const [f2, d2, y2, m2] = function([t3, e3, r3, n4]) {
              return t3 = isNaN(t3) ? 0 : t3 * Et, Ot([r3, Math.cos(t3) * e3, Math.sin(t3) * e3, n4]);
            }([h2, p2 != null ? p2 : ze(i2, l2, r2), ze(s2, u5, r2), ze(a2, c2, r2)]);
            return new Kt(f2, d2, y2, m2, false);
          }
          case "lab": {
            const [n3, i2, s2, a2] = Ot(Pe(t2.lab, e2.lab, r2));
            return new Kt(n3, i2, s2, a2, false);
          }
        }
      }, array: Pe, padding: function(t2, e2, r2) {
        return new Jt(Pe(t2.values, e2.values, r2));
      }, variableAnchorOffsetCollection: function(t2, e2, r2) {
        const n2 = t2.values, i2 = e2.values;
        if (n2.length !== i2.length)
          throw new ae(`Cannot interpolate values of different length. from: ${t2.toString()}, to: ${e2.toString()}`);
        const s2 = [];
        for (let t3 = 0;t3 < n2.length; t3 += 2) {
          if (n2[t3] !== i2[t3])
            throw new ae(`Cannot interpolate values containing mismatched anchors. from[${t3}]: ${n2[t3]}, to[${t3}]: ${i2[t3]}`);
          s2.push(n2[t3]);
          const [e3, a2] = n2[t3 + 1], [o2, l2] = i2[t3 + 1];
          s2.push([ze(e3, o2, r2), ze(a2, l2, r2)]);
        }
        return new Qt(s2);
      } };

      class Be {
        constructor(t2, e2, r2, n2, i2) {
          this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
          for (const [t3, e3] of i2)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static interpolationFactor(t2, e2, r2, n2) {
          let i2 = 0;
          if (t2.name === "exponential")
            i2 = Ve(e2, t2.base, r2, n2);
          else if (t2.name === "linear")
            i2 = Ve(e2, 1, r2, n2);
          else if (t2.name === "cubic-bezier") {
            const s2 = t2.controlPoints;
            i2 = new Ie(s2[0], s2[1], s2[2], s2[3]).solve(Ve(e2, 1, r2, n2));
          }
          return i2;
        }
        static parse(t2, e2) {
          let [r2, n2, i2, ...s2] = t2;
          if (!Array.isArray(n2) || n2.length === 0)
            return e2.error("Expected an interpolation type expression.", 1);
          if (n2[0] === "linear")
            n2 = { name: "linear" };
          else if (n2[0] === "exponential") {
            const t3 = n2[1];
            if (typeof t3 != "number")
              return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
            n2 = { name: "exponential", base: t3 };
          } else {
            if (n2[0] !== "cubic-bezier")
              return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
            {
              const t3 = n2.slice(1);
              if (t3.length !== 4 || t3.some((t4) => typeof t4 != "number" || t4 < 0 || t4 > 1))
                return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              n2 = { name: "cubic-bezier", controlPoints: t3 };
            }
          }
          if (t2.length - 1 < 4)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if ((t2.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          if (i2 = e2.parse(i2, 2, ut), !i2)
            return null;
          const a2 = [];
          let o2 = null;
          r2 === "interpolate-hcl" || r2 === "interpolate-lab" ? o2 = pt : e2.expectedType && e2.expectedType.kind !== "value" && (o2 = e2.expectedType);
          for (let t3 = 0;t3 < s2.length; t3 += 2) {
            const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
            if (typeof r3 != "number")
              return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
            if (a2.length && a2[a2.length - 1][0] >= r3)
              return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
            const u5 = e2.parse(n3, l2, o2);
            if (!u5)
              return null;
            o2 = o2 || u5.type, a2.push([r3, u5]);
          }
          return Mt(o2, ut) || Mt(o2, pt) || Mt(o2, gt) || Mt(o2, vt) || Mt(o2, bt(ut)) ? new Be(o2, r2, n2, i2, a2) : e2.error(`Type ${wt(o2)} is not interpolatable.`);
        }
        evaluate(t2) {
          const e2 = this.labels, r2 = this.outputs;
          if (e2.length === 1)
            return r2[0].evaluate(t2);
          const n2 = this.input.evaluate(t2);
          if (n2 <= e2[0])
            return r2[0].evaluate(t2);
          const i2 = e2.length;
          if (n2 >= e2[i2 - 1])
            return r2[i2 - 1].evaluate(t2);
          const s2 = _e(e2, n2), a2 = Be.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
          switch (this.operator) {
            case "interpolate":
              return Ce[this.type.kind](o2, l2, a2);
            case "interpolate-hcl":
              return Ce.color(o2, l2, a2, "hcl");
            case "interpolate-lab":
              return Ce.color(o2, l2, a2, "lab");
          }
        }
        eachChild(t2) {
          t2(this.input);
          for (const e2 of this.outputs)
            t2(e2);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined());
        }
      }
      function Ve(t2, e2, r2, n2) {
        const i2 = n2 - r2, s2 = t2 - r2;
        return i2 === 0 ? 0 : e2 === 1 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
      }

      class Ee {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expectected at least one argument.");
          let r2 = null;
          const n2 = e2.expectedType;
          n2 && n2.kind !== "value" && (r2 = n2);
          const i2 = [];
          for (const n3 of t2.slice(1)) {
            const t3 = e2.parse(n3, 1 + i2.length, r2, undefined, { typeAnnotation: "omit" });
            if (!t3)
              return null;
            r2 = r2 || t3.type, i2.push(t3);
          }
          if (!r2)
            throw new Error("No output type");
          const s2 = n2 && i2.some((t3) => At(n2, t3.type));
          return new Ee(s2 ? dt : r2, i2);
        }
        evaluate(t2) {
          let e2, r2 = null, n2 = 0;
          for (const i2 of this.args)
            if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof te && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), r2 !== null)
              break;
          return r2;
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
      }
      function Fe(t2, e2) {
        return t2 === "==" || t2 === "!=" ? e2.kind === "boolean" || e2.kind === "string" || e2.kind === "number" || e2.kind === "null" || e2.kind === "value" : e2.kind === "string" || e2.kind === "number" || e2.kind === "value";
      }
      function Te(t2, e2, r2, n2) {
        return n2.compare(e2, r2) === 0;
      }
      function $e(t2, e2, r2) {
        const n2 = t2 !== "==" && t2 !== "!=";
        return class i2 {
          constructor(t3, e3, r3) {
            this.type = ht, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = t3.type.kind === "value" || e3.type.kind === "value";
          }
          static parse(t3, e3) {
            if (t3.length !== 3 && t3.length !== 4)
              return e3.error("Expected two or three arguments.");
            const r3 = t3[0];
            let s2 = e3.parse(t3[1], 1, dt);
            if (!s2)
              return null;
            if (!Fe(r3, s2.type))
              return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${wt(s2.type)}'.`);
            let a2 = e3.parse(t3[2], 2, dt);
            if (!a2)
              return null;
            if (!Fe(r3, a2.type))
              return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${wt(a2.type)}'.`);
            if (s2.type.kind !== a2.type.kind && s2.type.kind !== "value" && a2.type.kind !== "value")
              return e3.error(`Cannot compare types '${wt(s2.type)}' and '${wt(a2.type)}'.`);
            n2 && (s2.type.kind === "value" && a2.type.kind !== "value" ? s2 = new le(a2.type, [s2]) : s2.type.kind !== "value" && a2.type.kind === "value" && (a2 = new le(s2.type, [a2])));
            let o2 = null;
            if (t3.length === 4) {
              if (s2.type.kind !== "string" && a2.type.kind !== "string" && s2.type.kind !== "value" && a2.type.kind !== "value")
                return e3.error("Cannot use collator to compare non-string types.");
              if (o2 = e3.parse(t3[3], 3, yt), !o2)
                return null;
            }
            return new i2(s2, a2, o2);
          }
          evaluate(i3) {
            const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
            if (n2 && this.hasUntypedArgument) {
              const e3 = ne(s2), r3 = ne(a2);
              if (e3.kind !== r3.kind || e3.kind !== "string" && e3.kind !== "number")
                throw new ae(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
            }
            if (this.collator && !n2 && this.hasUntypedArgument) {
              const t3 = ne(s2), r3 = ne(a2);
              if (t3.kind !== "string" || r3.kind !== "string")
                return e2(i3, s2, a2);
            }
            return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
          }
          eachChild(t3) {
            t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
          }
          outputDefined() {
            return true;
          }
        };
      }
      const Le = $e("==", function(t2, e2, r2) {
        return e2 === r2;
      }, Te), De = $e("!=", function(t2, e2, r2) {
        return e2 !== r2;
      }, function(t2, e2, r2, n2) {
        return !Te(0, e2, r2, n2);
      }), Oe = $e("<", function(t2, e2, r2) {
        return e2 < r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) < 0;
      }), je = $e(">", function(t2, e2, r2) {
        return e2 > r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) > 0;
      }), Re = $e("<=", function(t2, e2, r2) {
        return e2 <= r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) <= 0;
      }), Ue = $e(">=", function(t2, e2, r2) {
        return e2 >= r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) >= 0;
      });

      class qe {
        constructor(t2, e2, r2) {
          this.type = yt, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error("Expected one argument.");
          const r2 = t2[1];
          if (typeof r2 != "object" || Array.isArray(r2))
            return e2.error("Collator options argument must be an object.");
          const n2 = e2.parse(r2["case-sensitive"] !== undefined && r2["case-sensitive"], 1, ht);
          if (!n2)
            return null;
          const i2 = e2.parse(r2["diacritic-sensitive"] !== undefined && r2["diacritic-sensitive"], 1, ht);
          if (!i2)
            return null;
          let s2 = null;
          return r2.locale && (s2 = e2.parse(r2.locale, 1, ct), !s2) ? null : new qe(n2, i2, s2);
        }
        evaluate(t2) {
          return new Xt(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
        }
        eachChild(t2) {
          t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
        }
        outputDefined() {
          return false;
        }
      }

      class Ne {
        constructor(t2, e2, r2, n2, i2) {
          this.type = ct, this.number = t2, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
        }
        static parse(t2, e2) {
          if (t2.length !== 3)
            return e2.error("Expected two arguments.");
          const r2 = e2.parse(t2[1], 1, ut);
          if (!r2)
            return null;
          const n2 = t2[2];
          if (typeof n2 != "object" || Array.isArray(n2))
            return e2.error("NumberFormat options argument must be an object.");
          let i2 = null;
          if (n2.locale && (i2 = e2.parse(n2.locale, 1, ct), !i2))
            return null;
          let s2 = null;
          if (n2.currency && (s2 = e2.parse(n2.currency, 1, ct), !s2))
            return null;
          let a2 = null;
          if (n2["min-fraction-digits"] && (a2 = e2.parse(n2["min-fraction-digits"], 1, ut), !a2))
            return null;
          let o2 = null;
          return n2["max-fraction-digits"] && (o2 = e2.parse(n2["max-fraction-digits"], 1, ut), !o2) ? null : new Ne(r2, i2, s2, a2, o2);
        }
        evaluate(t2) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : undefined, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : undefined, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : undefined }).format(this.number.evaluate(t2));
        }
        eachChild(t2) {
          t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
      }

      class Ze {
        constructor(t2) {
          this.type = mt, this.sections = t2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          const r2 = t2[1];
          if (!Array.isArray(r2) && typeof r2 == "object")
            return e2.error("First argument must be an image or text section.");
          const n2 = [];
          let i2 = false;
          for (let r3 = 1;r3 <= t2.length - 1; ++r3) {
            const s2 = t2[r3];
            if (i2 && typeof s2 == "object" && !Array.isArray(s2)) {
              i2 = false;
              let t3 = null;
              if (s2["font-scale"] && (t3 = e2.parse(s2["font-scale"], 1, ut), !t3))
                return null;
              let r4 = null;
              if (s2["text-font"] && (r4 = e2.parse(s2["text-font"], 1, bt(ct)), !r4))
                return null;
              let a2 = null;
              if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, pt), !a2))
                return null;
              const o2 = n2[n2.length - 1];
              o2.scale = t3, o2.font = r4, o2.textColor = a2;
            } else {
              const s3 = e2.parse(t2[r3], 1, dt);
              if (!s3)
                return null;
              const a2 = s3.type.kind;
              if (a2 !== "string" && a2 !== "value" && a2 !== "null" && a2 !== "resolvedImage")
                return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
            }
          }
          return new Ze(n2);
        }
        evaluate(t2) {
          return new Yt(this.sections.map((e2) => {
            const r2 = e2.content.evaluate(t2);
            return ne(r2) === xt ? new Ht("", r2, null, null, null) : new Ht(ie(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
          }));
        }
        eachChild(t2) {
          for (const e2 of this.sections)
            t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
        }
        outputDefined() {
          return false;
        }
      }

      class Ge {
        constructor(t2) {
          this.type = xt, this.input = t2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error("Expected two arguments.");
          const r2 = e2.parse(t2[1], 1, ct);
          return r2 ? new Ge(r2) : e2.error("No image name provided.");
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2), r2 = te.fromString(e2);
          return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
        }
        eachChild(t2) {
          t2(this.input);
        }
        outputDefined() {
          return false;
        }
      }

      class Ke {
        constructor(t2) {
          this.type = ut, this.input = t2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1);
          return r2 ? r2.type.kind !== "array" && r2.type.kind !== "string" && r2.type.kind !== "value" ? e2.error(`Expected argument of type string or array, but found ${wt(r2.type)} instead.`) : new Ke(r2) : null;
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2);
          if (typeof e2 == "string")
            return [...e2].length;
          if (Array.isArray(e2))
            return e2.length;
          throw new ae(`Expected value to be of type string or array, but found ${wt(ne(e2))} instead.`);
        }
        eachChild(t2) {
          t2(this.input);
        }
        outputDefined() {
          return false;
        }
      }
      const Xe = 8192;
      function He(t2, e2) {
        const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
        return [Math.round(r2 * i2 * Xe), Math.round(n2 * i2 * Xe)];
      }
      function Ye(t2, e2) {
        const r2 = Math.pow(2, e2.z);
        return [(i2 = (t2[0] / Xe + e2.x) / r2, 360 * i2 - 180), (n2 = (t2[1] / Xe + e2.y) / r2, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n2) * Math.PI / 180)) - 90)];
        var n2, i2;
      }
      function Je(t2, e2) {
        t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
      }
      function We(t2, e2) {
        return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
      }
      function Qe(t2, e2, r2) {
        const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
        return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
      }
      function tr(t2, e2, r2, n2) {
        return (i2 = [n2[0] - r2[0], n2[1] - r2[1]])[0] * (s2 = [e2[0] - t2[0], e2[1] - t2[1]])[1] - i2[1] * s2[0] != 0 && !(!ar(t2, e2, r2, n2) || !ar(r2, n2, t2, e2));
        var i2, s2;
      }
      function er(t2, e2, r2) {
        for (const n2 of r2)
          for (let r3 = 0;r3 < n2.length - 1; ++r3)
            if (tr(t2, e2, n2[r3], n2[r3 + 1]))
              return true;
        return false;
      }
      function rr(t2, e2, r2 = false) {
        let n2 = false;
        for (const o2 of e2)
          for (let e3 = 0;e3 < o2.length - 1; e3++) {
            if (Qe(t2, o2[e3], o2[e3 + 1]))
              return r2;
            (s2 = o2[e3])[1] > (i2 = t2)[1] != (a2 = o2[e3 + 1])[1] > i2[1] && i2[0] < (a2[0] - s2[0]) * (i2[1] - s2[1]) / (a2[1] - s2[1]) + s2[0] && (n2 = !n2);
          }
        var i2, s2, a2;
        return n2;
      }
      function nr(t2, e2) {
        for (const r2 of e2)
          if (rr(t2, r2))
            return true;
        return false;
      }
      function ir(t2, e2) {
        for (const r2 of t2)
          if (!rr(r2, e2))
            return false;
        for (let r2 = 0;r2 < t2.length - 1; ++r2)
          if (er(t2[r2], t2[r2 + 1], e2))
            return false;
        return true;
      }
      function sr(t2, e2) {
        for (const r2 of e2)
          if (ir(t2, r2))
            return true;
        return false;
      }
      function ar(t2, e2, r2, n2) {
        const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
        return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
      }
      function or(t2, e2, r2) {
        const n2 = [];
        for (let i2 = 0;i2 < t2.length; i2++) {
          const s2 = [];
          for (let n3 = 0;n3 < t2[i2].length; n3++) {
            const a2 = He(t2[i2][n3], r2);
            Je(e2, a2), s2.push(a2);
          }
          n2.push(s2);
        }
        return n2;
      }
      function lr(t2, e2, r2) {
        const n2 = [];
        for (let i2 = 0;i2 < t2.length; i2++) {
          const s2 = or(t2[i2], e2, r2);
          n2.push(s2);
        }
        return n2;
      }
      function ur(t2, e2, r2, n2) {
        if (t2[0] < r2[0] || t2[0] > r2[2]) {
          const e3 = 0.5 * n2;
          let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
          i2 === 0 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
        }
        Je(e2, t2);
      }
      function cr(t2, e2, r2, n2) {
        const i2 = Math.pow(2, n2.z) * Xe, s2 = [n2.x * Xe, n2.y * Xe], a2 = [];
        for (const n3 of t2)
          for (const t3 of n3) {
            const n4 = [t3.x + s2[0], t3.y + s2[1]];
            ur(n4, e2, r2, i2), a2.push(n4);
          }
        return a2;
      }
      function hr(t2, e2, r2, n2) {
        const i2 = Math.pow(2, n2.z) * Xe, s2 = [n2.x * Xe, n2.y * Xe], a2 = [];
        for (const r3 of t2) {
          const t3 = [];
          for (const n3 of r3) {
            const r4 = [n3.x + s2[0], n3.y + s2[1]];
            Je(e2, r4), t3.push(r4);
          }
          a2.push(t3);
        }
        if (e2[2] - e2[0] <= i2 / 2) {
          (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
          for (const t3 of a2)
            for (const n3 of t3)
              ur(n3, e2, r2, i2);
        }
        var o2;
        return a2;
      }

      class pr {
        constructor(t2, e2) {
          this.type = ht, this.geojson = t2, this.geometries = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (re(t2[1])) {
            const e3 = t2[1];
            if (e3.type === "FeatureCollection") {
              const t3 = [];
              for (const r2 of e3.features) {
                const { type: e4, coordinates: n2 } = r2.geometry;
                e4 === "Polygon" && t3.push(n2), e4 === "MultiPolygon" && t3.push(...n2);
              }
              if (t3.length)
                return new pr(e3, { type: "MultiPolygon", coordinates: t3 });
            } else if (e3.type === "Feature") {
              const t3 = e3.geometry.type;
              if (t3 === "Polygon" || t3 === "MultiPolygon")
                return new pr(e3, e3.geometry);
            } else if (e3.type === "Polygon" || e3.type === "MultiPolygon")
              return new pr(e3, e3);
          }
          return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t2) {
          if (t2.geometry() != null && t2.canonicalID() != null) {
            if (t2.geometryType() === "Point")
              return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (e2.type === "Polygon") {
                  const s2 = or(e2.coordinates, n2, i2), a2 = cr(t3.geometry(), r2, n2, i2);
                  if (!We(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!rr(t4, s2))
                      return false;
                }
                if (e2.type === "MultiPolygon") {
                  const s2 = lr(e2.coordinates, n2, i2), a2 = cr(t3.geometry(), r2, n2, i2);
                  if (!We(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!nr(t4, s2))
                      return false;
                }
                return true;
              }(t2, this.geometries);
            if (t2.geometryType() === "LineString")
              return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (e2.type === "Polygon") {
                  const s2 = or(e2.coordinates, n2, i2), a2 = hr(t3.geometry(), r2, n2, i2);
                  if (!We(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!ir(t4, s2))
                      return false;
                }
                if (e2.type === "MultiPolygon") {
                  const s2 = lr(e2.coordinates, n2, i2), a2 = hr(t3.geometry(), r2, n2, i2);
                  if (!We(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!sr(t4, s2))
                      return false;
                }
                return true;
              }(t2, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }
      let fr = class {
        constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
          if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
            for (let t3 = (this.length >> 1) - 1;t3 >= 0; t3--)
              this._down(t3);
        }
        push(t2) {
          this.data.push(t2), this._up(this.length++);
        }
        pop() {
          if (this.length === 0)
            return;
          const t2 = this.data[0], e2 = this.data.pop();
          return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
        }
        peek() {
          return this.data[0];
        }
        _up(t2) {
          const { data: e2, compare: r2 } = this, n2 = e2[t2];
          for (;t2 > 0; ) {
            const i2 = t2 - 1 >> 1, s2 = e2[i2];
            if (r2(n2, s2) >= 0)
              break;
            e2[t2] = s2, t2 = i2;
          }
          e2[t2] = n2;
        }
        _down(t2) {
          const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
          for (;t2 < n2; ) {
            let n3 = 1 + (t2 << 1);
            const s2 = n3 + 1;
            if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0)
              break;
            e2[t2] = e2[n3], t2 = n3;
          }
          e2[t2] = i2;
        }
      };
      function dr(t2, e2, r2, n2, i2) {
        yr(t2, e2, r2, n2 || t2.length - 1, i2 || gr);
      }
      function yr(t2, e2, r2, n2, i2) {
        for (;n2 > r2; ) {
          if (n2 - r2 > 600) {
            var s2 = n2 - r2 + 1, a2 = e2 - r2 + 1, o2 = Math.log(s2), l2 = 0.5 * Math.exp(2 * o2 / 3), u5 = 0.5 * Math.sqrt(o2 * l2 * (s2 - l2) / s2) * (a2 - s2 / 2 < 0 ? -1 : 1);
            yr(t2, e2, Math.max(r2, Math.floor(e2 - a2 * l2 / s2 + u5)), Math.min(n2, Math.floor(e2 + (s2 - a2) * l2 / s2 + u5)), i2);
          }
          var c2 = t2[e2], h2 = r2, p2 = n2;
          for (mr(t2, r2, e2), i2(t2[n2], c2) > 0 && mr(t2, r2, n2);h2 < p2; ) {
            for (mr(t2, h2, p2), h2++, p2--;i2(t2[h2], c2) < 0; )
              h2++;
            for (;i2(t2[p2], c2) > 0; )
              p2--;
          }
          i2(t2[r2], c2) === 0 ? mr(t2, r2, p2) : mr(t2, ++p2, n2), p2 <= e2 && (r2 = p2 + 1), e2 <= p2 && (n2 = p2 - 1);
        }
      }
      function mr(t2, e2, r2) {
        var n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      function gr(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function xr(t2, e2) {
        if (t2.length <= 1)
          return [t2];
        const r2 = [];
        let n2, i2;
        for (const e3 of t2) {
          const t3 = br(e3);
          t3 !== 0 && (e3.area = Math.abs(t3), i2 === undefined && (i2 = t3 < 0), i2 === t3 < 0 ? (n2 && r2.push(n2), n2 = [e3]) : n2.push(e3));
        }
        if (n2 && r2.push(n2), e2 > 1)
          for (let t3 = 0;t3 < r2.length; t3++)
            r2[t3].length <= e2 || (dr(r2[t3], e2, 1, r2[t3].length - 1, vr), r2[t3] = r2[t3].slice(0, e2));
        return r2;
      }
      function vr(t2, e2) {
        return e2.area - t2.area;
      }
      function br(t2) {
        let e2 = 0;
        for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1;i2 < s2; a2 = i2++)
          r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
        return e2;
      }
      const wr = 1 / 298.257223563, _r = wr * (2 - wr), Ar = Math.PI / 180;

      class Sr {
        constructor(t2) {
          const e2 = 6378.137 * Ar * 1000, r2 = Math.cos(t2 * Ar), n2 = 1 / (1 - _r * (1 - r2 * r2)), i2 = Math.sqrt(n2);
          this.kx = e2 * i2 * r2, this.ky = e2 * i2 * n2 * (1 - _r);
        }
        distance(t2, e2) {
          const r2 = this.wrap(t2[0] - e2[0]) * this.kx, n2 = (t2[1] - e2[1]) * this.ky;
          return Math.sqrt(r2 * r2 + n2 * n2);
        }
        pointOnLine(t2, e2) {
          let r2, n2, i2, s2, a2 = 1 / 0;
          for (let o2 = 0;o2 < t2.length - 1; o2++) {
            let l2 = t2[o2][0], u5 = t2[o2][1], c2 = this.wrap(t2[o2 + 1][0] - l2) * this.kx, h2 = (t2[o2 + 1][1] - u5) * this.ky, p2 = 0;
            c2 === 0 && h2 === 0 || (p2 = (this.wrap(e2[0] - l2) * this.kx * c2 + (e2[1] - u5) * this.ky * h2) / (c2 * c2 + h2 * h2), p2 > 1 ? (l2 = t2[o2 + 1][0], u5 = t2[o2 + 1][1]) : p2 > 0 && (l2 += c2 / this.kx * p2, u5 += h2 / this.ky * p2)), c2 = this.wrap(e2[0] - l2) * this.kx, h2 = (e2[1] - u5) * this.ky;
            const f2 = c2 * c2 + h2 * h2;
            f2 < a2 && (a2 = f2, r2 = l2, n2 = u5, i2 = o2, s2 = p2);
          }
          return { point: [r2, n2], index: i2, t: Math.max(0, Math.min(1, s2)) };
        }
        wrap(t2) {
          for (;t2 < -180; )
            t2 += 360;
          for (;t2 > 180; )
            t2 -= 360;
          return t2;
        }
      }
      function kr(t2, e2) {
        return e2[0] - t2[0];
      }
      function Mr(t2) {
        return t2[1] - t2[0] + 1;
      }
      function Ir(t2, e2) {
        return t2[1] >= t2[0] && t2[1] < e2;
      }
      function zr(t2, e2) {
        if (t2[0] > t2[1])
          return [null, null];
        const r2 = Mr(t2);
        if (e2) {
          if (r2 === 2)
            return [t2, null];
          const e3 = Math.floor(r2 / 2);
          return [[t2[0], t2[0] + e3], [t2[0] + e3, t2[1]]];
        }
        if (r2 === 1)
          return [t2, null];
        const n2 = Math.floor(r2 / 2) - 1;
        return [[t2[0], t2[0] + n2], [t2[0] + n2 + 1, t2[1]]];
      }
      function Pr(t2, e2) {
        if (!Ir(e2, t2.length))
          return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let n2 = e2[0];n2 <= e2[1]; ++n2)
          Je(r2, t2[n2]);
        return r2;
      }
      function Cr(t2) {
        const e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const r2 of t2)
          for (const t3 of r2)
            Je(e2, t3);
        return e2;
      }
      function Br(t2) {
        return t2[0] !== -1 / 0 && t2[1] !== -1 / 0 && t2[2] !== 1 / 0 && t2[3] !== 1 / 0;
      }
      function Vr(t2, e2, r2) {
        if (!Br(t2) || !Br(e2))
          return NaN;
        let n2 = 0, i2 = 0;
        return t2[2] < e2[0] && (n2 = e2[0] - t2[2]), t2[0] > e2[2] && (n2 = t2[0] - e2[2]), t2[1] > e2[3] && (i2 = t2[1] - e2[3]), t2[3] < e2[1] && (i2 = e2[1] - t2[3]), r2.distance([0, 0], [n2, i2]);
      }
      function Er(t2, e2, r2) {
        const n2 = r2.pointOnLine(e2, t2);
        return r2.distance(t2, n2.point);
      }
      function Fr(t2, e2, r2, n2, i2) {
        const s2 = Math.min(Er(t2, [r2, n2], i2), Er(e2, [r2, n2], i2)), a2 = Math.min(Er(r2, [t2, e2], i2), Er(n2, [t2, e2], i2));
        return Math.min(s2, a2);
      }
      function Tr(t2, e2, r2, n2, i2) {
        if (!Ir(e2, t2.length) || !Ir(n2, r2.length))
          return 1 / 0;
        let s2 = 1 / 0;
        for (let a2 = e2[0];a2 < e2[1]; ++a2) {
          const e3 = t2[a2], o2 = t2[a2 + 1];
          for (let t3 = n2[0];t3 < n2[1]; ++t3) {
            const n3 = r2[t3], a3 = r2[t3 + 1];
            if (tr(e3, o2, n3, a3))
              return 0;
            s2 = Math.min(s2, Fr(e3, o2, n3, a3, i2));
          }
        }
        return s2;
      }
      function $r(t2, e2, r2, n2, i2) {
        if (!Ir(e2, t2.length) || !Ir(n2, r2.length))
          return NaN;
        let s2 = 1 / 0;
        for (let a2 = e2[0];a2 <= e2[1]; ++a2)
          for (let e3 = n2[0];e3 <= n2[1]; ++e3)
            if (s2 = Math.min(s2, i2.distance(t2[a2], r2[e3])), s2 === 0)
              return s2;
        return s2;
      }
      function Lr(t2, e2, r2) {
        if (rr(t2, e2, true))
          return 0;
        let n2 = 1 / 0;
        for (const i2 of e2) {
          const e3 = i2[0], s2 = i2[i2.length - 1];
          if (e3 !== s2 && (n2 = Math.min(n2, Er(t2, [s2, e3], r2)), n2 === 0))
            return n2;
          const a2 = r2.pointOnLine(i2, t2);
          if (n2 = Math.min(n2, r2.distance(t2, a2.point)), n2 === 0)
            return n2;
        }
        return n2;
      }
      function Dr(t2, e2, r2, n2) {
        if (!Ir(e2, t2.length))
          return NaN;
        for (let n3 = e2[0];n3 <= e2[1]; ++n3)
          if (rr(t2[n3], r2, true))
            return 0;
        let i2 = 1 / 0;
        for (let s2 = e2[0];s2 < e2[1]; ++s2) {
          const e3 = t2[s2], a2 = t2[s2 + 1];
          for (const t3 of r2)
            for (let r3 = 0, s3 = t3.length, o2 = s3 - 1;r3 < s3; o2 = r3++) {
              const s4 = t3[o2], l2 = t3[r3];
              if (tr(e3, a2, s4, l2))
                return 0;
              i2 = Math.min(i2, Fr(e3, a2, s4, l2, n2));
            }
        }
        return i2;
      }
      function Or(t2, e2) {
        for (const r2 of t2)
          for (const t3 of r2)
            if (rr(t3, e2, true))
              return true;
        return false;
      }
      function jr(t2, e2, r2, n2 = 1 / 0) {
        const i2 = Cr(t2), s2 = Cr(e2);
        if (n2 !== 1 / 0 && Vr(i2, s2, r2) >= n2)
          return n2;
        if (We(i2, s2)) {
          if (Or(t2, e2))
            return 0;
        } else if (Or(e2, t2))
          return 0;
        let a2 = 1 / 0;
        for (const n3 of t2)
          for (let t3 = 0, i3 = n3.length, s3 = i3 - 1;t3 < i3; s3 = t3++) {
            const i4 = n3[s3], o2 = n3[t3];
            for (const t4 of e2)
              for (let e3 = 0, n4 = t4.length, s4 = n4 - 1;e3 < n4; s4 = e3++) {
                const n5 = t4[s4], l2 = t4[e3];
                if (tr(i4, o2, n5, l2))
                  return 0;
                a2 = Math.min(a2, Fr(i4, o2, n5, l2, r2));
              }
          }
        return a2;
      }
      function Rr(t2, e2, r2, n2, i2, s2) {
        if (!s2)
          return;
        const a2 = Vr(Pr(n2, s2), i2, r2);
        a2 < e2 && t2.push([a2, s2, [0, 0]]);
      }
      function Ur(t2, e2, r2, n2, i2, s2, a2) {
        if (!s2 || !a2)
          return;
        const o2 = Vr(Pr(n2, s2), Pr(i2, a2), r2);
        o2 < e2 && t2.push([o2, s2, a2]);
      }
      function qr(t2, e2, r2, n2, i2 = 1 / 0) {
        let s2 = Math.min(n2.distance(t2[0], r2[0][0]), i2);
        if (s2 === 0)
          return s2;
        const a2 = new fr([[0, [0, t2.length - 1], [0, 0]]], kr), o2 = Cr(r2);
        for (;a2.length > 0; ) {
          const i3 = a2.pop();
          if (i3[0] >= s2)
            continue;
          const l2 = i3[1], u5 = e2 ? 50 : 100;
          if (Mr(l2) <= u5) {
            if (!Ir(l2, t2.length))
              return NaN;
            if (e2) {
              const e3 = Dr(t2, l2, r2, n2);
              if (isNaN(e3) || e3 === 0)
                return e3;
              s2 = Math.min(s2, e3);
            } else
              for (let e3 = l2[0];e3 <= l2[1]; ++e3) {
                const i4 = Lr(t2[e3], r2, n2);
                if (s2 = Math.min(s2, i4), s2 === 0)
                  return 0;
              }
          } else {
            const r3 = zr(l2, e2);
            Rr(a2, s2, n2, t2, o2, r3[0]), Rr(a2, s2, n2, t2, o2, r3[1]);
          }
        }
        return s2;
      }
      function Nr(t2, e2, r2, n2, i2, s2 = 1 / 0) {
        let a2 = Math.min(s2, i2.distance(t2[0], r2[0]));
        if (a2 === 0)
          return a2;
        const o2 = new fr([[0, [0, t2.length - 1], [0, r2.length - 1]]], kr);
        for (;o2.length > 0; ) {
          const s3 = o2.pop();
          if (s3[0] >= a2)
            continue;
          const l2 = s3[1], u5 = s3[2], c2 = e2 ? 50 : 100, h2 = n2 ? 50 : 100;
          if (Mr(l2) <= c2 && Mr(u5) <= h2) {
            if (!Ir(l2, t2.length) && Ir(u5, r2.length))
              return NaN;
            let s4;
            if (e2 && n2)
              s4 = Tr(t2, l2, r2, u5, i2), a2 = Math.min(a2, s4);
            else if (e2 && !n2) {
              const e3 = t2.slice(l2[0], l2[1] + 1);
              for (let t3 = u5[0];t3 <= u5[1]; ++t3)
                if (s4 = Er(r2[t3], e3, i2), a2 = Math.min(a2, s4), a2 === 0)
                  return a2;
            } else if (!e2 && n2) {
              const e3 = r2.slice(u5[0], u5[1] + 1);
              for (let r3 = l2[0];r3 <= l2[1]; ++r3)
                if (s4 = Er(t2[r3], e3, i2), a2 = Math.min(a2, s4), a2 === 0)
                  return a2;
            } else
              s4 = $r(t2, l2, r2, u5, i2), a2 = Math.min(a2, s4);
          } else {
            const s4 = zr(l2, e2), c3 = zr(u5, n2);
            Ur(o2, a2, i2, t2, r2, s4[0], c3[0]), Ur(o2, a2, i2, t2, r2, s4[0], c3[1]), Ur(o2, a2, i2, t2, r2, s4[1], c3[0]), Ur(o2, a2, i2, t2, r2, s4[1], c3[1]);
          }
        }
        return a2;
      }
      function Zr(t2) {
        return t2.type === "MultiPolygon" ? t2.coordinates.map((t3) => ({ type: "Polygon", coordinates: t3 })) : t2.type === "MultiLineString" ? t2.coordinates.map((t3) => ({ type: "LineString", coordinates: t3 })) : t2.type === "MultiPoint" ? t2.coordinates.map((t3) => ({ type: "Point", coordinates: t3 })) : [t2];
      }

      class Gr {
        constructor(t2, e2) {
          this.type = ut, this.geojson = t2, this.geometries = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`'distance' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (re(t2[1])) {
            const e3 = t2[1];
            if (e3.type === "FeatureCollection")
              return new Gr(e3, e3.features.map((t3) => Zr(t3.geometry)).flat());
            if (e3.type === "Feature")
              return new Gr(e3, Zr(e3.geometry));
            if ("type" in e3 && "coordinates" in e3)
              return new Gr(e3, Zr(e3));
          }
          return e2.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t2) {
          if (t2.geometry() != null && t2.canonicalID() != null) {
            if (t2.geometryType() === "Point")
              return function(t3, e2) {
                const r2 = t3.geometry(), n2 = r2.flat().map((e3) => Ye([e3.x, e3.y], t3.canonical));
                if (r2.length === 0)
                  return NaN;
                const i2 = new Sr(n2[0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2) {
                  switch (t4.type) {
                    case "Point":
                      s2 = Math.min(s2, Nr(n2, false, [t4.coordinates], false, i2, s2));
                      break;
                    case "LineString":
                      s2 = Math.min(s2, Nr(n2, false, t4.coordinates, true, i2, s2));
                      break;
                    case "Polygon":
                      s2 = Math.min(s2, qr(n2, false, t4.coordinates, i2, s2));
                  }
                  if (s2 === 0)
                    return s2;
                }
                return s2;
              }(t2, this.geometries);
            if (t2.geometryType() === "LineString")
              return function(t3, e2) {
                const r2 = t3.geometry(), n2 = r2.flat().map((e3) => Ye([e3.x, e3.y], t3.canonical));
                if (r2.length === 0)
                  return NaN;
                const i2 = new Sr(n2[0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2) {
                  switch (t4.type) {
                    case "Point":
                      s2 = Math.min(s2, Nr(n2, true, [t4.coordinates], false, i2, s2));
                      break;
                    case "LineString":
                      s2 = Math.min(s2, Nr(n2, true, t4.coordinates, true, i2, s2));
                      break;
                    case "Polygon":
                      s2 = Math.min(s2, qr(n2, true, t4.coordinates, i2, s2));
                  }
                  if (s2 === 0)
                    return s2;
                }
                return s2;
              }(t2, this.geometries);
            if (t2.geometryType() === "Polygon")
              return function(t3, e2) {
                const r2 = t3.geometry();
                if (r2.length === 0 || r2[0].length === 0)
                  return NaN;
                const n2 = xr(r2, 0).map((e3) => e3.map((e4) => e4.map((e5) => Ye([e5.x, e5.y], t3.canonical)))), i2 = new Sr(n2[0][0][0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2)
                  for (const e3 of n2) {
                    switch (t4.type) {
                      case "Point":
                        s2 = Math.min(s2, qr([t4.coordinates], false, e3, i2, s2));
                        break;
                      case "LineString":
                        s2 = Math.min(s2, qr(t4.coordinates, true, e3, i2, s2));
                        break;
                      case "Polygon":
                        s2 = Math.min(s2, jr(e3, t4.coordinates, i2, s2));
                    }
                    if (s2 === 0)
                      return s2;
                  }
                return s2;
              }(t2, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }
      const Kr = { "==": Le, "!=": De, ">": je, "<": Oe, ">=": Ue, "<=": Re, array: le, at: me, boolean: le, case: be, coalesce: Ee, collator: qe, format: Ze, image: Ge, in: ge, "index-of": xe, interpolate: Be, "interpolate-hcl": Be, "interpolate-lab": Be, length: Ke, let: de2, literal: se, match: ve, number: le, "number-format": Ne, object: le, slice: we, step: Ae, string: le, "to-boolean": ce2, "to-color": ce2, "to-number": ce2, "to-string": ce2, var: ye, within: pr, distance: Gr };

      class Xr {
        constructor(t2, e2, r2, n2) {
          this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
        }
        evaluate(t2) {
          return this._evaluate(t2, this.args);
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return false;
        }
        static parse(t2, e2) {
          const r2 = t2[0], n2 = Xr.definitions[r2];
          if (!n2)
            return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1);
          let o2 = null;
          for (const [n3, s3] of a2) {
            o2 = new fe(e2.registry, Qr, e2.path, null, e2.scope);
            const a3 = [];
            let l2 = false;
            for (let e3 = 1;e3 < t2.length; e3++) {
              const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, s4 = o2.parse(r3, 1 + a3.length, i3);
              if (!s4) {
                l2 = true;
                break;
              }
              a3.push(s4);
            }
            if (!l2)
              if (Array.isArray(n3) && n3.length !== a3.length)
                o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
              else {
                for (let t3 = 0;t3 < a3.length; t3++) {
                  const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = a3[t3];
                  o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                }
                if (o2.errors.length === 0)
                  return new Xr(r2, i2, s3, a3);
              }
          }
          if (a2.length === 1)
            e2.errors.push(...o2.errors);
          else {
            const r3 = (a2.length ? a2 : s2).map(([t3]) => {
              return e3 = t3, Array.isArray(e3) ? `(${e3.map(wt).join(", ")})` : `(${wt(e3.type)}...)`;
              var e3;
            }).join(" | "), n3 = [];
            for (let r4 = 1;r4 < t2.length; r4++) {
              const i3 = e2.parse(t2[r4], 1 + n3.length);
              if (!i3)
                return null;
              n3.push(wt(i3.type));
            }
            e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
          }
          return null;
        }
        static register(t2, e2) {
          Xr.definitions = e2;
          for (const r2 in e2)
            t2[r2] = Xr;
        }
      }
      function Hr(t2, [e2, r2, n2, i2]) {
        e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
        const s2 = i2 ? i2.evaluate(t2) : 1, a2 = ee(e2, r2, n2, s2);
        if (a2)
          throw new ae(a2);
        return new Kt(e2 / 255, r2 / 255, n2 / 255, s2, false);
      }
      function Yr(t2, e2) {
        return t2 in e2;
      }
      function Jr(t2, e2) {
        const r2 = e2[t2];
        return r2 === undefined ? null : r2;
      }
      function Wr(t2) {
        return { type: t2 };
      }
      function Qr(t2) {
        if (t2 instanceof ye)
          return Qr(t2.boundExpression);
        if (t2 instanceof Xr && t2.name === "error")
          return false;
        if (t2 instanceof qe)
          return false;
        if (t2 instanceof pr)
          return false;
        if (t2 instanceof Gr)
          return false;
        const e2 = t2 instanceof ce2 || t2 instanceof le;
        let r2 = true;
        return t2.eachChild((t3) => {
          r2 = e2 ? r2 && Qr(t3) : r2 && t3 instanceof se;
        }), !!r2 && tn(t2) && rn(t2, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function tn(t2) {
        if (t2 instanceof Xr) {
          if (t2.name === "get" && t2.args.length === 1)
            return false;
          if (t2.name === "feature-state")
            return false;
          if (t2.name === "has" && t2.args.length === 1)
            return false;
          if (t2.name === "properties" || t2.name === "geometry-type" || t2.name === "id")
            return false;
          if (/^filter-/.test(t2.name))
            return false;
        }
        if (t2 instanceof pr)
          return false;
        if (t2 instanceof Gr)
          return false;
        let e2 = true;
        return t2.eachChild((t3) => {
          e2 && !tn(t3) && (e2 = false);
        }), e2;
      }
      function en(t2) {
        if (t2 instanceof Xr && t2.name === "feature-state")
          return false;
        let e2 = true;
        return t2.eachChild((t3) => {
          e2 && !en(t3) && (e2 = false);
        }), e2;
      }
      function rn(t2, e2) {
        if (t2 instanceof Xr && e2.indexOf(t2.name) >= 0)
          return false;
        let r2 = true;
        return t2.eachChild((t3) => {
          r2 && !rn(t3, e2) && (r2 = false);
        }), r2;
      }
      function nn(t2) {
        return { result: "success", value: t2 };
      }
      function sn(t2) {
        return { result: "error", value: t2 };
      }
      function an(t2) {
        return t2["property-type"] === "data-driven" || t2["property-type"] === "cross-faded-data-driven";
      }
      function on(t2) {
        return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
      }
      function ln(t2) {
        return !!t2.expression && t2.expression.interpolated;
      }
      function un(t2) {
        return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : t2 === null ? "null" : typeof t2;
      }
      function cn(t2) {
        return typeof t2 == "object" && t2 !== null && !Array.isArray(t2);
      }
      function hn(t2) {
        return t2;
      }
      function pn(t2, e2) {
        const r2 = e2.type === "color", n2 = t2.stops && typeof t2.stops[0][0] == "object", i2 = n2 || !(n2 || t2.property !== undefined), s2 = t2.type || (ln(e2) ? "exponential" : "interval");
        if (r2 || e2.type === "padding") {
          const n3 = r2 ? Kt.parse : Jt.parse;
          (t2 = st({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], n3(t3[1])])), t2.default = n3(t2.default ? t2.default : e2.default);
        }
        if (t2.colorSpace && (a2 = t2.colorSpace) !== "rgb" && a2 !== "hcl" && a2 !== "lab")
          throw new Error(`Unknown color space: "${t2.colorSpace}"`);
        var a2;
        let o2, l2, u5;
        if (s2 === "exponential")
          o2 = mn;
        else if (s2 === "interval")
          o2 = yn;
        else if (s2 === "categorical") {
          o2 = dn, l2 = Object.create(null);
          for (const e3 of t2.stops)
            l2[e3[0]] = e3[1];
          u5 = typeof t2.stops[0][0];
        } else {
          if (s2 !== "identity")
            throw new Error(`Unknown function type "${s2}"`);
          o2 = gn;
        }
        if (n2) {
          const r3 = {}, n3 = [];
          for (let e3 = 0;e3 < t2.stops.length; e3++) {
            const i4 = t2.stops[e3], s4 = i4[0].zoom;
            r3[s4] === undefined && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
          }
          const i3 = [];
          for (const t3 of n3)
            i3.push([r3[t3].zoom, pn(r3[t3], e2)]);
          const s3 = { name: "linear" };
          return { kind: "composite", interpolationType: s3, interpolationFactor: Be.interpolationFactor.bind(undefined, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => mn({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
        }
        if (i2) {
          const r3 = s2 === "exponential" ? { name: "exponential", base: t2.base !== undefined ? t2.base : 1 } : null;
          return { kind: "camera", interpolationType: r3, interpolationFactor: Be.interpolationFactor.bind(undefined, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => o2(t2, e2, r4, l2, u5) };
        }
        return { kind: "source", evaluate(r3, n3) {
          const i3 = n3 && n3.properties ? n3.properties[t2.property] : undefined;
          return i3 === undefined ? fn(t2.default, e2.default) : o2(t2, e2, i3, l2, u5);
        } };
      }
      function fn(t2, e2, r2) {
        return t2 !== undefined ? t2 : e2 !== undefined ? e2 : r2 !== undefined ? r2 : undefined;
      }
      function dn(t2, e2, r2, n2, i2) {
        return fn(typeof r2 === i2 ? n2[r2] : undefined, t2.default, e2.default);
      }
      function yn(t2, e2, r2) {
        if (un(r2) !== "number")
          return fn(t2.default, e2.default);
        const n2 = t2.stops.length;
        if (n2 === 1)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[n2 - 1][0])
          return t2.stops[n2 - 1][1];
        const i2 = _e(t2.stops.map((t3) => t3[0]), r2);
        return t2.stops[i2][1];
      }
      function mn(t2, e2, r2) {
        const n2 = t2.base !== undefined ? t2.base : 1;
        if (un(r2) !== "number")
          return fn(t2.default, e2.default);
        const i2 = t2.stops.length;
        if (i2 === 1)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[i2 - 1][0])
          return t2.stops[i2 - 1][1];
        const s2 = _e(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n3) {
          const i3 = n3 - r3, s3 = t3 - r3;
          return i3 === 0 ? 0 : e3 === 1 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
        }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1], u5 = Ce[e2.type] || hn;
        return typeof o2.evaluate == "function" ? { evaluate(...e3) {
          const r3 = o2.evaluate.apply(undefined, e3), n3 = l2.evaluate.apply(undefined, e3);
          if (r3 !== undefined && n3 !== undefined)
            return u5(r3, n3, a2, t2.colorSpace);
        } } : u5(o2, l2, a2, t2.colorSpace);
      }
      function gn(t2, e2, r2) {
        switch (e2.type) {
          case "color":
            r2 = Kt.parse(r2);
            break;
          case "formatted":
            r2 = Yt.fromString(r2.toString());
            break;
          case "resolvedImage":
            r2 = te.fromString(r2.toString());
            break;
          case "padding":
            r2 = Jt.parse(r2);
            break;
          default:
            un(r2) === e2.type || e2.type === "enum" && e2.values[r2] || (r2 = undefined);
        }
        return fn(r2, t2.default, e2.default);
      }
      Xr.register(Kr, { error: [{ kind: "error" }, [ct], (t2, [e2]) => {
        throw new ae(e2.evaluate(t2));
      }], typeof: [ct, [dt], (t2, [e2]) => wt(ne(e2.evaluate(t2)))], "to-rgba": [bt(ut, 4), [pt], (t2, [e2]) => {
        const [r2, n2, i2, s2] = e2.evaluate(t2).rgb;
        return [255 * r2, 255 * n2, 255 * i2, s2];
      }], rgb: [pt, [ut, ut, ut], Hr], rgba: [pt, [ut, ut, ut, ut], Hr], has: { type: ht, overloads: [[[ct], (t2, [e2]) => Yr(e2.evaluate(t2), t2.properties())], [[ct, ft], (t2, [e2, r2]) => Yr(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: dt, overloads: [[[ct], (t2, [e2]) => Jr(e2.evaluate(t2), t2.properties())], [[ct, ft], (t2, [e2, r2]) => Jr(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [dt, [ct], (t2, [e2]) => Jr(e2.evaluate(t2), t2.featureState || {})], properties: [ft, [], (t2) => t2.properties()], "geometry-type": [ct, [], (t2) => t2.geometryType()], id: [dt, [], (t2) => t2.id()], zoom: [ut, [], (t2) => t2.globals.zoom], "heatmap-density": [ut, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [ut, [], (t2) => t2.globals.lineProgress || 0], accumulated: [dt, [], (t2) => t2.globals.accumulated === undefined ? null : t2.globals.accumulated], "+": [ut, Wr(ut), (t2, e2) => {
        let r2 = 0;
        for (const n2 of e2)
          r2 += n2.evaluate(t2);
        return r2;
      }], "*": [ut, Wr(ut), (t2, e2) => {
        let r2 = 1;
        for (const n2 of e2)
          r2 *= n2.evaluate(t2);
        return r2;
      }], "-": { type: ut, overloads: [[[ut, ut], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[ut], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [ut, [ut, ut], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [ut, [ut, ut], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [ut, [], () => Math.LN2], pi: [ut, [], () => Math.PI], e: [ut, [], () => Math.E], "^": [ut, [ut, ut], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [ut, [ut], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [ut, [ut], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [ut, [ut], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [ut, [ut], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [ut, [ut], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [ut, [ut], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [ut, [ut], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [ut, [ut], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [ut, [ut], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [ut, [ut], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [ut, Wr(ut), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [ut, Wr(ut), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [ut, [ut], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [ut, [ut], (t2, [e2]) => {
        const r2 = e2.evaluate(t2);
        return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
      }], floor: [ut, [ut], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [ut, [ut], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [ht, [ct, dt], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [ht, [dt], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [ht, [ct], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [ht, [ct, dt], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 < i2;
      }], "filter-id-<": [ht, [dt], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 < n2;
      }], "filter->": [ht, [ct, dt], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 > i2;
      }], "filter-id->": [ht, [dt], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 > n2;
      }], "filter-<=": [ht, [ct, dt], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 <= i2;
      }], "filter-id-<=": [ht, [dt], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 <= n2;
      }], "filter->=": [ht, [ct, dt], (t2, [e2, r2]) => {
        const n2 = t2.properties()[e2.value], i2 = r2.value;
        return typeof n2 == typeof i2 && n2 >= i2;
      }], "filter-id->=": [ht, [dt], (t2, [e2]) => {
        const r2 = t2.id(), n2 = e2.value;
        return typeof r2 == typeof n2 && r2 >= n2;
      }], "filter-has": [ht, [dt], (t2, [e2]) => (e2.value in t2.properties())], "filter-has-id": [ht, [], (t2) => t2.id() !== null && t2.id() !== undefined], "filter-type-in": [ht, [bt(ct)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [ht, [bt(dt)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [ht, [ct, bt(dt)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [ht, [ct, bt(dt)], (t2, [e2, r2]) => function(t3, e3, r3, n2) {
        for (;r3 <= n2; ) {
          const i2 = r3 + n2 >> 1;
          if (e3[i2] === t3)
            return true;
          e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
        }
        return false;
      }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: ht, overloads: [[[ht, ht], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [Wr(ht), (t2, e2) => {
        for (const r2 of e2)
          if (!r2.evaluate(t2))
            return false;
        return true;
      }]] }, any: { type: ht, overloads: [[[ht, ht], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [Wr(ht), (t2, e2) => {
        for (const r2 of e2)
          if (r2.evaluate(t2))
            return true;
        return false;
      }]] }, "!": [ht, [ht], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [ht, [ct], (t2, [e2]) => {
        const r2 = t2.globals && t2.globals.isSupportedScript;
        return !r2 || r2(e2.evaluate(t2));
      }], upcase: [ct, [ct], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [ct, [ct], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [ct, Wr(dt), (t2, e2) => e2.map((e3) => ie(e3.evaluate(t2))).join("")], "resolved-locale": [ct, [yt], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()] });

      class xn {
        constructor(t2, e2) {
          var r2;
          this.expression = t2, this._warningHistory = {}, this._evaluator = new pe, this._defaultValue = e2 ? (r2 = e2).type === "color" && cn(r2.default) ? new Kt(0, 0, 0, 0) : r2.type === "color" ? Kt.parse(r2.default) || null : r2.type === "padding" ? Jt.parse(r2.default) || null : r2.type === "variableAnchorOffsetCollection" ? Qt.parse(r2.default) || null : r2.default === undefined ? null : r2.default : null, this._enumValues = e2 && e2.type === "enum" ? e2.values : null;
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this.expression.evaluate(this._evaluator);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null;
          try {
            const t3 = this.expression.evaluate(this._evaluator);
            if (t3 == null || typeof t3 == "number" && t3 != t3)
              return this._defaultValue;
            if (this._enumValues && !(t3 in this._enumValues))
              throw new ae(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
            return t3;
          } catch (t3) {
            return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, typeof console != "undefined" && console.warn(t3.message)), this._defaultValue;
          }
        }
      }
      function vn(t2) {
        return Array.isArray(t2) && t2.length > 0 && typeof t2[0] == "string" && t2[0] in Kr;
      }
      function bn(t2, e2) {
        const r2 = new fe(Kr, Qr, [], e2 ? function(t3) {
          const e3 = { color: pt, string: ct, number: ut, enum: ct, boolean: ht, formatted: mt, padding: gt, resolvedImage: xt, variableAnchorOffsetCollection: vt };
          return t3.type === "array" ? bt(e3[t3.value] || dt, t3.length) : e3[t3.type];
        }(e2) : undefined), n2 = r2.parse(t2, undefined, undefined, undefined, e2 && e2.type === "string" ? { typeAnnotation: "coerce" } : undefined);
        return n2 ? nn(new xn(n2, e2)) : sn(r2.errors);
      }

      class wn {
        constructor(t2, e2) {
          this.kind = t2, this._styleExpression = e2, this.isStateDependent = t2 !== "constant" && !en(e2.expression);
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
        }
      }

      class _n {
        constructor(t2, e2, r2, n2) {
          this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = t2 !== "camera" && !en(e2.expression), this.interpolationType = n2;
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
        }
        interpolationFactor(t2, e2, r2) {
          return this.interpolationType ? Be.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
        }
      }
      function An(t2, e2) {
        const r2 = bn(t2, e2);
        if (r2.result === "error")
          return r2;
        const n2 = r2.value.expression, i2 = tn(n2);
        if (!i2 && !an(e2))
          return sn([new at("", "data expressions not supported")]);
        const s2 = rn(n2, ["zoom"]);
        if (!s2 && !on(e2))
          return sn([new at("", "zoom expressions not supported")]);
        const a2 = kn(n2);
        return a2 || s2 ? a2 instanceof at ? sn([a2]) : a2 instanceof Be && !ln(e2) ? sn([new at("", '"interpolate" expressions cannot be used with this property')]) : nn(a2 ? new _n(i2 ? "camera" : "composite", r2.value, a2.labels, a2 instanceof Be ? a2.interpolation : undefined) : new wn(i2 ? "constant" : "source", r2.value)) : sn([new at("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }

      class Sn {
        constructor(t2, e2) {
          this._parameters = t2, this._specification = e2, st(this, pn(this._parameters, this._specification));
        }
        static deserialize(t2) {
          return new Sn(t2._parameters, t2._specification);
        }
        static serialize(t2) {
          return { _parameters: t2._parameters, _specification: t2._specification };
        }
      }
      function kn(t2) {
        let e2 = null;
        if (t2 instanceof de2)
          e2 = kn(t2.result);
        else if (t2 instanceof Ee) {
          for (const r2 of t2.args)
            if (e2 = kn(r2), e2)
              break;
        } else
          (t2 instanceof Ae || t2 instanceof Be) && t2.input instanceof Xr && t2.input.name === "zoom" && (e2 = t2);
        return e2 instanceof at || t2.eachChild((t3) => {
          const r2 = kn(t3);
          r2 instanceof at ? e2 = r2 : !e2 && r2 ? e2 = new at("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new at("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e2;
      }
      function Mn(t2) {
        if (t2 === true || t2 === false)
          return true;
        if (!Array.isArray(t2) || t2.length === 0)
          return false;
        switch (t2[0]) {
          case "has":
            return t2.length >= 2 && t2[1] !== "$id" && t2[1] !== "$type";
          case "in":
            return t2.length >= 3 && (typeof t2[1] != "string" || Array.isArray(t2[2]));
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return t2.length !== 3 || Array.isArray(t2[1]) || Array.isArray(t2[2]);
          case "any":
          case "all":
            for (const e2 of t2.slice(1))
              if (!Mn(e2) && typeof e2 != "boolean")
                return false;
            return true;
          default:
            return true;
        }
      }
      const In = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
      function zn(t2) {
        if (t2 == null)
          return { filter: () => true, needGeometry: false };
        Mn(t2) || (t2 = Bn(t2));
        const e2 = bn(t2, In);
        if (e2.result === "error")
          throw new Error(e2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
        return { filter: (t3, r2, n2) => e2.value.evaluate(t3, r2, {}, n2), needGeometry: Cn(t2) };
      }
      function Pn(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function Cn(t2) {
        if (!Array.isArray(t2))
          return false;
        if (t2[0] === "within" || t2[0] === "distance")
          return true;
        for (let e2 = 1;e2 < t2.length; e2++)
          if (Cn(t2[e2]))
            return true;
        return false;
      }
      function Bn(t2) {
        if (!t2)
          return true;
        const e2 = t2[0];
        return t2.length <= 1 ? e2 !== "any" : e2 === "==" ? Vn(t2[1], t2[2], "==") : e2 === "!=" ? Tn(Vn(t2[1], t2[2], "==")) : e2 === "<" || e2 === ">" || e2 === "<=" || e2 === ">=" ? Vn(t2[1], t2[2], e2) : e2 === "any" ? (r2 = t2.slice(1), ["any"].concat(r2.map(Bn))) : e2 === "all" ? ["all"].concat(t2.slice(1).map(Bn)) : e2 === "none" ? ["all"].concat(t2.slice(1).map(Bn).map(Tn)) : e2 === "in" ? En(t2[1], t2.slice(2)) : e2 === "!in" ? Tn(En(t2[1], t2.slice(2))) : e2 === "has" ? Fn(t2[1]) : e2 !== "!has" || Tn(Fn(t2[1]));
        var r2;
      }
      function Vn(t2, e2, r2) {
        switch (t2) {
          case "$type":
            return [`filter-type-${r2}`, e2];
          case "$id":
            return [`filter-id-${r2}`, e2];
          default:
            return [`filter-${r2}`, t2, e2];
        }
      }
      function En(t2, e2) {
        if (e2.length === 0)
          return false;
        switch (t2) {
          case "$type":
            return ["filter-type-in", ["literal", e2]];
          case "$id":
            return ["filter-id-in", ["literal", e2]];
          default:
            return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(Pn)]] : ["filter-in-small", t2, ["literal", e2]];
        }
      }
      function Fn(t2) {
        switch (t2) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", t2];
        }
      }
      function Tn(t2) {
        return ["!", t2];
      }
      function $n(t2) {
        const e2 = typeof t2;
        if (e2 === "number" || e2 === "boolean" || e2 === "string" || t2 == null)
          return JSON.stringify(t2);
        if (Array.isArray(t2)) {
          let e3 = "[";
          for (const r3 of t2)
            e3 += `${$n(r3)},`;
          return `${e3}]`;
        }
        const r2 = Object.keys(t2).sort();
        let n2 = "{";
        for (let e3 = 0;e3 < r2.length; e3++)
          n2 += `${JSON.stringify(r2[e3])}:${$n(t2[r2[e3]])},`;
        return `${n2}}`;
      }
      function Ln(t2) {
        let e2 = "";
        for (const r2 of K)
          e2 += `/${$n(t2[r2])}`;
        return e2;
      }
      function Dn(t2) {
        const e2 = t2.value;
        return e2 ? [new it(t2.key, e2, "constants have been deprecated as of v8")] : [];
      }
      function On(t2) {
        return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
      }
      function jn(t2) {
        if (Array.isArray(t2))
          return t2.map(jn);
        if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
          const e2 = {};
          for (const r2 in t2)
            e2[r2] = jn(t2[r2]);
          return e2;
        }
        return On(t2);
      }
      function Rn(t2) {
        const { key: e2, value: r2 } = t2, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec, o2 = t2.validateSpec;
        let l2 = [];
        const u5 = un(r2);
        if (u5 !== "object")
          return [new it(e2, r2, `object expected, ${u5} found`)];
        for (const t3 in r2) {
          const u6 = t3.split(".")[0], c2 = n2[u6] || n2["*"];
          let h2;
          if (i2[u6])
            h2 = i2[u6];
          else if (n2[u6])
            h2 = o2;
          else if (i2["*"])
            h2 = i2["*"];
          else {
            if (!n2["*"]) {
              l2.push(new it(e2, r2[t3], `unknown property "${t3}"`));
              continue;
            }
            h2 = o2;
          }
          l2 = l2.concat(h2({ key: (e2 ? `${e2}.` : e2) + t3, value: r2[t3], valueSpec: c2, style: s2, styleSpec: a2, object: r2, objectKey: t3, validateSpec: o2 }, r2));
        }
        for (const t3 in n2)
          i2[t3] || n2[t3].required && n2[t3].default === undefined && r2[t3] === undefined && l2.push(new it(e2, r2, `missing required property "${t3}"`));
        return l2;
      }
      function Un(t2) {
        const { value: e2, valueSpec: r2, style: n2, styleSpec: i2, key: s2 } = t2, a2 = t2.arrayElementValidator || t2.validateSpec;
        if (un(e2) !== "array")
          return [new it(s2, e2, `array expected, ${un(e2)} found`)];
        if (r2.length && e2.length !== r2.length)
          return [new it(s2, e2, `array length ${r2.length} expected, length ${e2.length} found`)];
        if (r2["min-length"] && e2.length < r2["min-length"])
          return [new it(s2, e2, `array length at least ${r2["min-length"]} expected, length ${e2.length} found`)];
        let o2 = { type: r2.value, values: r2.values };
        i2.$version < 7 && (o2.function = r2.function), un(r2.value) === "object" && (o2 = r2.value);
        let l2 = [];
        for (let r3 = 0;r3 < e2.length; r3++)
          l2 = l2.concat(a2({ array: e2, arrayIndex: r3, value: e2[r3], valueSpec: o2, validateSpec: t2.validateSpec, style: n2, styleSpec: i2, key: `${s2}[${r3}]` }));
        return l2;
      }
      function qn(t2) {
        const { key: e2, value: r2, valueSpec: n2 } = t2;
        let i2 = un(r2);
        return i2 === "number" && r2 != r2 && (i2 = "NaN"), i2 !== "number" ? [new it(e2, r2, `number expected, ${i2} found`)] : ("minimum" in n2) && r2 < n2.minimum ? [new it(e2, r2, `${r2} is less than the minimum value ${n2.minimum}`)] : ("maximum" in n2) && r2 > n2.maximum ? [new it(e2, r2, `${r2} is greater than the maximum value ${n2.maximum}`)] : [];
      }
      function Nn(t2) {
        const e2 = t2.valueSpec, r2 = On(t2.value.type);
        let n2, i2, s2, a2 = {};
        const o2 = r2 !== "categorical" && t2.value.property === undefined, l2 = !o2, u5 = un(t2.value.stops) === "array" && un(t2.value.stops[0]) === "array" && un(t2.value.stops[0][0]) === "object", c2 = Rn({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, validateSpec: t2.validateSpec, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
          if (r2 === "identity")
            return [new it(t3.key, t3.value, 'identity function may not have a "stops" property')];
          let e3 = [];
          const n3 = t3.value;
          return e3 = e3.concat(Un({ key: t3.key, value: n3, valueSpec: t3.valueSpec, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: h2 })), un(n3) === "array" && n3.length === 0 && e3.push(new it(t3.key, n3, "array must have at least one stop")), e3;
        }, default: function(t3) {
          return t3.validateSpec({ key: t3.key, value: t3.value, valueSpec: e2, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec });
        } } });
        return r2 === "identity" && o2 && c2.push(new it(t2.key, t2.value, 'missing required property "property"')), r2 === "identity" || t2.value.stops || c2.push(new it(t2.key, t2.value, 'missing required property "stops"')), r2 === "exponential" && t2.valueSpec.expression && !ln(t2.valueSpec) && c2.push(new it(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !an(t2.valueSpec) ? c2.push(new it(t2.key, t2.value, "property functions not supported")) : o2 && !on(t2.valueSpec) && c2.push(new it(t2.key, t2.value, "zoom functions not supported"))), r2 !== "categorical" && !u5 || t2.value.property !== undefined || c2.push(new it(t2.key, t2.value, '"property" property is required')), c2;
        function h2(t3) {
          let r3 = [];
          const { value: n3, key: o3 } = t3;
          if (un(n3) !== "array")
            return [new it(o3, n3, `array expected, ${un(n3)} found`)];
          if (n3.length !== 2)
            return [new it(o3, n3, `array length 2 expected, length ${n3.length} found`)];
          if (u5) {
            if (un(n3[0]) !== "object")
              return [new it(o3, n3, `object expected, ${un(n3[0])} found`)];
            if (n3[0].zoom === undefined)
              return [new it(o3, n3, "object stop key must have zoom")];
            if (n3[0].value === undefined)
              return [new it(o3, n3, "object stop key must have value")];
            if (s2 && s2 > On(n3[0].zoom))
              return [new it(o3, n3[0].zoom, "stop zoom values must appear in ascending order")];
            On(n3[0].zoom) !== s2 && (s2 = On(n3[0].zoom), i2 = undefined, a2 = {}), r3 = r3.concat(Rn({ key: `${o3}[0]`, value: n3[0], valueSpec: { zoom: {} }, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: qn, value: p2 } }));
          } else
            r3 = r3.concat(p2({ key: `${o3}[0]`, value: n3[0], valueSpec: {}, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec }, n3));
          return vn(jn(n3[1])) ? r3.concat([new it(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")]) : r3.concat(t3.validateSpec({ key: `${o3}[1]`, value: n3[1], valueSpec: e2, validateSpec: t3.validateSpec, style: t3.style, styleSpec: t3.styleSpec }));
        }
        function p2(t3, s3) {
          const o3 = un(t3.value), l3 = On(t3.value), u6 = t3.value !== null ? t3.value : s3;
          if (n2) {
            if (o3 !== n2)
              return [new it(t3.key, u6, `${o3} stop domain type must match previous stop domain type ${n2}`)];
          } else
            n2 = o3;
          if (o3 !== "number" && o3 !== "string" && o3 !== "boolean")
            return [new it(t3.key, u6, "stop domain value must be a number, string, or boolean")];
          if (o3 !== "number" && r2 !== "categorical") {
            let n3 = `number expected, ${o3} found`;
            return an(e2) && r2 === undefined && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new it(t3.key, u6, n3)];
          }
          return r2 !== "categorical" || o3 !== "number" || isFinite(l3) && Math.floor(l3) === l3 ? r2 !== "categorical" && o3 === "number" && i2 !== undefined && l3 < i2 ? [new it(t3.key, u6, "stop domain values must appear in ascending order")] : (i2 = l3, r2 === "categorical" && (l3 in a2) ? [new it(t3.key, u6, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new it(t3.key, u6, `integer expected, found ${l3}`)];
        }
      }
      function Zn(t2) {
        const e2 = (t2.expressionContext === "property" ? An : bn)(jn(t2.value), t2.valueSpec);
        if (e2.result === "error")
          return e2.value.map((e3) => new it(`${t2.key}${e3.key}`, t2.value, e3.message));
        const r2 = e2.value.expression || e2.value._styleExpression.expression;
        if (t2.expressionContext === "property" && t2.propertyKey === "text-font" && !r2.outputDefined())
          return [new it(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (t2.expressionContext === "property" && t2.propertyType === "layout" && !en(r2))
          return [new it(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (t2.expressionContext === "filter" && !en(r2))
          return [new it(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
        if (t2.expressionContext && t2.expressionContext.indexOf("cluster") === 0) {
          if (!rn(r2, ["zoom", "feature-state"]))
            return [new it(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (t2.expressionContext === "cluster-initial" && !tn(r2))
            return [new it(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function Gn(t2) {
        const { key: e2, value: r2, valueSpec: n2 } = t2, i2 = [];
        return Array.isArray(n2.values) ? n2.values.indexOf(On(r2)) === -1 && i2.push(new it(e2, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : Object.keys(n2.values).indexOf(On(r2)) === -1 && i2.push(new it(e2, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
      }
      function Kn(t2) {
        return Mn(jn(t2.value)) ? Zn(st({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Xn(t2);
      }
      function Xn(t2) {
        const { value: e2, key: r2 } = t2;
        if (un(e2) !== "array")
          return [new it(r2, e2, `array expected, ${un(e2)} found`)];
        const n2 = t2.styleSpec;
        let i2, s2 = [];
        if (e2.length < 1)
          return [new it(r2, e2, "filter array must have at least 1 element")];
        switch (s2 = s2.concat(Gn({ key: `${r2}[0]`, value: e2[0], valueSpec: n2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), On(e2[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            e2.length >= 2 && On(e2[1]) === "$type" && s2.push(new it(r2, e2, `"$type" cannot be use with operator "${e2[0]}"`));
          case "==":
          case "!=":
            e2.length !== 3 && s2.push(new it(r2, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
          case "in":
          case "!in":
            e2.length >= 2 && (i2 = un(e2[1]), i2 !== "string" && s2.push(new it(`${r2}[1]`, e2[1], `string expected, ${i2} found`)));
            for (let a2 = 2;a2 < e2.length; a2++)
              i2 = un(e2[a2]), On(e2[1]) === "$type" ? s2 = s2.concat(Gn({ key: `${r2}[${a2}]`, value: e2[a2], valueSpec: n2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : i2 !== "string" && i2 !== "number" && i2 !== "boolean" && s2.push(new it(`${r2}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let n3 = 1;n3 < e2.length; n3++)
              s2 = s2.concat(Xn({ key: `${r2}[${n3}]`, value: e2[n3], style: t2.style, styleSpec: t2.styleSpec }));
            break;
          case "has":
          case "!has":
            i2 = un(e2[1]), e2.length !== 2 ? s2.push(new it(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : i2 !== "string" && s2.push(new it(`${r2}[1]`, e2[1], `string expected, ${i2} found`));
        }
        return s2;
      }
      function Hn(t2, e2) {
        const { key: r2, validateSpec: n2, style: i2, styleSpec: s2, value: a2, objectKey: o2 } = t2, l2 = s2[`${e2}_${t2.layerType}`];
        if (!l2)
          return [];
        const u5 = o2.match(/^(.*)-transition$/);
        if (e2 === "paint" && u5 && l2[u5[1]] && l2[u5[1]].transition)
          return n2({ key: r2, value: a2, valueSpec: s2.transition, style: i2, styleSpec: s2 });
        const c2 = t2.valueSpec || l2[o2];
        if (!c2)
          return [new it(r2, a2, `unknown property "${o2}"`)];
        let h2;
        if (un(a2) === "string" && an(c2) && !c2.tokens && (h2 = /^{([^}]+)}$/.exec(a2)))
          return [new it(r2, a2, `"${o2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h2[1])} }\`.`)];
        const p2 = [];
        return t2.layerType === "symbol" && (o2 === "text-field" && i2 && !i2.glyphs && p2.push(new it(r2, a2, 'use of "text-field" requires a style "glyphs" property')), o2 === "text-font" && cn(jn(a2)) && On(a2.type) === "identity" && p2.push(new it(r2, a2, '"text-font" does not support identity functions'))), p2.concat(n2({ key: t2.key, value: a2, valueSpec: c2, style: i2, styleSpec: s2, expressionContext: "property", propertyType: e2, propertyKey: o2 }));
      }
      function Yn(t2) {
        return Hn(t2, "paint");
      }
      function Jn(t2) {
        return Hn(t2, "layout");
      }
      function Wn(t2) {
        let e2 = [];
        const { value: r2, key: n2, style: i2, styleSpec: s2 } = t2;
        r2.type || r2.ref || e2.push(new it(n2, r2, 'either "type" or "ref" is required'));
        let a2 = On(r2.type);
        const o2 = On(r2.ref);
        if (r2.id) {
          const s3 = On(r2.id);
          for (let a3 = 0;a3 < t2.arrayIndex; a3++) {
            const t3 = i2.layers[a3];
            On(t3.id) === s3 && e2.push(new it(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
          }
        }
        if ("ref" in r2) {
          let t3;
          ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
            t4 in r2 && e2.push(new it(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
          }), i2.layers.forEach((e3) => {
            On(e3.id) === o2 && (t3 = e3);
          }), t3 ? t3.ref ? e2.push(new it(n2, r2.ref, "ref cannot reference another ref layer")) : a2 = On(t3.type) : e2.push(new it(n2, r2.ref, `ref layer "${o2}" not found`));
        } else if (a2 !== "background")
          if (r2.source) {
            const t3 = i2.sources && i2.sources[r2.source], s3 = t3 && On(t3.type);
            t3 ? s3 === "vector" && a2 === "raster" ? e2.push(new it(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : s3 !== "raster-dem" && a2 === "hillshade" ? e2.push(new it(n2, r2.source, `layer "${r2.id}" requires a raster-dem source`)) : s3 === "raster" && a2 !== "raster" ? e2.push(new it(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : s3 !== "vector" || r2["source-layer"] ? s3 === "raster-dem" && a2 !== "hillshade" ? e2.push(new it(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : a2 !== "line" || !r2.paint || !r2.paint["line-gradient"] || s3 === "geojson" && t3.lineMetrics || e2.push(new it(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new it(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e2.push(new it(n2, r2.source, `source "${r2.source}" not found`));
          } else
            e2.push(new it(n2, r2, 'missing required property "source"'));
        return e2 = e2.concat(Rn({ key: n2, value: r2, valueSpec: s2.layer, style: t2.style, styleSpec: t2.styleSpec, validateSpec: t2.validateSpec, objectElementValidators: { "*": () => [], type: () => t2.validateSpec({ key: `${n2}.type`, value: r2.type, valueSpec: s2.layer.type, style: t2.style, styleSpec: t2.styleSpec, validateSpec: t2.validateSpec, object: r2, objectKey: "type" }), filter: Kn, layout: (t3) => Rn({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": (t4) => Jn(st({ layerType: a2 }, t4)) } }), paint: (t3) => Rn({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, validateSpec: t3.validateSpec, objectElementValidators: { "*": (t4) => Yn(st({ layerType: a2 }, t4)) } }) } })), e2;
      }
      function Qn(t2) {
        const { value: e2, key: r2 } = t2, n2 = un(e2);
        return n2 !== "string" ? [new it(r2, e2, `string expected, ${n2} found`)] : [];
      }
      const ti = { promoteId: function({ key: t2, value: e2 }) {
        if (un(e2) === "string")
          return Qn({ key: t2, value: e2 });
        {
          const r2 = [];
          for (const n2 in e2)
            r2.push(...Qn({ key: `${t2}.${n2}`, value: e2[n2] }));
          return r2;
        }
      } };
      function ei(t2) {
        const { value: e2, key: r2, styleSpec: n2, style: i2, validateSpec: s2 } = t2;
        if (!e2.type)
          return [new it(r2, e2, '"type" is required')];
        const a2 = On(e2.type);
        let o2;
        switch (a2) {
          case "vector":
          case "raster":
            return o2 = Rn({ key: r2, value: e2, valueSpec: n2[`source_${a2.replace("-", "_")}`], style: t2.style, styleSpec: n2, objectElementValidators: ti, validateSpec: s2 }), o2;
          case "raster-dem":
            return o2 = function(t3) {
              var e3;
              const r3 = (e3 = t3.sourceName) !== null && e3 !== undefined ? e3 : "", n3 = t3.value, i3 = t3.styleSpec, s3 = i3.source_raster_dem, a3 = t3.style;
              let o3 = [];
              const l2 = un(n3);
              if (n3 === undefined)
                return o3;
              if (l2 !== "object")
                return o3.push(new it("source_raster_dem", n3, `object expected, ${l2} found`)), o3;
              const u5 = On(n3.encoding) === "custom", c2 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h2 = t3.value.encoding ? `"${t3.value.encoding}"` : "Default";
              for (const e4 in n3)
                !u5 && c2.includes(e4) ? o3.push(new it(e4, n3[e4], `In "${r3}": "${e4}" is only valid when "encoding" is set to "custom". ${h2} encoding found`)) : s3[e4] ? o3 = o3.concat(t3.validateSpec({ key: e4, value: n3[e4], valueSpec: s3[e4], validateSpec: t3.validateSpec, style: a3, styleSpec: i3 })) : o3.push(new it(e4, n3[e4], `unknown property "${e4}"`));
              return o3;
            }({ sourceName: r2, value: e2, style: t2.style, styleSpec: n2, validateSpec: s2 }), o2;
          case "geojson":
            if (o2 = Rn({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, validateSpec: s2, objectElementValidators: ti }), e2.cluster)
              for (const t3 in e2.clusterProperties) {
                const [n3, i3] = e2.clusterProperties[t3], a3 = typeof n3 == "string" ? [n3, ["accumulated"], ["get", t3]] : n3;
                o2.push(...Zn({ key: `${r2}.${t3}.map`, value: i3, validateSpec: s2, expressionContext: "cluster-map" })), o2.push(...Zn({ key: `${r2}.${t3}.reduce`, value: a3, validateSpec: s2, expressionContext: "cluster-reduce" }));
              }
            return o2;
          case "video":
            return Rn({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, validateSpec: s2, styleSpec: n2 });
          case "image":
            return Rn({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, validateSpec: s2, styleSpec: n2 });
          case "canvas":
            return [new it(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return Gn({ key: `${r2}.type`, value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i2, validateSpec: s2, styleSpec: n2 });
        }
      }
      function ri(t2) {
        const { value: e2, styleSpec: r2 } = t2, n2 = r2.light, i2 = t2.style;
        let s2 = [];
        const a2 = un(e2);
        if (e2 === undefined)
          return s2;
        if (a2 !== "object")
          return s2 = s2.concat([new it("light", e2, `object expected, ${a2} found`)]), s2;
        for (const a3 in e2) {
          const o2 = a3.match(/^(.*)-transition$/);
          s2 = s2.concat(o2 && n2[o2[1]] && n2[o2[1]].transition ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: r2.transition, validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : n2[a3] ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: n2[a3], validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : [new it(a3, e2[a3], `unknown property "${a3}"`)]);
        }
        return s2;
      }
      function ni(t2) {
        const { value: e2, styleSpec: r2 } = t2, n2 = r2.sky, i2 = t2.style, s2 = un(e2);
        if (e2 === undefined)
          return [];
        if (s2 !== "object")
          return [new it("sky", e2, `object expected, ${s2} found`)];
        let a2 = [];
        for (const s3 in e2)
          a2 = a2.concat(n2[s3] ? t2.validateSpec({ key: s3, value: e2[s3], valueSpec: n2[s3], style: i2, styleSpec: r2 }) : [new it(s3, e2[s3], `unknown property "${s3}"`)]);
        return a2;
      }
      function ii(t2) {
        const { value: e2, styleSpec: r2 } = t2, n2 = r2.terrain, i2 = t2.style;
        let s2 = [];
        const a2 = un(e2);
        if (e2 === undefined)
          return s2;
        if (a2 !== "object")
          return s2 = s2.concat([new it("terrain", e2, `object expected, ${a2} found`)]), s2;
        for (const a3 in e2)
          s2 = s2.concat(n2[a3] ? t2.validateSpec({ key: a3, value: e2[a3], valueSpec: n2[a3], validateSpec: t2.validateSpec, style: i2, styleSpec: r2 }) : [new it(a3, e2[a3], `unknown property "${a3}"`)]);
        return s2;
      }
      function si(t2) {
        let e2 = [];
        const { value: r2, key: n2 } = t2;
        if (Array.isArray(r2)) {
          const i2 = [], s2 = [];
          for (const a2 in r2)
            r2[a2].id && i2.includes(r2[a2].id) && e2.push(new it(n2, r2, `all the sprites' ids must be unique, but ${r2[a2].id} is duplicated`)), i2.push(r2[a2].id), r2[a2].url && s2.includes(r2[a2].url) && e2.push(new it(n2, r2, `all the sprites' URLs must be unique, but ${r2[a2].url} is duplicated`)), s2.push(r2[a2].url), e2 = e2.concat(Rn({ key: `${n2}[${a2}]`, value: r2[a2], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t2.validateSpec }));
          return e2;
        }
        return Qn({ key: n2, value: r2 });
      }
      const ai = { "*": () => [], array: Un, boolean: function(t2) {
        const { value: e2, key: r2 } = t2, n2 = un(e2);
        return n2 !== "boolean" ? [new it(r2, e2, `boolean expected, ${n2} found`)] : [];
      }, number: qn, color: function(t2) {
        const { key: e2, value: r2 } = t2, n2 = un(r2);
        return n2 !== "string" ? [new it(e2, r2, `color expected, ${n2} found`)] : Kt.parse(String(r2)) ? [] : [new it(e2, r2, `color expected, "${r2}" found`)];
      }, constants: Dn, enum: Gn, filter: Kn, function: Nn, layer: Wn, object: Rn, source: ei, light: ri, sky: ni, terrain: ii, projection: function(t2) {
        const { value: e2, styleSpec: r2 } = t2, n2 = r2.projection, i2 = t2.style, s2 = un(e2);
        if (e2 === undefined)
          return [];
        if (s2 !== "object")
          return [new it("projection", e2, `object expected, ${s2} found`)];
        let a2 = [];
        for (const s3 in e2)
          a2 = a2.concat(n2[s3] ? t2.validateSpec({ key: s3, value: e2[s3], valueSpec: n2[s3], style: i2, styleSpec: r2 }) : [new it(s3, e2[s3], `unknown property "${s3}"`)]);
        return a2;
      }, string: Qn, formatted: function(t2) {
        return Qn(t2).length === 0 ? [] : Zn(t2);
      }, resolvedImage: function(t2) {
        return Qn(t2).length === 0 ? [] : Zn(t2);
      }, padding: function(t2) {
        const { key: e2, value: r2 } = t2;
        if (un(r2) === "array") {
          if (r2.length < 1 || r2.length > 4)
            return [new it(e2, r2, `padding requires 1 to 4 values; ${r2.length} values found`)];
          const n2 = { type: "number" };
          let i2 = [];
          for (let s2 = 0;s2 < r2.length; s2++)
            i2 = i2.concat(t2.validateSpec({ key: `${e2}[${s2}]`, value: r2[s2], validateSpec: t2.validateSpec, valueSpec: n2 }));
          return i2;
        }
        return qn({ key: e2, value: r2, valueSpec: {} });
      }, variableAnchorOffsetCollection: function(t2) {
        const { key: e2, value: r2 } = t2, n2 = un(r2), i2 = t2.styleSpec;
        if (n2 !== "array" || r2.length < 1 || r2.length % 2 != 0)
          return [new it(e2, r2, "variableAnchorOffsetCollection requires a non-empty array of even length")];
        let s2 = [];
        for (let n3 = 0;n3 < r2.length; n3 += 2)
          s2 = s2.concat(Gn({ key: `${e2}[${n3}]`, value: r2[n3], valueSpec: i2.layout_symbol["text-anchor"] })), s2 = s2.concat(Un({ key: `${e2}[${n3 + 1}]`, value: r2[n3 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t2.validateSpec, style: t2.style, styleSpec: i2 }));
        return s2;
      }, sprite: si };
      function oi(t2) {
        const { value: e2, valueSpec: r2, styleSpec: n2 } = t2;
        return t2.validateSpec = oi, r2.expression && cn(On(e2)) ? Nn(t2) : r2.expression && vn(jn(e2)) ? Zn(t2) : r2.type && ai[r2.type] ? ai[r2.type](t2) : Rn(st({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
      }
      function li(t2) {
        const { value: e2, key: r2 } = t2, n2 = Qn(t2);
        return n2.length || (e2.indexOf("{fontstack}") === -1 && n2.push(new it(r2, e2, '"glyphs" url must include a "{fontstack}" token')), e2.indexOf("{range}") === -1 && n2.push(new it(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
      }
      function ui(t2, e2 = G) {
        let r2 = [];
        return r2 = r2.concat(oi({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, validateSpec: oi, objectElementValidators: { glyphs: li, "*": () => [] } })), t2.constants && (r2 = r2.concat(Dn({ key: "constants", value: t2.constants, style: t2, styleSpec: e2, validateSpec: oi }))), hi(r2);
      }
      function ci(t2) {
        return function(e2) {
          return t2({ ...e2, validateSpec: oi });
        };
      }
      function hi(t2) {
        return [].concat(t2).sort((t3, e2) => t3.line - e2.line);
      }
      function pi(t2) {
        return function(...e2) {
          return hi(t2.apply(this, e2));
        };
      }
      ui.source = pi(ci(ei)), ui.sprite = pi(ci(si)), ui.glyphs = pi(ci(li)), ui.light = pi(ci(ri)), ui.sky = pi(ci(ni)), ui.terrain = pi(ci(ii)), ui.layer = pi(ci(Wn)), ui.filter = pi(ci(Kn)), ui.paintProperty = pi(ci(Yn)), ui.layoutProperty = pi(ci(Jn));
      const fi = ui, di = fi.light, yi = fi.sky, mi = fi.paintProperty, gi = fi.layoutProperty;
      function xi(t2, e2) {
        let r2 = false;
        if (e2 && e2.length)
          for (const n2 of e2)
            t2.fire(new N(new Error(n2.message))), r2 = true;
        return r2;
      }

      class vi {
        constructor(t2, e2, r2) {
          const n2 = this.cells = [];
          if (t2 instanceof ArrayBuffer) {
            this.arrayBuffer = t2;
            const i3 = new Int32Array(this.arrayBuffer);
            t2 = i3[0], this.d = (e2 = i3[1]) + 2 * (r2 = i3[2]);
            for (let t3 = 0;t3 < this.d * this.d; t3++) {
              const e3 = i3[3 + t3], r3 = i3[3 + t3 + 1];
              n2.push(e3 === r3 ? null : i3.subarray(e3, r3));
            }
            const s2 = i3[3 + n2.length + 1];
            this.keys = i3.subarray(i3[3 + n2.length], s2), this.bboxes = i3.subarray(s2), this.insert = this._insertReadonly;
          } else {
            this.d = e2 + 2 * r2;
            for (let t3 = 0;t3 < this.d * this.d; t3++)
              n2.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
          const i2 = r2 / e2 * t2;
          this.min = -i2, this.max = t2 + i2;
        }
        insert(t2, e2, r2, n2, i2) {
          this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++, undefined, undefined), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(t2, e2, r2, n2, i2, s2) {
          this.cells[i2].push(s2);
        }
        query(t2, e2, r2, n2, i2) {
          const s2 = this.min, a2 = this.max;
          if (t2 <= s2 && e2 <= s2 && a2 <= r2 && a2 <= n2 && !i2)
            return Array.prototype.slice.call(this.keys);
          {
            const s3 = [];
            return this._forEachCell(t2, e2, r2, n2, this._queryCell, s3, {}, i2), s3;
          }
        }
        _queryCell(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = this.cells[i2];
          if (l2 !== null) {
            const i3 = this.keys, u5 = this.bboxes;
            for (let c2 = 0;c2 < l2.length; c2++) {
              const h2 = l2[c2];
              if (a2[h2] === undefined) {
                const l3 = 4 * h2;
                (o2 ? o2(u5[l3 + 0], u5[l3 + 1], u5[l3 + 2], u5[l3 + 3]) : t2 <= u5[l3 + 2] && e2 <= u5[l3 + 3] && r2 >= u5[l3 + 0] && n2 >= u5[l3 + 1]) ? (a2[h2] = true, s2.push(i3[h2])) : a2[h2] = false;
              }
            }
          }
        }
        _forEachCell(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = this._convertToCellCoord(t2), u5 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2);
          for (let p2 = l2;p2 <= c2; p2++)
            for (let l3 = u5;l3 <= h2; l3++) {
              const u6 = this.d * l3 + p2;
              if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(l3), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(l3 + 1))) && i2.call(this, t2, e2, r2, n2, u6, s2, a2, o2))
                return;
            }
        }
        _convertFromCellCoord(t2) {
          return (t2 - this.padding) / this.scale;
        }
        _convertToCellCoord(t2) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          const t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1;
          let r2 = 0;
          for (let t3 = 0;t3 < this.cells.length; t3++)
            r2 += this.cells[t3].length;
          const n2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
          n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
          let i2 = e2;
          for (let e3 = 0;e3 < t2.length; e3++) {
            const r3 = t2[e3];
            n2[3 + e3] = i2, n2.set(r3, i2), i2 += r3.length;
          }
          return n2[3 + t2.length] = i2, n2.set(this.keys, i2), i2 += this.keys.length, n2[3 + t2.length + 1] = i2, n2.set(this.bboxes, i2), i2 += this.bboxes.length, n2.buffer;
        }
        static serialize(t2, e2) {
          const r2 = t2.toArrayBuffer();
          return e2 && e2.push(r2), { buffer: r2 };
        }
        static deserialize(t2) {
          return new vi(t2.buffer);
        }
      }
      const bi = {};
      function wi(t2, e2, r2 = {}) {
        if (bi[t2])
          throw new Error(`${t2} is already registered.`);
        Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), bi[t2] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
      }
      wi("Object", Object), wi("TransferableGridIndex", vi), wi("Color", Kt), wi("Error", Error), wi("AJAXError", L), wi("ResolvedImage", te), wi("StylePropertyFunction", Sn), wi("StyleExpression", xn, { omit: ["_evaluator"] }), wi("ZoomDependentExpression", _n), wi("ZoomConstantExpression", wn), wi("CompoundExpression", Xr, { omit: ["_evaluate"] });
      for (const t2 in Kr)
        Kr[t2]._classRegistryKey || wi(`Expression_${t2}`, Kr[t2]);
      function _i(t2) {
        return t2 && typeof ArrayBuffer != "undefined" && (t2 instanceof ArrayBuffer || t2.constructor && t2.constructor.name === "ArrayBuffer");
      }
      function Ai(t2) {
        return t2.$name || t2.constructor._classRegistryKey;
      }
      function Si(t2) {
        return !function(t3) {
          if (t3 === null || typeof t3 != "object")
            return false;
          const e2 = Ai(t3);
          return !(!e2 || e2 === "Object");
        }(t2) && (t2 == null || typeof t2 == "boolean" || typeof t2 == "number" || typeof t2 == "string" || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob || t2 instanceof Error || _i(t2) || I(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData);
      }
      function ki(t2, e2) {
        if (Si(t2))
          return (_i(t2) || I(t2)) && e2 && e2.push(t2), ArrayBuffer.isView(t2) && e2 && e2.push(t2.buffer), t2 instanceof ImageData && e2 && e2.push(t2.data.buffer), t2;
        if (Array.isArray(t2)) {
          const r3 = [];
          for (const n3 of t2)
            r3.push(ki(n3, e2));
          return r3;
        }
        if (typeof t2 != "object")
          throw new Error("can't serialize object of type " + typeof t2);
        const r2 = Ai(t2);
        if (!r2)
          throw new Error(`can't serialize object of unregistered class ${t2.constructor.name}`);
        if (!bi[r2])
          throw new Error(`${r2} is not registered.`);
        const { klass: n2 } = bi[r2], i2 = n2.serialize ? n2.serialize(t2, e2) : {};
        if (n2.serialize) {
          if (e2 && i2 === e2[e2.length - 1])
            throw new Error("statically serialized object won't survive transfer of $name property");
        } else {
          for (const n3 in t2) {
            if (!t2.hasOwnProperty(n3))
              continue;
            if (bi[r2].omit.indexOf(n3) >= 0)
              continue;
            const s2 = t2[n3];
            i2[n3] = bi[r2].shallow.indexOf(n3) >= 0 ? s2 : ki(s2, e2);
          }
          t2 instanceof Error && (i2.message = t2.message);
        }
        if (i2.$name)
          throw new Error("$name property is reserved for worker serialization logic.");
        return r2 !== "Object" && (i2.$name = r2), i2;
      }
      function Mi(t2) {
        if (Si(t2))
          return t2;
        if (Array.isArray(t2))
          return t2.map(Mi);
        if (typeof t2 != "object")
          throw new Error("can't deserialize object of type " + typeof t2);
        const e2 = Ai(t2) || "Object";
        if (!bi[e2])
          throw new Error(`can't deserialize unregistered class ${e2}`);
        const { klass: r2 } = bi[e2];
        if (!r2)
          throw new Error(`can't deserialize unregistered class ${e2}`);
        if (r2.deserialize)
          return r2.deserialize(t2);
        const n2 = Object.create(r2.prototype);
        for (const r3 of Object.keys(t2)) {
          if (r3 === "$name")
            continue;
          const i2 = t2[r3];
          n2[r3] = bi[e2].shallow.indexOf(r3) >= 0 ? i2 : Mi(i2);
        }
        return n2;
      }

      class Ii {
        constructor() {
          this.first = true;
        }
        update(t2, e2) {
          const r2 = Math.floor(t2);
          return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
        }
      }
      const zi = { "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255, "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607, Khmer: (t2) => t2 >= 6016 && t2 <= 6143, "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303, "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527, "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591, "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215, "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279, "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311, "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471, "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727, "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983, "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263, "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287, "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351, Katakana: (t2) => t2 >= 12448 && t2 <= 12543, Kanbun: (t2) => t2 >= 12688 && t2 <= 12703, "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783, "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055, "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311, "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967, "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743, "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055, "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103, "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135, "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519 };
      function Pi(t2) {
        for (const e2 of t2)
          if (Ti(e2.charCodeAt(0)))
            return true;
        return false;
      }
      function Ci(t2) {
        for (const e2 of t2)
          if (!Ei(e2.charCodeAt(0)))
            return false;
        return true;
      }
      function Bi(t2) {
        const e2 = t2.map((t3) => {
          try {
            return new RegExp(`\\p{sc=${t3}}`, "u").source;
          } catch (t4) {
            return null;
          }
        }).filter((t3) => t3);
        return new RegExp(e2.join("|"), "u");
      }
      const Vi = Bi(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
      function Ei(t2) {
        return !Vi.test(String.fromCodePoint(t2));
      }
      const Fi = Bi(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
      function Ti(t2) {
        return !(t2 !== 746 && t2 !== 747 && (t2 < 4352 || !(zi["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || zi["CJK Compatibility"](t2) || zi["CJK Strokes"](t2) || !(!zi["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || t2 === 12336) || zi["Enclosed CJK Letters and Months"](t2) || zi["Ideographic Description Characters"](t2) || zi.Kanbun(t2) || zi.Katakana(t2) && t2 !== 12540 || !(!zi["Halfwidth and Fullwidth Forms"](t2) || t2 === 65288 || t2 === 65289 || t2 === 65293 || t2 >= 65306 && t2 <= 65310 || t2 === 65339 || t2 === 65341 || t2 === 65343 || t2 >= 65371 && t2 <= 65503 || t2 === 65507 || t2 >= 65512 && t2 <= 65519) || !(!zi["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || zi["Vertical Forms"](t2) || zi["Yijing Hexagram Symbols"](t2) || /\p{sc=Cans}/u.test(String.fromCodePoint(t2)) || /\p{sc=Hang}/u.test(String.fromCodePoint(t2)) || Fi.test(String.fromCodePoint(t2)))));
      }
      function $i(t2) {
        return !(Ti(t2) || function(t3) {
          return !!(zi["Latin-1 Supplement"](t3) && (t3 === 167 || t3 === 169 || t3 === 174 || t3 === 177 || t3 === 188 || t3 === 189 || t3 === 190 || t3 === 215 || t3 === 247) || zi["General Punctuation"](t3) && (t3 === 8214 || t3 === 8224 || t3 === 8225 || t3 === 8240 || t3 === 8241 || t3 === 8251 || t3 === 8252 || t3 === 8258 || t3 === 8263 || t3 === 8264 || t3 === 8265 || t3 === 8273) || zi["Letterlike Symbols"](t3) || zi["Number Forms"](t3) || zi["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9000 || t3 === 9003 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || t3 === 9167 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || zi["Control Pictures"](t3) && t3 !== 9251 || zi["Optical Character Recognition"](t3) || zi["Enclosed Alphanumerics"](t3) || zi["Geometric Shapes"](t3) || zi["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || zi["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || zi["CJK Symbols and Punctuation"](t3) || zi.Katakana(t3) || zi["Private Use Area"](t3) || zi["CJK Compatibility Forms"](t3) || zi["Small Form Variants"](t3) || zi["Halfwidth and Fullwidth Forms"](t3) || t3 === 8734 || t3 === 8756 || t3 === 8757 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || t3 === 65532 || t3 === 65533);
        }(t2));
      }
      const Li = Bi(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
      function Di(t2) {
        return Li.test(String.fromCodePoint(t2));
      }
      function Oi(t2, e2) {
        return !(!e2 && Di(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || zi.Khmer(t2));
      }
      function ji(t2) {
        for (const e2 of t2)
          if (Di(e2.charCodeAt(0)))
            return true;
        return false;
      }
      const Ri = new class {
        constructor() {
          this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
        }
        setState(t2) {
          this.pluginStatus = t2.pluginStatus, this.pluginURL = t2.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(t2) {
          this.applyArabicShaping = t2.applyArabicShaping, this.processBidirectionalText = t2.processBidirectionalText, this.processStyledBidirectionalText = t2.processStyledBidirectionalText;
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getPluginURL() {
          return this.pluginURL;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
      };

      class Ui {
        constructor(t2, e2) {
          this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Ii, this.transition = {});
        }
        isSupportedScript(t2) {
          return function(t3, e2) {
            for (const r2 of t3)
              if (!Oi(r2.charCodeAt(0), e2))
                return false;
            return true;
          }(t2, Ri.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const t2 = this.zoom, e2 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
          return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
        }
      }

      class qi {
        constructor(t2, e2) {
          this.property = t2, this.value = e2, this.expression = function(t3, e3) {
            if (cn(t3))
              return new Sn(t3, e3);
            if (vn(t3)) {
              const r2 = An(t3, e3);
              if (r2.result === "error")
                throw new Error(r2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
              return r2.value;
            }
            {
              let r2 = t3;
              return e3.type === "color" && typeof t3 == "string" ? r2 = Kt.parse(t3) : e3.type !== "padding" || typeof t3 != "number" && !Array.isArray(t3) ? e3.type === "variableAnchorOffsetCollection" && Array.isArray(t3) && (r2 = Qt.parse(t3)) : r2 = Jt.parse(t3), { kind: "constant", evaluate: () => r2 };
            }
          }(e2 === undefined ? t2.specification.default : e2, t2.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(t2, e2, r2) {
          return this.property.possiblyEvaluate(this, t2, e2, r2);
        }
      }

      class Ni {
        constructor(t2) {
          this.property = t2, this.value = new qi(t2, undefined);
        }
        transitioned(t2, e2) {
          return new Gi(this.property, this.value, e2, g({}, t2.transition, this.transition), t2.now);
        }
        untransitioned() {
          return new Gi(this.property, this.value, null, {}, 0);
        }
      }

      class Zi {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
        }
        getValue(t2) {
          return w(this._values[t2].value.value);
        }
        setValue(t2, e2) {
          Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Ni(this._values[t2].property)), this._values[t2].value = new qi(this._values[t2].property, e2 === null ? undefined : w(e2));
        }
        getTransition(t2) {
          return w(this._values[t2].transition);
        }
        setTransition(t2, e2) {
          Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Ni(this._values[t2].property)), this._values[t2].transition = w(e2) || undefined;
        }
        serialize() {
          const t2 = {};
          for (const e2 of Object.keys(this._values)) {
            const r2 = this.getValue(e2);
            r2 !== undefined && (t2[e2] = r2);
            const n2 = this.getTransition(e2);
            n2 !== undefined && (t2[`${e2}-transition`] = n2);
          }
          return t2;
        }
        transitioned(t2, e2) {
          const r2 = new Ki(this._properties);
          for (const n2 of Object.keys(this._values))
            r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
          return r2;
        }
        untransitioned() {
          const t2 = new Ki(this._properties);
          for (const e2 of Object.keys(this._values))
            t2._values[e2] = this._values[e2].untransitioned();
          return t2;
        }
      }

      class Gi {
        constructor(t2, e2, r2, n2, i2) {
          this.property = t2, this.value = e2, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
          if (s2) {
            if (n2 > this.end)
              return this.prior = null, i2;
            if (this.value.isDataDriven())
              return this.prior = null, i2;
            if (n2 < this.begin)
              return s2.possiblyEvaluate(t2, e2, r2);
            {
              const a2 = (n2 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, function(t3) {
                if (t3 <= 0)
                  return 0;
                if (t3 >= 1)
                  return 1;
                const e3 = t3 * t3, r3 = e3 * t3;
                return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e3) + r3 - 0.75);
              }(a2));
            }
          }
          return i2;
        }
      }

      class Ki {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = new Yi(this._properties);
          for (const i2 of Object.keys(this._values))
            n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
          return n2;
        }
        hasTransition() {
          for (const t2 of Object.keys(this._values))
            if (this._values[t2].prior)
              return true;
          return false;
        }
      }

      class Xi {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
        }
        hasValue(t2) {
          return this._values[t2].value !== undefined;
        }
        getValue(t2) {
          return w(this._values[t2].value);
        }
        setValue(t2, e2) {
          this._values[t2] = new qi(this._values[t2].property, e2 === null ? undefined : w(e2));
        }
        serialize() {
          const t2 = {};
          for (const e2 of Object.keys(this._values)) {
            const r2 = this.getValue(e2);
            r2 !== undefined && (t2[e2] = r2);
          }
          return t2;
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = new Yi(this._properties);
          for (const i2 of Object.keys(this._values))
            n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
          return n2;
        }
      }

      class Hi {
        constructor(t2, e2, r2) {
          this.property = t2, this.value = e2, this.parameters = r2;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(t2) {
          return this.value.kind === "constant" ? this.value.value : t2;
        }
        evaluate(t2, e2, r2, n2) {
          return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
        }
      }

      class Yi {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
        }
        get(t2) {
          return this._values[t2];
        }
      }

      class Ji {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2) {
          if (t2.isDataDriven())
            throw new Error("Value should not be data driven");
          return t2.expression.evaluate(e2);
        }
        interpolate(t2, e2, r2) {
          const n2 = Ce[this.specification.type];
          return n2 ? n2(t2, e2, r2) : t2;
        }
      }

      class Wi {
        constructor(t2, e2) {
          this.specification = t2, this.overrides = e2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          return new Hi(this, t2.expression.kind === "constant" || t2.expression.kind === "camera" ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
        }
        interpolate(t2, e2, r2) {
          if (t2.value.kind !== "constant" || e2.value.kind !== "constant")
            return t2;
          if (t2.value.value === undefined || e2.value.value === undefined)
            return new Hi(this, { kind: "constant", value: undefined }, t2.parameters);
          const n2 = Ce[this.specification.type];
          if (n2) {
            const i2 = n2(t2.value.value, e2.value.value, r2);
            return new Hi(this, { kind: "constant", value: i2 }, t2.parameters);
          }
          return t2;
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return t2.kind === "constant" ? t2.value : t2.evaluate(e2, r2, n2, i2, s2);
        }
      }

      class Qi extends Wi {
        possiblyEvaluate(t2, e2, r2, n2) {
          if (t2.value === undefined)
            return new Hi(this, { kind: "constant", value: undefined }, e2);
          if (t2.expression.kind === "constant") {
            const i2 = t2.expression.evaluate(e2, null, {}, r2, n2), s2 = t2.property.specification.type === "resolvedImage" && typeof i2 != "string" ? i2.name : i2, a2 = this._calculate(s2, s2, s2, e2);
            return new Hi(this, { kind: "constant", value: a2 }, e2);
          }
          if (t2.expression.kind === "camera") {
            const r3 = this._calculate(t2.expression.evaluate({ zoom: e2.zoom - 1 }), t2.expression.evaluate({ zoom: e2.zoom }), t2.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
            return new Hi(this, { kind: "constant", value: r3 }, e2);
          }
          return new Hi(this, t2.expression, e2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          if (t2.kind === "source") {
            const a2 = t2.evaluate(e2, r2, n2, i2, s2);
            return this._calculate(a2, a2, a2, e2);
          }
          return t2.kind === "composite" ? this._calculate(t2.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r2, n2), e2) : t2.value;
        }
        _calculate(t2, e2, r2, n2) {
          return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
        }
        interpolate(t2) {
          return t2;
        }
      }

      class ts {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          if (t2.value !== undefined) {
            if (t2.expression.kind === "constant") {
              const i2 = t2.expression.evaluate(e2, null, {}, r2, n2);
              return this._calculate(i2, i2, i2, e2);
            }
            return this._calculate(t2.expression.evaluate(new Ui(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new Ui(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new Ui(Math.floor(e2.zoom + 1), e2)), e2);
          }
        }
        _calculate(t2, e2, r2, n2) {
          return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
        }
        interpolate(t2) {
          return t2;
        }
      }

      class es {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          return !!t2.expression.evaluate(e2, null, {}, r2, n2);
        }
        interpolate() {
          return false;
        }
      }

      class rs {
        constructor(t2) {
          this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const e2 in t2) {
            const r2 = t2[e2];
            r2.specification.overridable && this.overridableProperties.push(e2);
            const n2 = this.defaultPropertyValues[e2] = new qi(r2, undefined), i2 = this.defaultTransitionablePropertyValues[e2] = new Ni(r2);
            this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
          }
        }
      }
      wi("DataDrivenProperty", Wi), wi("DataConstantProperty", Ji), wi("CrossFadedDataDrivenProperty", Qi), wi("CrossFadedProperty", ts), wi("ColorRampProperty", es);
      const ns = "-transition";

      class is extends Z {
        constructor(t2, e2) {
          if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false }, t2.type !== "custom" && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, t2.type !== "background" && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new Xi(e2.layout)), e2.paint)) {
            this._transitionablePaint = new Zi(e2.paint);
            for (const e3 in t2.paint)
              this.setPaintProperty(e3, t2.paint[e3], { validate: false });
            for (const e3 in t2.layout)
              this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Yi(e2.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(t2) {
          return t2 === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t2);
        }
        setLayoutProperty(t2, e2, r2 = {}) {
          e2 != null && this._validate(gi, `layers.${this.id}.layout.${t2}`, t2, e2, r2) || (t2 !== "visibility" ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
        }
        getPaintProperty(t2) {
          return t2.endsWith(ns) ? this._transitionablePaint.getTransition(t2.slice(0, -11)) : this._transitionablePaint.getValue(t2);
        }
        setPaintProperty(t2, e2, r2 = {}) {
          if (e2 != null && this._validate(mi, `layers.${this.id}.paint.${t2}`, t2, e2, r2))
            return false;
          if (t2.endsWith(ns))
            return this._transitionablePaint.setTransition(t2.slice(0, -11), e2 || undefined), false;
          {
            const r3 = this._transitionablePaint._values[t2], n2 = r3.property.specification["property-type"] === "cross-faded-data-driven", i2 = r3.value.isDataDriven(), s2 = r3.value;
            this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
            const a2 = this._transitionablePaint._values[t2].value;
            return a2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(t2, s2, a2);
          }
        }
        _handleSpecialPaintPropertyUpdate(t2) {
        }
        _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
          return false;
        }
        isHidden(t2) {
          return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(t2) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t2, e2) {
          t2.getCrossfadeParameters && (this._crossfadeParameters = t2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, undefined, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, undefined, e2);
        }
        serialize() {
          const t2 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), b(t2, (t3, e2) => !(t3 === undefined || e2 === "layout" && !Object.keys(t3).length || e2 === "paint" && !Object.keys(t3).length));
        }
        _validate(t2, e2, r2, n2, i2 = {}) {
          return (!i2 || i2.validate !== false) && xi(this, t2.call(fi, { key: e2, layerType: this.type, objectKey: r2, value: n2, styleSpec: G, style: { glyphs: true, sprite: true } }));
        }
        is3D() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        resize() {
        }
        isStateDependent() {
          for (const t2 in this.paint._values) {
            const e2 = this.paint.get(t2);
            if (e2 instanceof Hi && an(e2.property.specification) && (e2.value.kind === "source" || e2.value.kind === "composite") && e2.value.isStateDependent)
              return true;
          }
          return false;
        }
      }
      const ss = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };

      class as {
        constructor(t2, e2) {
          this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }

      class os {
        constructor() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        }
        static serialize(t2, e2) {
          return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
        }
        static deserialize(t2) {
          const e2 = Object.create(this.prototype);
          return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t2) {
          this.reserve(t2), this.length = t2;
        }
        reserve(t2) {
          if (t2 > this.capacity) {
            this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const e2 = this.uint8;
            this._refreshViews(), e2 && this.uint8.set(e2);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function ls(t2, e2 = 1) {
        let r2 = 0, n2 = 0;
        return { members: t2.map((t3) => {
          const i2 = ss[t3.type].BYTES_PER_ELEMENT, s2 = r2 = us(r2, Math.max(e2, i2)), a2 = t3.components || 1;
          return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
        }), size: us(r2, Math.max(n2, e2)), alignment: e2 };
      }
      function us(t2, e2) {
        return Math.ceil(t2 / e2) * e2;
      }

      class cs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
        }
      }
      cs.prototype.bytesPerElement = 4, wi("StructArrayLayout2i4", cs);

      class hs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
        }
      }
      hs.prototype.bytesPerElement = 6, wi("StructArrayLayout3i6", hs);

      class ps extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
        }
      }
      ps.prototype.bytesPerElement = 8, wi("StructArrayLayout4i8", ps);

      class fs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 6 * t2;
          return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
        }
      }
      fs.prototype.bytesPerElement = 12, wi("StructArrayLayout2i4i12", fs);

      class ds extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 4 * t2, l2 = 8 * t2;
          return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.uint8[l2 + 4] = n2, this.uint8[l2 + 5] = i2, this.uint8[l2 + 6] = s2, this.uint8[l2 + 7] = a2, t2;
        }
      }
      ds.prototype.bytesPerElement = 8, wi("StructArrayLayout2i4ub8", ds);

      class ys extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
        }
      }
      ys.prototype.bytesPerElement = 8, wi("StructArrayLayout2f8", ys);

      class ms extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u5) {
          const c2 = this.length;
          return this.resize(c2 + 1), this.emplace(c2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u5);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u5, c2) {
          const h2 = 10 * t2;
          return this.uint16[h2 + 0] = e2, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i2, this.uint16[h2 + 4] = s2, this.uint16[h2 + 5] = a2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l2, this.uint16[h2 + 8] = u5, this.uint16[h2 + 9] = c2, t2;
        }
      }
      ms.prototype.bytesPerElement = 20, wi("StructArrayLayout10ui20", ms);

      class gs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u5, c2, h2) {
          const p2 = this.length;
          return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u5, c2, h2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u5, c2, h2, p2) {
          const f2 = 12 * t2;
          return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u5, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t2;
        }
      }
      gs.prototype.bytesPerElement = 24, wi("StructArrayLayout4i4ui4i24", gs);

      class xs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
        }
      }
      xs.prototype.bytesPerElement = 12, wi("StructArrayLayout3f12", xs);

      class vs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.uint32[1 * t2 + 0] = e2, t2;
        }
      }
      vs.prototype.bytesPerElement = 4, wi("StructArrayLayout1ul4", vs);

      class bs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u5 = this.length;
          return this.resize(u5 + 1), this.emplace(u5, t2, e2, r2, n2, i2, s2, a2, o2, l2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u5) {
          const c2 = 10 * t2, h2 = 5 * t2;
          return this.int16[c2 + 0] = e2, this.int16[c2 + 1] = r2, this.int16[c2 + 2] = n2, this.int16[c2 + 3] = i2, this.int16[c2 + 4] = s2, this.int16[c2 + 5] = a2, this.uint32[h2 + 3] = o2, this.uint16[c2 + 8] = l2, this.uint16[c2 + 9] = u5, t2;
        }
      }
      bs.prototype.bytesPerElement = 20, wi("StructArrayLayout6i1ul2ui20", bs);

      class ws extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 6 * t2;
          return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
        }
      }
      ws.prototype.bytesPerElement = 12, wi("StructArrayLayout2i2i2i12", ws);

      class _s extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
        }
        emplace(t2, e2, r2, n2, i2, s2) {
          const a2 = 4 * t2, o2 = 8 * t2;
          return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
        }
      }
      _s.prototype.bytesPerElement = 16, wi("StructArrayLayout2f1f2i16", _s);

      class As extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 16 * t2, l2 = 4 * t2, u5 = 8 * t2;
          return this.uint8[o2 + 0] = e2, this.uint8[o2 + 1] = r2, this.float32[l2 + 1] = n2, this.float32[l2 + 2] = i2, this.int16[u5 + 6] = s2, this.int16[u5 + 7] = a2, t2;
        }
      }
      As.prototype.bytesPerElement = 16, wi("StructArrayLayout2ub2f2i16", As);

      class Ss extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
        }
      }
      Ss.prototype.bytesPerElement = 6, wi("StructArrayLayout3ui6", Ss);

      class ks extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u5, c2, h2, p2, f2, d2, y2, m2) {
          const g2 = this.length;
          return this.resize(g2 + 1), this.emplace(g2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u5, c2, h2, p2, f2, d2, y2, m2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u5, c2, h2, p2, f2, d2, y2, m2, g2) {
          const x2 = 24 * t2, v3 = 12 * t2, b2 = 48 * t2;
          return this.int16[x2 + 0] = e2, this.int16[x2 + 1] = r2, this.uint16[x2 + 2] = n2, this.uint16[x2 + 3] = i2, this.uint32[v3 + 2] = s2, this.uint32[v3 + 3] = a2, this.uint32[v3 + 4] = o2, this.uint16[x2 + 10] = l2, this.uint16[x2 + 11] = u5, this.uint16[x2 + 12] = c2, this.float32[v3 + 7] = h2, this.float32[v3 + 8] = p2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = d2, this.uint8[b2 + 38] = y2, this.uint32[v3 + 10] = m2, this.int16[x2 + 22] = g2, t2;
        }
      }
      ks.prototype.bytesPerElement = 48, wi("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", ks);

      class Ms extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u5, c2, h2, p2, f2, d2, y2, m2, g2, x2, v3, b2, w2, _2, A2, S2, k2, M2, I2) {
          const z2 = this.length;
          return this.resize(z2 + 1), this.emplace(z2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u5, c2, h2, p2, f2, d2, y2, m2, g2, x2, v3, b2, w2, _2, A2, S2, k2, M2, I2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u5, c2, h2, p2, f2, d2, y2, m2, g2, x2, v3, b2, w2, _2, A2, S2, k2, M2, I2, z2) {
          const P2 = 32 * t2, C3 = 16 * t2;
          return this.int16[P2 + 0] = e2, this.int16[P2 + 1] = r2, this.int16[P2 + 2] = n2, this.int16[P2 + 3] = i2, this.int16[P2 + 4] = s2, this.int16[P2 + 5] = a2, this.int16[P2 + 6] = o2, this.int16[P2 + 7] = l2, this.uint16[P2 + 8] = u5, this.uint16[P2 + 9] = c2, this.uint16[P2 + 10] = h2, this.uint16[P2 + 11] = p2, this.uint16[P2 + 12] = f2, this.uint16[P2 + 13] = d2, this.uint16[P2 + 14] = y2, this.uint16[P2 + 15] = m2, this.uint16[P2 + 16] = g2, this.uint16[P2 + 17] = x2, this.uint16[P2 + 18] = v3, this.uint16[P2 + 19] = b2, this.uint16[P2 + 20] = w2, this.uint16[P2 + 21] = _2, this.uint16[P2 + 22] = A2, this.uint32[C3 + 12] = S2, this.float32[C3 + 13] = k2, this.float32[C3 + 14] = M2, this.uint16[P2 + 30] = I2, this.uint16[P2 + 31] = z2, t2;
        }
      }
      Ms.prototype.bytesPerElement = 64, wi("StructArrayLayout8i15ui1ul2f2ui64", Ms);

      class Is extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.float32[1 * t2 + 0] = e2, t2;
        }
      }
      Is.prototype.bytesPerElement = 4, wi("StructArrayLayout1f4", Is);

      class zs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.uint16[6 * t2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
        }
      }
      zs.prototype.bytesPerElement = 12, wi("StructArrayLayout1ui2f12", zs);

      class Ps extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 4 * t2;
          return this.uint32[2 * t2 + 0] = e2, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, t2;
        }
      }
      Ps.prototype.bytesPerElement = 8, wi("StructArrayLayout1ul2ui8", Ps);

      class Cs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
        }
      }
      Cs.prototype.bytesPerElement = 4, wi("StructArrayLayout2ui4", Cs);

      class Bs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.uint16[1 * t2 + 0] = e2, t2;
        }
      }
      Bs.prototype.bytesPerElement = 2, wi("StructArrayLayout1ui2", Bs);

      class Vs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
        }
      }
      Vs.prototype.bytesPerElement = 16, wi("StructArrayLayout4f16", Vs);

      class Es extends as {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new s(this.anchorPointX, this.anchorPointY);
        }
      }
      Es.prototype.size = 20;

      class Fs extends bs {
        get(t2) {
          return new Es(this, t2);
        }
      }
      wi("CollisionBoxArray", Fs);

      class Ts extends as {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(t2) {
          this._structArray.uint8[this._pos1 + 37] = t2;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(t2) {
          this._structArray.uint8[this._pos1 + 38] = t2;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(t2) {
          this._structArray.uint32[this._pos4 + 10] = t2;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      Ts.prototype.size = 48;

      class $s extends ks {
        get(t2) {
          return new Ts(this, t2);
        }
      }
      wi("PlacedSymbolArray", $s);

      class Ls extends as {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(t2) {
          this._structArray.uint32[this._pos4 + 12] = t2;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      Ls.prototype.size = 64;

      class Ds extends Ms {
        get(t2) {
          return new Ls(this, t2);
        }
      }
      wi("SymbolInstanceArray", Ds);

      class Os extends Is {
        getoffsetX(t2) {
          return this.float32[1 * t2 + 0];
        }
      }
      wi("GlyphOffsetArray", Os);

      class js extends hs {
        getx(t2) {
          return this.int16[3 * t2 + 0];
        }
        gety(t2) {
          return this.int16[3 * t2 + 1];
        }
        gettileUnitDistanceFromAnchor(t2) {
          return this.int16[3 * t2 + 2];
        }
      }
      wi("SymbolLineVertexArray", js);

      class Rs extends as {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      Rs.prototype.size = 12;

      class Us extends zs {
        get(t2) {
          return new Rs(this, t2);
        }
      }
      wi("TextAnchorOffsetArray", Us);

      class qs extends as {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      qs.prototype.size = 8;

      class Ns extends Ps {
        get(t2) {
          return new qs(this, t2);
        }
      }
      wi("FeatureIndexArray", Ns);

      class Zs extends cs {
      }

      class Gs extends cs {
      }

      class Ks extends cs {
      }

      class Xs extends fs {
      }

      class Hs extends ds {
      }

      class Ys extends ys {
      }

      class Js extends ms {
      }

      class Ws extends gs {
      }

      class Qs extends xs {
      }

      class ta extends vs {
      }

      class ea2 extends ws {
      }

      class ra extends As {
      }

      class na extends Ss {
      }

      class ia extends Cs {
      }
      const sa = ls([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: aa2 } = sa;

      class oa {
        constructor(t2 = []) {
          this.segments = t2;
        }
        prepareSegment(t2, e2, r2, n2) {
          let i2 = this.segments[this.segments.length - 1];
          return t2 > oa.MAX_VERTEX_ARRAY_LENGTH && A(`Max vertices per segment is ${oa.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > oa.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, n2 !== undefined && (i2.sortKey = n2), this.segments.push(i2)), i2;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t2 of this.segments)
            for (const e2 in t2.vaos)
              t2.vaos[e2].destroy();
        }
        static simpleSegment(t2, e2, r2, n2) {
          return new oa([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
        }
      }
      function la(t2, e2) {
        return 256 * (t2 = y(Math.floor(t2), 0, 255)) + y(Math.floor(e2), 0, 255);
      }
      oa.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, wi("SegmentVector", oa);
      const ua = ls([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var ca3 = { exports: {} }, ha = { exports: {} };
      ha.exports = function(t2, e2) {
        var r2, n2, i2, s2, a2, o2, l2, u5;
        for (n2 = t2.length - (r2 = 3 & t2.length), i2 = e2, a2 = 3432918353, o2 = 461845907, u5 = 0;u5 < n2; )
          l2 = 255 & t2.charCodeAt(u5) | (255 & t2.charCodeAt(++u5)) << 8 | (255 & t2.charCodeAt(++u5)) << 16 | (255 & t2.charCodeAt(++u5)) << 24, ++u5, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
        switch (l2 = 0, r2) {
          case 3:
            l2 ^= (255 & t2.charCodeAt(u5 + 2)) << 16;
          case 2:
            l2 ^= (255 & t2.charCodeAt(u5 + 1)) << 8;
          case 1:
            i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t2.charCodeAt(u5))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
        }
        return i2 ^= t2.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
      };
      var pa = ha.exports, fa = { exports: {} };
      fa.exports = function(t2, e2) {
        for (var r2, n2 = t2.length, i2 = e2 ^ n2, s2 = 0;n2 >= 4; )
          r2 = 1540483477 * (65535 & (r2 = 255 & t2.charCodeAt(s2) | (255 & t2.charCodeAt(++s2)) << 8 | (255 & t2.charCodeAt(++s2)) << 16 | (255 & t2.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
        switch (n2) {
          case 3:
            i2 ^= (255 & t2.charCodeAt(s2 + 2)) << 16;
          case 2:
            i2 ^= (255 & t2.charCodeAt(s2 + 1)) << 8;
          case 1:
            i2 = 1540483477 * (65535 & (i2 ^= 255 & t2.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
        }
        return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
      };
      var da2 = pa, ya = fa.exports;
      ca3.exports = da2, ca3.exports.murmur3 = da2, ca3.exports.murmur2 = ya;
      var ma = r(ca3.exports);

      class ga {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = false;
        }
        add(t2, e2, r2, n2) {
          this.ids.push(xa(t2)), this.positions.push(e2, r2, n2);
        }
        getPositions(t2) {
          if (!this.indexed)
            throw new Error("Trying to get index, but feature positions are not indexed");
          const e2 = xa(t2);
          let r2 = 0, n2 = this.ids.length - 1;
          for (;r2 < n2; ) {
            const t3 = r2 + n2 >> 1;
            this.ids[t3] >= e2 ? n2 = t3 : r2 = t3 + 1;
          }
          const i2 = [];
          for (;this.ids[r2] === e2; )
            i2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
          return i2;
        }
        static serialize(t2, e2) {
          const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
          return va(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
        }
        static deserialize(t2) {
          const e2 = new ga;
          return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
        }
      }
      function xa(t2) {
        const e2 = +t2;
        return !isNaN(e2) && e2 <= Number.MAX_SAFE_INTEGER ? e2 : ma(String(t2));
      }
      function va(t2, e2, r2, n2) {
        for (;r2 < n2; ) {
          const i2 = t2[r2 + n2 >> 1];
          let s2 = r2 - 1, a2 = n2 + 1;
          for (;; ) {
            do {
              s2++;
            } while (t2[s2] < i2);
            do {
              a2--;
            } while (t2[a2] > i2);
            if (s2 >= a2)
              break;
            ba(t2, s2, a2), ba(e2, 3 * s2, 3 * a2), ba(e2, 3 * s2 + 1, 3 * a2 + 1), ba(e2, 3 * s2 + 2, 3 * a2 + 2);
          }
          a2 - r2 < n2 - a2 ? (va(t2, e2, r2, a2), r2 = a2 + 1) : (va(t2, e2, a2 + 1, n2), n2 = a2);
        }
      }
      function ba(t2, e2, r2) {
        const n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      wi("FeaturePositionMap", ga);

      class wa {
        constructor(t2, e2) {
          this.gl = t2.gl, this.location = e2;
        }
      }

      class _a extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = 0;
        }
        set(t2) {
          this.current !== t2 && (this.current = t2, this.gl.uniform1f(this.location, t2));
        }
      }

      class Aa extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = [0, 0, 0, 0];
        }
        set(t2) {
          t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] && t2[3] === this.current[3] || (this.current = t2, this.gl.uniform4f(this.location, t2[0], t2[1], t2[2], t2[3]));
        }
      }

      class Sa extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = Kt.transparent;
        }
        set(t2) {
          t2.r === this.current.r && t2.g === this.current.g && t2.b === this.current.b && t2.a === this.current.a || (this.current = t2, this.gl.uniform4f(this.location, t2.r, t2.g, t2.b, t2.a));
        }
      }
      const ka = new Float32Array(16);
      function Ma(t2) {
        return [la(255 * t2.r, 255 * t2.g), la(255 * t2.b, 255 * t2.a)];
      }

      class Ia {
        constructor(t2, e2, r2) {
          this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2;
        }
        setUniform(t2, e2, r2) {
          t2.set(r2.constantOr(this.value));
        }
        getBinding(t2, e2, r2) {
          return this.type === "color" ? new Sa(t2, e2) : new _a(t2, e2);
        }
      }

      class za {
        constructor(t2, e2) {
          this.uniformNames = e2.map((t3) => `u_${t3}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(t2, e2) {
          this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t2.tlbr;
        }
        setUniform(t2, e2, r2, n2) {
          const i2 = n2 === "u_pattern_to" ? this.patternTo : n2 === "u_pattern_from" ? this.patternFrom : n2 === "u_pixel_ratio_to" ? this.pixelRatioTo : n2 === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          i2 && t2.set(i2);
        }
        getBinding(t2, e2, r2) {
          return r2.substr(0, 9) === "u_pattern" ? new Aa(t2, e2) : new _a(t2, e2);
        }
      }

      class Pa {
        constructor(t2, e2, r2, n2) {
          this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: r2 === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2;
        }
        populatePaintArray(t2, e2, r2, n2, i2) {
          const s2 = this.paintVertexArray.length, a2 = this.expression.evaluate(new Ui(0), e2, {}, n2, [], i2);
          this.paintVertexArray.resize(t2), this._setPaintValue(s2, t2, a2);
        }
        updatePaintArray(t2, e2, r2, n2) {
          const i2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
          this._setPaintValue(t2, e2, i2);
        }
        _setPaintValue(t2, e2, r2) {
          if (this.type === "color") {
            const n2 = Ma(r2);
            for (let r3 = t2;r3 < e2; r3++)
              this.paintVertexArray.emplace(r3, n2[0], n2[1]);
          } else {
            for (let n2 = t2;n2 < e2; n2++)
              this.paintVertexArray.emplace(n2, r2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2));
          }
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }

      class Ca {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: r2 === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2;
        }
        populatePaintArray(t2, e2, r2, n2, i2) {
          const s2 = this.expression.evaluate(new Ui(this.zoom), e2, {}, n2, [], i2), a2 = this.expression.evaluate(new Ui(this.zoom + 1), e2, {}, n2, [], i2), o2 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, s2, a2);
        }
        updatePaintArray(t2, e2, r2, n2) {
          const i2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), s2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
          this._setPaintValue(t2, e2, i2, s2);
        }
        _setPaintValue(t2, e2, r2, n2) {
          if (this.type === "color") {
            const i2 = Ma(r2), s2 = Ma(n2);
            for (let r3 = t2;r3 < e2; r3++)
              this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
          } else {
            for (let i2 = t2;i2 < e2; i2++)
              this.paintVertexArray.emplace(i2, r2, n2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
          }
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t2, e2) {
          const r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = y(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
          t2.set(n2);
        }
        getBinding(t2, e2, r2) {
          return new _a(t2, e2);
        }
      }

      class Ba {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.expression = t2, this.type = e2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = s2, this.zoomInPaintVertexArray = new i2, this.zoomOutPaintVertexArray = new i2;
        }
        populatePaintArray(t2, e2, r2) {
          const n2 = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r2);
        }
        updatePaintArray(t2, e2, r2, n2, i2) {
          this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], i2);
        }
        _setPaintValues(t2, e2, r2, n2) {
          if (!n2 || !r2)
            return;
          const { min: i2, mid: s2, max: a2 } = r2, o2 = n2[i2], l2 = n2[s2], u5 = n2[a2];
          if (o2 && l2 && u5)
            for (let r3 = t2;r3 < e2; r3++)
              this.zoomInPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], l2.pixelRatio, o2.pixelRatio), this.zoomOutPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], u5.tl[0], u5.tl[1], u5.br[0], u5.br[1], l2.pixelRatio, u5.pixelRatio);
        }
        upload(t2) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, ua.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, ua.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }

      class Va {
        constructor(t2, e2, r2) {
          this.binders = {}, this._buffers = [];
          const n2 = [];
          for (const i2 in t2.paint._values) {
            if (!r2(i2))
              continue;
            const s2 = t2.paint.get(i2);
            if (!(s2 instanceof Hi && an(s2.property.specification)))
              continue;
            const a2 = Fa(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u5 = s2.property.useIntegerZoom, c2 = s2.property.specification["property-type"], h2 = c2 === "cross-faded" || c2 === "cross-faded-data-driven";
            if (o2.kind === "constant")
              this.binders[i2] = h2 ? new za(o2.value, a2) : new Ia(o2.value, a2, l2), n2.push(`/u_${i2}`);
            else if (o2.kind === "source" || h2) {
              const r3 = Ta(i2, l2, "source");
              this.binders[i2] = h2 ? new Ba(o2, l2, u5, e2, r3, t2.id) : new Pa(o2, a2, l2, r3), n2.push(`/a_${i2}`);
            } else {
              const t3 = Ta(i2, l2, "composite");
              this.binders[i2] = new Ca(o2, a2, l2, u5, e2, t3), n2.push(`/z_${i2}`);
            }
          }
          this.cacheKey = n2.sort().join("");
        }
        getMaxValue(t2) {
          const e2 = this.binders[t2];
          return e2 instanceof Pa || e2 instanceof Ca ? e2.maxValue : 0;
        }
        populatePaintArrays(t2, e2, r2, n2, i2) {
          for (const s2 in this.binders) {
            const a2 = this.binders[s2];
            (a2 instanceof Pa || a2 instanceof Ca || a2 instanceof Ba) && a2.populatePaintArray(t2, e2, r2, n2, i2);
          }
        }
        setConstantPatternPositions(t2, e2) {
          for (const r2 in this.binders) {
            const n2 = this.binders[r2];
            n2 instanceof za && n2.setConstantPatternPositions(t2, e2);
          }
        }
        updatePaintArrays(t2, e2, r2, n2, i2) {
          let s2 = false;
          for (const a2 in t2) {
            const o2 = e2.getPositions(a2);
            for (const e3 of o2) {
              const o3 = r2.feature(e3.index);
              for (const r3 in this.binders) {
                const l2 = this.binders[r3];
                if ((l2 instanceof Pa || l2 instanceof Ca || l2 instanceof Ba) && l2.expression.isStateDependent === true) {
                  const u5 = n2.paint.get(r3);
                  l2.expression = u5.value, l2.updatePaintArray(e3.start, e3.end, o3, t2[a2], i2), s2 = true;
                }
              }
            }
          }
          return s2;
        }
        defines() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            (r2 instanceof Ia || r2 instanceof za) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
          }
          return t2;
        }
        getBinderAttributes() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (r2 instanceof Pa || r2 instanceof Ca)
              for (let e3 = 0;e3 < r2.paintVertexAttributes.length; e3++)
                t2.push(r2.paintVertexAttributes[e3].name);
            else if (r2 instanceof Ba)
              for (let e3 = 0;e3 < ua.members.length; e3++)
                t2.push(ua.members[e3].name);
          }
          return t2;
        }
        getBinderUniforms() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (r2 instanceof Ia || r2 instanceof za || r2 instanceof Ca)
              for (const e3 of r2.uniformNames)
                t2.push(e3);
          }
          return t2;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t2, e2) {
          const r2 = [];
          for (const n2 in this.binders) {
            const i2 = this.binders[n2];
            if (i2 instanceof Ia || i2 instanceof za || i2 instanceof Ca) {
              for (const s2 of i2.uniformNames)
                if (e2[s2]) {
                  const a2 = i2.getBinding(t2, e2[s2], s2);
                  r2.push({ name: s2, property: n2, binding: a2 });
                }
            }
          }
          return r2;
        }
        setUniforms(t2, e2, r2, n2) {
          for (const { name: t3, property: i2, binding: s2 } of e2)
            this.binders[i2].setUniform(s2, n2, r2.get(i2), t3);
        }
        updatePaintBuffers(t2) {
          this._buffers = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (t2 && r2 instanceof Ba) {
              const e3 = t2.fromScale === 2 ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
              e3 && this._buffers.push(e3);
            } else
              (r2 instanceof Pa || r2 instanceof Ca) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
          }
        }
        upload(t2) {
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            (r2 instanceof Pa || r2 instanceof Ca || r2 instanceof Ba) && r2.upload(t2);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t2 in this.binders) {
            const e2 = this.binders[t2];
            (e2 instanceof Pa || e2 instanceof Ca || e2 instanceof Ba) && e2.destroy();
          }
        }
      }

      class Ea {
        constructor(t2, e2, r2 = () => true) {
          this.programConfigurations = {};
          for (const n2 of t2)
            this.programConfigurations[n2.id] = new Va(n2, e2, r2);
          this.needsUpload = false, this._featureMap = new ga, this._bufferOffset = 0;
        }
        populatePaintArrays(t2, e2, r2, n2, i2, s2) {
          for (const r3 in this.programConfigurations)
            this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, s2);
          e2.id !== undefined && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
        }
        updatePaintArrays(t2, e2, r2, n2) {
          for (const i2 of r2)
            this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(t2, this._featureMap, e2, i2, n2) || this.needsUpload;
        }
        get(t2) {
          return this.programConfigurations[t2];
        }
        upload(t2) {
          if (this.needsUpload) {
            for (const e2 in this.programConfigurations)
              this.programConfigurations[e2].upload(t2);
            this.needsUpload = false;
          }
        }
        destroy() {
          for (const t2 in this.programConfigurations)
            this.programConfigurations[t2].destroy();
        }
      }
      function Fa(t2, e2) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
      }
      function Ta(t2, e2, r2) {
        const n2 = { color: { source: ys, composite: Vs }, number: { source: Is, composite: ys } }, i2 = function(t3) {
          return { "line-pattern": { source: Js, composite: Js }, "fill-pattern": { source: Js, composite: Js }, "fill-extrusion-pattern": { source: Js, composite: Js } }[t3];
        }(t2);
        return i2 && i2[r2] || n2[e2][r2];
      }
      wi("ConstantBinder", Ia), wi("CrossFadedConstantBinder", za), wi("SourceExpressionBinder", Pa), wi("CrossFadedCompositeBinder", Ba), wi("CompositeExpressionBinder", Ca), wi("ProgramConfiguration", Va, { omit: ["_buffers"] }), wi("ProgramConfigurationSet", Ea);
      const $a = 8192, La = Math.pow(2, 14) - 1, Da = -La - 1;
      function Oa(t2) {
        const e2 = $a / t2.extent, r2 = t2.loadGeometry();
        for (let t3 = 0;t3 < r2.length; t3++) {
          const n2 = r2[t3];
          for (let t4 = 0;t4 < n2.length; t4++) {
            const r3 = n2[t4], i2 = Math.round(r3.x * e2), s2 = Math.round(r3.y * e2);
            r3.x = y(i2, Da, La), r3.y = y(s2, Da, La), (i2 < r3.x || i2 > r3.x + 1 || s2 < r3.y || s2 > r3.y + 1) && A("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return r2;
      }
      function ja(t2, e2) {
        return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? Oa(t2) : [] };
      }
      function Ra(t2, e2, r2, n2, i2) {
        t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
      }

      class Ua {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Gs, this.indexArray = new na, this.segments = new oa, this.programConfigurations = new Ea(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          const n2 = this.layers[0], i2 = [];
          let s2 = null, a2 = false;
          n2.type === "circle" && (s2 = n2.layout.get("circle-sort-key"), a2 = !s2.isConstant());
          for (const { feature: e3, id: n3, index: o2, sourceLayerIndex: l2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u5 = ja(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new Ui(this.zoom), u5, r2))
              continue;
            const c2 = a2 ? s2.evaluate(u5, {}, r2) : undefined, h2 = { id: n3, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u5.geometry : Oa(e3), patterns: {}, sortKey: c2 };
            i2.push(h2);
          }
          a2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of i2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, o2 = t2[s3].feature;
            this.addFeature(n3, i3, s3, r2), e2.featureIndex.insert(o2, i3, s3, a3, this.index);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, aa2), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t2, e2, r2, n2) {
          for (const r3 of e2)
            for (const e3 of r3) {
              const { x: r4, y: n3 } = e3;
              if (r4 < 0 || r4 >= $a || n3 < 0 || n3 >= $a)
                continue;
              const i2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), s2 = i2.vertexLength;
              Ra(this.layoutVertexArray, r4, n3, -1, -1), Ra(this.layoutVertexArray, r4, n3, 1, -1), Ra(this.layoutVertexArray, r4, n3, 1, 1), Ra(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(s2, s2 + 1, s2 + 2), this.indexArray.emplaceBack(s2, s2 + 3, s2 + 2), i2.vertexLength += 4, i2.primitiveLength += 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2);
        }
      }
      function qa(t2, e2) {
        for (let r2 = 0;r2 < t2.length; r2++)
          if (Wa(e2, t2[r2]))
            return true;
        for (let r2 = 0;r2 < e2.length; r2++)
          if (Wa(t2, e2[r2]))
            return true;
        return !!Ka(t2, e2);
      }
      function Na(t2, e2, r2) {
        return !!Wa(t2, e2) || !!Ha(e2, t2, r2);
      }
      function Za(t2, e2) {
        if (t2.length === 1)
          return Ja(e2, t2[0]);
        for (let r2 = 0;r2 < e2.length; r2++) {
          const n2 = e2[r2];
          for (let e3 = 0;e3 < n2.length; e3++)
            if (Wa(t2, n2[e3]))
              return true;
        }
        for (let r2 = 0;r2 < t2.length; r2++)
          if (Ja(e2, t2[r2]))
            return true;
        for (let r2 = 0;r2 < e2.length; r2++)
          if (Ka(t2, e2[r2]))
            return true;
        return false;
      }
      function Ga(t2, e2, r2) {
        if (t2.length > 1) {
          if (Ka(t2, e2))
            return true;
          for (let n2 = 0;n2 < e2.length; n2++)
            if (Ha(e2[n2], t2, r2))
              return true;
        }
        for (let n2 = 0;n2 < t2.length; n2++)
          if (Ha(t2[n2], e2, r2))
            return true;
        return false;
      }
      function Ka(t2, e2) {
        if (t2.length === 0 || e2.length === 0)
          return false;
        for (let r2 = 0;r2 < t2.length - 1; r2++) {
          const n2 = t2[r2], i2 = t2[r2 + 1];
          for (let t3 = 0;t3 < e2.length - 1; t3++)
            if (Xa(n2, i2, e2[t3], e2[t3 + 1]))
              return true;
        }
        return false;
      }
      function Xa(t2, e2, r2, n2) {
        return S(t2, r2, n2) !== S(e2, r2, n2) && S(t2, e2, r2) !== S(t2, e2, n2);
      }
      function Ha(t2, e2, r2) {
        const n2 = r2 * r2;
        if (e2.length === 1)
          return t2.distSqr(e2[0]) < n2;
        for (let r3 = 1;r3 < e2.length; r3++)
          if (Ya(t2, e2[r3 - 1], e2[r3]) < n2)
            return true;
        return false;
      }
      function Ya(t2, e2, r2) {
        const n2 = e2.distSqr(r2);
        if (n2 === 0)
          return t2.distSqr(e2);
        const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
        return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
      }
      function Ja(t2, e2) {
        let r2, n2, i2, s2 = false;
        for (let a2 = 0;a2 < t2.length; a2++) {
          r2 = t2[a2];
          for (let t3 = 0, a3 = r2.length - 1;t3 < r2.length; a3 = t3++)
            n2 = r2[t3], i2 = r2[a3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
        }
        return s2;
      }
      function Wa(t2, e2) {
        let r2 = false;
        for (let n2 = 0, i2 = t2.length - 1;n2 < t2.length; i2 = n2++) {
          const s2 = t2[n2], a2 = t2[i2];
          s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
        }
        return r2;
      }
      function Qa(t2, e2, r2) {
        const n2 = r2[0], i2 = r2[2];
        if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
          return false;
        const s2 = S(t2, e2, r2[0]);
        return s2 !== S(t2, e2, r2[1]) || s2 !== S(t2, e2, r2[2]) || s2 !== S(t2, e2, r2[3]);
      }
      function to(t2, e2, r2) {
        const n2 = e2.paint.get(t2).value;
        return n2.kind === "constant" ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
      }
      function eo(t2) {
        return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
      }
      function ro(t2, e2, r2, n2, i2) {
        if (!e2[0] && !e2[1])
          return t2;
        const a2 = s.convert(e2)._mult(i2);
        r2 === "viewport" && a2._rotate(-n2);
        const o2 = [];
        for (let e3 = 0;e3 < t2.length; e3++)
          o2.push(t2[e3].sub(a2));
        return o2;
      }
      let no, io;
      wi("CircleBucket", Ua, { omit: ["layers"] });
      var so = { get paint() {
        return io = io || new rs({ "circle-radius": new Wi(G.paint_circle["circle-radius"]), "circle-color": new Wi(G.paint_circle["circle-color"]), "circle-blur": new Wi(G.paint_circle["circle-blur"]), "circle-opacity": new Wi(G.paint_circle["circle-opacity"]), "circle-translate": new Ji(G.paint_circle["circle-translate"]), "circle-translate-anchor": new Ji(G.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Ji(G.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Ji(G.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Wi(G.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Wi(G.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Wi(G.paint_circle["circle-stroke-opacity"]) });
      }, get layout() {
        return no = no || new rs({ "circle-sort-key": new Wi(G.layout_circle["circle-sort-key"]) });
      } }, ao = 0.000001, oo = typeof Float32Array != "undefined" ? Float32Array : Array;
      function lo(t2) {
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }
      function uo(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u5 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], y2 = e2[12], m2 = e2[13], g2 = e2[14], x2 = e2[15], v3 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
        return t2[0] = v3 * n2 + b2 * o2 + w2 * h2 + _2 * y2, t2[1] = v3 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[2] = v3 * s2 + b2 * u5 + w2 * f2 + _2 * g2, t2[3] = v3 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[4] = (v3 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y2, t2[5] = v3 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[6] = v3 * s2 + b2 * u5 + w2 * f2 + _2 * g2, t2[7] = v3 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[8] = (v3 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y2, t2[9] = v3 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[10] = v3 * s2 + b2 * u5 + w2 * f2 + _2 * g2, t2[11] = v3 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[12] = (v3 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y2, t2[13] = v3 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[14] = v3 * s2 + b2 * u5 + w2 * f2 + _2 * g2, t2[15] = v3 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2;
      }
      Math.hypot || (Math.hypot = function() {
        for (var t2 = 0, e2 = arguments.length;e2--; )
          t2 += arguments[e2] * arguments[e2];
        return Math.sqrt(t2);
      });
      var co, ho = uo;
      function po(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
        return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
      }
      co = new oo(4), oo != Float32Array && (co[0] = 0, co[1] = 0, co[2] = 0, co[3] = 0);

      class fo extends is {
        constructor(t2) {
          super(t2, so);
        }
        createBucket(t2) {
          return new Ua(t2);
        }
        queryRadius(t2) {
          const e2 = t2;
          return to("circle-radius", this, e2) + to("circle-stroke-width", this, e2) + eo(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = ro(t2, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, a2), u5 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2), c2 = this.paint.get("circle-pitch-alignment") === "map", h2 = c2 ? l2 : function(t3, e3) {
            return t3.map((t4) => yo(t4, e3));
          }(l2, o2), p2 = c2 ? u5 * a2 : u5;
          for (const t3 of n2)
            for (const e3 of t3) {
              const t4 = c2 ? e3 : yo(e3, o2);
              let r3 = p2;
              const n3 = po([], [e3.x, e3.y, 0, 1], o2);
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? r3 *= n3[3] / s2.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (r3 *= s2.cameraToCenterDistance / n3[3]), Na(h2, t4, r3))
                return true;
            }
          return false;
        }
      }
      function yo(t2, e2) {
        const r2 = po([], [t2.x, t2.y, 0, 1], e2);
        return new s(r2[0] / r2[3], r2[1] / r2[3]);
      }

      class mo extends Ua {
      }
      let go;
      wi("HeatmapBucket", mo, { omit: ["layers"] });
      var xo = { get paint() {
        return go = go || new rs({ "heatmap-radius": new Wi(G.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Wi(G.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Ji(G.paint_heatmap["heatmap-intensity"]), "heatmap-color": new es(G.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Ji(G.paint_heatmap["heatmap-opacity"]) });
      } };
      function vo(t2, { width: e2, height: r2 }, n2, i2) {
        if (i2) {
          if (i2 instanceof Uint8ClampedArray)
            i2 = new Uint8Array(i2.buffer);
          else if (i2.length !== e2 * r2 * n2)
            throw new RangeError(`mismatched image size. expected: ${i2.length} but got: ${e2 * r2 * n2}`);
        } else
          i2 = new Uint8Array(e2 * r2 * n2);
        return t2.width = e2, t2.height = r2, t2.data = i2, t2;
      }
      function bo(t2, { width: e2, height: r2 }, n2) {
        if (e2 === t2.width && r2 === t2.height)
          return;
        const i2 = vo({}, { width: e2, height: r2 }, n2);
        wo(t2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, e2), height: Math.min(t2.height, r2) }, n2), t2.width = e2, t2.height = r2, t2.data = i2.data;
      }
      function wo(t2, e2, r2, n2, i2, s2) {
        if (i2.width === 0 || i2.height === 0)
          return e2;
        if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const a2 = t2.data, o2 = e2.data;
        if (a2 === o2)
          throw new Error("srcData equals dstData, so image is already copied");
        for (let l2 = 0;l2 < i2.height; l2++) {
          const u5 = ((r2.y + l2) * t2.width + r2.x) * s2, c2 = ((n2.y + l2) * e2.width + n2.x) * s2;
          for (let t3 = 0;t3 < i2.width * s2; t3++)
            o2[c2 + t3] = a2[u5 + t3];
        }
        return e2;
      }

      class _o {
        constructor(t2, e2) {
          vo(this, t2, 1, e2);
        }
        resize(t2) {
          bo(this, t2, 1);
        }
        clone() {
          return new _o({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t2, e2, r2, n2, i2) {
          wo(t2, e2, r2, n2, i2, 1);
        }
      }

      class Ao {
        constructor(t2, e2) {
          vo(this, t2, 4, e2);
        }
        resize(t2) {
          bo(this, t2, 4);
        }
        replace(t2, e2) {
          e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
        }
        clone() {
          return new Ao({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t2, e2, r2, n2, i2) {
          wo(t2, e2, r2, n2, i2, 4);
        }
      }
      function So(t2) {
        const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Ao({ width: r2, height: n2 });
        if (Math.log(r2) / Math.LN2 % 1 != 0)
          throw new Error(`width is not a power of 2 - ${r2}`);
        const s2 = (r3, n3, s3) => {
          e2[t2.evaluationKey] = s3;
          const a2 = t2.expression.evaluate(e2);
          i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a);
        };
        if (t2.clips)
          for (let e3 = 0, i3 = 0;e3 < n2; ++e3, i3 += 4 * r2)
            for (let n3 = 0, a2 = 0;n3 < r2; n3++, a2 += 4) {
              const o2 = n3 / (r2 - 1), { start: l2, end: u5 } = t2.clips[e3];
              s2(i3, a2, l2 * (1 - o2) + u5 * o2);
            }
        else
          for (let t3 = 0, e3 = 0;t3 < r2; t3++, e3 += 4)
            s2(0, e3, t3 / (r2 - 1));
        return i2;
      }
      wi("AlphaImage", _o), wi("RGBAImage", Ao);
      const ko = "big-fb";

      class Mo extends is {
        createBucket(t2) {
          return new mo(t2);
        }
        constructor(t2) {
          super(t2, xo), this.heatmapFbos = new Map, this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          t2 === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = So({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbos.has(ko) && this.heatmapFbos.delete(ko);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }
      let Io;
      var zo = { get paint() {
        return Io = Io || new rs({ "hillshade-illumination-direction": new Ji(G.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Ji(G.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Ji(G.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Ji(G.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Ji(G.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Ji(G.paint_hillshade["hillshade-accent-color"]) });
      } };

      class Po extends is {
        constructor(t2) {
          super(t2, zo);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }
      const Co = ls([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Bo } = Co;
      function Vo(t2, e2, r2 = 2) {
        const n2 = e2 && e2.length, i2 = n2 ? e2[0] * r2 : t2.length;
        let s2 = Eo(t2, 0, i2, r2, true);
        const a2 = [];
        if (!s2 || s2.next === s2.prev)
          return a2;
        let o2, l2, u5;
        if (n2 && (s2 = function(t3, e3, r3, n3) {
          const i3 = [];
          for (let r4 = 0, s3 = e3.length;r4 < s3; r4++) {
            const a3 = Eo(t3, e3[r4] * n3, r4 < s3 - 1 ? e3[r4 + 1] * n3 : t3.length, n3, false);
            a3 === a3.next && (a3.steiner = true), i3.push(No(a3));
          }
          i3.sort(jo);
          for (let t4 = 0;t4 < i3.length; t4++)
            r3 = Ro(i3[t4], r3);
          return r3;
        }(t2, e2, s2, r2)), t2.length > 80 * r2) {
          o2 = 1 / 0, l2 = 1 / 0;
          let e3 = -1 / 0, n3 = -1 / 0;
          for (let s3 = r2;s3 < i2; s3 += r2) {
            const r3 = t2[s3], i3 = t2[s3 + 1];
            r3 < o2 && (o2 = r3), i3 < l2 && (l2 = i3), r3 > e3 && (e3 = r3), i3 > n3 && (n3 = i3);
          }
          u5 = Math.max(e3 - o2, n3 - l2), u5 = u5 !== 0 ? 32767 / u5 : 0;
        }
        return To(s2, a2, r2, o2, l2, u5, 0), a2;
      }
      function Eo(t2, e2, r2, n2, i2) {
        let s2;
        if (i2 === function(t3, e3, r3, n3) {
          let i3 = 0;
          for (let s3 = e3, a2 = r3 - n3;s3 < r3; s3 += n3)
            i3 += (t3[a2] - t3[s3]) * (t3[s3 + 1] + t3[a2 + 1]), a2 = s3;
          return i3;
        }(t2, e2, r2, n2) > 0)
          for (let i3 = e2;i3 < r2; i3 += n2)
            s2 = tl(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
        else
          for (let i3 = r2 - n2;i3 >= e2; i3 -= n2)
            s2 = tl(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
        return s2 && Xo(s2, s2.next) && (el(s2), s2 = s2.next), s2;
      }
      function Fo(t2, e2) {
        if (!t2)
          return t2;
        e2 || (e2 = t2);
        let r2, n2 = t2;
        do {
          if (r2 = false, n2.steiner || !Xo(n2, n2.next) && Ko(n2.prev, n2, n2.next) !== 0)
            n2 = n2.next;
          else {
            if (el(n2), n2 = e2 = n2.prev, n2 === n2.next)
              break;
            r2 = true;
          }
        } while (r2 || n2 !== e2);
        return e2;
      }
      function To(t2, e2, r2, n2, i2, s2, a2) {
        if (!t2)
          return;
        !a2 && s2 && function(t3, e3, r3, n3) {
          let i3 = t3;
          do {
            i3.z === 0 && (i3.z = qo(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
          } while (i3 !== t3);
          i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
            let e4, r4 = 1;
            do {
              let n4, i4 = t4;
              t4 = null;
              let s3 = null;
              for (e4 = 0;i4; ) {
                e4++;
                let a3 = i4, o3 = 0;
                for (let t5 = 0;t5 < r4 && (o3++, a3 = a3.nextZ, a3); t5++)
                  ;
                let l2 = r4;
                for (;o3 > 0 || l2 > 0 && a3; )
                  o3 !== 0 && (l2 === 0 || !a3 || i4.z <= a3.z) ? (n4 = i4, i4 = i4.nextZ, o3--) : (n4 = a3, a3 = a3.nextZ, l2--), s3 ? s3.nextZ = n4 : t4 = n4, n4.prevZ = s3, s3 = n4;
                i4 = a3;
              }
              s3.nextZ = null, r4 *= 2;
            } while (e4 > 1);
          }(i3);
        }(t2, n2, i2, s2);
        let o2 = t2;
        for (;t2.prev !== t2.next; ) {
          const { prev: l2, next: u5 } = t2;
          if (s2 ? Lo(t2, n2, i2, s2) : $o(t2))
            e2.push(l2.i, t2.i, u5.i), el(t2), t2 = u5.next, o2 = u5.next;
          else if ((t2 = u5) === o2) {
            a2 ? a2 === 1 ? To(t2 = Do(Fo(t2), e2), e2, r2, n2, i2, s2, 2) : a2 === 2 && Oo(t2, e2, r2, n2, i2, s2) : To(Fo(t2), e2, r2, n2, i2, s2, 1);
            break;
          }
        }
      }
      function $o(t2) {
        const e2 = t2.prev, r2 = t2, n2 = t2.next;
        if (Ko(e2, r2, n2) >= 0)
          return false;
        const i2 = e2.x, s2 = r2.x, a2 = n2.x, o2 = e2.y, l2 = r2.y, u5 = n2.y, c2 = i2 < s2 ? i2 < a2 ? i2 : a2 : s2 < a2 ? s2 : a2, h2 = o2 < l2 ? o2 < u5 ? o2 : u5 : l2 < u5 ? l2 : u5, p2 = i2 > s2 ? i2 > a2 ? i2 : a2 : s2 > a2 ? s2 : a2, f2 = o2 > l2 ? o2 > u5 ? o2 : u5 : l2 > u5 ? l2 : u5;
        let d2 = n2.next;
        for (;d2 !== e2; ) {
          if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f2 && Zo(i2, o2, s2, l2, a2, u5, d2.x, d2.y) && Ko(d2.prev, d2, d2.next) >= 0)
            return false;
          d2 = d2.next;
        }
        return true;
      }
      function Lo(t2, e2, r2, n2) {
        const i2 = t2.prev, s2 = t2, a2 = t2.next;
        if (Ko(i2, s2, a2) >= 0)
          return false;
        const o2 = i2.x, l2 = s2.x, u5 = a2.x, c2 = i2.y, h2 = s2.y, p2 = a2.y, f2 = o2 < l2 ? o2 < u5 ? o2 : u5 : l2 < u5 ? l2 : u5, d2 = c2 < h2 ? c2 < p2 ? c2 : p2 : h2 < p2 ? h2 : p2, y2 = o2 > l2 ? o2 > u5 ? o2 : u5 : l2 > u5 ? l2 : u5, m2 = c2 > h2 ? c2 > p2 ? c2 : p2 : h2 > p2 ? h2 : p2, g2 = qo(f2, d2, e2, r2, n2), x2 = qo(y2, m2, e2, r2, n2);
        let { prevZ: v3, nextZ: b2 } = t2;
        for (;v3 && v3.z >= g2 && b2 && b2.z <= x2; ) {
          if (v3.x >= f2 && v3.x <= y2 && v3.y >= d2 && v3.y <= m2 && v3 !== i2 && v3 !== a2 && Zo(o2, c2, l2, h2, u5, p2, v3.x, v3.y) && Ko(v3.prev, v3, v3.next) >= 0)
            return false;
          if (v3 = v3.prevZ, b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && Zo(o2, c2, l2, h2, u5, p2, b2.x, b2.y) && Ko(b2.prev, b2, b2.next) >= 0)
            return false;
          b2 = b2.nextZ;
        }
        for (;v3 && v3.z >= g2; ) {
          if (v3.x >= f2 && v3.x <= y2 && v3.y >= d2 && v3.y <= m2 && v3 !== i2 && v3 !== a2 && Zo(o2, c2, l2, h2, u5, p2, v3.x, v3.y) && Ko(v3.prev, v3, v3.next) >= 0)
            return false;
          v3 = v3.prevZ;
        }
        for (;b2 && b2.z <= x2; ) {
          if (b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && Zo(o2, c2, l2, h2, u5, p2, b2.x, b2.y) && Ko(b2.prev, b2, b2.next) >= 0)
            return false;
          b2 = b2.nextZ;
        }
        return true;
      }
      function Do(t2, e2) {
        let r2 = t2;
        do {
          const n2 = r2.prev, i2 = r2.next.next;
          !Xo(n2, i2) && Ho(n2, r2, r2.next, i2) && Wo(n2, i2) && Wo(i2, n2) && (e2.push(n2.i, r2.i, i2.i), el(r2), el(r2.next), r2 = t2 = i2), r2 = r2.next;
        } while (r2 !== t2);
        return Fo(r2);
      }
      function Oo(t2, e2, r2, n2, i2, s2) {
        let a2 = t2;
        do {
          let t3 = a2.next.next;
          for (;t3 !== a2.prev; ) {
            if (a2.i !== t3.i && Go(a2, t3)) {
              let o2 = Qo(a2, t3);
              return a2 = Fo(a2, a2.next), o2 = Fo(o2, o2.next), To(a2, e2, r2, n2, i2, s2, 0), void To(o2, e2, r2, n2, i2, s2, 0);
            }
            t3 = t3.next;
          }
          a2 = a2.next;
        } while (a2 !== t2);
      }
      function jo(t2, e2) {
        return t2.x - e2.x;
      }
      function Ro(t2, e2) {
        const r2 = function(t3, e3) {
          let r3 = e3;
          const { x: n3, y: i2 } = t3;
          let s2, a2 = -1 / 0;
          do {
            if (i2 <= r3.y && i2 >= r3.next.y && r3.next.y !== r3.y) {
              const t4 = r3.x + (i2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
              if (t4 <= n3 && t4 > a2 && (a2 = t4, s2 = r3.x < r3.next.x ? r3 : r3.next, t4 === n3))
                return s2;
            }
            r3 = r3.next;
          } while (r3 !== e3);
          if (!s2)
            return null;
          const o2 = s2, l2 = s2.x, u5 = s2.y;
          let c2 = 1 / 0;
          r3 = s2;
          do {
            if (n3 >= r3.x && r3.x >= l2 && n3 !== r3.x && Zo(i2 < u5 ? n3 : a2, i2, l2, u5, i2 < u5 ? a2 : n3, i2, r3.x, r3.y)) {
              const e4 = Math.abs(i2 - r3.y) / (n3 - r3.x);
              Wo(r3, t3) && (e4 < c2 || e4 === c2 && (r3.x > s2.x || r3.x === s2.x && Uo(s2, r3))) && (s2 = r3, c2 = e4);
            }
            r3 = r3.next;
          } while (r3 !== o2);
          return s2;
        }(t2, e2);
        if (!r2)
          return e2;
        const n2 = Qo(r2, t2);
        return Fo(n2, n2.next), Fo(r2, r2.next);
      }
      function Uo(t2, e2) {
        return Ko(t2.prev, t2, e2.prev) < 0 && Ko(e2.next, t2, t2.next) < 0;
      }
      function qo(t2, e2, r2, n2, i2) {
        return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
      }
      function No(t2) {
        let e2 = t2, r2 = t2;
        do {
          (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
        } while (e2 !== t2);
        return r2;
      }
      function Zo(t2, e2, r2, n2, i2, s2, a2, o2) {
        return (i2 - a2) * (e2 - o2) >= (t2 - a2) * (s2 - o2) && (t2 - a2) * (n2 - o2) >= (r2 - a2) * (e2 - o2) && (r2 - a2) * (s2 - o2) >= (i2 - a2) * (n2 - o2);
      }
      function Go(t2, e2) {
        return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
          let r2 = t3;
          do {
            if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && Ho(r2, r2.next, t3, e3))
              return true;
            r2 = r2.next;
          } while (r2 !== t3);
          return false;
        }(t2, e2) && (Wo(t2, e2) && Wo(e2, t2) && function(t3, e3) {
          let r2 = t3, n2 = false;
          const i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
          do {
            r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
          } while (r2 !== t3);
          return n2;
        }(t2, e2) && (Ko(t2.prev, t2, e2.prev) || Ko(t2, e2.prev, e2)) || Xo(t2, e2) && Ko(t2.prev, t2, t2.next) > 0 && Ko(e2.prev, e2, e2.next) > 0);
      }
      function Ko(t2, e2, r2) {
        return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
      }
      function Xo(t2, e2) {
        return t2.x === e2.x && t2.y === e2.y;
      }
      function Ho(t2, e2, r2, n2) {
        const i2 = Jo(Ko(t2, e2, r2)), s2 = Jo(Ko(t2, e2, n2)), a2 = Jo(Ko(r2, n2, t2)), o2 = Jo(Ko(r2, n2, e2));
        return i2 !== s2 && a2 !== o2 || !(i2 !== 0 || !Yo(t2, r2, e2)) || !(s2 !== 0 || !Yo(t2, n2, e2)) || !(a2 !== 0 || !Yo(r2, t2, n2)) || !(o2 !== 0 || !Yo(r2, e2, n2));
      }
      function Yo(t2, e2, r2) {
        return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
      }
      function Jo(t2) {
        return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
      }
      function Wo(t2, e2) {
        return Ko(t2.prev, t2, t2.next) < 0 ? Ko(t2, e2, t2.next) >= 0 && Ko(t2, t2.prev, e2) >= 0 : Ko(t2, e2, t2.prev) < 0 || Ko(t2, t2.next, e2) < 0;
      }
      function Qo(t2, e2) {
        const r2 = rl(t2.i, t2.x, t2.y), n2 = rl(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
        return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
      }
      function tl(t2, e2, r2, n2) {
        const i2 = rl(t2, e2, r2);
        return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
      }
      function el(t2) {
        t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
      }
      function rl(t2, e2, r2) {
        return { i: t2, x: e2, y: r2, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
      }
      function nl(t2, e2, r2) {
        const n2 = r2.patternDependencies;
        let i2 = false;
        for (const r3 of e2) {
          const e3 = r3.paint.get(`${t2}-pattern`);
          e3.isConstant() || (i2 = true);
          const s2 = e3.constantOr(null);
          s2 && (i2 = true, n2[s2.to] = true, n2[s2.from] = true);
        }
        return i2;
      }
      function il(t2, e2, r2, n2, i2) {
        const s2 = i2.patternDependencies;
        for (const a2 of e2) {
          const e3 = a2.paint.get(`${t2}-pattern`).value;
          if (e3.kind !== "constant") {
            let t3 = e3.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), o2 = e3.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), l2 = e3.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
            t3 = t3 && t3.name ? t3.name : t3, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, s2[t3] = true, s2[o2] = true, s2[l2] = true, r2.patterns[a2.id] = { min: t3, mid: o2, max: l2 };
          }
        }
        return r2;
      }

      class sl {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Ks, this.indexArray = new na, this.indexArray2 = new ia, this.programConfigurations = new Ea(t2.layers, t2.zoom), this.segments = new oa, this.segments2 = new oa, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          this.hasPattern = nl("fill", this.layers, e2);
          const n2 = this.layers[0].layout.get("fill-sort-key"), i2 = !n2.isConstant(), s2 = [];
          for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u5 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, c2 = ja(a2, t3);
            if (!this.layers[0]._featureFilter.filter(new Ui(this.zoom), c2, r2))
              continue;
            const h2 = i2 ? n2.evaluate(c2, {}, r2, e2.availableImages) : undefined, p2 = { id: o2, properties: a2.properties, type: a2.type, sourceLayerIndex: u5, index: l2, geometry: t3 ? c2.geometry : Oa(a2), patterns: {}, sortKey: h2 };
            s2.push(p2);
          }
          i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
            if (this.hasPattern) {
              const t3 = il("fill", this.layers, n3, this.zoom, e2);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, s3, r2, {});
            e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        addFeatures(t2, e2, r2) {
          for (const t3 of this.patternFeatures)
            this.addFeature(t3, t3.geometry, t3.index, e2, r2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Bo), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(t2, e2, r2, n2, i2) {
          for (const t3 of xr(e2, 500)) {
            let e3 = 0;
            for (const r4 of t3)
              e3 += r4.length;
            const r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], s2 = [];
            for (const e4 of t3) {
              if (e4.length === 0)
                continue;
              e4 !== t3[0] && s2.push(i3.length / 2);
              const r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
              this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
              for (let t4 = 1;t4 < e4.length; t4++)
                this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
              r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
            }
            const a2 = Vo(i3, s2);
            for (let t4 = 0;t4 < a2.length; t4 += 3)
              this.indexArray.emplaceBack(n3 + a2[t4], n3 + a2[t4 + 1], n3 + a2[t4 + 2]);
            r3.vertexLength += e3, r3.primitiveLength += a2.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
        }
      }
      let al, ol;
      wi("FillBucket", sl, { omit: ["layers", "patternFeatures"] });
      var ll = { get paint() {
        return ol = ol || new rs({ "fill-antialias": new Ji(G.paint_fill["fill-antialias"]), "fill-opacity": new Wi(G.paint_fill["fill-opacity"]), "fill-color": new Wi(G.paint_fill["fill-color"]), "fill-outline-color": new Wi(G.paint_fill["fill-outline-color"]), "fill-translate": new Ji(G.paint_fill["fill-translate"]), "fill-translate-anchor": new Ji(G.paint_fill["fill-translate-anchor"]), "fill-pattern": new Qi(G.paint_fill["fill-pattern"]) });
      }, get layout() {
        return al = al || new rs({ "fill-sort-key": new Wi(G.layout_fill["fill-sort-key"]) });
      } };

      class ul extends is {
        constructor(t2) {
          super(t2, ll);
        }
        recalculate(t2, e2) {
          super.recalculate(t2, e2);
          const r2 = this.paint._values["fill-outline-color"];
          r2.value.kind === "constant" && r2.value.value === undefined && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t2) {
          return new sl(t2);
        }
        queryRadius() {
          return eo(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2) {
          return Za(ro(t2, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, a2), n2);
        }
        isTileClipped() {
          return true;
        }
      }
      const cl = ls([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), hl = ls([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: pl } = cl;
      var fl = {}, dl = n, yl = ml;
      function ml(t2, e2, r2, n2, i2) {
        this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(gl, this, e2);
      }
      function gl(t2, e2, r2) {
        t2 == 1 ? e2.id = r2.readVarint() : t2 == 2 ? function(t3, e3) {
          for (var r3 = t3.readVarint() + t3.pos;t3.pos < r3; ) {
            var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
            e3.properties[n2] = i2;
          }
        }(r2, e2) : t2 == 3 ? e2.type = r2.readVarint() : t2 == 4 && (e2._geometry = r2.pos);
      }
      function xl(t2) {
        for (var e2, r2, n2 = 0, i2 = 0, s2 = t2.length, a2 = s2 - 1;i2 < s2; a2 = i2++)
          n2 += ((r2 = t2[a2]).x - (e2 = t2[i2]).x) * (e2.y + r2.y);
        return n2;
      }
      ml.types = ["Unknown", "Point", "LineString", "Polygon"], ml.prototype.loadGeometry = function() {
        var t2 = this._pbf;
        t2.pos = this._geometry;
        for (var e2, r2 = t2.readVarint() + t2.pos, n2 = 1, i2 = 0, s2 = 0, a2 = 0, o2 = [];t2.pos < r2; ) {
          if (i2 <= 0) {
            var l2 = t2.readVarint();
            n2 = 7 & l2, i2 = l2 >> 3;
          }
          if (i2--, n2 === 1 || n2 === 2)
            s2 += t2.readSVarint(), a2 += t2.readSVarint(), n2 === 1 && (e2 && o2.push(e2), e2 = []), e2.push(new dl(s2, a2));
          else {
            if (n2 !== 7)
              throw new Error("unknown command " + n2);
            e2 && e2.push(e2[0].clone());
          }
        }
        return e2 && o2.push(e2), o2;
      }, ml.prototype.bbox = function() {
        var t2 = this._pbf;
        t2.pos = this._geometry;
        for (var e2 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u5 = -1 / 0;t2.pos < e2; ) {
          if (n2 <= 0) {
            var c2 = t2.readVarint();
            r2 = 7 & c2, n2 = c2 >> 3;
          }
          if (n2--, r2 === 1 || r2 === 2)
            (i2 += t2.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t2.readSVarint()) < l2 && (l2 = s2), s2 > u5 && (u5 = s2);
          else if (r2 !== 7)
            throw new Error("unknown command " + r2);
        }
        return [a2, l2, o2, u5];
      }, ml.prototype.toGeoJSON = function(t2, e2, r2) {
        var n2, i2, s2 = this.extent * Math.pow(2, r2), a2 = this.extent * t2, o2 = this.extent * e2, l2 = this.loadGeometry(), u5 = ml.types[this.type];
        function c2(t3) {
          for (var e3 = 0;e3 < t3.length; e3++) {
            var r3 = t3[e3];
            t3[e3] = [360 * (r3.x + a2) / s2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / s2) * Math.PI / 180)) - 90];
          }
        }
        switch (this.type) {
          case 1:
            var h2 = [];
            for (n2 = 0;n2 < l2.length; n2++)
              h2[n2] = l2[n2][0];
            c2(l2 = h2);
            break;
          case 2:
            for (n2 = 0;n2 < l2.length; n2++)
              c2(l2[n2]);
            break;
          case 3:
            for (l2 = function(t3) {
              var e3 = t3.length;
              if (e3 <= 1)
                return [t3];
              for (var r3, n3, i3 = [], s3 = 0;s3 < e3; s3++) {
                var a3 = xl(t3[s3]);
                a3 !== 0 && (n3 === undefined && (n3 = a3 < 0), n3 === a3 < 0 ? (r3 && i3.push(r3), r3 = [t3[s3]]) : r3.push(t3[s3]));
              }
              return r3 && i3.push(r3), i3;
            }(l2), n2 = 0;n2 < l2.length; n2++)
              for (i2 = 0;i2 < l2[n2].length; i2++)
                c2(l2[n2][i2]);
        }
        l2.length === 1 ? l2 = l2[0] : u5 = "Multi" + u5;
        var p2 = { type: "Feature", geometry: { type: u5, coordinates: l2 }, properties: this.properties };
        return "id" in this && (p2.id = this.id), p2;
      };
      var vl = yl, bl = wl;
      function wl(t2, e2) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(_l, this, e2), this.length = this._features.length;
      }
      function _l(t2, e2, r2) {
        t2 === 15 ? e2.version = r2.readVarint() : t2 === 1 ? e2.name = r2.readString() : t2 === 5 ? e2.extent = r2.readVarint() : t2 === 2 ? e2._features.push(r2.pos) : t2 === 3 ? e2._keys.push(r2.readString()) : t2 === 4 && e2._values.push(function(t3) {
          for (var e3 = null, r3 = t3.readVarint() + t3.pos;t3.pos < r3; ) {
            var n2 = t3.readVarint() >> 3;
            e3 = n2 === 1 ? t3.readString() : n2 === 2 ? t3.readFloat() : n2 === 3 ? t3.readDouble() : n2 === 4 ? t3.readVarint64() : n2 === 5 ? t3.readVarint() : n2 === 6 ? t3.readSVarint() : n2 === 7 ? t3.readBoolean() : null;
          }
          return e3;
        }(r2));
      }
      wl.prototype.feature = function(t2) {
        if (t2 < 0 || t2 >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[t2];
        var e2 = this._pbf.readVarint() + this._pbf.pos;
        return new vl(this._pbf, e2, this.extent, this._keys, this._values);
      };
      var Al = bl;
      function Sl(t2, e2, r2) {
        if (t2 === 3) {
          var n2 = new Al(r2, r2.readVarint() + r2.pos);
          n2.length && (e2[n2.name] = n2);
        }
      }
      fl.VectorTile = function(t2, e2) {
        this.layers = t2.readFields(Sl, {}, e2);
      }, fl.VectorTileFeature = yl, fl.VectorTileLayer = bl;
      const kl = fl.VectorTileFeature.types, Ml = Math.pow(2, 13);
      function Il(t2, e2, r2, n2, i2, s2, a2, o2) {
        t2.emplaceBack(e2, r2, 2 * Math.floor(n2 * Ml) + a2, i2 * Ml * 2, s2 * Ml * 2, Math.round(o2));
      }

      class zl {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Xs, this.centroidVertexArray = new Zs, this.indexArray = new na, this.programConfigurations = new Ea(t2.layers, t2.zoom), this.segments = new oa, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          this.features = [], this.hasPattern = nl("fill-extrusion", this.layers, e2);
          for (const { feature: n2, id: i2, index: s2, sourceLayerIndex: a2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, o2 = ja(n2, t3);
            if (!this.layers[0]._featureFilter.filter(new Ui(this.zoom), o2, r2))
              continue;
            const l2 = { id: i2, sourceLayerIndex: a2, index: s2, geometry: t3 ? o2.geometry : Oa(n2), properties: n2.properties, type: n2.type, patterns: {} };
            this.hasPattern ? this.features.push(il("fill-extrusion", this.layers, l2, this.zoom, e2)) : this.addFeature(l2, l2.geometry, s2, r2, {}), e2.featureIndex.insert(n2, l2.geometry, s2, a2, this.index, true);
          }
        }
        addFeatures(t2, e2, r2) {
          for (const t3 of this.features) {
            const { geometry: n2 } = t3;
            this.addFeature(t3, n2, t3.index, e2, r2);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, pl), this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, hl.members, true), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(t2, e2, r2, n2, i2) {
          for (const r3 of xr(e2, 500)) {
            const e3 = { x: 0, y: 0, vertexCount: 0 };
            let n3 = 0;
            for (const t3 of r3)
              n3 += t3.length;
            let i3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const t3 of r3) {
              if (t3.length === 0)
                continue;
              if (Cl(t3))
                continue;
              let r4 = 0;
              for (let n4 = 0;n4 < t3.length; n4++) {
                const s3 = t3[n4];
                if (n4 >= 1) {
                  const a3 = t3[n4 - 1];
                  if (!Pl(s3, a3)) {
                    i3.vertexLength + 4 > oa.MAX_VERTEX_ARRAY_LENGTH && (i3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const t4 = s3.sub(a3)._perp()._unit(), n5 = a3.dist(s3);
                    r4 + n5 > 32768 && (r4 = 0), Il(this.layoutVertexArray, s3.x, s3.y, t4.x, t4.y, 0, 0, r4), Il(this.layoutVertexArray, s3.x, s3.y, t4.x, t4.y, 0, 1, r4), e3.x += 2 * s3.x, e3.y += 2 * s3.y, e3.vertexCount += 2, r4 += n5, Il(this.layoutVertexArray, a3.x, a3.y, t4.x, t4.y, 0, 0, r4), Il(this.layoutVertexArray, a3.x, a3.y, t4.x, t4.y, 0, 1, r4), e3.x += 2 * a3.x, e3.y += 2 * a3.y, e3.vertexCount += 2;
                    const o3 = i3.vertexLength;
                    this.indexArray.emplaceBack(o3, o3 + 2, o3 + 1), this.indexArray.emplaceBack(o3 + 1, o3 + 2, o3 + 3), i3.vertexLength += 4, i3.primitiveLength += 2;
                  }
                }
              }
            }
            if (i3.vertexLength + n3 > oa.MAX_VERTEX_ARRAY_LENGTH && (i3 = this.segments.prepareSegment(n3, this.layoutVertexArray, this.indexArray)), kl[t2.type] !== "Polygon")
              continue;
            const s2 = [], a2 = [], o2 = i3.vertexLength;
            for (const t3 of r3)
              if (t3.length !== 0) {
                t3 !== r3[0] && a2.push(s2.length / 2);
                for (let r4 = 0;r4 < t3.length; r4++) {
                  const n4 = t3[r4];
                  Il(this.layoutVertexArray, n4.x, n4.y, 0, 0, 1, 1, 0), e3.x += n4.x, e3.y += n4.y, e3.vertexCount += 1, s2.push(n4.x), s2.push(n4.y);
                }
              }
            const l2 = Vo(s2, a2);
            for (let t3 = 0;t3 < l2.length; t3 += 3)
              this.indexArray.emplaceBack(o2 + l2[t3], o2 + l2[t3 + 2], o2 + l2[t3 + 1]);
            i3.primitiveLength += l2.length / 3, i3.vertexLength += n3;
            for (let t3 = 0;t3 < e3.vertexCount; t3++) {
              const t4 = Math.floor(e3.x / e3.vertexCount), r4 = Math.floor(e3.y / e3.vertexCount);
              this.centroidVertexArray.emplaceBack(t4, r4);
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
        }
      }
      function Pl(t2, e2) {
        return t2.x === e2.x && (t2.x < 0 || t2.x > $a) || t2.y === e2.y && (t2.y < 0 || t2.y > $a);
      }
      function Cl(t2) {
        return t2.every((t3) => t3.x < 0) || t2.every((t3) => t3.x > $a) || t2.every((t3) => t3.y < 0) || t2.every((t3) => t3.y > $a);
      }
      let Bl;
      wi("FillExtrusionBucket", zl, { omit: ["layers", "features"] });
      var Vl = { get paint() {
        return Bl = Bl || new rs({ "fill-extrusion-opacity": new Ji(G["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Wi(G["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Ji(G["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Ji(G["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new Qi(G["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Wi(G["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Wi(G["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new Ji(G["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
      } };

      class El extends is {
        constructor(t2) {
          super(t2, Vl);
        }
        createBucket(t2) {
          return new zl(t2);
        }
        queryRadius() {
          return eo(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return true;
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, a2, o2, l2) {
          const u5 = ro(t2, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a2.angle, o2), c2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), h2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), p2 = function(t3, e3, r3, n3) {
            const i3 = [];
            for (const r4 of t3) {
              const t4 = [r4.x, r4.y, 0, 1];
              po(t4, t4, e3), i3.push(new s(t4[0] / t4[3], t4[1] / t4[3]));
            }
            return i3;
          }(u5, l2), f2 = function(t3, e3, r3, n3) {
            const i3 = [], a3 = [], o3 = n3[8] * e3, l3 = n3[9] * e3, u6 = n3[10] * e3, c3 = n3[11] * e3, h3 = n3[8] * r3, p3 = n3[9] * r3, f3 = n3[10] * r3, d2 = n3[11] * r3;
            for (const e4 of t3) {
              const t4 = [], r4 = [];
              for (const i4 of e4) {
                const { x: e5, y: a4 } = i4, y2 = n3[0] * e5 + n3[4] * a4 + n3[12], m2 = n3[1] * e5 + n3[5] * a4 + n3[13], g2 = n3[2] * e5 + n3[6] * a4 + n3[14], x2 = n3[3] * e5 + n3[7] * a4 + n3[15], v3 = g2 + u6, b2 = x2 + c3, w2 = y2 + h3, _2 = m2 + p3, A2 = g2 + f3, S2 = x2 + d2, k2 = new s((y2 + o3) / b2, (m2 + l3) / b2);
                k2.z = v3 / b2, t4.push(k2);
                const M2 = new s(w2 / S2, _2 / S2);
                M2.z = A2 / S2, r4.push(M2);
              }
              i3.push(t4), a3.push(r4);
            }
            return [i3, a3];
          }(n2, h2, c2, l2);
          return function(t3, e3, r3) {
            let n3 = 1 / 0;
            Za(r3, e3) && (n3 = Tl(r3, e3[0]));
            for (let i3 = 0;i3 < e3.length; i3++) {
              const s2 = e3[i3], a3 = t3[i3];
              for (let t4 = 0;t4 < s2.length - 1; t4++) {
                const e4 = s2[t4], i4 = [e4, s2[t4 + 1], a3[t4 + 1], a3[t4], e4];
                qa(r3, i4) && (n3 = Math.min(n3, Tl(r3, i4)));
              }
            }
            return n3 !== 1 / 0 && n3;
          }(f2[0], f2[1], p2);
        }
      }
      function Fl(t2, e2) {
        return t2.x * e2.x + t2.y * e2.y;
      }
      function Tl(t2, e2) {
        if (t2.length === 1) {
          let r2 = 0;
          const n2 = e2[r2++];
          let i2;
          for (;!i2 || n2.equals(i2); )
            if (i2 = e2[r2++], !i2)
              return 1 / 0;
          for (;r2 < e2.length; r2++) {
            const s2 = e2[r2], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u5 = a2.sub(n2), c2 = Fl(o2, o2), h2 = Fl(o2, l2), p2 = Fl(l2, l2), f2 = Fl(u5, o2), d2 = Fl(u5, l2), y2 = c2 * p2 - h2 * h2, m2 = (p2 * f2 - h2 * d2) / y2, g2 = (c2 * d2 - h2 * f2) / y2, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
            if (isFinite(x2))
              return x2;
          }
          return 1 / 0;
        }
        {
          let t3 = 1 / 0;
          for (const r2 of e2)
            t3 = Math.min(t3, r2.z);
          return t3;
        }
      }
      const $l = ls([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: Ll } = $l, Dl = ls([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: Ol } = Dl, jl = fl.VectorTileFeature.types, Rl = Math.cos(Math.PI / 180 * 37.5), Ul = Math.pow(2, 14) / 0.5;

      class ql {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
            this.gradients[t3.id] = {};
          }), this.layoutVertexArray = new Hs, this.layoutVertexArray2 = new Ys, this.indexArray = new na, this.programConfigurations = new Ea(t2.layers, t2.zoom), this.segments = new oa, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          this.hasPattern = nl("line", this.layers, e2);
          const n2 = this.layers[0].layout.get("line-sort-key"), i2 = !n2.isConstant(), s2 = [];
          for (const { feature: e3, id: a2, index: o2, sourceLayerIndex: l2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u5 = ja(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new Ui(this.zoom), u5, r2))
              continue;
            const c2 = i2 ? n2.evaluate(u5, {}, r2) : undefined, h2 = { id: a2, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: o2, geometry: t3 ? u5.geometry : Oa(e3), patterns: {}, sortKey: c2 };
            s2.push(h2);
          }
          i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
            if (this.hasPattern) {
              const t3 = il("line", this.layers, n3, this.zoom, e2);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, s3, r2, {});
            e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        addFeatures(t2, e2, r2) {
          for (const t3 of this.patternFeatures)
            this.addFeature(t3, t3.geometry, t3.index, e2, r2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Ol)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ll), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t2) {
          if (t2.properties && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_end"))
            return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
        }
        addFeature(t2, e2, r2, n2, i2) {
          const s2 = this.layers[0].layout, a2 = s2.get("line-join").evaluate(t2, {}), o2 = s2.get("line-cap"), l2 = s2.get("line-miter-limit"), u5 = s2.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t2);
          for (const r3 of e2)
            this.addLine(r3, t2, a2, o2, l2, u5);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
        }
        addLine(t2, e2, r2, n2, i2, s2) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let e3 = 0;e3 < t2.length - 1; e3++)
              this.totalDistance += t2[e3].dist(t2[e3 + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const a2 = jl[e2.type] === "Polygon";
          let o2 = t2.length;
          for (;o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); )
            o2--;
          let l2 = 0;
          for (;l2 < o2 - 1 && t2[l2].equals(t2[l2 + 1]); )
            l2++;
          if (o2 < (a2 ? 3 : 2))
            return;
          r2 === "bevel" && (i2 = 1.05);
          const u5 = this.overscaling <= 16 ? 15 * $a / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
          let h2, p2, f2, d2, y2;
          this.e1 = this.e2 = -1, a2 && (h2 = t2[o2 - 2], y2 = t2[l2].sub(h2)._unit()._perp());
          for (let e3 = l2;e3 < o2; e3++) {
            if (f2 = e3 === o2 - 1 ? a2 ? t2[l2 + 1] : undefined : t2[e3 + 1], f2 && t2[e3].equals(f2))
              continue;
            y2 && (d2 = y2), h2 && (p2 = h2), h2 = t2[e3], y2 = f2 ? f2.sub(h2)._unit()._perp() : d2, d2 = d2 || y2;
            let m2 = d2.add(y2);
            m2.x === 0 && m2.y === 0 || m2._unit();
            const g2 = d2.x * y2.x + d2.y * y2.y, x2 = m2.x * y2.x + m2.y * y2.y, v3 = x2 !== 0 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < Rl && p2 && f2, _2 = d2.x * y2.y - d2.y * y2.x > 0;
            if (w2 && e3 > l2) {
              const t3 = h2.dist(p2);
              if (t3 > 2 * u5) {
                const e4 = h2.sub(h2.sub(p2)._mult(u5 / t3)._round());
                this.updateDistance(p2, e4), this.addCurrentVertex(e4, d2, 0, 0, c2), p2 = e4;
              }
            }
            const A2 = p2 && f2;
            let S2 = A2 ? r2 : a2 ? "butt" : n2;
            if (A2 && S2 === "round" && (v3 < s2 ? S2 = "miter" : v3 <= 2 && (S2 = "fakeround")), S2 === "miter" && v3 > i2 && (S2 = "bevel"), S2 === "bevel" && (v3 > 2 && (S2 = "flipbevel"), v3 < i2 && (S2 = "miter")), p2 && this.updateDistance(p2, h2), S2 === "miter")
              m2._mult(v3), this.addCurrentVertex(h2, m2, 0, 0, c2);
            else if (S2 === "flipbevel") {
              if (v3 > 100)
                m2 = y2.mult(-1);
              else {
                const t3 = v3 * d2.add(y2).mag() / d2.sub(y2).mag();
                m2._perp()._mult(t3 * (_2 ? -1 : 1));
              }
              this.addCurrentVertex(h2, m2, 0, 0, c2), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c2);
            } else if (S2 === "bevel" || S2 === "fakeround") {
              const t3 = -Math.sqrt(v3 * v3 - 1), e4 = _2 ? t3 : 0, r3 = _2 ? 0 : t3;
              if (p2 && this.addCurrentVertex(h2, d2, e4, r3, c2), S2 === "fakeround") {
                const t4 = Math.round(180 * b2 / Math.PI / 20);
                for (let e5 = 1;e5 < t4; e5++) {
                  let r4 = e5 / t4;
                  if (r4 !== 0.5) {
                    const t5 = r4 - 0.5;
                    r4 += r4 * t5 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                  }
                  const n3 = y2.sub(d2)._mult(r4)._add(d2)._unit()._mult(_2 ? -1 : 1);
                  this.addHalfVertex(h2, n3.x, n3.y, false, _2, 0, c2);
                }
              }
              f2 && this.addCurrentVertex(h2, y2, -e4, -r3, c2);
            } else if (S2 === "butt")
              this.addCurrentVertex(h2, m2, 0, 0, c2);
            else if (S2 === "square") {
              const t3 = p2 ? 1 : -1;
              this.addCurrentVertex(h2, m2, t3, t3, c2);
            } else
              S2 === "round" && (p2 && (this.addCurrentVertex(h2, d2, 0, 0, c2), this.addCurrentVertex(h2, d2, 1, 1, c2, true)), f2 && (this.addCurrentVertex(h2, y2, -1, -1, c2, true), this.addCurrentVertex(h2, y2, 0, 0, c2)));
            if (w2 && e3 < o2 - 1) {
              const t3 = h2.dist(f2);
              if (t3 > 2 * u5) {
                const e4 = h2.add(f2.sub(h2)._mult(u5 / t3)._round());
                this.updateDistance(h2, e4), this.addCurrentVertex(e4, y2, 0, 0, c2), h2 = e4;
              }
            }
          }
        }
        addCurrentVertex(t2, e2, r2, n2, i2, s2 = false) {
          const a2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
          this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, s2, false, r2, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2), this.distance > Ul / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t2, e2, r2, n2, i2, s2));
        }
        addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, a2, o2) {
          const l2 = 0.5 * (this.lineClips ? this.scaledDistance * (Ul - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (a2 === 0 ? 0 : a2 < 0 ? -1 : 1) | (63 & l2) << 2, l2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const u5 = o2.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u5), o2.primitiveLength++), s2 ? this.e2 = u5 : this.e1 = u5;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(t2, e2) {
          this.distance += t2.dist(e2), this.updateScaledDistance();
        }
      }
      let Nl, Zl;
      wi("LineBucket", ql, { omit: ["layers", "patternFeatures"] });
      var Gl = { get paint() {
        return Zl = Zl || new rs({ "line-opacity": new Wi(G.paint_line["line-opacity"]), "line-color": new Wi(G.paint_line["line-color"]), "line-translate": new Ji(G.paint_line["line-translate"]), "line-translate-anchor": new Ji(G.paint_line["line-translate-anchor"]), "line-width": new Wi(G.paint_line["line-width"]), "line-gap-width": new Wi(G.paint_line["line-gap-width"]), "line-offset": new Wi(G.paint_line["line-offset"]), "line-blur": new Wi(G.paint_line["line-blur"]), "line-dasharray": new ts(G.paint_line["line-dasharray"]), "line-pattern": new Qi(G.paint_line["line-pattern"]), "line-gradient": new es(G.paint_line["line-gradient"]) });
      }, get layout() {
        return Nl = Nl || new rs({ "line-cap": new Ji(G.layout_line["line-cap"]), "line-join": new Wi(G.layout_line["line-join"]), "line-miter-limit": new Ji(G.layout_line["line-miter-limit"]), "line-round-limit": new Ji(G.layout_line["line-round-limit"]), "line-sort-key": new Wi(G.layout_line["line-sort-key"]) });
      } };

      class Kl extends Wi {
        possiblyEvaluate(t2, e2) {
          return e2 = new Ui(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, zoomHistory: e2.zoomHistory, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
        }
        evaluate(t2, e2, r2, n2) {
          return e2 = g({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
        }
      }
      let Xl;

      class Hl extends is {
        constructor(t2) {
          super(t2, Gl), this.gradientVersion = 0, Xl || (Xl = new Kl(Gl.paint.properties["line-width"].specification), Xl.useIntegerZoom = true);
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          if (t2 === "line-gradient") {
            const t3 = this.gradientExpression();
            this.stepInterpolant = !!function(t4) {
              return t4._styleExpression !== undefined;
            }(t3) && t3._styleExpression.expression instanceof Ae, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(t2, e2) {
          super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = Xl.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
        }
        createBucket(t2) {
          return new ql(t2);
        }
        queryRadius(t2) {
          const e2 = t2, r2 = Yl(to("line-width", this, e2), to("line-gap-width", this, e2)), n2 = to("line-offset", this, e2);
          return r2 / 2 + Math.abs(n2) + eo(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, a2, o2) {
          const l2 = ro(t2, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a2.angle, o2), u5 = o2 / 2 * Yl(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), c2 = this.paint.get("line-offset").evaluate(e2, r2);
          return c2 && (n2 = function(t3, e3) {
            const r3 = [];
            for (let n3 = 0;n3 < t3.length; n3++) {
              const i3 = t3[n3], a3 = [];
              for (let t4 = 0;t4 < i3.length; t4++) {
                const r4 = i3[t4 - 1], n4 = i3[t4], o3 = i3[t4 + 1], l3 = t4 === 0 ? new s(0, 0) : n4.sub(r4)._unit()._perp(), u6 = t4 === i3.length - 1 ? new s(0, 0) : o3.sub(n4)._unit()._perp(), c3 = l3._add(u6)._unit(), h2 = c3.x * u6.x + c3.y * u6.y;
                h2 !== 0 && c3._mult(1 / h2), a3.push(c3._mult(e3)._add(n4));
              }
              r3.push(a3);
            }
            return r3;
          }(n2, c2 * o2)), function(t3, e3, r3) {
            for (let n3 = 0;n3 < e3.length; n3++) {
              const i3 = e3[n3];
              if (t3.length >= 3) {
                for (let e4 = 0;e4 < i3.length; e4++)
                  if (Wa(t3, i3[e4]))
                    return true;
              }
              if (Ga(t3, i3, r3))
                return true;
            }
            return false;
          }(l2, n2, u5);
        }
        isTileClipped() {
          return true;
        }
      }
      function Yl(t2, e2) {
        return e2 > 0 ? e2 + 2 * t2 : t2;
      }
      const Jl = ls([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Wl = ls([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      ls([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const Ql = ls([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
      ls([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const tu = ls([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), eu = ls([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function ru(t2, e2, r2) {
        return t2.sections.forEach((t3) => {
          t3.text = function(t4, e3, r3) {
            const n2 = e3.layout.get("text-transform").evaluate(r3, {});
            return n2 === "uppercase" ? t4 = t4.toLocaleUpperCase() : n2 === "lowercase" && (t4 = t4.toLocaleLowerCase()), Ri.applyArabicShaping && (t4 = Ri.applyArabicShaping(t4)), t4;
          }(t3.text, e2, r2);
        }), t2;
      }
      ls([{ name: "triangle", components: 3, type: "Uint16" }]), ls([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), ls([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), ls([{ type: "Float32", name: "offsetX" }]), ls([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), ls([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
      const nu = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
      var iu = 24, su = lu, au = function(t2, e2, r2, n2, i2) {
        var s2, a2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u5 = l2 >> 1, c2 = -7, h2 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e2 + h2];
        for (h2 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2;c2 > 0; s2 = 256 * s2 + t2[e2 + h2], h2 += p2, c2 -= 8)
          ;
        for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2;c2 > 0; a2 = 256 * a2 + t2[e2 + h2], h2 += p2, c2 -= 8)
          ;
        if (s2 === 0)
          s2 = 1 - u5;
        else {
          if (s2 === l2)
            return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
          a2 += Math.pow(2, n2), s2 -= u5;
        }
        return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
      }, ou = function(t2, e2, r2, n2, i2, s2) {
        var a2, o2, l2, u5 = 8 * s2 - i2 - 1, c2 = (1 << u5) - 1, h2 = c2 >> 1, p2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, y2 = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0;
        for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e2 += a2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h2 >= c2 ? (o2 = 0, a2 = c2) : a2 + h2 >= 1 ? (o2 = (e2 * l2 - 1) * Math.pow(2, i2), a2 += h2) : (o2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i2), a2 = 0));i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8)
          ;
        for (a2 = a2 << i2 | o2, u5 += i2;u5 > 0; t2[r2 + f2] = 255 & a2, f2 += d2, a2 /= 256, u5 -= 8)
          ;
        t2[r2 + f2 - d2] |= 128 * y2;
      };
      function lu(t2) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      lu.Varint = 0, lu.Fixed64 = 1, lu.Bytes = 2, lu.Fixed32 = 5;
      var uu = 4294967296, cu = 1 / uu, hu = typeof TextDecoder == "undefined" ? null : new TextDecoder("utf-8");
      function pu(t2) {
        return t2.type === lu.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
      }
      function fu(t2, e2, r2) {
        return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
      }
      function du(t2, e2, r2) {
        var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
        r2.realloc(n2);
        for (var i2 = r2.pos - 1;i2 >= t2; i2--)
          r2.buf[i2 + n2] = r2.buf[i2];
      }
      function yu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeVarint(t2[r2]);
      }
      function mu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeSVarint(t2[r2]);
      }
      function gu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeFloat(t2[r2]);
      }
      function xu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeDouble(t2[r2]);
      }
      function vu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeBoolean(t2[r2]);
      }
      function bu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeFixed32(t2[r2]);
      }
      function wu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeSFixed32(t2[r2]);
      }
      function _u(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeFixed64(t2[r2]);
      }
      function Au(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeSFixed64(t2[r2]);
      }
      function Su(t2, e2) {
        return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
      }
      function ku(t2, e2, r2) {
        t2[r2] = e2, t2[r2 + 1] = e2 >>> 8, t2[r2 + 2] = e2 >>> 16, t2[r2 + 3] = e2 >>> 24;
      }
      function Mu(t2, e2) {
        return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
      }
      lu.prototype = { destroy: function() {
        this.buf = null;
      }, readFields: function(t2, e2, r2) {
        for (r2 = r2 || this.length;this.pos < r2; ) {
          var n2 = this.readVarint(), i2 = n2 >> 3, s2 = this.pos;
          this.type = 7 & n2, t2(i2, e2, this), this.pos === s2 && this.skip(n2);
        }
        return e2;
      }, readMessage: function(t2, e2) {
        return this.readFields(t2, e2, this.readVarint() + this.pos);
      }, readFixed32: function() {
        var t2 = Su(this.buf, this.pos);
        return this.pos += 4, t2;
      }, readSFixed32: function() {
        var t2 = Mu(this.buf, this.pos);
        return this.pos += 4, t2;
      }, readFixed64: function() {
        var t2 = Su(this.buf, this.pos) + Su(this.buf, this.pos + 4) * uu;
        return this.pos += 8, t2;
      }, readSFixed64: function() {
        var t2 = Su(this.buf, this.pos) + Mu(this.buf, this.pos + 4) * uu;
        return this.pos += 8, t2;
      }, readFloat: function() {
        var t2 = au(this.buf, this.pos, true, 23, 4);
        return this.pos += 4, t2;
      }, readDouble: function() {
        var t2 = au(this.buf, this.pos, true, 52, 8);
        return this.pos += 8, t2;
      }, readVarint: function(t2) {
        var e2, r2, n2 = this.buf;
        return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t3, e3, r3) {
          var n3, i2, s2 = r3.buf;
          if (n3 = (112 & (i2 = s2[r3.pos++])) >> 4, i2 < 128)
            return fu(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 3, i2 < 128)
            return fu(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 10, i2 < 128)
            return fu(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 17, i2 < 128)
            return fu(t3, n3, e3);
          if (n3 |= (127 & (i2 = s2[r3.pos++])) << 24, i2 < 128)
            return fu(t3, n3, e3);
          if (n3 |= (1 & (i2 = s2[r3.pos++])) << 31, i2 < 128)
            return fu(t3, n3, e3);
          throw new Error("Expected varint not more than 10 bytes");
        }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
      }, readVarint64: function() {
        return this.readVarint(true);
      }, readSVarint: function() {
        var t2 = this.readVarint();
        return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
      }, readBoolean: function() {
        return Boolean(this.readVarint());
      }, readString: function() {
        var t2 = this.readVarint() + this.pos, e2 = this.pos;
        return this.pos = t2, t2 - e2 >= 12 && hu ? function(t3, e3, r2) {
          return hu.decode(t3.subarray(e3, r2));
        }(this.buf, e2, t2) : function(t3, e3, r2) {
          for (var n2 = "", i2 = e3;i2 < r2; ) {
            var s2, a2, o2, l2 = t3[i2], u5 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
            if (i2 + c2 > r2)
              break;
            c2 === 1 ? l2 < 128 && (u5 = l2) : c2 === 2 ? (192 & (s2 = t3[i2 + 1])) == 128 && (u5 = (31 & l2) << 6 | 63 & s2) <= 127 && (u5 = null) : c2 === 3 ? (a2 = t3[i2 + 2], (192 & (s2 = t3[i2 + 1])) == 128 && (192 & a2) == 128 && ((u5 = (15 & l2) << 12 | (63 & s2) << 6 | 63 & a2) <= 2047 || u5 >= 55296 && u5 <= 57343) && (u5 = null)) : c2 === 4 && (a2 = t3[i2 + 2], o2 = t3[i2 + 3], (192 & (s2 = t3[i2 + 1])) == 128 && (192 & a2) == 128 && (192 & o2) == 128 && ((u5 = (15 & l2) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u5 >= 1114112) && (u5 = null)), u5 === null ? (u5 = 65533, c2 = 1) : u5 > 65535 && (u5 -= 65536, n2 += String.fromCharCode(u5 >>> 10 & 1023 | 55296), u5 = 56320 | 1023 & u5), n2 += String.fromCharCode(u5), i2 += c2;
          }
          return n2;
        }(this.buf, e2, t2);
      }, readBytes: function() {
        var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
        return this.pos = t2, e2;
      }, readPackedVarint: function(t2, e2) {
        if (this.type !== lu.Bytes)
          return t2.push(this.readVarint(e2));
        var r2 = pu(this);
        for (t2 = t2 || [];this.pos < r2; )
          t2.push(this.readVarint(e2));
        return t2;
      }, readPackedSVarint: function(t2) {
        if (this.type !== lu.Bytes)
          return t2.push(this.readSVarint());
        var e2 = pu(this);
        for (t2 = t2 || [];this.pos < e2; )
          t2.push(this.readSVarint());
        return t2;
      }, readPackedBoolean: function(t2) {
        if (this.type !== lu.Bytes)
          return t2.push(this.readBoolean());
        var e2 = pu(this);
        for (t2 = t2 || [];this.pos < e2; )
          t2.push(this.readBoolean());
        return t2;
      }, readPackedFloat: function(t2) {
        if (this.type !== lu.Bytes)
          return t2.push(this.readFloat());
        var e2 = pu(this);
        for (t2 = t2 || [];this.pos < e2; )
          t2.push(this.readFloat());
        return t2;
      }, readPackedDouble: function(t2) {
        if (this.type !== lu.Bytes)
          return t2.push(this.readDouble());
        var e2 = pu(this);
        for (t2 = t2 || [];this.pos < e2; )
          t2.push(this.readDouble());
        return t2;
      }, readPackedFixed32: function(t2) {
        if (this.type !== lu.Bytes)
          return t2.push(this.readFixed32());
        var e2 = pu(this);
        for (t2 = t2 || [];this.pos < e2; )
          t2.push(this.readFixed32());
        return t2;
      }, readPackedSFixed32: function(t2) {
        if (this.type !== lu.Bytes)
          return t2.push(this.readSFixed32());
        var e2 = pu(this);
        for (t2 = t2 || [];this.pos < e2; )
          t2.push(this.readSFixed32());
        return t2;
      }, readPackedFixed64: function(t2) {
        if (this.type !== lu.Bytes)
          return t2.push(this.readFixed64());
        var e2 = pu(this);
        for (t2 = t2 || [];this.pos < e2; )
          t2.push(this.readFixed64());
        return t2;
      }, readPackedSFixed64: function(t2) {
        if (this.type !== lu.Bytes)
          return t2.push(this.readSFixed64());
        var e2 = pu(this);
        for (t2 = t2 || [];this.pos < e2; )
          t2.push(this.readSFixed64());
        return t2;
      }, skip: function(t2) {
        var e2 = 7 & t2;
        if (e2 === lu.Varint)
          for (;this.buf[this.pos++] > 127; )
            ;
        else if (e2 === lu.Bytes)
          this.pos = this.readVarint() + this.pos;
        else if (e2 === lu.Fixed32)
          this.pos += 4;
        else {
          if (e2 !== lu.Fixed64)
            throw new Error("Unimplemented type: " + e2);
          this.pos += 8;
        }
      }, writeTag: function(t2, e2) {
        this.writeVarint(t2 << 3 | e2);
      }, realloc: function(t2) {
        for (var e2 = this.length || 16;e2 < this.pos + t2; )
          e2 *= 2;
        if (e2 !== this.length) {
          var r2 = new Uint8Array(e2);
          r2.set(this.buf), this.buf = r2, this.length = e2;
        }
      }, finish: function() {
        return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
      }, writeFixed32: function(t2) {
        this.realloc(4), ku(this.buf, t2, this.pos), this.pos += 4;
      }, writeSFixed32: function(t2) {
        this.realloc(4), ku(this.buf, t2, this.pos), this.pos += 4;
      }, writeFixed64: function(t2) {
        this.realloc(8), ku(this.buf, -1 & t2, this.pos), ku(this.buf, Math.floor(t2 * cu), this.pos + 4), this.pos += 8;
      }, writeSFixed64: function(t2) {
        this.realloc(8), ku(this.buf, -1 & t2, this.pos), ku(this.buf, Math.floor(t2 * cu), this.pos + 4), this.pos += 8;
      }, writeVarint: function(t2) {
        (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
          var r2, n2;
          if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552000 || t3 < -18446744073709552000)
            throw new Error("Given varint doesn't fit into 10 bytes");
          e2.realloc(10), function(t4, e3, r3) {
            r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
          }(r2, 0, e2), function(t4, e3) {
            var r3 = (7 & t4) << 4;
            e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
          }(n2, e2);
        }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
      }, writeSVarint: function(t2) {
        this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
      }, writeBoolean: function(t2) {
        this.writeVarint(Boolean(t2));
      }, writeString: function(t2) {
        t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
        var e2 = this.pos;
        this.pos = function(t3, e3, r3) {
          for (var n2, i2, s2 = 0;s2 < e3.length; s2++) {
            if ((n2 = e3.charCodeAt(s2)) > 55295 && n2 < 57344) {
              if (!i2) {
                n2 > 56319 || s2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                continue;
              }
              if (n2 < 56320) {
                t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                continue;
              }
              n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
            } else
              i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
            n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
          }
          return r3;
        }(this.buf, t2, this.pos);
        var r2 = this.pos - e2;
        r2 >= 128 && du(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
      }, writeFloat: function(t2) {
        this.realloc(4), ou(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
      }, writeDouble: function(t2) {
        this.realloc(8), ou(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
      }, writeBytes: function(t2) {
        var e2 = t2.length;
        this.writeVarint(e2), this.realloc(e2);
        for (var r2 = 0;r2 < e2; r2++)
          this.buf[this.pos++] = t2[r2];
      }, writeRawMessage: function(t2, e2) {
        this.pos++;
        var r2 = this.pos;
        t2(e2, this);
        var n2 = this.pos - r2;
        n2 >= 128 && du(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
      }, writeMessage: function(t2, e2, r2) {
        this.writeTag(t2, lu.Bytes), this.writeRawMessage(e2, r2);
      }, writePackedVarint: function(t2, e2) {
        e2.length && this.writeMessage(t2, yu, e2);
      }, writePackedSVarint: function(t2, e2) {
        e2.length && this.writeMessage(t2, mu, e2);
      }, writePackedBoolean: function(t2, e2) {
        e2.length && this.writeMessage(t2, vu, e2);
      }, writePackedFloat: function(t2, e2) {
        e2.length && this.writeMessage(t2, gu, e2);
      }, writePackedDouble: function(t2, e2) {
        e2.length && this.writeMessage(t2, xu, e2);
      }, writePackedFixed32: function(t2, e2) {
        e2.length && this.writeMessage(t2, bu, e2);
      }, writePackedSFixed32: function(t2, e2) {
        e2.length && this.writeMessage(t2, wu, e2);
      }, writePackedFixed64: function(t2, e2) {
        e2.length && this.writeMessage(t2, _u, e2);
      }, writePackedSFixed64: function(t2, e2) {
        e2.length && this.writeMessage(t2, Au, e2);
      }, writeBytesField: function(t2, e2) {
        this.writeTag(t2, lu.Bytes), this.writeBytes(e2);
      }, writeFixed32Field: function(t2, e2) {
        this.writeTag(t2, lu.Fixed32), this.writeFixed32(e2);
      }, writeSFixed32Field: function(t2, e2) {
        this.writeTag(t2, lu.Fixed32), this.writeSFixed32(e2);
      }, writeFixed64Field: function(t2, e2) {
        this.writeTag(t2, lu.Fixed64), this.writeFixed64(e2);
      }, writeSFixed64Field: function(t2, e2) {
        this.writeTag(t2, lu.Fixed64), this.writeSFixed64(e2);
      }, writeVarintField: function(t2, e2) {
        this.writeTag(t2, lu.Varint), this.writeVarint(e2);
      }, writeSVarintField: function(t2, e2) {
        this.writeTag(t2, lu.Varint), this.writeSVarint(e2);
      }, writeStringField: function(t2, e2) {
        this.writeTag(t2, lu.Bytes), this.writeString(e2);
      }, writeFloatField: function(t2, e2) {
        this.writeTag(t2, lu.Fixed32), this.writeFloat(e2);
      }, writeDoubleField: function(t2, e2) {
        this.writeTag(t2, lu.Fixed64), this.writeDouble(e2);
      }, writeBooleanField: function(t2, e2) {
        this.writeVarintField(t2, Boolean(e2));
      } };
      var Iu = r(su);
      const zu = 3;
      function Pu(t2, e2, r2) {
        t2 === 1 && r2.readMessage(Cu, e2);
      }
      function Cu(t2, e2, r2) {
        if (t2 === 3) {
          const { id: t3, bitmap: n2, width: i2, height: s2, left: a2, top: o2, advance: l2 } = r2.readMessage(Bu, {});
          e2.push({ id: t3, bitmap: new _o({ width: i2 + 2 * zu, height: s2 + 2 * zu }, n2), metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 } });
        }
      }
      function Bu(t2, e2, r2) {
        t2 === 1 ? e2.id = r2.readVarint() : t2 === 2 ? e2.bitmap = r2.readBytes() : t2 === 3 ? e2.width = r2.readVarint() : t2 === 4 ? e2.height = r2.readVarint() : t2 === 5 ? e2.left = r2.readSVarint() : t2 === 6 ? e2.top = r2.readSVarint() : t2 === 7 && (e2.advance = r2.readVarint());
      }
      const Vu = zu;
      function Eu(t2) {
        let e2 = 0, r2 = 0;
        for (const n3 of t2)
          e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
        t2.sort((t3, e3) => e3.h - t3.h);
        const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
        let i2 = 0, s2 = 0;
        for (const e3 of t2)
          for (let t3 = n2.length - 1;t3 >= 0; t3--) {
            const r3 = n2[t3];
            if (!(e3.w > r3.w || e3.h > r3.h)) {
              if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                const e4 = n2.pop();
                t3 < n2.length && (n2[t3] = e4);
              } else
                e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
              break;
            }
          }
        return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
      }
      const Fu = 1;

      class Tu {
        constructor(t2, { pixelRatio: e2, version: r2, stretchX: n2, stretchY: i2, content: s2, textFitWidth: a2, textFitHeight: o2 }) {
          this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2, this.textFitWidth = a2, this.textFitHeight = o2;
        }
        get tl() {
          return [this.paddedRect.x + Fu, this.paddedRect.y + Fu];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - Fu, this.paddedRect.y + this.paddedRect.h - Fu];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * Fu) / this.pixelRatio, (this.paddedRect.h - 2 * Fu) / this.pixelRatio];
        }
      }

      class $u {
        constructor(t2, e2) {
          const r2 = {}, n2 = {};
          this.haveRenderCallbacks = [];
          const i2 = [];
          this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
          const { w: s2, h: a2 } = Eu(i2), o2 = new Ao({ width: s2 || 1, height: a2 || 1 });
          for (const e3 in t2) {
            const n3 = t2[e3], i3 = r2[e3].paddedRect;
            Ao.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + Fu, y: i3.y + Fu }, n3.data);
          }
          for (const t3 in e2) {
            const r3 = e2[t3], i3 = n2[t3].paddedRect, s3 = i3.x + Fu, a3 = i3.y + Fu, l2 = r3.data.width, u5 = r3.data.height;
            Ao.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r3.data), Ao.copy(r3.data, o2, { x: 0, y: u5 - 1 }, { x: s3, y: a3 - 1 }, { width: l2, height: 1 }), Ao.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u5 }, { width: l2, height: 1 }), Ao.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u5 }), Ao.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3 + l2, y: a3 }, { width: 1, height: u5 });
          }
          this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
        }
        addImages(t2, e2, r2) {
          for (const n2 in t2) {
            const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2 * Fu, h: i2.data.height + 2 * Fu };
            r2.push(s2), e2[n2] = new Tu(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
          }
        }
        patchUpdatedImages(t2, e2) {
          t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const r2 in t2.updatedImages)
            this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
        }
        patchUpdatedImage(t2, e2, r2) {
          if (!t2 || !e2)
            return;
          if (t2.version === e2.version)
            return;
          t2.version = e2.version;
          const [n2, i2] = t2.tl;
          r2.update(e2.data, undefined, { x: n2, y: i2 });
        }
      }
      var Lu;
      wi("ImagePosition", Tu), wi("ImageAtlas", $u), t.ah = undefined, (Lu = t.ah || (t.ah = {}))[Lu.none = 0] = "none", Lu[Lu.horizontal = 1] = "horizontal", Lu[Lu.vertical = 2] = "vertical", Lu[Lu.horizontalOnly = 3] = "horizontalOnly";
      const Du = -17;

      class Ou {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(t2, e2) {
          const r2 = new Ou;
          return r2.scale = t2 || 1, r2.fontStack = e2, r2;
        }
        static forImage(t2) {
          const e2 = new Ou;
          return e2.imageName = t2, e2;
        }
      }

      class ju {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(t2, e2) {
          const r2 = new ju;
          for (let n2 = 0;n2 < t2.sections.length; n2++) {
            const i2 = t2.sections[n2];
            i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
          }
          return r2;
        }
        length() {
          return this.text.length;
        }
        getSection(t2) {
          return this.sections[this.sectionIndex[t2]];
        }
        getSectionIndex(t2) {
          return this.sectionIndex[t2];
        }
        getCharCode(t2) {
          return this.text.charCodeAt(t2);
        }
        verticalizePunctuation() {
          this.text = function(t2) {
            let e2 = "";
            for (let r2 = 0;r2 < t2.length; r2++) {
              const n2 = t2.charCodeAt(r2 + 1) || null, i2 = t2.charCodeAt(r2 - 1) || null;
              e2 += n2 && $i(n2) && !nu[t2[r2 + 1]] || i2 && $i(i2) && !nu[t2[r2 - 1]] || !nu[t2[r2]] ? t2[r2] : nu[t2[r2]];
            }
            return e2;
          }(this.text);
        }
        trim() {
          let t2 = 0;
          for (let e3 = 0;e3 < this.text.length && Uu[this.text.charCodeAt(e3)]; e3++)
            t2++;
          let e2 = this.text.length;
          for (let r2 = this.text.length - 1;r2 >= 0 && r2 >= t2 && Uu[this.text.charCodeAt(r2)]; r2--)
            e2--;
          this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
        }
        substring(t2, e2) {
          const r2 = new ju;
          return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
        }
        addTextSection(t2, e2) {
          this.text += t2.text, this.sections.push(Ou.forText(t2.scale, t2.fontStack || e2));
          const r2 = this.sections.length - 1;
          for (let e3 = 0;e3 < t2.text.length; ++e3)
            this.sectionIndex.push(r2);
        }
        addImageSection(t2) {
          const e2 = t2.image ? t2.image.name : "";
          if (e2.length === 0)
            return void A("Can't add FormattedSection with an empty image.");
          const r2 = this.getNextImageSectionCharCode();
          r2 ? (this.text += String.fromCharCode(r2), this.sections.push(Ou.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : A("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function Ru(e2, r2, n2, i2, s2, a2, o2, l2, u5, c2, h2, p2, f2, d2, y2) {
        const m2 = ju.fromFeature(e2, s2);
        let g2;
        p2 === t.ah.vertical && m2.verticalizePunctuation();
        const { processBidirectionalText: x2, processStyledBidirectionalText: v3 } = Ri;
        if (x2 && m2.sections.length === 1) {
          g2 = [];
          const t2 = x2(m2.toString(), Yu(m2, c2, a2, r2, i2, d2));
          for (const e3 of t2) {
            const t3 = new ju;
            t3.text = e3, t3.sections = m2.sections;
            for (let r3 = 0;r3 < e3.length; r3++)
              t3.sectionIndex.push(0);
            g2.push(t3);
          }
        } else if (v3) {
          g2 = [];
          const t2 = v3(m2.text, m2.sectionIndex, Yu(m2, c2, a2, r2, i2, d2));
          for (const e3 of t2) {
            const t3 = new ju;
            t3.text = e3[0], t3.sectionIndex = e3[1], t3.sections = m2.sections, g2.push(t3);
          }
        } else
          g2 = function(t2, e3) {
            const r3 = [], n3 = t2.text;
            let i3 = 0;
            for (const n4 of e3)
              r3.push(t2.substring(i3, n4)), i3 = n4;
            return i3 < n3.length && r3.push(t2.substring(i3, n3.length)), r3;
          }(m2, Yu(m2, c2, a2, r2, i2, d2));
        const b2 = [], w2 = { positionedLines: b2, text: m2.toString(), top: h2[1], bottom: h2[1], left: h2[0], right: h2[0], writingMode: p2, iconsInText: false, verticalizable: false };
        return function(e3, r3, n3, i3, s3, a3, o3, l3, u6, c3, h3, p3) {
          let f3 = 0, d3 = Du, y3 = 0, m3 = 0;
          const g3 = l3 === "right" ? 1 : l3 === "left" ? 0 : 0.5;
          let x3 = 0;
          for (const o4 of s3) {
            o4.trim();
            const s4 = o4.getMaxScale(), l4 = (s4 - 1) * iu, b4 = { positionedGlyphs: [], lineOffset: 0 };
            e3.positionedLines[x3] = b4;
            const w4 = b4.positionedGlyphs;
            let _3 = 0;
            if (!o4.length()) {
              d3 += a3, ++x3;
              continue;
            }
            for (let a4 = 0;a4 < o4.length(); a4++) {
              const y4 = o4.getSection(a4), m4 = o4.getSectionIndex(a4), g4 = o4.getCharCode(a4);
              let x4 = 0, b5 = null, A3 = null, S2 = null, k2 = iu;
              const M2 = !(u6 === t.ah.horizontal || !h3 && !Ti(g4) || h3 && (Uu[g4] || (v4 = g4, /\p{sc=Arab}/u.test(String.fromCodePoint(v4)))));
              if (y4.imageName) {
                const t2 = i3[y4.imageName];
                if (!t2)
                  continue;
                S2 = y4.imageName, e3.iconsInText = e3.iconsInText || true, A3 = t2.paddedRect;
                const r4 = t2.displaySize;
                y4.scale = y4.scale * iu / p3, b5 = { width: r4[0], height: r4[1], left: Fu, top: -Vu, advance: M2 ? r4[1] : r4[0] }, x4 = l4 + (iu - r4[1] * y4.scale), k2 = b5.advance;
                const n4 = M2 ? r4[0] * y4.scale - iu * s4 : r4[1] * y4.scale - iu * s4;
                n4 > 0 && n4 > _3 && (_3 = n4);
              } else {
                const t2 = n3[y4.fontStack], e4 = t2 && t2[g4];
                if (e4 && e4.rect)
                  A3 = e4.rect, b5 = e4.metrics;
                else {
                  const t3 = r3[y4.fontStack], e5 = t3 && t3[g4];
                  if (!e5)
                    continue;
                  b5 = e5.metrics;
                }
                x4 = (s4 - y4.scale) * iu;
              }
              M2 ? (e3.verticalizable = true, w4.push({ glyph: g4, imageName: S2, x: f3, y: d3 + x4, vertical: M2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m4, metrics: b5, rect: A3 }), f3 += k2 * y4.scale + c3) : (w4.push({ glyph: g4, imageName: S2, x: f3, y: d3 + x4, vertical: M2, scale: y4.scale, fontStack: y4.fontStack, sectionIndex: m4, metrics: b5, rect: A3 }), f3 += b5.advance * y4.scale + c3);
            }
            w4.length !== 0 && (y3 = Math.max(f3 - c3, y3), Wu(w4, 0, w4.length - 1, g3, _3)), f3 = 0;
            const A2 = a3 * s4 + _3;
            b4.lineOffset = Math.max(_3, l4), d3 += A2, m3 = Math.max(A2, m3), ++x3;
          }
          var v4;
          const b3 = d3 - Du, { horizontalAlign: w3, verticalAlign: _2 } = Ju(o3);
          (function(t2, e4, r4, n4, i4, s4, a4, o4, l4) {
            const u7 = (e4 - r4) * i4;
            let c4 = 0;
            c4 = s4 !== a4 ? -o4 * n4 - Du : (-n4 * l4 + 0.5) * a4;
            for (const e5 of t2)
              for (const t3 of e5.positionedGlyphs)
                t3.x += u7, t3.y += c4;
          })(e3.positionedLines, g3, w3, _2, y3, m3, a3, b3, s3.length), e3.top += -_2 * b3, e3.bottom = e3.top + b3, e3.left += -w3 * y3, e3.right = e3.left + y3;
        }(w2, r2, n2, i2, g2, o2, l2, u5, p2, c2, f2, y2), !function(t2) {
          for (const e3 of t2)
            if (e3.positionedGlyphs.length !== 0)
              return false;
          return true;
        }(b2) && w2;
      }
      const Uu = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, qu = { 10: true, 32: true, 38: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true }, Nu = { 40: true };
      function Zu(t2, e2, r2, n2, i2, s2) {
        if (e2.imageName) {
          const t3 = n2[e2.imageName];
          return t3 ? t3.displaySize[0] * e2.scale * iu / s2 + i2 : 0;
        }
        {
          const n3 = r2[e2.fontStack], s3 = n3 && n3[t2];
          return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
        }
      }
      function Gu(t2, e2, r2, n2) {
        const i2 = Math.pow(t2 - e2, 2);
        return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
      }
      function Ku(t2, e2, r2) {
        let n2 = 0;
        return t2 === 10 && (n2 -= 1e4), r2 && (n2 += 150), t2 !== 40 && t2 !== 65288 || (n2 += 50), e2 !== 41 && e2 !== 65289 || (n2 += 50), n2;
      }
      function Xu(t2, e2, r2, n2, i2, s2) {
        let a2 = null, o2 = Gu(e2, r2, i2, s2);
        for (const t3 of n2) {
          const n3 = Gu(e2 - t3.x, r2, i2, s2) + t3.badness;
          n3 <= o2 && (a2 = t3, o2 = n3);
        }
        return { index: t2, x: e2, priorBreak: a2, badness: o2 };
      }
      function Hu(t2) {
        return t2 ? Hu(t2.priorBreak).concat(t2.index) : [];
      }
      function Yu(t2, e2, r2, n2, i2, s2) {
        if (!t2)
          return [];
        const a2 = [], o2 = function(t3, e3, r3, n3, i3, s3) {
          let a3 = 0;
          for (let r4 = 0;r4 < t3.length(); r4++) {
            const o3 = t3.getSection(r4);
            a3 += Zu(t3.getCharCode(r4), o3, n3, i3, e3, s3);
          }
          return a3 / Math.max(1, Math.ceil(a3 / r3));
        }(t2, e2, r2, n2, i2, s2), l2 = t2.text.indexOf("​") >= 0;
        let u5 = 0;
        for (let r3 = 0;r3 < t2.length(); r3++) {
          const h2 = t2.getSection(r3), p2 = t2.getCharCode(r3);
          if (Uu[p2] || (u5 += Zu(p2, h2, n2, i2, e2, s2)), r3 < t2.length() - 1) {
            const e3 = !((c2 = p2) < 11904) && (!!zi["CJK Compatibility Forms"](c2) || !!zi["CJK Compatibility"](c2) || !!zi["CJK Strokes"](c2) || !!zi["CJK Symbols and Punctuation"](c2) || !!zi["Enclosed CJK Letters and Months"](c2) || !!zi["Halfwidth and Fullwidth Forms"](c2) || !!zi["Ideographic Description Characters"](c2) || !!zi["Vertical Forms"](c2) || Fi.test(String.fromCodePoint(c2)));
            (qu[p2] || e3 || h2.imageName || r3 !== t2.length() - 2 && Nu[t2.getCharCode(r3 + 1)]) && a2.push(Xu(r3 + 1, u5, o2, a2, Ku(p2, t2.getCharCode(r3 + 1), e3 && l2), false));
          }
        }
        var c2;
        return Hu(Xu(t2.length(), u5, o2, a2, 0, true));
      }
      function Ju(t2) {
        let e2 = 0.5, r2 = 0.5;
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            e2 = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e2 = 0;
        }
        switch (t2) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            r2 = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            r2 = 0;
        }
        return { horizontalAlign: e2, verticalAlign: r2 };
      }
      function Wu(t2, e2, r2, n2, i2) {
        if (!n2 && !i2)
          return;
        const s2 = t2[r2], a2 = (t2[r2].x + s2.metrics.advance * s2.scale) * n2;
        for (let n3 = e2;n3 <= r2; n3++)
          t2[n3].x -= a2, t2[n3].y += i2;
      }
      function Qu(t2, e2, r2) {
        const { horizontalAlign: n2, verticalAlign: i2 } = Ju(r2), s2 = e2[0] - t2.displaySize[0] * n2, a2 = e2[1] - t2.displaySize[1] * i2;
        return { image: t2, top: a2, bottom: a2 + t2.displaySize[1], left: s2, right: s2 + t2.displaySize[0] };
      }
      function tc(t2) {
        var e2, r2;
        let { left: n2, top: i2 } = t2, s2 = t2.right - n2, a2 = t2.bottom - i2;
        const o2 = (e2 = t2.image.textFitWidth) !== null && e2 !== undefined ? e2 : "stretchOrShrink", l2 = (r2 = t2.image.textFitHeight) !== null && r2 !== undefined ? r2 : "stretchOrShrink", u5 = (t2.image.content[2] - t2.image.content[0]) / (t2.image.content[3] - t2.image.content[1]);
        if (l2 === "proportional") {
          if (o2 === "stretchOnly" && s2 / a2 < u5 || o2 === "proportional") {
            const t3 = Math.ceil(a2 * u5);
            n2 *= t3 / s2, s2 = t3;
          }
        } else if (o2 === "proportional" && l2 === "stretchOnly" && u5 !== 0 && s2 / a2 > u5) {
          const t3 = Math.ceil(s2 / u5);
          i2 *= t3 / a2, a2 = t3;
        }
        return { x1: n2, y1: i2, x2: n2 + s2, y2: i2 + a2 };
      }
      function ec(t2, e2, r2, n2, i2, s2) {
        const a2 = t2.image;
        let o2;
        if (a2.content) {
          const t3 = a2.content, e3 = a2.pixelRatio || 1;
          o2 = [t3[0] / e3, t3[1] / e3, a2.displaySize[0] - t3[2] / e3, a2.displaySize[1] - t3[3] / e3];
        }
        const l2 = e2.left * s2, u5 = e2.right * s2;
        let c2, h2, p2, f2;
        r2 === "width" || r2 === "both" ? (f2 = i2[0] + l2 - n2[3], h2 = i2[0] + u5 + n2[1]) : (f2 = i2[0] + (l2 + u5 - a2.displaySize[0]) / 2, h2 = f2 + a2.displaySize[0]);
        const d2 = e2.top * s2, y2 = e2.bottom * s2;
        return r2 === "height" || r2 === "both" ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (d2 + y2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: o2 };
      }
      const rc = 255, nc = 128, ic = rc * nc;
      function sc(t2, e2) {
        const { expression: r2 } = e2;
        if (r2.kind === "constant")
          return { kind: "constant", layoutSize: r2.evaluate(new Ui(t2 + 1)) };
        if (r2.kind === "source")
          return { kind: "source" };
        {
          const { zoomStops: e3, interpolationType: n2 } = r2;
          let i2 = 0;
          for (;i2 < e3.length && e3[i2] <= t2; )
            i2++;
          i2 = Math.max(0, i2 - 1);
          let s2 = i2;
          for (;s2 < e3.length && e3[s2] < t2 + 1; )
            s2++;
          s2 = Math.min(e3.length - 1, s2);
          const a2 = e3[i2], o2 = e3[s2];
          return r2.kind === "composite" ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : { kind: "camera", minZoom: a2, maxZoom: o2, minSize: r2.evaluate(new Ui(a2)), maxSize: r2.evaluate(new Ui(o2)), interpolationType: n2 };
        }
      }
      function ac2(t2, e2, r2) {
        let n2 = "never";
        const i2 = t2.get(e2);
        return i2 ? n2 = i2 : t2.get(r2) && (n2 = "always"), n2;
      }
      const oc = fl.VectorTileFeature.types, lc = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function uc(t2, e2, r2, n2, i2, s2, a2, o2, l2, u5, c2, h2, p2) {
        const f2 = o2 ? Math.min(ic, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(ic, Math.round(o2[1])) : 0;
        t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u5, 16 * c2, 256 * h2, 256 * p2);
      }
      function cc2(t2, e2, r2) {
        t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2);
      }
      function hc(t2) {
        for (const e2 of t2.sections)
          if (ji(e2.text))
            return true;
        return false;
      }

      class pc {
        constructor(t2) {
          this.layoutVertexArray = new Ws, this.indexArray = new na, this.programConfigurations = t2, this.segments = new oa, this.dynamicLayoutVertexArray = new Qs, this.opacityVertexArray = new ta, this.hasVisibleVertices = false, this.placedSymbolArray = new $s;
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(t2, e2, r2, n2) {
          this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Jl.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, Wl.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, lc, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      wi("SymbolBuffers", pc);

      class fc {
        constructor(t2, e2, r2) {
          this.layoutVertexArray = new t2, this.layoutAttributes = e2, this.indexArray = new r2, this.segments = new oa, this.collisionVertexArray = new ra;
        }
        upload(t2) {
          this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Ql.members, true);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      wi("CollisionBuffers", fc);

      class dc {
        constructor(e2) {
          this.collisionBoxArray = e2.collisionBoxArray, this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((t2) => t2.id), this.index = e2.index, this.pixelRatio = e2.pixelRatio, this.sourceLayerIndex = e2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = lo([]), this.placementViewportMatrix = lo([]);
          const r2 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = sc(this.zoom, r2["text-size"]), this.iconSizeData = sc(this.zoom, r2["icon-size"]);
          const n2 = this.layers[0].layout, i2 = n2.get("symbol-sort-key"), s2 = n2.get("symbol-z-order");
          this.canOverlap = ac2(n2, "text-overlap", "text-allow-overlap") !== "never" || ac2(n2, "icon-overlap", "icon-allow-overlap") !== "never" || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = s2 !== "viewport-y" && !i2.isConstant(), this.sortFeaturesByY = (s2 === "viewport-y" || s2 === "auto" && !this.sortFeaturesByKey) && this.canOverlap, n2.get("symbol-placement") === "point" && (this.writingModes = n2.get("text-writing-mode").map((e3) => t.ah[e3])), this.stateDependentLayerIds = this.layers.filter((t2) => t2.isStateDependent()).map((t2) => t2.id), this.sourceID = e2.sourceID;
        }
        createArrays() {
          this.text = new pc(new Ea(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new pc(new Ea(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new Os, this.lineVertexArray = new js, this.symbolInstances = new Ds, this.textAnchorOffsets = new Us;
        }
        calculateGlyphDependencies(t2, e2, r2, n2, i2) {
          for (let s2 = 0;s2 < t2.length; s2++)
            if (e2[t2.charCodeAt(s2)] = true, (r2 || n2) && i2) {
              const r3 = nu[t2.charAt(s2)];
              r3 && (e2[r3.charCodeAt(0)] = true);
            }
        }
        populate(e2, r2, n2) {
          const i2 = this.layers[0], s2 = i2.layout, a2 = s2.get("text-font"), o2 = s2.get("text-field"), l2 = s2.get("icon-image"), u5 = (o2.value.kind !== "constant" || o2.value.value instanceof Yt && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && (a2.value.kind !== "constant" || a2.value.value.length > 0), c2 = l2.value.kind !== "constant" || !!l2.value.value || Object.keys(l2.parameters).length > 0, h2 = s2.get("symbol-sort-key");
          if (this.features = [], !u5 && !c2)
            return;
          const { iconDependencies: p2, glyphDependencies: f2, availableImages: d2 } = r2, y2 = new Ui(this.zoom);
          for (const { feature: r3, id: o3, index: l3, sourceLayerIndex: m2 } of e2) {
            const e3 = i2._featureFilter.needGeometry, g2 = ja(r3, e3);
            if (!i2._featureFilter.filter(y2, g2, n2))
              continue;
            let x2, v3;
            if (e3 || (g2.geometry = Oa(r3)), u5) {
              const t2 = i2.getValueAndResolveTokens("text-field", g2, n2, d2), e4 = Yt.factory(t2), r4 = this.hasRTLText = this.hasRTLText || hc(e4);
              (!r4 || Ri.getRTLTextPluginStatus() === "unavailable" || r4 && Ri.isParsed()) && (x2 = ru(e4, i2, g2));
            }
            if (c2) {
              const t2 = i2.getValueAndResolveTokens("icon-image", g2, n2, d2);
              v3 = t2 instanceof te ? t2 : te.fromString(t2);
            }
            if (!x2 && !v3)
              continue;
            const b2 = this.sortFeaturesByKey ? h2.evaluate(g2, {}, n2) : undefined;
            if (this.features.push({ id: o3, text: x2, icon: v3, index: l3, sourceLayerIndex: m2, geometry: g2.geometry, properties: r3.properties, type: oc[r3.type], sortKey: b2 }), v3 && (p2[v3.name] = true), x2) {
              const e4 = a2.evaluate(g2, {}, n2).join(","), r4 = s2.get("text-rotation-alignment") !== "viewport" && s2.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.ah.vertical) >= 0;
              for (const t2 of x2.sections)
                if (t2.image)
                  p2[t2.image.name] = true;
                else {
                  const n3 = Pi(x2.toString()), i3 = t2.fontStack || e4, s3 = f2[i3] = f2[i3] || {};
                  this.calculateGlyphDependencies(t2.text, s3, r4, this.allowVerticalPlacement, n3);
                }
            }
          }
          s2.get("symbol-placement") === "line" && (this.features = function(t2) {
            const e3 = {}, r3 = {}, n3 = [];
            let i3 = 0;
            function s3(e4) {
              n3.push(t2[e4]), i3++;
            }
            function a3(t3, e4, i4) {
              const s4 = r3[t3];
              return delete r3[t3], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
            }
            function o3(t3, r4, i4) {
              const s4 = e3[r4];
              return delete e3[r4], e3[t3] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
            }
            function l3(t3, e4, r4) {
              const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
              return `${t3}:${n4.x}:${n4.y}`;
            }
            for (let u6 = 0;u6 < t2.length; u6++) {
              const c3 = t2[u6], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
              if (!p3) {
                s3(u6);
                continue;
              }
              const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
              if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                const t3 = o3(f3, d3, h3), i4 = a3(f3, d3, n3[t3].geometry);
                delete e3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t3].geometry = null;
              } else
                f3 in r3 ? a3(f3, d3, h3) : (d3 in e3) ? o3(f3, d3, h3) : (s3(u6), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
            }
            return n3.filter((t3) => t3.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((t2, e3) => t2.sortKey - e3.sortKey);
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t2) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t2, e2) {
          const r2 = this.lineVertexArray.length;
          if (t2.segment !== undefined) {
            let r3 = t2.dist(e2[t2.segment + 1]), n2 = t2.dist(e2[t2.segment]);
            const i2 = {};
            for (let n3 = t2.segment + 1;n3 < e2.length; n3++)
              i2[n3] = { x: e2[n3].x, y: e2[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < e2.length - 1 && (r3 += e2[n3 + 1].dist(e2[n3]));
            for (let r4 = t2.segment || 0;r4 >= 0; r4--)
              i2[r4] = { x: e2[r4].x, y: e2[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += e2[r4 - 1].dist(e2[r4]));
            for (let t3 = 0;t3 < e2.length; t3++) {
              const e3 = i2[t3];
              this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
        }
        addSymbols(e2, r2, n2, i2, s2, a2, o2, l2, u5, c2, h2, p2) {
          const { indexArray: f2, layoutVertexArray: d2 } = e2, y2 = e2.segments.prepareSegment(4 * r2.length, d2, f2, this.canOverlap ? a2.sortKey : undefined), m2 = this.glyphOffsetArray.length, g2 = y2.vertexLength, x2 = this.allowVerticalPlacement && o2 === t.ah.vertical ? Math.PI / 2 : 0, v3 = a2.text && a2.text.sections;
          for (let t2 = 0;t2 < r2.length; t2++) {
            const { tl: i3, tr: s3, bl: o3, br: u6, tex: c3, pixelOffsetTL: h3, pixelOffsetBR: m3, minFontScaleX: g3, minFontScaleY: b2, glyphOffset: w2, isSDF: _2, sectionIndex: A2 } = r2[t2], S2 = y2.vertexLength, k2 = w2[1];
            uc(d2, l2.x, l2.y, i3.x, k2 + i3.y, c3.x, c3.y, n2, _2, h3.x, h3.y, g3, b2), uc(d2, l2.x, l2.y, s3.x, k2 + s3.y, c3.x + c3.w, c3.y, n2, _2, m3.x, h3.y, g3, b2), uc(d2, l2.x, l2.y, o3.x, k2 + o3.y, c3.x, c3.y + c3.h, n2, _2, h3.x, m3.y, g3, b2), uc(d2, l2.x, l2.y, u6.x, k2 + u6.y, c3.x + c3.w, c3.y + c3.h, n2, _2, m3.x, m3.y, g3, b2), cc2(e2.dynamicLayoutVertexArray, l2, x2), f2.emplaceBack(S2, S2 + 1, S2 + 2), f2.emplaceBack(S2 + 1, S2 + 2, S2 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w2[0]), t2 !== r2.length - 1 && A2 === r2[t2 + 1].sectionIndex || e2.programConfigurations.populatePaintArrays(d2.length, a2, a2.index, {}, p2, v3 && v3[A2]);
          }
          e2.placedSymbolArray.emplaceBack(l2.x, l2.y, m2, this.glyphOffsetArray.length - m2, g2, u5, c2, l2.segment, n2 ? n2[0] : 0, n2 ? n2[1] : 0, i2[0], i2[1], o2, 0, false, 0, h2);
        }
        _addCollisionDebugVertex(t2, e2, r2, n2, i2, s2) {
          return e2.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(s2.x), Math.round(s2.y));
        }
        addCollisionDebugVertices(t2, e2, r2, n2, i2, a2, o2) {
          const l2 = i2.segments.prepareSegment(4, i2.layoutVertexArray, i2.indexArray), u5 = l2.vertexLength, c2 = i2.layoutVertexArray, h2 = i2.collisionVertexArray, p2 = o2.anchorX, f2 = o2.anchorY;
          this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(t2, e2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(r2, e2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(r2, n2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(t2, n2)), l2.vertexLength += 4;
          const d2 = i2.indexArray;
          d2.emplaceBack(u5, u5 + 1), d2.emplaceBack(u5 + 1, u5 + 2), d2.emplaceBack(u5 + 2, u5 + 3), d2.emplaceBack(u5 + 3, u5), l2.primitiveLength += 4;
        }
        addDebugCollisionBoxes(t2, e2, r2, n2) {
          for (let i2 = t2;i2 < e2; i2++) {
            const t3 = this.collisionBoxArray.get(i2);
            this.addCollisionDebugVertices(t3.x1, t3.y1, t3.x2, t3.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, t3.anchorPoint, r2);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new fc(ea2, tu.members, ia), this.iconCollisionBox = new fc(ea2, tu.members, ia);
          for (let t2 = 0;t2 < this.symbolInstances.length; t2++) {
            const e2 = this.symbolInstances.get(t2);
            this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
          }
        }
        _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u5 = {};
          for (let n3 = e2;n3 < r2; n3++) {
            const e3 = t2.get(n3);
            u5.textBox = { x1: e3.x1, y1: e3.y1, x2: e3.x2, y2: e3.y2, anchorPointX: e3.anchorPointX, anchorPointY: e3.anchorPointY }, u5.textFeatureIndex = e3.featureIndex;
            break;
          }
          for (let e3 = n2;e3 < i2; e3++) {
            const r3 = t2.get(e3);
            u5.verticalTextBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u5.verticalTextFeatureIndex = r3.featureIndex;
            break;
          }
          for (let e3 = s2;e3 < a2; e3++) {
            const r3 = t2.get(e3);
            u5.iconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u5.iconFeatureIndex = r3.featureIndex;
            break;
          }
          for (let e3 = o2;e3 < l2; e3++) {
            const r3 = t2.get(e3);
            u5.verticalIconBox = { x1: r3.x1, y1: r3.y1, x2: r3.x2, y2: r3.y2, anchorPointX: r3.anchorPointX, anchorPointY: r3.anchorPointY }, u5.verticalIconFeatureIndex = r3.featureIndex;
            break;
          }
          return u5;
        }
        deserializeCollisionBoxes(t2) {
          this.collisionArrays = [];
          for (let e2 = 0;e2 < this.symbolInstances.length; e2++) {
            const r2 = this.symbolInstances.get(e2);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(t2, e2) {
          const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
          for (let e3 = r2.vertexStartIndex;e3 < n2; e3 += 4)
            t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
        }
        getSortedSymbolIndexes(t2) {
          if (this.sortedAngle === t2 && this.symbolInstanceIndexes !== undefined)
            return this.symbolInstanceIndexes;
          const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
          for (let t3 = 0;t3 < this.symbolInstances.length; ++t3) {
            s2.push(t3);
            const a2 = this.symbolInstances.get(t3);
            n2.push(0 | Math.round(e2 * a2.anchorX + r2 * a2.anchorY)), i2.push(a2.featureIndex);
          }
          return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
        }
        addToSortKeyRanges(t2, e2) {
          const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
        }
        sortFeatures(t2) {
          if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const t3 of this.symbolInstanceIndexes) {
              const e2 = this.symbolInstances.get(t3);
              this.featureSortOrder.push(e2.featureIndex), [e2.rightJustifiedTextSymbolIndex, e2.centerJustifiedTextSymbolIndex, e2.leftJustifiedTextSymbolIndex].forEach((t4, e3, r2) => {
                t4 >= 0 && r2.indexOf(t4) === e3 && this.addIndicesForPlacedSymbol(this.text, t4);
              }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let yc, mc;
      wi("SymbolBucket", dc, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), dc.MAX_GLYPHS = 65535, dc.addDynamicAttributes = cc2;
      var gc = { get paint() {
        return mc = mc || new rs({ "icon-opacity": new Wi(G.paint_symbol["icon-opacity"]), "icon-color": new Wi(G.paint_symbol["icon-color"]), "icon-halo-color": new Wi(G.paint_symbol["icon-halo-color"]), "icon-halo-width": new Wi(G.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Wi(G.paint_symbol["icon-halo-blur"]), "icon-translate": new Ji(G.paint_symbol["icon-translate"]), "icon-translate-anchor": new Ji(G.paint_symbol["icon-translate-anchor"]), "text-opacity": new Wi(G.paint_symbol["text-opacity"]), "text-color": new Wi(G.paint_symbol["text-color"], { runtimeType: pt, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new Wi(G.paint_symbol["text-halo-color"]), "text-halo-width": new Wi(G.paint_symbol["text-halo-width"]), "text-halo-blur": new Wi(G.paint_symbol["text-halo-blur"]), "text-translate": new Ji(G.paint_symbol["text-translate"]), "text-translate-anchor": new Ji(G.paint_symbol["text-translate-anchor"]) });
      }, get layout() {
        return yc = yc || new rs({ "symbol-placement": new Ji(G.layout_symbol["symbol-placement"]), "symbol-spacing": new Ji(G.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Ji(G.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Wi(G.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Ji(G.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new Ji(G.layout_symbol["icon-allow-overlap"]), "icon-overlap": new Ji(G.layout_symbol["icon-overlap"]), "icon-ignore-placement": new Ji(G.layout_symbol["icon-ignore-placement"]), "icon-optional": new Ji(G.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Ji(G.layout_symbol["icon-rotation-alignment"]), "icon-size": new Wi(G.layout_symbol["icon-size"]), "icon-text-fit": new Ji(G.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new Ji(G.layout_symbol["icon-text-fit-padding"]), "icon-image": new Wi(G.layout_symbol["icon-image"]), "icon-rotate": new Wi(G.layout_symbol["icon-rotate"]), "icon-padding": new Wi(G.layout_symbol["icon-padding"]), "icon-keep-upright": new Ji(G.layout_symbol["icon-keep-upright"]), "icon-offset": new Wi(G.layout_symbol["icon-offset"]), "icon-anchor": new Wi(G.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Ji(G.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Ji(G.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Ji(G.layout_symbol["text-rotation-alignment"]), "text-field": new Wi(G.layout_symbol["text-field"]), "text-font": new Wi(G.layout_symbol["text-font"]), "text-size": new Wi(G.layout_symbol["text-size"]), "text-max-width": new Wi(G.layout_symbol["text-max-width"]), "text-line-height": new Ji(G.layout_symbol["text-line-height"]), "text-letter-spacing": new Wi(G.layout_symbol["text-letter-spacing"]), "text-justify": new Wi(G.layout_symbol["text-justify"]), "text-radial-offset": new Wi(G.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Ji(G.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Wi(G.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Wi(G.layout_symbol["text-anchor"]), "text-max-angle": new Ji(G.layout_symbol["text-max-angle"]), "text-writing-mode": new Ji(G.layout_symbol["text-writing-mode"]), "text-rotate": new Wi(G.layout_symbol["text-rotate"]), "text-padding": new Ji(G.layout_symbol["text-padding"]), "text-keep-upright": new Ji(G.layout_symbol["text-keep-upright"]), "text-transform": new Wi(G.layout_symbol["text-transform"]), "text-offset": new Wi(G.layout_symbol["text-offset"]), "text-allow-overlap": new Ji(G.layout_symbol["text-allow-overlap"]), "text-overlap": new Ji(G.layout_symbol["text-overlap"]), "text-ignore-placement": new Ji(G.layout_symbol["text-ignore-placement"]), "text-optional": new Ji(G.layout_symbol["text-optional"]) });
      } };

      class xc {
        constructor(t2) {
          if (t2.property.overrides === undefined)
            throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = t2.property.overrides ? t2.property.overrides.runtimeType : lt, this.defaultValue = t2;
        }
        evaluate(t2) {
          if (t2.formattedSection) {
            const e2 = this.defaultValue.property.overrides;
            if (e2 && e2.hasOverride(t2.formattedSection))
              return e2.getOverride(t2.formattedSection);
          }
          return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t2) {
          this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return null;
        }
      }
      wi("FormatSectionOverride", xc, { omit: ["defaultValue"] });

      class vc extends is {
        constructor(t2) {
          super(t2, gc);
        }
        recalculate(t2, e2) {
          if (super.recalculate(t2, e2), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const t3 = this.layout.get("text-writing-mode");
            if (t3) {
              const e3 = [];
              for (const r2 of t3)
                e3.indexOf(r2) < 0 && e3.push(r2);
              this.layout._values["text-writing-mode"] = e3;
            } else
              this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t2, e2, r2, n2) {
          const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
          return s2.isDataDriven() || vn(s2.value) || !i2 ? i2 : function(t3, e3) {
            return e3.replace(/{([^{}]+)}/g, (e4, r3) => t3 && (r3 in t3) ? String(t3[r3]) : "");
          }(e2.properties, i2);
        }
        createBucket(t2) {
          return new dc(t2);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const t2 of gc.paint.overridableProperties) {
            if (!vc.hasPaintOverride(this.layout, t2))
              continue;
            const e2 = this.paint.get(t2), r2 = new xc(e2), n2 = new xn(r2, e2.property.specification);
            let i2 = null;
            i2 = e2.value.kind === "constant" || e2.value.kind === "source" ? new wn("source", n2) : new _n("composite", n2, e2.value.zoomStops), this.paint._values[t2] = new Hi(e2.property, i2, e2.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
          return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && vc.hasPaintOverride(this.layout, t2);
        }
        static hasPaintOverride(t2, e2) {
          const r2 = t2.get("text-field"), n2 = gc.paint.properties[e2];
          let i2 = false;
          const s2 = (t3) => {
            for (const e3 of t3)
              if (n2.overrides && n2.overrides.hasOverride(e3))
                return void (i2 = true);
          };
          if (r2.value.kind === "constant" && r2.value.value instanceof Yt)
            s2(r2.value.value.sections);
          else if (r2.value.kind === "source") {
            const t3 = (e4) => {
              i2 || (e4 instanceof se && ne(e4.value) === mt ? s2(e4.value.sections) : e4 instanceof Ze ? s2(e4.sections) : e4.eachChild(t3));
            }, e3 = r2.value;
            e3._styleExpression && t3(e3._styleExpression.expression);
          }
          return i2;
        }
      }
      let bc4;
      var wc = { get paint() {
        return bc4 = bc4 || new rs({ "background-color": new Ji(G.paint_background["background-color"]), "background-pattern": new ts(G.paint_background["background-pattern"]), "background-opacity": new Ji(G.paint_background["background-opacity"]) });
      } };

      class _c extends is {
        constructor(t2) {
          super(t2, wc);
        }
      }
      let Ac;
      var Sc = { get paint() {
        return Ac = Ac || new rs({ "raster-opacity": new Ji(G.paint_raster["raster-opacity"]), "raster-hue-rotate": new Ji(G.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Ji(G.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Ji(G.paint_raster["raster-brightness-max"]), "raster-saturation": new Ji(G.paint_raster["raster-saturation"]), "raster-contrast": new Ji(G.paint_raster["raster-contrast"]), "raster-resampling": new Ji(G.paint_raster["raster-resampling"]), "raster-fade-duration": new Ji(G.paint_raster["raster-fade-duration"]) });
      } };

      class kc extends is {
        constructor(t2) {
          super(t2, Sc);
        }
      }

      class Mc extends is {
        constructor(t2) {
          super(t2, {}), this.onAdd = (t3) => {
            this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
          }, this.onRemove = (t3) => {
            this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
          }, this.implementation = t2;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== undefined;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return false;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }

      class Ic {
        constructor(t2) {
          this._methodToThrottle = t2, this._triggered = false, typeof MessageChannel != "undefined" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
            this._triggered = false, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
            this._triggered = false, this._methodToThrottle();
          }, 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      const zc = 6371008.8;

      class Pc {
        constructor(t2, e2) {
          if (isNaN(t2) || isNaN(e2))
            throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
          if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Pc(m(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t2) {
          const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
          return zc * Math.acos(Math.min(i2, 1));
        }
        static convert(t2) {
          if (t2 instanceof Pc)
            return t2;
          if (Array.isArray(t2) && (t2.length === 2 || t2.length === 3))
            return new Pc(Number(t2[0]), Number(t2[1]));
          if (!Array.isArray(t2) && typeof t2 == "object" && t2 !== null)
            return new Pc(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const Cc = 2 * Math.PI * zc;
      function Bc(t2) {
        return Cc * Math.cos(t2 * Math.PI / 180);
      }
      function Vc(t2) {
        return (180 + t2) / 360;
      }
      function Ec(t2) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
      }
      function Fc(t2, e2) {
        return t2 / Bc(e2);
      }
      function Tc(t2) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
      }

      class $c {
        constructor(t2, e2, r2 = 0) {
          this.x = +t2, this.y = +e2, this.z = +r2;
        }
        static fromLngLat(t2, e2 = 0) {
          const r2 = Pc.convert(t2);
          return new $c(Vc(r2.lng), Ec(r2.lat), Fc(e2, r2.lat));
        }
        toLngLat() {
          return new Pc(360 * this.x - 180, Tc(this.y));
        }
        toAltitude() {
          return this.z * Bc(Tc(this.y));
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Cc * (t2 = Tc(this.y), 1 / Math.cos(t2 * Math.PI / 180));
          var t2;
        }
      }
      function Lc(t2, e2, r2) {
        var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
        return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
      }

      class Dc {
        constructor(t2, e2, r2) {
          if (!function(t3, e3, r3) {
            return !(t3 < 0 || t3 > 25 || r3 < 0 || r3 >= Math.pow(2, t3) || e3 < 0 || e3 >= Math.pow(2, t3));
          }(t2, e2, r2))
            throw new Error(`x=${e2}, y=${r2}, z=${t2} outside of bounds. 0<=x<${Math.pow(2, t2)}, 0<=y<${Math.pow(2, t2)} 0<=z<=25 `);
          this.z = t2, this.x = e2, this.y = r2, this.key = Rc(0, t2, t2, e2, r2);
        }
        equals(t2) {
          return this.z === t2.z && this.x === t2.x && this.y === t2.y;
        }
        url(t2, e2, r2) {
          const n2 = (s2 = this.y, a2 = this.z, o2 = Lc(256 * (i2 = this.x), 256 * (s2 = Math.pow(2, a2) - s2 - 1), a2), l2 = Lc(256 * (i2 + 1), 256 * (s2 + 1), a2), o2[0] + "," + o2[1] + "," + l2[0] + "," + l2[1]);
          var i2, s2, a2, o2, l2;
          const u5 = function(t3, e3, r3) {
            let n3, i3 = "";
            for (let s3 = t3;s3 > 0; s3--)
              n3 = 1 << s3 - 1, i3 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
            return i3;
          }(this.z, this.x, this.y);
          return t2[(this.x + this.y) % t2.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(r2 === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e2 > 1 ? "@2x" : "").replace(/{quadkey}/g, u5).replace(/{bbox-epsg-3857}/g, n2);
        }
        isChildOf(t2) {
          const e2 = this.z - t2.z;
          return e2 > 0 && t2.x === this.x >> e2 && t2.y === this.y >> e2;
        }
        getTilePoint(t2) {
          const e2 = Math.pow(2, this.z);
          return new s((t2.x * e2 - this.x) * $a, (t2.y * e2 - this.y) * $a);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }

      class Oc {
        constructor(t2, e2) {
          this.wrap = t2, this.canonical = e2, this.key = Rc(t2, e2.z, e2.z, e2.x, e2.y);
        }
      }

      class jc {
        constructor(t2, e2, r2, n2, i2) {
          if (t2 < r2)
            throw new Error(`overscaledZ should be >= z; overscaledZ = ${t2}; z = ${r2}`);
          this.overscaledZ = t2, this.wrap = e2, this.canonical = new Dc(r2, +n2, +i2), this.key = Rc(e2, t2, r2, n2, i2);
        }
        clone() {
          return new jc(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(t2) {
          return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
        }
        scaledTo(t2) {
          if (t2 > this.overscaledZ)
            throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
          const e2 = this.canonical.z - t2;
          return t2 > this.canonical.z ? new jc(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new jc(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
        }
        calculateScaledKey(t2, e2) {
          if (t2 > this.overscaledZ)
            throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
          const r2 = this.canonical.z - t2;
          return t2 > this.canonical.z ? Rc(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y) : Rc(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
        }
        isChildOf(t2) {
          if (t2.wrap !== this.wrap)
            return false;
          const e2 = this.canonical.z - t2.canonical.z;
          return t2.overscaledZ === 0 || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
        }
        children(t2) {
          if (this.overscaledZ >= t2)
            return [new jc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
          return [new jc(e2, this.wrap, e2, r2, n2), new jc(e2, this.wrap, e2, r2 + 1, n2), new jc(e2, this.wrap, e2, r2, n2 + 1), new jc(e2, this.wrap, e2, r2 + 1, n2 + 1)];
        }
        isLessThan(t2) {
          return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
        }
        wrapped() {
          return new jc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t2) {
          return new jc(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Oc(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(t2) {
          return this.canonical.getTilePoint(new $c(t2.x - this.wrap, t2.y));
        }
      }
      function Rc(t2, e2, r2, n2, i2) {
        (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
        const s2 = 1 << r2;
        return (s2 * s2 * t2 + s2 * i2 + n2).toString(36) + r2.toString(36) + e2.toString(36);
      }
      wi("CanonicalTileID", Dc), wi("OverscaledTileID", jc, { omit: ["posMatrix"] });

      class Uc {
        constructor(t2, e2, r2, n2 = 1, i2 = 1, s2 = 1, a2 = 0) {
          if (this.uid = t2, e2.height !== e2.width)
            throw new RangeError("DEM tiles must be square");
          if (r2 && !["mapbox", "terrarium", "custom"].includes(r2))
            return void A(`"${r2}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = e2.height;
          const o2 = this.dim = e2.height - 2;
          switch (this.data = new Uint32Array(e2.data.buffer), r2) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = n2, this.greenFactor = i2, this.blueFactor = s2, this.baseShift = a2;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let t3 = 0;t3 < o2; t3++)
            this.data[this._idx(-1, t3)] = this.data[this._idx(0, t3)], this.data[this._idx(o2, t3)] = this.data[this._idx(o2 - 1, t3)], this.data[this._idx(t3, -1)] = this.data[this._idx(t3, 0)], this.data[this._idx(t3, o2)] = this.data[this._idx(t3, o2 - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o2, -1)] = this.data[this._idx(o2 - 1, 0)], this.data[this._idx(-1, o2)] = this.data[this._idx(0, o2 - 1)], this.data[this._idx(o2, o2)] = this.data[this._idx(o2 - 1, o2 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let t3 = 0;t3 < o2; t3++)
            for (let e3 = 0;e3 < o2; e3++) {
              const r3 = this.get(t3, e3);
              r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
            }
        }
        get(t2, e2) {
          const r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e2);
          return this.unpack(r2[n2], r2[n2 + 1], r2[n2 + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(t2, e2) {
          if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (e2 + 1) * this.stride + (t2 + 1);
        }
        unpack(t2, e2, r2) {
          return t2 * this.redFactor + e2 * this.greenFactor + r2 * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new Ao({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(t2, e2, r2) {
          if (this.dim !== t2.dim)
            throw new Error("dem dimension mismatch");
          let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
          switch (e2) {
            case -1:
              n2 = i2 - 1;
              break;
            case 1:
              i2 = n2 + 1;
          }
          switch (r2) {
            case -1:
              s2 = a2 - 1;
              break;
            case 1:
              a2 = s2 + 1;
          }
          const o2 = -e2 * this.dim, l2 = -r2 * this.dim;
          for (let e3 = s2;e3 < a2; e3++)
            for (let r3 = n2;r3 < i2; r3++)
              this.data[this._idx(r3, e3)] = t2.data[this._idx(r3 + o2, e3 + l2)];
        }
      }
      wi("DEMData", Uc);

      class qc {
        constructor(t2) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let e2 = 0;e2 < t2.length; e2++) {
            const r2 = t2[e2];
            this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
          }
        }
        encode(t2) {
          return this._stringToNumber[t2];
        }
        decode(t2) {
          if (t2 >= this._numberToString.length)
            throw new Error(`Out of bounds. Index requested n=${t2} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[t2];
        }
      }

      class Nc {
        constructor(t2, e2, r2, n2, i2) {
          this.type = "Feature", this._vectorTileFeature = t2, t2._z = e2, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
        }
        get geometry() {
          return this._geometry === undefined && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(t2) {
          this._geometry = t2;
        }
        toJSON() {
          const t2 = { geometry: this.geometry };
          for (const e2 in this)
            e2 !== "_geometry" && e2 !== "_vectorTileFeature" && (t2[e2] = this[e2]);
          return t2;
        }
      }

      class Zc {
        constructor(t2, e2) {
          this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new vi($a, 16, 0), this.grid3D = new vi($a, 16, 0), this.featureIndexArray = new Ns, this.promoteId = e2;
        }
        insert(t2, e2, r2, n2, i2, s2) {
          const a2 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(r2, n2, i2);
          const o2 = s2 ? this.grid3D : this.grid;
          for (let t3 = 0;t3 < e2.length; t3++) {
            const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let t4 = 0;t4 < r3.length; t4++) {
              const e3 = r3[t4];
              n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
            }
            n3[0] < $a && n3[1] < $a && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new fl.VectorTile(new Iu(this.rawTileData)).layers, this.sourceLayerCoder = new qc(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(t2, e2, r2, n2) {
          this.loadVTLayers();
          const i2 = t2.params || {}, a2 = $a / t2.tileSize / t2.scale, o2 = zn(i2.filter), l2 = t2.queryGeometry, u5 = t2.queryPadding * a2, c2 = Kc(l2), h2 = this.grid.query(c2.minX - u5, c2.minY - u5, c2.maxX + u5, c2.maxY + u5), p2 = Kc(t2.cameraQueryGeometry), f2 = this.grid3D.query(p2.minX - u5, p2.minY - u5, p2.maxX + u5, p2.maxY + u5, (e3, r3, n3, i3) => function(t3, e4, r4, n4, i4) {
            for (const s2 of t3)
              if (e4 <= s2.x && r4 <= s2.y && n4 >= s2.x && i4 >= s2.y)
                return true;
            const a3 = [new s(e4, r4), new s(e4, i4), new s(n4, i4), new s(n4, r4)];
            if (t3.length > 2) {
              for (const e5 of a3)
                if (Wa(t3, e5))
                  return true;
            }
            for (let e5 = 0;e5 < t3.length - 1; e5++)
              if (Qa(t3[e5], t3[e5 + 1], a3))
                return true;
            return false;
          }(t2.cameraQueryGeometry, e3 - u5, r3 - u5, n3 + u5, i3 + u5));
          for (const t3 of f2)
            h2.push(t3);
          h2.sort(Xc);
          const d2 = {};
          let y2;
          for (let s2 = 0;s2 < h2.length; s2++) {
            const u6 = h2[s2];
            if (u6 === y2)
              continue;
            y2 = u6;
            const c3 = this.featureIndexArray.get(u6);
            let p3 = null;
            this.loadMatchingFeature(d2, c3.bucketIndex, c3.sourceLayerIndex, c3.featureIndex, o2, i2.layers, i2.availableImages, e2, r2, n2, (e3, r3, n3) => (p3 || (p3 = Oa(e3)), r3.queryIntersectsFeature(l2, e3, n3, p3, this.z, t2.transform, a2, t2.pixelPosMatrix)));
          }
          return d2;
        }
        loadMatchingFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2, u5, c2) {
          const h2 = this.bucketLayerIDs[e2];
          if (s2 && !function(t3, e3) {
            for (let r3 = 0;r3 < t3.length; r3++)
              if (e3.indexOf(t3[r3]) >= 0)
                return true;
            return false;
          }(s2, h2))
            return;
          const p2 = this.sourceLayerCoder.decode(r2), f2 = this.vtLayers[p2].feature(n2);
          if (i2.needGeometry) {
            const t3 = ja(f2, true);
            if (!i2.filter(new Ui(this.tileID.overscaledZ), t3, this.tileID.canonical))
              return;
          } else if (!i2.filter(new Ui(this.tileID.overscaledZ), f2))
            return;
          const d2 = this.getId(f2, p2);
          for (let e3 = 0;e3 < h2.length; e3++) {
            const r3 = h2[e3];
            if (s2 && s2.indexOf(r3) < 0)
              continue;
            const i3 = o2[r3];
            if (!i3)
              continue;
            let p3 = {};
            d2 && u5 && (p3 = u5.getState(i3.sourceLayer || "_geojsonTileLayer", d2));
            const y2 = g({}, l2[r3]);
            y2.paint = Gc(y2.paint, i3.paint, f2, p3, a2), y2.layout = Gc(y2.layout, i3.layout, f2, p3, a2);
            const m2 = !c2 || c2(f2, i3, p3);
            if (!m2)
              continue;
            const x2 = new Nc(f2, this.z, this.x, this.y, d2);
            x2.layer = y2;
            let v3 = t2[r3];
            v3 === undefined && (v3 = t2[r3] = []), v3.push({ featureIndex: n2, feature: x2, intersectionZ: m2 });
          }
        }
        lookupSymbolFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = {};
          this.loadVTLayers();
          const u5 = zn(i2);
          for (const i3 of t2)
            this.loadMatchingFeature(l2, r2, n2, i3, u5, s2, a2, o2, e2);
          return l2;
        }
        hasLayer(t2) {
          for (const e2 of this.bucketLayerIDs)
            for (const r2 of e2)
              if (t2 === r2)
                return true;
          return false;
        }
        getId(t2, e2) {
          let r2 = t2.id;
          return this.promoteId && (r2 = t2.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[e2]], typeof r2 == "boolean" && (r2 = Number(r2))), r2;
        }
      }
      function Gc(t2, e2, r2, n2, i2) {
        return v2(t2, (t3, s2) => {
          const a2 = e2 instanceof Yi ? e2.get(s2) : null;
          return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
        });
      }
      function Kc(t2) {
        let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
        for (const s2 of t2)
          e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
        return { minX: e2, minY: r2, maxX: n2, maxY: i2 };
      }
      function Xc(t2, e2) {
        return e2 - t2;
      }
      function Hc(t2, e2, r2, n2, i2) {
        const a2 = [];
        for (let o2 = 0;o2 < t2.length; o2++) {
          const l2 = t2[o2];
          let u5;
          for (let t3 = 0;t3 < l2.length - 1; t3++) {
            let o3 = l2[t3], c2 = l2[t3 + 1];
            o3.x < e2 && c2.x < e2 || (o3.x < e2 ? o3 = new s(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x < e2 && (c2 = new s(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y < r2 && c2.y < r2 || (o3.y < r2 ? o3 = new s(o3.x + (r2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r2)._round() : c2.y < r2 && (c2 = new s(o3.x + (r2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r2)._round()), o3.x >= n2 && c2.x >= n2 || (o3.x >= n2 ? o3 = new s(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x >= n2 && (c2 = new s(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y >= i2 && c2.y >= i2 || (o3.y >= i2 ? o3 = new s(o3.x + (i2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), i2)._round() : c2.y >= i2 && (c2 = new s(o3.x + (i2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), i2)._round()), u5 && o3.equals(u5[u5.length - 1]) || (u5 = [o3], a2.push(u5)), u5.push(c2)))));
          }
        }
        return a2;
      }
      wi("FeatureIndex", Zc, { omit: ["rawTileData", "sourceLayerCoder"] });

      class Yc extends s {
        constructor(t2, e2, r2, n2) {
          super(t2, e2), this.angle = r2, n2 !== undefined && (this.segment = n2);
        }
        clone() {
          return new Yc(this.x, this.y, this.angle, this.segment);
        }
      }
      function Jc(t2, e2, r2, n2, i2) {
        if (e2.segment === undefined || r2 === 0)
          return true;
        let s2 = e2, a2 = e2.segment + 1, o2 = 0;
        for (;o2 > -r2 / 2; ) {
          if (a2--, a2 < 0)
            return false;
          o2 -= t2[a2].dist(s2), s2 = t2[a2];
        }
        o2 += t2[a2].dist(t2[a2 + 1]), a2++;
        const l2 = [];
        let u5 = 0;
        for (;o2 < r2 / 2; ) {
          const e3 = t2[a2], r3 = t2[a2 + 1];
          if (!r3)
            return false;
          let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
          for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u5 += s3;o2 - l2[0].distance > n2; )
            u5 -= l2.shift().angleDelta;
          if (u5 > i2)
            return false;
          a2++, o2 += e3.dist(r3);
        }
        return true;
      }
      function Wc(t2) {
        let e2 = 0;
        for (let r2 = 0;r2 < t2.length - 1; r2++)
          e2 += t2[r2].dist(t2[r2 + 1]);
        return e2;
      }
      function Qc(t2, e2, r2) {
        return t2 ? 0.6 * e2 * r2 : 0;
      }
      function th(t2, e2) {
        return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
      }
      function eh(t2, e2, r2, n2, i2, s2) {
        const a2 = Qc(r2, i2, s2), o2 = th(r2, n2) * s2;
        let l2 = 0;
        const u5 = Wc(t2) / 2;
        for (let r3 = 0;r3 < t2.length - 1; r3++) {
          const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
          if (l2 + s3 > u5) {
            const c2 = (u5 - l2) / s3, h2 = Ce.number(n3.x, i3.x, c2), p2 = Ce.number(n3.y, i3.y, c2), f2 = new Yc(h2, p2, i3.angleTo(n3), r3);
            return f2._round(), !a2 || Jc(t2, f2, o2, a2, e2) ? f2 : undefined;
          }
          l2 += s3;
        }
      }
      function rh(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        const u5 = Qc(n2, s2, a2), c2 = th(n2, i2), h2 = c2 * a2, p2 = t2[0].x === 0 || t2[0].x === l2 || t2[0].y === 0 || t2[0].y === l2;
        return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), nh(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u5, r2, h2, p2, false, l2);
      }
      function nh(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        const u5 = s2 / 2, c2 = Wc(t2);
        let h2 = 0, p2 = e2 - r2, f2 = [];
        for (let e3 = 0;e3 < t2.length - 1; e3++) {
          const a3 = t2[e3], o3 = t2[e3 + 1], d2 = a3.dist(o3), y2 = o3.angleTo(a3);
          for (;p2 + r2 < h2 + d2; ) {
            p2 += r2;
            const m2 = (p2 - h2) / d2, g2 = Ce.number(a3.x, o3.x, m2), x2 = Ce.number(a3.y, o3.y, m2);
            if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u5 >= 0 && p2 + u5 <= c2) {
              const r3 = new Yc(g2, x2, y2, e3);
              r3._round(), n2 && !Jc(t2, r3, s2, n2, i2) || f2.push(r3);
            }
          }
          h2 += d2;
        }
        return o2 || f2.length || a2 || (f2 = nh(t2, h2 / 2, r2, n2, i2, s2, a2, true, l2)), f2;
      }
      wi("Anchor", Yc);
      const ih = Fu;
      function sh(t2, e2, r2, n2) {
        const i2 = [], a2 = t2.image, o2 = a2.pixelRatio, l2 = a2.paddedRect.w - 2 * ih, u5 = a2.paddedRect.h - 2 * ih;
        let c2 = { x1: t2.left, y1: t2.top, x2: t2.right, y2: t2.bottom };
        const h2 = a2.stretchX || [[0, l2]], p2 = a2.stretchY || [[0, u5]], f2 = (t3, e3) => t3 + e3[1] - e3[0], d2 = h2.reduce(f2, 0), y2 = p2.reduce(f2, 0), m2 = l2 - d2, g2 = u5 - y2;
        let x2 = 0, v3 = d2, b2 = 0, w2 = y2, _2 = 0, A2 = m2, S2 = 0, k2 = g2;
        if (a2.content && n2) {
          const e3 = a2.content, r3 = e3[2] - e3[0], n3 = e3[3] - e3[1];
          (a2.textFitWidth || a2.textFitHeight) && (c2 = tc(t2)), x2 = ah(h2, 0, e3[0]), b2 = ah(p2, 0, e3[1]), v3 = ah(h2, e3[0], e3[2]), w2 = ah(p2, e3[1], e3[3]), _2 = e3[0] - x2, S2 = e3[1] - b2, A2 = r3 - v3, k2 = n3 - w2;
        }
        const { x1: M2, y1: I2 } = c2, z2 = c2.x2 - M2, P2 = c2.y2 - I2, C3 = (t3, n3, i3, l3) => {
          const u6 = lh(t3.stretch - x2, v3, z2, M2), c3 = uh(t3.fixed - _2, A2, t3.stretch, d2), h3 = lh(n3.stretch - b2, w2, P2, I2), p3 = uh(n3.fixed - S2, k2, n3.stretch, y2), f3 = lh(i3.stretch - x2, v3, z2, M2), m3 = uh(i3.fixed - _2, A2, i3.stretch, d2), g3 = lh(l3.stretch - b2, w2, P2, I2), C4 = uh(l3.fixed - S2, k2, l3.stretch, y2), B3 = new s(u6, h3), V2 = new s(f3, h3), E2 = new s(f3, g3), F2 = new s(u6, g3), T2 = new s(c3 / o2, p3 / o2), $2 = new s(m3 / o2, C4 / o2), L2 = e2 * Math.PI / 180;
          if (L2) {
            const t4 = Math.sin(L2), e3 = Math.cos(L2), r3 = [e3, -t4, t4, e3];
            B3._matMult(r3), V2._matMult(r3), F2._matMult(r3), E2._matMult(r3);
          }
          const D3 = t3.stretch + t3.fixed, O2 = n3.stretch + n3.fixed;
          return { tl: B3, tr: V2, bl: F2, br: E2, tex: { x: a2.paddedRect.x + ih + D3, y: a2.paddedRect.y + ih + O2, w: i3.stretch + i3.fixed - D3, h: l3.stretch + l3.fixed - O2 }, writingMode: undefined, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: T2, pixelOffsetBR: $2, minFontScaleX: A2 / o2 / z2, minFontScaleY: k2 / o2 / P2, isSDF: r2 };
        };
        if (n2 && (a2.stretchX || a2.stretchY)) {
          const t3 = oh(h2, m2, d2), e3 = oh(p2, g2, y2);
          for (let r3 = 0;r3 < t3.length - 1; r3++) {
            const n3 = t3[r3], s2 = t3[r3 + 1];
            for (let t4 = 0;t4 < e3.length - 1; t4++)
              i2.push(C3(n3, e3[t4], s2, e3[t4 + 1]));
          }
        } else
          i2.push(C3({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l2 + 1 }, { fixed: 0, stretch: u5 + 1 }));
        return i2;
      }
      function ah(t2, e2, r2) {
        let n2 = 0;
        for (const i2 of t2)
          n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
        return n2;
      }
      function oh(t2, e2, r2) {
        const n2 = [{ fixed: -ih, stretch: 0 }];
        for (const [e3, r3] of t2) {
          const t3 = n2[n2.length - 1];
          n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
        }
        return n2.push({ fixed: e2 + ih, stretch: r2 }), n2;
      }
      function lh(t2, e2, r2, n2) {
        return t2 / e2 * r2 + n2;
      }
      function uh(t2, e2, r2, n2) {
        return t2 - e2 * r2 / n2;
      }

      class ch {
        constructor(t2, e2, r2, n2, i2, a2, o2, l2, u5, c2) {
          var h2;
          if (this.boxStartIndex = t2.length, u5) {
            let { top: t3, bottom: e3 } = a2;
            const r3 = a2.collisionPadding;
            r3 && (t3 -= r3[1], e3 += r3[3]);
            let n3 = e3 - t3;
            n3 > 0 && (n3 = Math.max(10, n3), this.circleDiameter = n3);
          } else {
            const u6 = ((h2 = a2.image) === null || h2 === undefined ? undefined : h2.content) && (a2.image.textFitWidth || a2.image.textFitHeight) ? tc(a2) : { x1: a2.left, y1: a2.top, x2: a2.right, y2: a2.bottom };
            u6.y1 = u6.y1 * o2 - l2[0], u6.y2 = u6.y2 * o2 + l2[2], u6.x1 = u6.x1 * o2 - l2[3], u6.x2 = u6.x2 * o2 + l2[1];
            const p2 = a2.collisionPadding;
            if (p2 && (u6.x1 -= p2[0] * o2, u6.y1 -= p2[1] * o2, u6.x2 += p2[2] * o2, u6.y2 += p2[3] * o2), c2) {
              const t3 = new s(u6.x1, u6.y1), e3 = new s(u6.x2, u6.y1), r3 = new s(u6.x1, u6.y2), n3 = new s(u6.x2, u6.y2), i3 = c2 * Math.PI / 180;
              t3._rotate(i3), e3._rotate(i3), r3._rotate(i3), n3._rotate(i3), u6.x1 = Math.min(t3.x, e3.x, r3.x, n3.x), u6.x2 = Math.max(t3.x, e3.x, r3.x, n3.x), u6.y1 = Math.min(t3.y, e3.y, r3.y, n3.y), u6.y2 = Math.max(t3.y, e3.y, r3.y, n3.y);
            }
            t2.emplaceBack(e2.x, e2.y, u6.x1, u6.y1, u6.x2, u6.y2, r2, n2, i2);
          }
          this.boxEndIndex = t2.length;
        }
      }

      class hh {
        constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
          if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
            for (let t3 = (this.length >> 1) - 1;t3 >= 0; t3--)
              this._down(t3);
        }
        push(t2) {
          this.data.push(t2), this._up(this.length++);
        }
        pop() {
          if (this.length === 0)
            return;
          const t2 = this.data[0], e2 = this.data.pop();
          return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
        }
        peek() {
          return this.data[0];
        }
        _up(t2) {
          const { data: e2, compare: r2 } = this, n2 = e2[t2];
          for (;t2 > 0; ) {
            const i2 = t2 - 1 >> 1, s2 = e2[i2];
            if (r2(n2, s2) >= 0)
              break;
            e2[t2] = s2, t2 = i2;
          }
          e2[t2] = n2;
        }
        _down(t2) {
          const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
          for (;t2 < n2; ) {
            let n3 = 1 + (t2 << 1);
            const s2 = n3 + 1;
            if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0)
              break;
            e2[t2] = e2[n3], t2 = n3;
          }
          e2[t2] = i2;
        }
      }
      function ph(t2, e2 = 1, r2 = false) {
        let n2 = 1 / 0, i2 = 1 / 0, a2 = -1 / 0, o2 = -1 / 0;
        const l2 = t2[0];
        for (let t3 = 0;t3 < l2.length; t3++) {
          const e3 = l2[t3];
          (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > a2) && (a2 = e3.x), (!t3 || e3.y > o2) && (o2 = e3.y);
        }
        const u5 = Math.min(a2 - n2, o2 - i2);
        let c2 = u5 / 2;
        const h2 = new hh([], fh);
        if (u5 === 0)
          return new s(n2, i2);
        for (let e3 = n2;e3 < a2; e3 += u5)
          for (let r3 = i2;r3 < o2; r3 += u5)
            h2.push(new dh(e3 + c2, r3 + c2, c2, t2));
        let p2 = function(t3) {
          let e3 = 0, r3 = 0, n3 = 0;
          const i3 = t3[0];
          for (let t4 = 0, s2 = i3.length, a3 = s2 - 1;t4 < s2; a3 = t4++) {
            const s3 = i3[t4], o3 = i3[a3], l3 = s3.x * o3.y - o3.x * s3.y;
            r3 += (s3.x + o3.x) * l3, n3 += (s3.y + o3.y) * l3, e3 += 3 * l3;
          }
          return new dh(r3 / e3, n3 / e3, 0, t3);
        }(t2), f2 = h2.length;
        for (;h2.length; ) {
          const n3 = h2.pop();
          (n3.d > p2.d || !p2.d) && (p2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, f2)), n3.max - p2.d <= e2 || (c2 = n3.h / 2, h2.push(new dh(n3.p.x - c2, n3.p.y - c2, c2, t2)), h2.push(new dh(n3.p.x + c2, n3.p.y - c2, c2, t2)), h2.push(new dh(n3.p.x - c2, n3.p.y + c2, c2, t2)), h2.push(new dh(n3.p.x + c2, n3.p.y + c2, c2, t2)), f2 += 4);
        }
        return r2 && (console.log(`num probes: ${f2}`), console.log(`best distance: ${p2.d}`)), p2.p;
      }
      function fh(t2, e2) {
        return e2.max - t2.max;
      }
      function dh(t2, e2, r2, n2) {
        this.p = new s(t2, e2), this.h = r2, this.d = function(t3, e3) {
          let r3 = false, n3 = 1 / 0;
          for (let i2 = 0;i2 < e3.length; i2++) {
            const s2 = e3[i2];
            for (let e4 = 0, i3 = s2.length, a2 = i3 - 1;e4 < i3; a2 = e4++) {
              const i4 = s2[e4], o2 = s2[a2];
              i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, Ya(t3, i4, o2));
            }
          }
          return (r3 ? 1 : -1) * Math.sqrt(n3);
        }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
      }
      var yh;
      t.aq = undefined, (yh = t.aq || (t.aq = {}))[yh.center = 1] = "center", yh[yh.left = 2] = "left", yh[yh.right = 3] = "right", yh[yh.top = 4] = "top", yh[yh.bottom = 5] = "bottom", yh[yh["top-left"] = 6] = "top-left", yh[yh["top-right"] = 7] = "top-right", yh[yh["bottom-left"] = 8] = "bottom-left", yh[yh["bottom-right"] = 9] = "bottom-right";
      const mh = 7, gh = Number.POSITIVE_INFINITY;
      function xh(t2, e2) {
        return e2[1] !== gh ? function(t3, e3, r2) {
          let n2 = 0, i2 = 0;
          switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t3) {
            case "top-right":
            case "top-left":
            case "top":
              i2 = r2 - mh;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              i2 = -r2 + mh;
          }
          switch (t3) {
            case "top-right":
            case "bottom-right":
            case "right":
              n2 = -e3;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              n2 = e3;
          }
          return [n2, i2];
        }(t2, e2[0], e2[1]) : function(t3, e3) {
          let r2 = 0, n2 = 0;
          e3 < 0 && (e3 = 0);
          const i2 = e3 / Math.SQRT2;
          switch (t3) {
            case "top-right":
            case "top-left":
              n2 = i2 - mh;
              break;
            case "bottom-right":
            case "bottom-left":
              n2 = -i2 + mh;
              break;
            case "bottom":
              n2 = -e3 + mh;
              break;
            case "top":
              n2 = e3 - mh;
          }
          switch (t3) {
            case "top-right":
            case "bottom-right":
              r2 = -i2;
              break;
            case "top-left":
            case "bottom-left":
              r2 = i2;
              break;
            case "left":
              r2 = e3;
              break;
            case "right":
              r2 = -e3;
          }
          return [r2, n2];
        }(t2, e2[0]);
      }
      function vh(t2, e2, r2) {
        var n2;
        const i2 = t2.layout, s2 = (n2 = i2.get("text-variable-anchor-offset")) === null || n2 === undefined ? undefined : n2.evaluate(e2, {}, r2);
        if (s2) {
          const t3 = s2.values, e3 = [];
          for (let r3 = 0;r3 < t3.length; r3 += 2) {
            const n3 = e3[r3] = t3[r3], i3 = t3[r3 + 1].map((t4) => t4 * iu);
            n3.startsWith("top") ? i3[1] -= mh : n3.startsWith("bottom") && (i3[1] += mh), e3[r3 + 1] = i3;
          }
          return new Qt(e3);
        }
        const a2 = i2.get("text-variable-anchor");
        if (a2) {
          let n3;
          n3 = t2._unevaluatedLayout.getValue("text-radial-offset") !== undefined ? [i2.get("text-radial-offset").evaluate(e2, {}, r2) * iu, gh] : i2.get("text-offset").evaluate(e2, {}, r2).map((t3) => t3 * iu);
          const s3 = [];
          for (const t3 of a2)
            s3.push(t3, xh(t3, n3));
          return new Qt(s3);
        }
        return null;
      }
      function bh(t2) {
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function wh(e2, r2, n2, i2, s2, a2, o2, l2, u5, c2, h2) {
        let p2 = a2.textMaxSize.evaluate(r2, {});
        p2 === undefined && (p2 = o2);
        const f2 = e2.layers[0].layout, d2 = f2.get("icon-offset").evaluate(r2, {}, h2), y2 = Ah(n2.horizontal), m2 = o2 / 24, g2 = e2.tilePixelRatio * m2, x2 = e2.tilePixelRatio * p2 / 24, v3 = e2.tilePixelRatio * l2, b2 = e2.tilePixelRatio * f2.get("symbol-spacing"), w2 = f2.get("text-padding") * e2.tilePixelRatio, _2 = function(t2, e3, r3, n3 = 1) {
          const i3 = t2.get("icon-padding").evaluate(e3, {}, r3), s3 = i3 && i3.values;
          return [s3[0] * n3, s3[1] * n3, s3[2] * n3, s3[3] * n3];
        }(f2, r2, h2, e2.tilePixelRatio), S2 = f2.get("text-max-angle") / 180 * Math.PI, k2 = f2.get("text-rotation-alignment") !== "viewport" && f2.get("symbol-placement") !== "point", M2 = f2.get("icon-rotation-alignment") === "map" && f2.get("symbol-placement") !== "point", I2 = f2.get("symbol-placement"), z2 = b2 / 2, P2 = f2.get("icon-text-fit");
        let C3;
        i2 && P2 !== "none" && (e2.allowVerticalPlacement && n2.vertical && (C3 = ec(i2, n2.vertical, P2, f2.get("icon-text-fit-padding"), d2, m2)), y2 && (i2 = ec(i2, y2, P2, f2.get("icon-text-fit-padding"), d2, m2)));
        const B3 = (l3, p3) => {
          p3.x < 0 || p3.x >= $a || p3.y < 0 || p3.y >= $a || function(e3, r3, n3, i3, s3, a3, o3, l4, u6, c3, h3, p4, f3, d3, y3, m3, g3, x3, v4, b3, w3, _3, S3, k3, M3) {
            const I3 = e3.addToLineVertexArray(r3, n3);
            let z3, P3, C4, B4, V2 = 0, E2 = 0, F2 = 0, T2 = 0, $2 = -1, L2 = -1;
            const D3 = {};
            let O2 = ma("");
            if (e3.allowVerticalPlacement && i3.vertical) {
              const t2 = l4.layout.get("text-rotate").evaluate(w3, {}, k3) + 90;
              C4 = new ch(u6, r3, c3, h3, p4, i3.vertical, f3, d3, y3, t2), o3 && (B4 = new ch(u6, r3, c3, h3, p4, o3, g3, x3, y3, t2));
            }
            if (s3) {
              const n4 = l4.layout.get("icon-rotate").evaluate(w3, {}), i4 = l4.layout.get("icon-text-fit") !== "none", a4 = sh(s3, n4, S3, i4), f4 = o3 ? sh(o3, n4, S3, i4) : undefined;
              P3 = new ch(u6, r3, c3, h3, p4, s3, g3, x3, false, n4), V2 = 4 * a4.length;
              const d4 = e3.iconSizeData;
              let y4 = null;
              d4.kind === "source" ? (y4 = [nc * l4.layout.get("icon-size").evaluate(w3, {})], y4[0] > ic && A(`${e3.layerIds[0]}: Value for "icon-size" is >= ${rc}. Reduce your "icon-size".`)) : d4.kind === "composite" && (y4 = [nc * _3.compositeIconSizes[0].evaluate(w3, {}, k3), nc * _3.compositeIconSizes[1].evaluate(w3, {}, k3)], (y4[0] > ic || y4[1] > ic) && A(`${e3.layerIds[0]}: Value for "icon-size" is >= ${rc}. Reduce your "icon-size".`)), e3.addSymbols(e3.icon, a4, y4, b3, v4, w3, t.ah.none, r3, I3.lineStartIndex, I3.lineLength, -1, k3), $2 = e3.icon.placedSymbolArray.length - 1, f4 && (E2 = 4 * f4.length, e3.addSymbols(e3.icon, f4, y4, b3, v4, w3, t.ah.vertical, r3, I3.lineStartIndex, I3.lineLength, -1, k3), L2 = e3.icon.placedSymbolArray.length - 1);
            }
            const j2 = Object.keys(i3.horizontal);
            for (const n4 of j2) {
              const s4 = i3.horizontal[n4];
              if (!z3) {
                O2 = ma(s4.text);
                const t2 = l4.layout.get("text-rotate").evaluate(w3, {}, k3);
                z3 = new ch(u6, r3, c3, h3, p4, s4, f3, d3, y3, t2);
              }
              const o4 = s4.positionedLines.length === 1;
              if (F2 += _h(e3, r3, s4, a3, l4, y3, w3, m3, I3, i3.vertical ? t.ah.horizontal : t.ah.horizontalOnly, o4 ? j2 : [n4], D3, $2, _3, k3), o4)
                break;
            }
            i3.vertical && (T2 += _h(e3, r3, i3.vertical, a3, l4, y3, w3, m3, I3, t.ah.vertical, ["vertical"], D3, L2, _3, k3));
            const R2 = z3 ? z3.boxStartIndex : e3.collisionBoxArray.length, U2 = z3 ? z3.boxEndIndex : e3.collisionBoxArray.length, q2 = C4 ? C4.boxStartIndex : e3.collisionBoxArray.length, N2 = C4 ? C4.boxEndIndex : e3.collisionBoxArray.length, Z2 = P3 ? P3.boxStartIndex : e3.collisionBoxArray.length, G2 = P3 ? P3.boxEndIndex : e3.collisionBoxArray.length, K2 = B4 ? B4.boxStartIndex : e3.collisionBoxArray.length, X2 = B4 ? B4.boxEndIndex : e3.collisionBoxArray.length;
            let H2 = -1;
            const Y2 = (t2, e4) => t2 && t2.circleDiameter ? Math.max(t2.circleDiameter, e4) : e4;
            H2 = Y2(z3, H2), H2 = Y2(C4, H2), H2 = Y2(P3, H2), H2 = Y2(B4, H2);
            const J2 = H2 > -1 ? 1 : 0;
            J2 && (H2 *= M3 / iu), e3.glyphOffsetArray.length >= dc.MAX_GLYPHS && A("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), w3.sortKey !== undefined && e3.addToSortKeyRanges(e3.symbolInstances.length, w3.sortKey);
            const W2 = vh(l4, w3, k3), [Q2, tt2] = function(e4, r4) {
              const n4 = e4.length, i4 = r4 == null ? undefined : r4.values;
              if ((i4 == null ? undefined : i4.length) > 0)
                for (let r5 = 0;r5 < i4.length; r5 += 2) {
                  const n5 = i4[r5 + 1];
                  e4.emplaceBack(t.aq[i4[r5]], n5[0], n5[1]);
                }
              return [n4, e4.length];
            }(e3.textAnchorOffsets, W2);
            e3.symbolInstances.emplaceBack(r3.x, r3.y, D3.right >= 0 ? D3.right : -1, D3.center >= 0 ? D3.center : -1, D3.left >= 0 ? D3.left : -1, D3.vertical || -1, $2, L2, O2, R2, U2, q2, N2, Z2, G2, K2, X2, c3, F2, T2, V2, E2, J2, 0, f3, H2, Q2, tt2);
          }(e2, p3, l3, n2, i2, s2, C3, e2.layers[0], e2.collisionBoxArray, r2.index, r2.sourceLayerIndex, e2.index, g2, [w2, w2, w2, w2], k2, u5, v3, _2, M2, d2, r2, a2, c2, h2, o2);
        };
        if (I2 === "line")
          for (const t2 of Hc(r2.geometry, 0, 0, $a, $a)) {
            const r3 = rh(t2, b2, S2, n2.vertical || y2, i2, 24, x2, e2.overscaling, $a);
            for (const n3 of r3)
              y2 && Sh(e2, y2.text, z2, n3) || B3(t2, n3);
          }
        else if (I2 === "line-center") {
          for (const t2 of r2.geometry)
            if (t2.length > 1) {
              const e3 = eh(t2, S2, n2.vertical || y2, i2, 24, x2);
              e3 && B3(t2, e3);
            }
        } else if (r2.type === "Polygon")
          for (const t2 of xr(r2.geometry, 0)) {
            const e3 = ph(t2, 16);
            B3(t2[0], new Yc(e3.x, e3.y, 0));
          }
        else if (r2.type === "LineString")
          for (const t2 of r2.geometry)
            B3(t2, new Yc(t2[0].x, t2[0].y, 0));
        else if (r2.type === "Point")
          for (const t2 of r2.geometry)
            for (const e3 of t2)
              B3([e3], new Yc(e3.x, e3.y, 0));
      }
      function _h(t2, e2, r2, n2, i2, a2, o2, l2, u5, c2, h2, p2, f2, d2, y2) {
        const m2 = function(t3, e3, r3, n3, i3, a3, o3, l3) {
          const u6 = n3.layout.get("text-rotate").evaluate(a3, {}) * Math.PI / 180, c3 = [];
          for (const t4 of e3.positionedLines)
            for (const n4 of t4.positionedGlyphs) {
              if (!n4.rect)
                continue;
              const a4 = n4.rect || {};
              let h3 = Vu + 1, p3 = true, f3 = 1, d3 = 0;
              const y3 = (i3 || l3) && n4.vertical, m3 = n4.metrics.advance * n4.scale / 2;
              if (l3 && e3.verticalizable && (d3 = t4.lineOffset / 2 - (n4.imageName ? -(iu - n4.metrics.width * n4.scale) / 2 : (n4.scale - 1) * iu)), n4.imageName) {
                const t5 = o3[n4.imageName];
                p3 = t5.sdf, f3 = t5.pixelRatio, h3 = Fu / f3;
              }
              const g3 = i3 ? [n4.x + m3, n4.y] : [0, 0];
              let x3 = i3 ? [0, 0] : [n4.x + m3 + r3[0], n4.y + r3[1] - d3], v3 = [0, 0];
              y3 && (v3 = x3, x3 = [0, 0]);
              const b2 = n4.metrics.isDoubleResolution ? 2 : 1, w2 = (n4.metrics.left - h3) * n4.scale - m3 + x3[0], _2 = (-n4.metrics.top - h3) * n4.scale + x3[1], A2 = w2 + a4.w / b2 * n4.scale / f3, S2 = _2 + a4.h / b2 * n4.scale / f3, k2 = new s(w2, _2), M2 = new s(A2, _2), I2 = new s(w2, S2), z2 = new s(A2, S2);
              if (y3) {
                const t5 = new s(-m3, m3 - Du), e4 = -Math.PI / 2, r4 = iu / 2 - m3, i4 = new s(5 - Du - r4, -(n4.imageName ? r4 : 0)), a5 = new s(...v3);
                k2._rotateAround(e4, t5)._add(i4)._add(a5), M2._rotateAround(e4, t5)._add(i4)._add(a5), I2._rotateAround(e4, t5)._add(i4)._add(a5), z2._rotateAround(e4, t5)._add(i4)._add(a5);
              }
              if (u6) {
                const t5 = Math.sin(u6), e4 = Math.cos(u6), r4 = [e4, -t5, t5, e4];
                k2._matMult(r4), M2._matMult(r4), I2._matMult(r4), z2._matMult(r4);
              }
              const P2 = new s(0, 0), C3 = new s(0, 0);
              c3.push({ tl: k2, tr: M2, bl: I2, br: z2, tex: a4, writingMode: e3.writingMode, glyphOffset: g3, sectionIndex: n4.sectionIndex, isSDF: p3, pixelOffsetTL: P2, pixelOffsetBR: C3, minFontScaleX: 0, minFontScaleY: 0 });
            }
          return c3;
        }(0, r2, l2, i2, a2, o2, n2, t2.allowVerticalPlacement), g2 = t2.textSizeData;
        let x2 = null;
        g2.kind === "source" ? (x2 = [nc * i2.layout.get("text-size").evaluate(o2, {})], x2[0] > ic && A(`${t2.layerIds[0]}: Value for "text-size" is >= ${rc}. Reduce your "text-size".`)) : g2.kind === "composite" && (x2 = [nc * d2.compositeTextSizes[0].evaluate(o2, {}, y2), nc * d2.compositeTextSizes[1].evaluate(o2, {}, y2)], (x2[0] > ic || x2[1] > ic) && A(`${t2.layerIds[0]}: Value for "text-size" is >= ${rc}. Reduce your "text-size".`)), t2.addSymbols(t2.text, m2, x2, l2, a2, o2, c2, e2, u5.lineStartIndex, u5.lineLength, f2, y2);
        for (const e3 of h2)
          p2[e3] = t2.text.placedSymbolArray.length - 1;
        return 4 * m2.length;
      }
      function Ah(t2) {
        for (const e2 in t2)
          return t2[e2];
        return null;
      }
      function Sh(t2, e2, r2, n2) {
        const i2 = t2.compareText;
        if (e2 in i2) {
          const t3 = i2[e2];
          for (let e3 = t3.length - 1;e3 >= 0; e3--)
            if (n2.dist(t3[e3]) < r2)
              return true;
        } else
          i2[e2] = [];
        return i2[e2].push(n2), false;
      }
      const kh = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];

      class Mh {
        static from(t2) {
          if (!(t2 instanceof ArrayBuffer))
            throw new Error("Data must be an instance of ArrayBuffer.");
          const [e2, r2] = new Uint8Array(t2, 0, 2);
          if (e2 !== 219)
            throw new Error("Data does not appear to be in a KDBush format.");
          const n2 = r2 >> 4;
          if (n2 !== 1)
            throw new Error(`Got v${n2} data when expected v1.`);
          const i2 = kh[15 & r2];
          if (!i2)
            throw new Error("Unrecognized array type.");
          const [s2] = new Uint16Array(t2, 2, 1), [a2] = new Uint32Array(t2, 4, 1);
          return new Mh(a2, s2, i2, t2);
        }
        constructor(t2, e2 = 64, r2 = Float64Array, n2) {
          if (isNaN(t2) || t2 < 0)
            throw new Error(`Unpexpected numItems value: ${t2}.`);
          this.numItems = +t2, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t2 < 65536 ? Uint16Array : Uint32Array;
          const i2 = kh.indexOf(this.ArrayType), s2 = 2 * t2 * this.ArrayType.BYTES_PER_ELEMENT, a2 = t2 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - a2 % 8) % 8;
          if (i2 < 0)
            throw new Error(`Unexpected typed array class: ${r2}.`);
          n2 && n2 instanceof ArrayBuffer ? (this.data = n2, this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 2 * t2, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + a2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t2);
        }
        add(t2, e2) {
          const r2 = this._pos >> 1;
          return this.ids[r2] = r2, this.coords[this._pos++] = t2, this.coords[this._pos++] = e2, r2;
        }
        finish() {
          const t2 = this._pos >> 1;
          if (t2 !== this.numItems)
            throw new Error(`Added ${t2} items when expected ${this.numItems}.`);
          return Ih(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
        }
        range(t2, e2, r2, n2) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: i2, coords: s2, nodeSize: a2 } = this, o2 = [0, i2.length - 1, 0], l2 = [];
          for (;o2.length; ) {
            const u5 = o2.pop() || 0, c2 = o2.pop() || 0, h2 = o2.pop() || 0;
            if (c2 - h2 <= a2) {
              for (let a3 = h2;a3 <= c2; a3++) {
                const o3 = s2[2 * a3], u6 = s2[2 * a3 + 1];
                o3 >= t2 && o3 <= r2 && u6 >= e2 && u6 <= n2 && l2.push(i2[a3]);
              }
              continue;
            }
            const p2 = h2 + c2 >> 1, f2 = s2[2 * p2], d2 = s2[2 * p2 + 1];
            f2 >= t2 && f2 <= r2 && d2 >= e2 && d2 <= n2 && l2.push(i2[p2]), (u5 === 0 ? t2 <= f2 : e2 <= d2) && (o2.push(h2), o2.push(p2 - 1), o2.push(1 - u5)), (u5 === 0 ? r2 >= f2 : n2 >= d2) && (o2.push(p2 + 1), o2.push(c2), o2.push(1 - u5));
          }
          return l2;
        }
        within(t2, e2, r2) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: n2, coords: i2, nodeSize: s2 } = this, a2 = [0, n2.length - 1, 0], o2 = [], l2 = r2 * r2;
          for (;a2.length; ) {
            const u5 = a2.pop() || 0, c2 = a2.pop() || 0, h2 = a2.pop() || 0;
            if (c2 - h2 <= s2) {
              for (let r3 = h2;r3 <= c2; r3++)
                Bh(i2[2 * r3], i2[2 * r3 + 1], t2, e2) <= l2 && o2.push(n2[r3]);
              continue;
            }
            const p2 = h2 + c2 >> 1, f2 = i2[2 * p2], d2 = i2[2 * p2 + 1];
            Bh(f2, d2, t2, e2) <= l2 && o2.push(n2[p2]), (u5 === 0 ? t2 - r2 <= f2 : e2 - r2 <= d2) && (a2.push(h2), a2.push(p2 - 1), a2.push(1 - u5)), (u5 === 0 ? t2 + r2 >= f2 : e2 + r2 >= d2) && (a2.push(p2 + 1), a2.push(c2), a2.push(1 - u5));
          }
          return o2;
        }
      }
      function Ih(t2, e2, r2, n2, i2, s2) {
        if (i2 - n2 <= r2)
          return;
        const a2 = n2 + i2 >> 1;
        zh(t2, e2, a2, n2, i2, s2), Ih(t2, e2, r2, n2, a2 - 1, 1 - s2), Ih(t2, e2, r2, a2 + 1, i2, 1 - s2);
      }
      function zh(t2, e2, r2, n2, i2, s2) {
        for (;i2 > n2; ) {
          if (i2 - n2 > 600) {
            const a3 = i2 - n2 + 1, o3 = r2 - n2 + 1, l3 = Math.log(a3), u5 = 0.5 * Math.exp(2 * l3 / 3), c2 = 0.5 * Math.sqrt(l3 * u5 * (a3 - u5) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
            zh(t2, e2, r2, Math.max(n2, Math.floor(r2 - o3 * u5 / a3 + c2)), Math.min(i2, Math.floor(r2 + (a3 - o3) * u5 / a3 + c2)), s2);
          }
          const a2 = e2[2 * r2 + s2];
          let o2 = n2, l2 = i2;
          for (Ph(t2, e2, n2, r2), e2[2 * i2 + s2] > a2 && Ph(t2, e2, n2, i2);o2 < l2; ) {
            for (Ph(t2, e2, o2, l2), o2++, l2--;e2[2 * o2 + s2] < a2; )
              o2++;
            for (;e2[2 * l2 + s2] > a2; )
              l2--;
          }
          e2[2 * n2 + s2] === a2 ? Ph(t2, e2, n2, l2) : (l2++, Ph(t2, e2, l2, i2)), l2 <= r2 && (n2 = l2 + 1), r2 <= l2 && (i2 = l2 - 1);
        }
      }
      function Ph(t2, e2, r2, n2) {
        Ch(t2, r2, n2), Ch(e2, 2 * r2, 2 * n2), Ch(e2, 2 * r2 + 1, 2 * n2 + 1);
      }
      function Ch(t2, e2, r2) {
        const n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      function Bh(t2, e2, r2, n2) {
        const i2 = t2 - r2, s2 = e2 - n2;
        return i2 * i2 + s2 * s2;
      }
      var Vh;
      t.bg = undefined, (Vh = t.bg || (t.bg = {})).create = "create", Vh.load = "load", Vh.fullLoad = "fullLoad";
      let Eh = null, Fh = [];
      const Th = 1000 / 60, $h = "loadTime", Lh = "fullLoadTime", Dh = { mark(t2) {
        performance.mark(t2);
      }, frame(t2) {
        const e2 = t2;
        Eh != null && Fh.push(e2 - Eh), Eh = e2;
      }, clearMetrics() {
        Eh = null, Fh = [], performance.clearMeasures($h), performance.clearMeasures(Lh);
        for (const e2 in t.bg)
          performance.clearMarks(t.bg[e2]);
      }, getPerformanceMetrics() {
        performance.measure($h, t.bg.create, t.bg.load), performance.measure(Lh, t.bg.create, t.bg.fullLoad);
        const e2 = performance.getEntriesByName($h)[0].duration, r2 = performance.getEntriesByName(Lh)[0].duration, n2 = Fh.length, i2 = 1 / (Fh.reduce((t2, e3) => t2 + e3, 0) / n2 / 1000), s2 = Fh.filter((t2) => t2 > Th).reduce((t2, e3) => t2 + (e3 - Th) / Th, 0);
        return { loadTime: e2, fullLoadTime: r2, fps: i2, percentDroppedFrames: s2 / (n2 + s2) * 100, totalFrames: n2 };
      } };
      t.$ = class extends ps {
      }, t.A = oo, t.B = yi, t.C = function(t2) {
        if (M == null) {
          const e2 = t2.navigator ? t2.navigator.userAgent : null;
          M = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
        }
        return M;
      }, t.D = Ji, t.E = Z, t.F = class {
        constructor(t2, e2) {
          this.target = t2, this.mapId = e2, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Ic(() => this.process()), this.subscription = function(t3, e3, r2, n2) {
            return t3.addEventListener(e3, r2, false), { unsubscribe: () => {
              t3.removeEventListener(e3, r2, false);
            } };
          }(this.target, "message", (t3) => this.receive(t3)), this.globalScope = k(self) ? t2 : window;
        }
        registerMessageHandler(t2, e2) {
          this.messageHandlers[t2] = e2;
        }
        sendAsync(t2, e2) {
          return new Promise((r2, n2) => {
            const i2 = Math.round(1000000000000000000 * Math.random()).toString(36).substring(0, 10);
            this.resolveRejects[i2] = { resolve: r2, reject: n2 }, e2 && e2.signal.addEventListener("abort", () => {
              delete this.resolveRejects[i2];
              const e3 = { id: i2, type: "<cancel>", origin: location.origin, targetMapId: t2.targetMapId, sourceMapId: this.mapId };
              this.target.postMessage(e3);
            }, { once: true });
            const s2 = [], a2 = Object.assign(Object.assign({}, t2), { id: i2, sourceMapId: this.mapId, origin: location.origin, data: ki(t2.data, s2) });
            this.target.postMessage(a2, { transfer: s2 });
          });
        }
        receive(t2) {
          const e2 = t2.data, r2 = e2.id;
          if (!(e2.origin !== "file://" && location.origin !== "file://" && e2.origin !== "resource://android" && location.origin !== "resource://android" && e2.origin !== location.origin || e2.targetMapId && this.mapId !== e2.targetMapId)) {
            if (e2.type === "<cancel>") {
              delete this.tasks[r2];
              const t3 = this.abortControllers[r2];
              return delete this.abortControllers[r2], void (t3 && t3.abort());
            }
            if (k(self) || e2.mustQueue)
              return this.tasks[r2] = e2, this.taskQueue.push(r2), void this.invoker.trigger();
            this.processTask(r2, e2);
          }
        }
        process() {
          if (this.taskQueue.length === 0)
            return;
          const t2 = this.taskQueue.shift(), e2 = this.tasks[t2];
          delete this.tasks[t2], this.taskQueue.length > 0 && this.invoker.trigger(), e2 && this.processTask(t2, e2);
        }
        processTask(t2, r2) {
          return e(this, undefined, undefined, function* () {
            if (r2.type === "<response>") {
              const e3 = this.resolveRejects[t2];
              if (delete this.resolveRejects[t2], !e3)
                return;
              return void (r2.error ? e3.reject(Mi(r2.error)) : e3.resolve(Mi(r2.data)));
            }
            if (!this.messageHandlers[r2.type])
              return void this.completeTask(t2, new Error(`Could not find a registered handler for ${r2.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
            const e2 = Mi(r2.data), n2 = new AbortController;
            this.abortControllers[t2] = n2;
            try {
              const i2 = yield this.messageHandlers[r2.type](r2.sourceMapId, e2, n2);
              this.completeTask(t2, null, i2);
            } catch (e3) {
              this.completeTask(t2, e3);
            }
          });
        }
        completeTask(t2, e2, r2) {
          const n2 = [];
          delete this.abortControllers[t2];
          const i2 = { id: t2, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: e2 ? ki(e2) : null, data: ki(r2, n2) };
          this.target.postMessage(i2, { transfer: n2 });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, t.G = $, t.H = function() {
        var t2 = new oo(16);
        return oo != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
      }, t.I = Tu, t.J = function(t2, e2, r2) {
        var n2, i2, s2, a2, o2, l2, u5, c2, h2, p2, f2, d2, y2 = r2[0], m2 = r2[1], g2 = r2[2];
        return e2 === t2 ? (t2[12] = e2[0] * y2 + e2[4] * m2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y2 + e2[5] * m2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y2 + e2[6] * m2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y2 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u5 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u5, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * y2 + o2 * m2 + h2 * g2 + e2[12], t2[13] = i2 * y2 + l2 * m2 + p2 * g2 + e2[13], t2[14] = s2 * y2 + u5 * m2 + f2 * g2 + e2[14], t2[15] = a2 * y2 + c2 * m2 + d2 * g2 + e2[15]), t2;
      }, t.K = function(t2, e2, r2) {
        var n2 = r2[0], i2 = r2[1], s2 = r2[2];
        return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
      }, t.L = uo, t.M = function(t2, e2) {
        const r2 = {};
        for (let n2 = 0;n2 < e2.length; n2++) {
          const i2 = e2[n2];
          i2 in t2 && (r2[i2] = t2[i2]);
        }
        return r2;
      }, t.N = Pc, t.O = Vc, t.P = s, t.Q = Ec, t.R = Ao, t.S = jc, t.T = Zi, t.U = h, t.V = p, t.W = P, t.X = $a, t.Y = ls, t.Z = $c, t._ = e, t.a = F, t.a$ = function(t2, e2) {
        var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = t2[4], o2 = t2[5], l2 = t2[6], u5 = t2[7], c2 = t2[8], h2 = t2[9], p2 = t2[10], f2 = t2[11], d2 = t2[12], y2 = t2[13], m2 = t2[14], g2 = t2[15], x2 = e2[0], v3 = e2[1], b2 = e2[2], w2 = e2[3], _2 = e2[4], A2 = e2[5], S2 = e2[6], k2 = e2[7], M2 = e2[8], I2 = e2[9], z2 = e2[10], P2 = e2[11], C3 = e2[12], B3 = e2[13], V2 = e2[14], E2 = e2[15];
        return Math.abs(r2 - x2) <= ao * Math.max(1, Math.abs(r2), Math.abs(x2)) && Math.abs(n2 - v3) <= ao * Math.max(1, Math.abs(n2), Math.abs(v3)) && Math.abs(i2 - b2) <= ao * Math.max(1, Math.abs(i2), Math.abs(b2)) && Math.abs(s2 - w2) <= ao * Math.max(1, Math.abs(s2), Math.abs(w2)) && Math.abs(a2 - _2) <= ao * Math.max(1, Math.abs(a2), Math.abs(_2)) && Math.abs(o2 - A2) <= ao * Math.max(1, Math.abs(o2), Math.abs(A2)) && Math.abs(l2 - S2) <= ao * Math.max(1, Math.abs(l2), Math.abs(S2)) && Math.abs(u5 - k2) <= ao * Math.max(1, Math.abs(u5), Math.abs(k2)) && Math.abs(c2 - M2) <= ao * Math.max(1, Math.abs(c2), Math.abs(M2)) && Math.abs(h2 - I2) <= ao * Math.max(1, Math.abs(h2), Math.abs(I2)) && Math.abs(p2 - z2) <= ao * Math.max(1, Math.abs(p2), Math.abs(z2)) && Math.abs(f2 - P2) <= ao * Math.max(1, Math.abs(f2), Math.abs(P2)) && Math.abs(d2 - C3) <= ao * Math.max(1, Math.abs(d2), Math.abs(C3)) && Math.abs(y2 - B3) <= ao * Math.max(1, Math.abs(y2), Math.abs(B3)) && Math.abs(m2 - V2) <= ao * Math.max(1, Math.abs(m2), Math.abs(V2)) && Math.abs(g2 - E2) <= ao * Math.max(1, Math.abs(g2), Math.abs(E2));
      }, t.a0 = oa, t.a1 = Dc, t.a2 = it, t.a3 = (t2) => {
        const e2 = window.document.createElement("video");
        return e2.muted = true, new Promise((r2) => {
          e2.onloadstart = () => {
            r2(e2);
          };
          for (const r3 of t2) {
            const t3 = window.document.createElement("source");
            j(r3) || (e2.crossOrigin = "Anonymous"), t3.src = r3, e2.appendChild(t3);
          }
        });
      }, t.a4 = function() {
        return x++;
      }, t.a5 = Fs, t.a6 = dc, t.a7 = zn, t.a8 = ja, t.a9 = Nc, t.aA = function(t2) {
        if (t2.type === "custom")
          return new Mc(t2);
        switch (t2.type) {
          case "background":
            return new _c(t2);
          case "circle":
            return new fo(t2);
          case "fill":
            return new ul(t2);
          case "fill-extrusion":
            return new El(t2);
          case "heatmap":
            return new Mo(t2);
          case "hillshade":
            return new Po(t2);
          case "line":
            return new Hl(t2);
          case "raster":
            return new kc(t2);
          case "symbol":
            return new vc(t2);
        }
      }, t.aB = w, t.aC = function(t2, e2) {
        if (!t2)
          return [{ command: "setStyle", args: [e2] }];
        let r2 = [];
        try {
          if (!H(t2.version, e2.version))
            return [{ command: "setStyle", args: [e2] }];
          H(t2.center, e2.center) || r2.push({ command: "setCenter", args: [e2.center] }), H(t2.zoom, e2.zoom) || r2.push({ command: "setZoom", args: [e2.zoom] }), H(t2.bearing, e2.bearing) || r2.push({ command: "setBearing", args: [e2.bearing] }), H(t2.pitch, e2.pitch) || r2.push({ command: "setPitch", args: [e2.pitch] }), H(t2.sprite, e2.sprite) || r2.push({ command: "setSprite", args: [e2.sprite] }), H(t2.glyphs, e2.glyphs) || r2.push({ command: "setGlyphs", args: [e2.glyphs] }), H(t2.transition, e2.transition) || r2.push({ command: "setTransition", args: [e2.transition] }), H(t2.light, e2.light) || r2.push({ command: "setLight", args: [e2.light] }), H(t2.terrain, e2.terrain) || r2.push({ command: "setTerrain", args: [e2.terrain] }), H(t2.sky, e2.sky) || r2.push({ command: "setSky", args: [e2.sky] }), H(t2.projection, e2.projection) || r2.push({ command: "setProjection", args: [e2.projection] });
          const n2 = {}, i2 = [];
          (function(t3, e3, r3, n3) {
            let i3;
            for (i3 in e3 = e3 || {}, t3 = t3 || {})
              Object.prototype.hasOwnProperty.call(t3, i3) && (Object.prototype.hasOwnProperty.call(e3, i3) || W(i3, r3, n3));
            for (i3 in e3)
              Object.prototype.hasOwnProperty.call(e3, i3) && (Object.prototype.hasOwnProperty.call(t3, i3) ? H(t3[i3], e3[i3]) || (t3[i3].type === "geojson" && e3[i3].type === "geojson" && tt(t3, e3, i3) ? Y(r3, { command: "setGeoJSONSourceData", args: [i3, e3[i3].data] }) : Q(i3, e3, r3, n3)) : J(i3, e3, r3));
          })(t2.sources, e2.sources, i2, n2);
          const s2 = [];
          t2.layers && t2.layers.forEach((t3) => {
            "source" in t3 && n2[t3.source] ? r2.push({ command: "removeLayer", args: [t3.id] }) : s2.push(t3);
          }), r2 = r2.concat(i2), function(t3, e3, r3) {
            e3 = e3 || [];
            const n3 = (t3 = t3 || []).map(rt), i3 = e3.map(rt), s3 = t3.reduce(nt, {}), a2 = e3.reduce(nt, {}), o2 = n3.slice(), l2 = Object.create(null);
            let u5, c2, h2, p2, f2;
            for (let t4 = 0, e4 = 0;t4 < n3.length; t4++)
              u5 = n3[t4], Object.prototype.hasOwnProperty.call(a2, u5) ? e4++ : (Y(r3, { command: "removeLayer", args: [u5] }), o2.splice(o2.indexOf(u5, e4), 1));
            for (let t4 = 0, e4 = 0;t4 < i3.length; t4++)
              u5 = i3[i3.length - 1 - t4], o2[o2.length - 1 - t4] !== u5 && (Object.prototype.hasOwnProperty.call(s3, u5) ? (Y(r3, { command: "removeLayer", args: [u5] }), o2.splice(o2.lastIndexOf(u5, o2.length - e4), 1)) : e4++, p2 = o2[o2.length - t4], Y(r3, { command: "addLayer", args: [a2[u5], p2] }), o2.splice(o2.length - t4, 0, u5), l2[u5] = true);
            for (let t4 = 0;t4 < i3.length; t4++)
              if (u5 = i3[t4], c2 = s3[u5], h2 = a2[u5], !l2[u5] && !H(c2, h2))
                if (H(c2.source, h2.source) && H(c2["source-layer"], h2["source-layer"]) && H(c2.type, h2.type)) {
                  for (f2 in et(c2.layout, h2.layout, r3, u5, null, "setLayoutProperty"), et(c2.paint, h2.paint, r3, u5, null, "setPaintProperty"), H(c2.filter, h2.filter) || Y(r3, { command: "setFilter", args: [u5, h2.filter] }), H(c2.minzoom, h2.minzoom) && H(c2.maxzoom, h2.maxzoom) || Y(r3, { command: "setLayerZoomRange", args: [u5, h2.minzoom, h2.maxzoom] }), c2)
                    Object.prototype.hasOwnProperty.call(c2, f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? et(c2[f2], h2[f2], r3, u5, f2.slice(6), "setPaintProperty") : H(c2[f2], h2[f2]) || Y(r3, { command: "setLayerProperty", args: [u5, f2, h2[f2]] }));
                  for (f2 in h2)
                    Object.prototype.hasOwnProperty.call(h2, f2) && !Object.prototype.hasOwnProperty.call(c2, f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? et(c2[f2], h2[f2], r3, u5, f2.slice(6), "setPaintProperty") : H(c2[f2], h2[f2]) || Y(r3, { command: "setLayerProperty", args: [u5, f2, h2[f2]] }));
                } else
                  Y(r3, { command: "removeLayer", args: [u5] }), p2 = o2[o2.lastIndexOf(u5) + 1], Y(r3, { command: "addLayer", args: [h2, p2] });
          }(s2, e2.layers, r2);
        } catch (t3) {
          console.warn("Unable to compute style diff:", t3), r2 = [{ command: "setStyle", args: [e2] }];
        }
        return r2;
      }, t.aD = function(t2) {
        const e2 = [], r2 = t2.id;
        return r2 === undefined && e2.push({ message: `layers.${r2}: missing required property "id"` }), t2.render === undefined && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && t2.renderingMode !== "2d" && t2.renderingMode !== "3d" && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
      }, t.aE = function t(e2, r2) {
        if (Array.isArray(e2)) {
          if (!Array.isArray(r2) || e2.length !== r2.length)
            return false;
          for (let n2 = 0;n2 < e2.length; n2++)
            if (!t(e2[n2], r2[n2]))
              return false;
          return true;
        }
        if (typeof e2 == "object" && e2 !== null && r2 !== null) {
          if (typeof r2 != "object")
            return false;
          if (Object.keys(e2).length !== Object.keys(r2).length)
            return false;
          for (const n2 in e2)
            if (!t(e2[n2], r2[n2]))
              return false;
          return true;
        }
        return e2 === r2;
      }, t.aF = v2, t.aG = b, t.aH = class extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = 0;
        }
        set(t2) {
          this.current !== t2 && (this.current = t2, this.gl.uniform1i(this.location, t2));
        }
      }, t.aI = _a, t.aJ = class extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = ka;
        }
        set(t2) {
          if (t2[12] !== this.current[12] || t2[0] !== this.current[0])
            return this.current = t2, void this.gl.uniformMatrix4fv(this.location, false, t2);
          for (let e2 = 1;e2 < 16; e2++)
            if (t2[e2] !== this.current[e2]) {
              this.current = t2, this.gl.uniformMatrix4fv(this.location, false, t2);
              break;
            }
        }
      }, t.aK = Aa, t.aL = Sa, t.aM = Kt, t.aN = class extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = [0, 0, 0];
        }
        set(t2) {
          t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] || (this.current = t2, this.gl.uniform3f(this.location, t2[0], t2[1], t2[2]));
        }
      }, t.aO = class extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = [0, 0];
        }
        set(t2) {
          t2[0] === this.current[0] && t2[1] === this.current[1] || (this.current = t2, this.gl.uniform2f(this.location, t2[0], t2[1]));
        }
      }, t.aP = function(t2, e2, r2, n2, i2, s2, a2) {
        var o2 = 1 / (e2 - r2), l2 = 1 / (n2 - i2), u5 = 1 / (s2 - a2);
        return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u5, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u5, t2[15] = 1, t2;
      }, t.aQ = ho, t.aR = class extends _s {
      }, t.aS = eu, t.aT = class extends Ss {
      }, t.aU = ko, t.aV = function(t2) {
        return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
      }, t.aW = So, t.aX = Zs, t.aY = na, t.aZ = class extends Bs {
      }, t.a_ = function(t2, e2) {
        return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3] && t2[4] === e2[4] && t2[5] === e2[5] && t2[6] === e2[6] && t2[7] === e2[7] && t2[8] === e2[8] && t2[9] === e2[9] && t2[10] === e2[10] && t2[11] === e2[11] && t2[12] === e2[12] && t2[13] === e2[13] && t2[14] === e2[14] && t2[15] === e2[15];
      }, t.aa = function(t2) {
        const e2 = {};
        if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
          const s2 = n2 || i2;
          return e2[r2] = !s2 || s2.toLowerCase(), "";
        }), e2["max-age"]) {
          const t3 = parseInt(e2["max-age"], 10);
          isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
        }
        return e2;
      }, t.ab = function(t2, e2) {
        const r2 = [];
        for (const n2 in t2)
          n2 in e2 || r2.push(n2);
        return r2;
      }, t.ac = y, t.ad = function(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u5 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
        return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u5 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u5 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
      }, t.ae = function(t2) {
        var e2 = new oo(16);
        return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
      }, t.af = po, t.ag = function(t2, e2) {
        let r2 = 0, n2 = 0;
        if (t2.kind === "constant")
          n2 = t2.layoutSize;
        else if (t2.kind !== "source") {
          const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? y(Be.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
          t2.kind === "camera" ? n2 = Ce.number(t2.minSize, t2.maxSize, o2) : r2 = o2;
        }
        return { uSizeT: r2, uSize: n2 };
      }, t.ai = function(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
        return t2.kind === "source" ? n2 / nc : t2.kind === "composite" ? Ce.number(n2 / nc, i2 / nc, r2) : e2;
      }, t.aj = cc2, t.ak = function(t2, e2, r2, n2) {
        const i2 = e2.y - t2.y, a2 = e2.x - t2.x, o2 = n2.y - r2.y, l2 = n2.x - r2.x, u5 = o2 * a2 - l2 * i2;
        if (u5 === 0)
          return null;
        const c2 = (l2 * (t2.y - r2.y) - o2 * (t2.x - r2.x)) / u5;
        return new s(t2.x + c2 * a2, t2.y + c2 * i2);
      }, t.al = Hc, t.am = qa, t.an = lo, t.ao = function(t2) {
        let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
        for (const s2 of t2)
          e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
        return [e2, r2, n2, i2];
      }, t.ap = iu, t.ar = ac2, t.as = function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u5 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], f2 = e2[11], d2 = e2[12], y2 = e2[13], m2 = e2[14], g2 = e2[15], x2 = r2 * o2 - n2 * a2, v3 = r2 * l2 - i2 * a2, b2 = r2 * u5 - s2 * a2, w2 = n2 * l2 - i2 * o2, _2 = n2 * u5 - s2 * o2, A2 = i2 * u5 - s2 * l2, S2 = c2 * y2 - h2 * d2, k2 = c2 * m2 - p2 * d2, M2 = c2 * g2 - f2 * d2, I2 = h2 * m2 - p2 * y2, z2 = h2 * g2 - f2 * y2, P2 = p2 * g2 - f2 * m2, C3 = x2 * P2 - v3 * z2 + b2 * I2 + w2 * M2 - _2 * k2 + A2 * S2;
        return C3 ? (t2[0] = (o2 * P2 - l2 * z2 + u5 * I2) * (C3 = 1 / C3), t2[1] = (i2 * z2 - n2 * P2 - s2 * I2) * C3, t2[2] = (y2 * A2 - m2 * _2 + g2 * w2) * C3, t2[3] = (p2 * _2 - h2 * A2 - f2 * w2) * C3, t2[4] = (l2 * M2 - a2 * P2 - u5 * k2) * C3, t2[5] = (r2 * P2 - i2 * M2 + s2 * k2) * C3, t2[6] = (m2 * b2 - d2 * A2 - g2 * v3) * C3, t2[7] = (c2 * A2 - p2 * b2 + f2 * v3) * C3, t2[8] = (a2 * z2 - o2 * M2 + u5 * S2) * C3, t2[9] = (n2 * M2 - r2 * z2 - s2 * S2) * C3, t2[10] = (d2 * _2 - y2 * b2 + g2 * x2) * C3, t2[11] = (h2 * b2 - c2 * _2 - f2 * x2) * C3, t2[12] = (o2 * k2 - a2 * I2 - l2 * S2) * C3, t2[13] = (r2 * I2 - n2 * k2 + i2 * S2) * C3, t2[14] = (y2 * v3 - d2 * w2 - m2 * x2) * C3, t2[15] = (c2 * w2 - h2 * v3 + p2 * x2) * C3, t2) : null;
      }, t.at = bh, t.au = Ju, t.av = Mh, t.aw = function() {
        const t2 = {}, e2 = G.$version;
        for (const r2 in G.$root) {
          const n2 = G.$root[r2];
          if (n2.required) {
            let i2 = null;
            i2 = r2 === "version" ? e2 : n2.type === "array" ? [] : {}, i2 != null && (t2[r2] = i2);
          }
        }
        return t2;
      }, t.ax = Ii, t.ay = D2, t.az = function(t2) {
        t2 = t2.slice();
        const e2 = Object.create(null);
        for (let r2 = 0;r2 < t2.length; r2++)
          e2[t2[r2].id] = t2[r2];
        for (let r2 = 0;r2 < t2.length; r2++)
          "ref" in t2[r2] && (t2[r2] = X(t2[r2], e2[t2[r2].ref]));
        return t2;
      }, t.b = I, t.b0 = function(t2, e2) {
        return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
      }, t.b1 = function(t2, e2, r2) {
        return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2[3] = e2[3] * r2[3], t2;
      }, t.b2 = function(t2, e2) {
        return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] * e2[3];
      }, t.b3 = m, t.b4 = Oc, t.b5 = Fc, t.b6 = function(t2, e2, r2, n2, i2) {
        var s2, a2 = 1 / Math.tan(e2 / 2);
        return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, i2 != null && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
      }, t.b7 = function(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], u5 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
        return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u5 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u5 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
      }, t.b8 = f, t.b9 = d, t.bA = su, t.bB = function(t2) {
        return t2.message === V;
      }, t.bC = bn, t.bD = Ri, t.ba = function(t2) {
        return t2 * Math.PI / 180;
      }, t.bb = function(t2, e2) {
        const { x: r2, y: n2 } = $c.fromLngLat(e2);
        return !(t2 < 0 || t2 > 25 || n2 < 0 || n2 >= 1 || r2 < 0 || r2 >= 1);
      }, t.bc = function(t2, e2) {
        return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }, t.bd = class extends hs {
      }, t.be = zc, t.bf = Dh, t.bh = L, t.bi = function(t2, e2) {
        F.REGISTERED_PROTOCOLS[t2] = e2;
      }, t.bj = function(t2) {
        delete F.REGISTERED_PROTOCOLS[t2];
      }, t.bk = function(t2, e2) {
        const r2 = {};
        for (let n3 = 0;n3 < t2.length; n3++) {
          const i2 = e2 && e2[t2[n3].id] || Ln(t2[n3]);
          e2 && (e2[t2[n3].id] = i2);
          let s2 = r2[i2];
          s2 || (s2 = r2[i2] = []), s2.push(t2[n3]);
        }
        const n2 = [];
        for (const t3 in r2)
          n2.push(r2[t3]);
        return n2;
      }, t.bl = wi, t.bm = qc, t.bn = Zc, t.bo = $u, t.bp = function(e2) {
        e2.bucket.createArrays(), e2.bucket.tilePixelRatio = $a / (512 * e2.bucket.overscaling), e2.bucket.compareText = {}, e2.bucket.iconsNeedLinear = false;
        const r2 = e2.bucket.layers[0], n2 = r2.layout, i2 = r2._unevaluatedLayout._values, s2 = { layoutIconSize: i2["icon-size"].possiblyEvaluate(new Ui(e2.bucket.zoom + 1), e2.canonical), layoutTextSize: i2["text-size"].possiblyEvaluate(new Ui(e2.bucket.zoom + 1), e2.canonical), textMaxSize: i2["text-size"].possiblyEvaluate(new Ui(18)) };
        if (e2.bucket.textSizeData.kind === "composite") {
          const { minZoom: t2, maxZoom: r3 } = e2.bucket.textSizeData;
          s2.compositeTextSizes = [i2["text-size"].possiblyEvaluate(new Ui(t2), e2.canonical), i2["text-size"].possiblyEvaluate(new Ui(r3), e2.canonical)];
        }
        if (e2.bucket.iconSizeData.kind === "composite") {
          const { minZoom: t2, maxZoom: r3 } = e2.bucket.iconSizeData;
          s2.compositeIconSizes = [i2["icon-size"].possiblyEvaluate(new Ui(t2), e2.canonical), i2["icon-size"].possiblyEvaluate(new Ui(r3), e2.canonical)];
        }
        const a2 = n2.get("text-line-height") * iu, o2 = n2.get("text-rotation-alignment") !== "viewport" && n2.get("symbol-placement") !== "point", l2 = n2.get("text-keep-upright"), u5 = n2.get("text-size");
        for (const i3 of e2.bucket.features) {
          const c2 = n2.get("text-font").evaluate(i3, {}, e2.canonical).join(","), h2 = u5.evaluate(i3, {}, e2.canonical), p2 = s2.layoutTextSize.evaluate(i3, {}, e2.canonical), f2 = s2.layoutIconSize.evaluate(i3, {}, e2.canonical), d2 = { horizontal: {}, vertical: undefined }, y2 = i3.text;
          let m2, g2 = [0, 0];
          if (y2) {
            const s3 = y2.toString(), u6 = n2.get("text-letter-spacing").evaluate(i3, {}, e2.canonical) * iu, f3 = Ci(s3) ? u6 : 0, m3 = n2.get("text-anchor").evaluate(i3, {}, e2.canonical), x3 = vh(r2, i3, e2.canonical);
            if (!x3) {
              const t2 = n2.get("text-radial-offset").evaluate(i3, {}, e2.canonical);
              g2 = t2 ? xh(m3, [t2 * iu, gh]) : n2.get("text-offset").evaluate(i3, {}, e2.canonical).map((t3) => t3 * iu);
            }
            let v4 = o2 ? "center" : n2.get("text-justify").evaluate(i3, {}, e2.canonical);
            const b2 = n2.get("symbol-placement") === "point" ? n2.get("text-max-width").evaluate(i3, {}, e2.canonical) * iu : 1 / 0, w2 = () => {
              e2.bucket.allowVerticalPlacement && Pi(s3) && (d2.vertical = Ru(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, "left", f3, g2, t.ah.vertical, true, p2, h2));
            };
            if (!o2 && x3) {
              const r3 = new Set;
              if (v4 === "auto")
                for (let t2 = 0;t2 < x3.values.length; t2 += 2)
                  r3.add(bh(x3.values[t2]));
              else
                r3.add(v4);
              let n3 = false;
              for (const i4 of r3)
                if (!d2.horizontal[i4])
                  if (n3)
                    d2.horizontal[i4] = d2.horizontal[0];
                  else {
                    const r4 = Ru(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, "center", i4, f3, g2, t.ah.horizontal, false, p2, h2);
                    r4 && (d2.horizontal[i4] = r4, n3 = r4.positionedLines.length === 1);
                  }
              w2();
            } else {
              v4 === "auto" && (v4 = bh(m3));
              const r3 = Ru(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, v4, f3, g2, t.ah.horizontal, false, p2, h2);
              r3 && (d2.horizontal[v4] = r3), w2(), Pi(s3) && o2 && l2 && (d2.vertical = Ru(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, v4, f3, g2, t.ah.vertical, false, p2, h2));
            }
          }
          let x2 = false;
          if (i3.icon && i3.icon.name) {
            const t2 = e2.imageMap[i3.icon.name];
            t2 && (m2 = Qu(e2.imagePositions[i3.icon.name], n2.get("icon-offset").evaluate(i3, {}, e2.canonical), n2.get("icon-anchor").evaluate(i3, {}, e2.canonical)), x2 = !!t2.sdf, e2.bucket.sdfIcons === undefined ? e2.bucket.sdfIcons = x2 : e2.bucket.sdfIcons !== x2 && A("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t2.pixelRatio !== e2.bucket.pixelRatio || n2.get("icon-rotate").constantOr(1) !== 0) && (e2.bucket.iconsNeedLinear = true));
          }
          const v3 = Ah(d2.horizontal) || d2.vertical;
          e2.bucket.iconsInText = !!v3 && v3.iconsInText, (v3 || m2) && wh(e2.bucket, i3, d2, m2, e2.imageMap, s2, p2, f2, g2, x2, e2.canonical);
        }
        e2.showCollisionBoxes && e2.bucket.generateCollisionDebugBuffers();
      }, t.bq = ql, t.br = sl, t.bs = zl, t.bt = fl, t.bu = Iu, t.bv = class {
        constructor(t2) {
          this._marks = { start: [t2.url, "start"].join("#"), end: [t2.url, "end"].join("#"), measure: t2.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let t2 = performance.getEntriesByName(this._marks.measure);
          return t2.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t2;
        }
      }, t.bw = function(t2, r2, n2, i2, s2) {
        return e(this, undefined, undefined, function* () {
          if (p())
            try {
              return yield P(t2, r2, n2, i2, s2);
            } catch (t3) {
            }
          return function(t3, e2, r3, n3, i3) {
            const { width: s3, height: a2 } = t3;
            C && B2 || (C = new OffscreenCanvas(s3, a2), B2 = C.getContext("2d", { willReadFrequently: true })), C.width = s3, C.height = a2, B2.drawImage(t3, 0, 0, s3, a2);
            const o2 = B2.getImageData(e2, r3, n3, i3);
            return B2.clearRect(0, 0, s3, a2), o2.data;
          }(t2, r2, n2, i2, s2);
        });
      }, t.bx = Uc, t.by = r, t.bz = n, t.c = E, t.d = (t2) => e(undefined, undefined, undefined, function* () {
        if (t2.byteLength === 0)
          return createImageBitmap(new ImageData(1, 1));
        const e2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
        try {
          return createImageBitmap(e2);
        } catch (t3) {
          throw new Error(`Could not load image because of ${t3.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      }), t.e = g, t.f = (t2) => new Promise((e2, r2) => {
        const n2 = new Image;
        n2.onload = () => {
          e2(n2), URL.revokeObjectURL(n2.src), n2.onload = null, window.requestAnimationFrame(() => {
            n2.src = z;
          });
        }, n2.onerror = () => r2(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const i2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
        n2.src = t2.byteLength ? URL.createObjectURL(i2) : z;
      }), t.g = T, t.h = (t2, e2) => O(g(t2, { type: "json" }), e2), t.i = k, t.j = N, t.k = q, t.l = (t2, e2) => O(g(t2, { type: "arrayBuffer" }), e2), t.m = O, t.n = function(t2) {
        return new Iu(t2).readFields(Pu, []);
      }, t.o = _o, t.p = Eu, t.q = rs, t.r = di, t.s = j, t.t = xi, t.u = fi, t.v = G, t.w = A, t.x = function([t2, e2, r2]) {
        return e2 += 90, e2 *= Math.PI / 180, r2 *= Math.PI / 180, { x: t2 * Math.cos(e2) * Math.sin(r2), y: t2 * Math.sin(e2) * Math.sin(r2), z: t2 * Math.cos(r2) };
      }, t.y = Ce, t.z = Ui;
    });
    define2("worker", ["./shared"], function(e) {

      class t {
        constructor(e2) {
          this.keyCache = {}, e2 && this.replace(e2);
        }
        replace(e2) {
          this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
        }
        update(t2, o2) {
          for (const o3 of t2) {
            this._layerConfigs[o3.id] = o3;
            const t3 = this._layers[o3.id] = e.aA(o3);
            t3._featureFilter = e.a7(t3.filter), this.keyCache[o3.id] && delete this.keyCache[o3.id];
          }
          for (const e2 of o2)
            delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
          this.familiesBySource = {};
          const i2 = e.bk(Object.values(this._layerConfigs), this.keyCache);
          for (const e2 of i2) {
            const t3 = e2.map((e3) => this._layers[e3.id]), o3 = t3[0];
            if (o3.visibility === "none")
              continue;
            const i3 = o3.source || "";
            let s2 = this.familiesBySource[i3];
            s2 || (s2 = this.familiesBySource[i3] = {});
            const r2 = o3.sourceLayer || "_geojsonTileLayer";
            let n2 = s2[r2];
            n2 || (n2 = s2[r2] = []), n2.push(t3);
          }
        }
      }

      class o {
        constructor(t2) {
          const o2 = {}, i2 = [];
          for (const e2 in t2) {
            const s3 = t2[e2], r3 = o2[e2] = {};
            for (const e3 in s3) {
              const t3 = s3[+e3];
              if (!t3 || t3.bitmap.width === 0 || t3.bitmap.height === 0)
                continue;
              const o3 = { x: 0, y: 0, w: t3.bitmap.width + 2, h: t3.bitmap.height + 2 };
              i2.push(o3), r3[e3] = { rect: o3, metrics: t3.metrics };
            }
          }
          const { w: s2, h: r2 } = e.p(i2), n2 = new e.o({ width: s2 || 1, height: r2 || 1 });
          for (const i3 in t2) {
            const s3 = t2[i3];
            for (const t3 in s3) {
              const r3 = s3[+t3];
              if (!r3 || r3.bitmap.width === 0 || r3.bitmap.height === 0)
                continue;
              const a2 = o2[i3][t3].rect;
              e.o.copy(r3.bitmap, n2, { x: 0, y: 0 }, { x: a2.x + 1, y: a2.y + 1 }, r3.bitmap);
            }
          }
          this.image = n2, this.positions = o2;
        }
      }
      e.bl("GlyphAtlas", o);

      class i {
        constructor(t2) {
          this.tileID = new e.S(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.inFlightDependencies = [];
        }
        parse(t2, i2, r2, n2) {
          return e._(this, undefined, undefined, function* () {
            this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.a5;
            const a2 = new e.bm(Object.keys(t2.layers).sort()), l2 = new e.bn(this.tileID, this.promoteId);
            l2.bucketLayerIDs = [];
            const c2 = {}, u5 = { featureIndex: l2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: r2 }, h2 = i2.familiesBySource[this.source];
            for (const o2 in h2) {
              const i3 = t2.layers[o2];
              if (!i3)
                continue;
              i3.version === 1 && e.w(`Vector tile source "${this.source}" layer "${o2}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const n3 = a2.encode(o2), d3 = [];
              for (let e2 = 0;e2 < i3.length; e2++) {
                const t3 = i3.feature(e2), s2 = l2.getId(t3, o2);
                d3.push({ feature: t3, id: s2, index: e2, sourceLayerIndex: n3 });
              }
              for (const t3 of h2[o2]) {
                const o3 = t3[0];
                o3.source !== this.source && e.w(`layer.source = ${o3.source} does not equal this.source = ${this.source}`), o3.minzoom && this.zoom < Math.floor(o3.minzoom) || o3.maxzoom && this.zoom >= o3.maxzoom || o3.visibility !== "none" && (s(t3, this.zoom, r2), (c2[o3.id] = o3.createBucket({ index: l2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n3, sourceID: this.source })).populate(d3, u5, this.tileID.canonical), l2.bucketLayerIDs.push(t3.map((e2) => e2.id)));
              }
            }
            const d2 = e.aF(u5.glyphDependencies, (e2) => Object.keys(e2).map(Number));
            this.inFlightDependencies.forEach((e2) => e2 == null ? undefined : e2.abort()), this.inFlightDependencies = [];
            let f2 = Promise.resolve({});
            if (Object.keys(d2).length) {
              const e2 = new AbortController;
              this.inFlightDependencies.push(e2), f2 = n2.sendAsync({ type: "GG", data: { stacks: d2, source: this.source, tileID: this.tileID, type: "glyphs" } }, e2);
            }
            const g2 = Object.keys(u5.iconDependencies);
            let p2 = Promise.resolve({});
            if (g2.length) {
              const e2 = new AbortController;
              this.inFlightDependencies.push(e2), p2 = n2.sendAsync({ type: "GI", data: { icons: g2, source: this.source, tileID: this.tileID, type: "icons" } }, e2);
            }
            const m2 = Object.keys(u5.patternDependencies);
            let y2 = Promise.resolve({});
            if (m2.length) {
              const e2 = new AbortController;
              this.inFlightDependencies.push(e2), y2 = n2.sendAsync({ type: "GI", data: { icons: m2, source: this.source, tileID: this.tileID, type: "patterns" } }, e2);
            }
            const [v3, w2, x2] = yield Promise.all([f2, p2, y2]), b2 = new o(v3), S2 = new e.bo(w2, x2);
            for (const t3 in c2) {
              const o2 = c2[t3];
              o2 instanceof e.a6 ? (s(o2.layers, this.zoom, r2), e.bp({ bucket: o2, glyphMap: v3, glyphPositions: b2.positions, imageMap: w2, imagePositions: S2.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : o2.hasPattern && (o2 instanceof e.bq || o2 instanceof e.br || o2 instanceof e.bs) && (s(o2.layers, this.zoom, r2), o2.addFeatures(u5, this.tileID.canonical, S2.patternPositions));
            }
            return this.status = "done", { buckets: Object.values(c2).filter((e2) => !e2.isEmpty()), featureIndex: l2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: b2.image, imageAtlas: S2, glyphMap: this.returnDependencies ? v3 : null, iconMap: this.returnDependencies ? w2 : null, glyphPositions: this.returnDependencies ? b2.positions : null };
          });
        }
      }
      function s(t2, o2, i2) {
        const s2 = new e.z(o2);
        for (const e2 of t2)
          e2.recalculate(s2, i2);
      }

      class r {
        constructor(e2, t2, o2) {
          this.actor = e2, this.layerIndex = t2, this.availableImages = o2, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            const i2 = yield e.l(t2.request, o2);
            try {
              return { vectorTile: new e.bt.VectorTile(new e.bu(i2.data)), rawData: i2.data, cacheControl: i2.cacheControl, expires: i2.expires };
            } catch (e2) {
              const o3 = new Uint8Array(i2.data);
              let s2 = `Unable to parse the tile at ${t2.request.url}, `;
              throw s2 += o3[0] === 31 && o3[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e2.message}`, new Error(s2);
            }
          });
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const o2 = t2.uid, s2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.bv(t2.request), r2 = new i(t2);
            this.loading[o2] = r2;
            const n2 = new AbortController;
            r2.abort = n2;
            try {
              const i2 = yield this.loadVectorTile(t2, n2);
              if (delete this.loading[o2], !i2)
                return null;
              const a2 = i2.rawData, l2 = {};
              i2.expires && (l2.expires = i2.expires), i2.cacheControl && (l2.cacheControl = i2.cacheControl);
              const c2 = {};
              if (s2) {
                const e2 = s2.finish();
                e2 && (c2.resourceTiming = JSON.parse(JSON.stringify(e2)));
              }
              r2.vectorTile = i2.vectorTile;
              const u5 = r2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor);
              this.loaded[o2] = r2, this.fetching[o2] = { rawTileData: a2, cacheControl: l2, resourceTiming: c2 };
              try {
                const t3 = yield u5;
                return e.e({ rawTileData: a2.slice(0) }, t3, l2, c2);
              } finally {
                delete this.fetching[o2];
              }
            } catch (e2) {
              throw delete this.loading[o2], r2.status = "done", this.loaded[o2] = r2, e2;
            }
          });
        }
        reloadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const o2 = t2.uid;
            if (!this.loaded || !this.loaded[o2])
              throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
            const i2 = this.loaded[o2];
            if (i2.showCollisionBoxes = t2.showCollisionBoxes, i2.status === "parsing") {
              const t3 = yield i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor);
              let s2;
              if (this.fetching[o2]) {
                const { rawTileData: i3, cacheControl: r2, resourceTiming: n2 } = this.fetching[o2];
                delete this.fetching[o2], s2 = e.e({ rawTileData: i3.slice(0) }, t3, r2, n2);
              } else
                s2 = t3;
              return s2;
            }
            if (i2.status === "done" && i2.vectorTile)
              return i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor);
          });
        }
        abortTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = this.loading, o2 = t2.uid;
            e2 && e2[o2] && e2[o2].abort && (e2[o2].abort.abort(), delete e2[o2]);
          });
        }
        removeTile(t2) {
          return e._(this, undefined, undefined, function* () {
            this.loaded && this.loaded[t2.uid] && delete this.loaded[t2.uid];
          });
        }
      }

      class n {
        constructor() {
          this.loaded = {};
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const { uid: o2, encoding: i2, rawImageData: s2, redFactor: r2, greenFactor: n2, blueFactor: a2, baseShift: l2 } = t2, c2 = s2.width + 2, u5 = s2.height + 2, h2 = e.b(s2) ? new e.R({ width: c2, height: u5 }, yield e.bw(s2, -1, -1, c2, u5)) : s2, d2 = new e.bx(o2, h2, i2, r2, n2, a2, l2);
            return this.loaded = this.loaded || {}, this.loaded[o2] = d2, d2;
          });
        }
        removeTile(e2) {
          const t2 = this.loaded, o2 = e2.uid;
          t2 && t2[o2] && delete t2[o2];
        }
      }
      function a(e2, t2) {
        if (e2.length !== 0) {
          l(e2[0], t2);
          for (var o2 = 1;o2 < e2.length; o2++)
            l(e2[o2], !t2);
        }
      }
      function l(e2, t2) {
        for (var o2 = 0, i2 = 0, s2 = 0, r2 = e2.length, n2 = r2 - 1;s2 < r2; n2 = s2++) {
          var a2 = (e2[s2][0] - e2[n2][0]) * (e2[n2][1] + e2[s2][1]), l2 = o2 + a2;
          i2 += Math.abs(o2) >= Math.abs(a2) ? o2 - l2 + a2 : a2 - l2 + o2, o2 = l2;
        }
        o2 + i2 >= 0 != !!t2 && e2.reverse();
      }
      var c = e.by(function e(t2, o2) {
        var i2, s2 = t2 && t2.type;
        if (s2 === "FeatureCollection")
          for (i2 = 0;i2 < t2.features.length; i2++)
            e(t2.features[i2], o2);
        else if (s2 === "GeometryCollection")
          for (i2 = 0;i2 < t2.geometries.length; i2++)
            e(t2.geometries[i2], o2);
        else if (s2 === "Feature")
          e(t2.geometry, o2);
        else if (s2 === "Polygon")
          a(t2.coordinates, o2);
        else if (s2 === "MultiPolygon")
          for (i2 = 0;i2 < t2.coordinates.length; i2++)
            a(t2.coordinates[i2], o2);
        return t2;
      });
      const u4 = e.bt.VectorTileFeature.prototype.toGeoJSON;
      var h = { exports: {} }, d = e.bz, f = e.bt.VectorTileFeature, g = p;
      function p(e2, t2) {
        this.options = t2 || {}, this.features = e2, this.length = e2.length;
      }
      function m(e2, t2) {
        this.id = typeof e2.id == "number" ? e2.id : undefined, this.type = e2.type, this.rawGeometry = e2.type === 1 ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
      }
      p.prototype.feature = function(e2) {
        return new m(this.features[e2], this.options.extent);
      }, m.prototype.loadGeometry = function() {
        var e2 = this.rawGeometry;
        this.geometry = [];
        for (var t2 = 0;t2 < e2.length; t2++) {
          for (var o2 = e2[t2], i2 = [], s2 = 0;s2 < o2.length; s2++)
            i2.push(new d(o2[s2][0], o2[s2][1]));
          this.geometry.push(i2);
        }
        return this.geometry;
      }, m.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var e2 = this.geometry, t2 = 1 / 0, o2 = -1 / 0, i2 = 1 / 0, s2 = -1 / 0, r2 = 0;r2 < e2.length; r2++)
          for (var n2 = e2[r2], a2 = 0;a2 < n2.length; a2++) {
            var l2 = n2[a2];
            t2 = Math.min(t2, l2.x), o2 = Math.max(o2, l2.x), i2 = Math.min(i2, l2.y), s2 = Math.max(s2, l2.y);
          }
        return [t2, i2, o2, s2];
      }, m.prototype.toGeoJSON = f.prototype.toGeoJSON;
      var y = e.bA, v2 = g;
      function w(e2) {
        var t2 = new y;
        return function(e3, t3) {
          for (var o2 in e3.layers)
            t3.writeMessage(3, x, e3.layers[o2]);
        }(e2, t2), t2.finish();
      }
      function x(e2, t2) {
        var o2;
        t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
        var i2 = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (o2 = 0;o2 < e2.length; o2++)
          i2.feature = e2.feature(o2), t2.writeMessage(2, b, i2);
        var s2 = i2.keys;
        for (o2 = 0;o2 < s2.length; o2++)
          t2.writeStringField(3, s2[o2]);
        var r2 = i2.values;
        for (o2 = 0;o2 < r2.length; o2++)
          t2.writeMessage(4, P, r2[o2]);
      }
      function b(e2, t2) {
        var o2 = e2.feature;
        o2.id !== undefined && t2.writeVarintField(1, o2.id), t2.writeMessage(2, S, e2), t2.writeVarintField(3, o2.type), t2.writeMessage(4, I, o2);
      }
      function S(e2, t2) {
        var { feature: o2, keys: i2, values: s2, keycache: r2, valuecache: n2 } = e2;
        for (var a2 in o2.properties) {
          var l2 = o2.properties[a2], c2 = r2[a2];
          if (l2 !== null) {
            c2 === undefined && (i2.push(a2), r2[a2] = c2 = i2.length - 1), t2.writeVarint(c2);
            var u5 = typeof l2;
            u5 !== "string" && u5 !== "boolean" && u5 !== "number" && (l2 = JSON.stringify(l2));
            var h2 = u5 + ":" + l2, d2 = n2[h2];
            d2 === undefined && (s2.push(l2), n2[h2] = d2 = s2.length - 1), t2.writeVarint(d2);
          }
        }
      }
      function _(e2, t2) {
        return (t2 << 3) + (7 & e2);
      }
      function M(e2) {
        return e2 << 1 ^ e2 >> 31;
      }
      function I(e2, t2) {
        for (var o2 = e2.loadGeometry(), i2 = e2.type, s2 = 0, r2 = 0, n2 = o2.length, a2 = 0;a2 < n2; a2++) {
          var l2 = o2[a2], c2 = 1;
          i2 === 1 && (c2 = l2.length), t2.writeVarint(_(1, c2));
          for (var u5 = i2 === 3 ? l2.length - 1 : l2.length, h2 = 0;h2 < u5; h2++) {
            h2 === 1 && i2 !== 1 && t2.writeVarint(_(2, u5 - 1));
            var d2 = l2[h2].x - s2, f2 = l2[h2].y - r2;
            t2.writeVarint(M(d2)), t2.writeVarint(M(f2)), s2 += d2, r2 += f2;
          }
          i2 === 3 && t2.writeVarint(_(7, 1));
        }
      }
      function P(e2, t2) {
        var o2 = typeof e2;
        o2 === "string" ? t2.writeStringField(1, e2) : o2 === "boolean" ? t2.writeBooleanField(7, e2) : o2 === "number" && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
      }
      h.exports = w, h.exports.fromVectorTileJs = w, h.exports.fromGeojsonVt = function(e2, t2) {
        t2 = t2 || {};
        var o2 = {};
        for (var i2 in e2)
          o2[i2] = new v2(e2[i2].features, t2), o2[i2].name = i2, o2[i2].version = t2.version, o2[i2].extent = t2.extent;
        return w({ layers: o2 });
      }, h.exports.GeoJSONWrapper = v2;
      var k = e.by(h.exports);
      const T = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, D2 = Math.fround || (C = new Float32Array(1), (e2) => (C[0] = +e2, C[0]));
      var C;
      const L = 3, O = 5, F = 6;

      class z {
        constructor(e2) {
          this.options = Object.assign(Object.create(T), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(e2) {
          const { log: t2, minZoom: o2, maxZoom: i2 } = this.options;
          t2 && console.time("total time");
          const s2 = `prepare ${e2.length} points`;
          t2 && console.time(s2), this.points = e2;
          const r2 = [];
          for (let t3 = 0;t3 < e2.length; t3++) {
            const o3 = e2[t3];
            if (!o3.geometry)
              continue;
            const [i3, s3] = o3.geometry.coordinates, n3 = D2(G(i3)), a2 = D2(j(s3));
            r2.push(n3, a2, 1 / 0, t3, -1, 1), this.options.reduce && r2.push(0);
          }
          let n2 = this.trees[i2 + 1] = this._createTree(r2);
          t2 && console.timeEnd(s2);
          for (let e3 = i2;e3 >= o2; e3--) {
            const o3 = +Date.now();
            n2 = this.trees[e3] = this._createTree(this._cluster(n2, e3)), t2 && console.log("z%d: %d clusters in %dms", e3, n2.numItems, +Date.now() - o3);
          }
          return t2 && console.timeEnd("total time"), this;
        }
        getClusters(e2, t2) {
          let o2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
          const i2 = Math.max(-90, Math.min(90, e2[1]));
          let s2 = e2[2] === 180 ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
          const r2 = Math.max(-90, Math.min(90, e2[3]));
          if (e2[2] - e2[0] >= 360)
            o2 = -180, s2 = 180;
          else if (o2 > s2) {
            const e3 = this.getClusters([o2, i2, 180, r2], t2), n3 = this.getClusters([-180, i2, s2, r2], t2);
            return e3.concat(n3);
          }
          const n2 = this.trees[this._limitZoom(t2)], a2 = n2.range(G(o2), j(r2), G(s2), j(i2)), l2 = n2.data, c2 = [];
          for (const e3 of a2) {
            const t3 = this.stride * e3;
            c2.push(l2[t3 + O] > 1 ? A(l2, t3, this.clusterProps) : this.points[l2[t3 + L]]);
          }
          return c2;
        }
        getChildren(e2) {
          const t2 = this._getOriginId(e2), o2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", s2 = this.trees[o2];
          if (!s2)
            throw new Error(i2);
          const r2 = s2.data;
          if (t2 * this.stride >= r2.length)
            throw new Error(i2);
          const n2 = this.options.radius / (this.options.extent * Math.pow(2, o2 - 1)), a2 = s2.within(r2[t2 * this.stride], r2[t2 * this.stride + 1], n2), l2 = [];
          for (const t3 of a2) {
            const o3 = t3 * this.stride;
            r2[o3 + 4] === e2 && l2.push(r2[o3 + O] > 1 ? A(r2, o3, this.clusterProps) : this.points[r2[o3 + L]]);
          }
          if (l2.length === 0)
            throw new Error(i2);
          return l2;
        }
        getLeaves(e2, t2, o2) {
          const i2 = [];
          return this._appendLeaves(i2, e2, t2 = t2 || 10, o2 = o2 || 0, 0), i2;
        }
        getTile(e2, t2, o2) {
          const i2 = this.trees[this._limitZoom(e2)], s2 = Math.pow(2, e2), { extent: r2, radius: n2 } = this.options, a2 = n2 / r2, l2 = (o2 - a2) / s2, c2 = (o2 + 1 + a2) / s2, u5 = { features: [] };
          return this._addTileFeatures(i2.range((t2 - a2) / s2, l2, (t2 + 1 + a2) / s2, c2), i2.data, t2, o2, s2, u5), t2 === 0 && this._addTileFeatures(i2.range(1 - a2 / s2, l2, 1, c2), i2.data, s2, o2, s2, u5), t2 === s2 - 1 && this._addTileFeatures(i2.range(0, l2, a2 / s2, c2), i2.data, -1, o2, s2, u5), u5.features.length ? u5 : null;
        }
        getClusterExpansionZoom(e2) {
          let t2 = this._getOriginZoom(e2) - 1;
          for (;t2 <= this.options.maxZoom; ) {
            const o2 = this.getChildren(e2);
            if (t2++, o2.length !== 1)
              break;
            e2 = o2[0].properties.cluster_id;
          }
          return t2;
        }
        _appendLeaves(e2, t2, o2, i2, s2) {
          const r2 = this.getChildren(t2);
          for (const t3 of r2) {
            const r3 = t3.properties;
            if (r3 && r3.cluster ? s2 + r3.point_count <= i2 ? s2 += r3.point_count : s2 = this._appendLeaves(e2, r3.cluster_id, o2, i2, s2) : s2 < i2 ? s2++ : e2.push(t3), e2.length === o2)
              break;
          }
          return s2;
        }
        _createTree(t2) {
          const o2 = new e.av(t2.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let e2 = 0;e2 < t2.length; e2 += this.stride)
            o2.add(t2[e2], t2[e2 + 1]);
          return o2.finish(), o2.data = t2, o2;
        }
        _addTileFeatures(e2, t2, o2, i2, s2, r2) {
          for (const n2 of e2) {
            const e3 = n2 * this.stride, a2 = t2[e3 + O] > 1;
            let l2, c2, u5;
            if (a2)
              l2 = E(t2, e3, this.clusterProps), c2 = t2[e3], u5 = t2[e3 + 1];
            else {
              const o3 = this.points[t2[e3 + L]];
              l2 = o3.properties;
              const [i3, s3] = o3.geometry.coordinates;
              c2 = G(i3), u5 = j(s3);
            }
            const h2 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * s2 - o2)), Math.round(this.options.extent * (u5 * s2 - i2))]], tags: l2 };
            let d2;
            d2 = a2 || this.options.generateId ? t2[e3 + L] : this.points[t2[e3 + L]].id, d2 !== undefined && (h2.id = d2), r2.features.push(h2);
          }
        }
        _limitZoom(e2) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
        }
        _cluster(e2, t2) {
          const { radius: o2, extent: i2, reduce: s2, minPoints: r2 } = this.options, n2 = o2 / (i2 * Math.pow(2, t2)), a2 = e2.data, l2 = [], c2 = this.stride;
          for (let o3 = 0;o3 < a2.length; o3 += c2) {
            if (a2[o3 + 2] <= t2)
              continue;
            a2[o3 + 2] = t2;
            const i3 = a2[o3], u5 = a2[o3 + 1], h2 = e2.within(a2[o3], a2[o3 + 1], n2), d2 = a2[o3 + O];
            let f2 = d2;
            for (const e3 of h2) {
              const o4 = e3 * c2;
              a2[o4 + 2] > t2 && (f2 += a2[o4 + O]);
            }
            if (f2 > d2 && f2 >= r2) {
              let e3, r3 = i3 * d2, n3 = u5 * d2, g2 = -1;
              const p2 = ((o3 / c2 | 0) << 5) + (t2 + 1) + this.points.length;
              for (const i4 of h2) {
                const l3 = i4 * c2;
                if (a2[l3 + 2] <= t2)
                  continue;
                a2[l3 + 2] = t2;
                const u6 = a2[l3 + O];
                r3 += a2[l3] * u6, n3 += a2[l3 + 1] * u6, a2[l3 + 4] = p2, s2 && (e3 || (e3 = this._map(a2, o3, true), g2 = this.clusterProps.length, this.clusterProps.push(e3)), s2(e3, this._map(a2, l3)));
              }
              a2[o3 + 4] = p2, l2.push(r3 / f2, n3 / f2, 1 / 0, p2, -1, f2), s2 && l2.push(g2);
            } else {
              for (let e3 = 0;e3 < c2; e3++)
                l2.push(a2[o3 + e3]);
              if (f2 > 1)
                for (const e3 of h2) {
                  const o4 = e3 * c2;
                  if (!(a2[o4 + 2] <= t2)) {
                    a2[o4 + 2] = t2;
                    for (let e4 = 0;e4 < c2; e4++)
                      l2.push(a2[o4 + e4]);
                  }
                }
            }
          }
          return l2;
        }
        _getOriginId(e2) {
          return e2 - this.points.length >> 5;
        }
        _getOriginZoom(e2) {
          return (e2 - this.points.length) % 32;
        }
        _map(e2, t2, o2) {
          if (e2[t2 + O] > 1) {
            const i3 = this.clusterProps[e2[t2 + F]];
            return o2 ? Object.assign({}, i3) : i3;
          }
          const i2 = this.points[e2[t2 + L]].properties, s2 = this.options.map(i2);
          return o2 && s2 === i2 ? Object.assign({}, s2) : s2;
        }
      }
      function A(e2, t2, o2) {
        return { type: "Feature", id: e2[t2 + L], properties: E(e2, t2, o2), geometry: { type: "Point", coordinates: [(i2 = e2[t2], 360 * (i2 - 0.5)), R(e2[t2 + 1])] } };
        var i2;
      }
      function E(e2, t2, o2) {
        const i2 = e2[t2 + O], s2 = i2 >= 1e4 ? `${Math.round(i2 / 1000)}k` : i2 >= 1000 ? Math.round(i2 / 100) / 10 + "k" : i2, r2 = e2[t2 + F], n2 = r2 === -1 ? {} : Object.assign({}, o2[r2]);
        return Object.assign(n2, { cluster: true, cluster_id: e2[t2 + L], point_count: i2, point_count_abbreviated: s2 });
      }
      function G(e2) {
        return e2 / 360 + 0.5;
      }
      function j(e2) {
        const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
      }
      function R(e2) {
        const t2 = (180 - 360 * e2) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
      }
      function Z(e2, t2, o2, i2) {
        let s2 = i2;
        const r2 = t2 + (o2 - t2 >> 1);
        let n2, a2 = o2 - t2;
        const l2 = e2[t2], c2 = e2[t2 + 1], u5 = e2[o2], h2 = e2[o2 + 1];
        for (let i3 = t2 + 3;i3 < o2; i3 += 3) {
          const t3 = N(e2[i3], e2[i3 + 1], l2, c2, u5, h2);
          if (t3 > s2)
            n2 = i3, s2 = t3;
          else if (t3 === s2) {
            const e3 = Math.abs(i3 - r2);
            e3 < a2 && (n2 = i3, a2 = e3);
          }
        }
        s2 > i2 && (n2 - t2 > 3 && Z(e2, t2, n2, i2), e2[n2 + 2] = s2, o2 - n2 > 3 && Z(e2, n2, o2, i2));
      }
      function N(e2, t2, o2, i2, s2, r2) {
        let n2 = s2 - o2, a2 = r2 - i2;
        if (n2 !== 0 || a2 !== 0) {
          const l2 = ((e2 - o2) * n2 + (t2 - i2) * a2) / (n2 * n2 + a2 * a2);
          l2 > 1 ? (o2 = s2, i2 = r2) : l2 > 0 && (o2 += n2 * l2, i2 += a2 * l2);
        }
        return n2 = e2 - o2, a2 = t2 - i2, n2 * n2 + a2 * a2;
      }
      function J(e2, t2, o2, i2) {
        const s2 = { id: e2 == null ? null : e2, type: t2, geometry: o2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if (t2 === "Point" || t2 === "MultiPoint" || t2 === "LineString")
          W(s2, o2);
        else if (t2 === "Polygon")
          W(s2, o2[0]);
        else if (t2 === "MultiLineString")
          for (const e3 of o2)
            W(s2, e3);
        else if (t2 === "MultiPolygon")
          for (const e3 of o2)
            W(s2, e3[0]);
        return s2;
      }
      function W(e2, t2) {
        for (let o2 = 0;o2 < t2.length; o2 += 3)
          e2.minX = Math.min(e2.minX, t2[o2]), e2.minY = Math.min(e2.minY, t2[o2 + 1]), e2.maxX = Math.max(e2.maxX, t2[o2]), e2.maxY = Math.max(e2.maxY, t2[o2 + 1]);
      }
      function Y(e2, t2, o2, i2) {
        if (!t2.geometry)
          return;
        const s2 = t2.geometry.coordinates;
        if (s2 && s2.length === 0)
          return;
        const r2 = t2.geometry.type, n2 = Math.pow(o2.tolerance / ((1 << o2.maxZoom) * o2.extent), 2);
        let a2 = [], l2 = t2.id;
        if (o2.promoteId ? l2 = t2.properties[o2.promoteId] : o2.generateId && (l2 = i2 || 0), r2 === "Point")
          V(s2, a2);
        else if (r2 === "MultiPoint")
          for (const e3 of s2)
            V(e3, a2);
        else if (r2 === "LineString")
          X(s2, a2, n2, false);
        else if (r2 === "MultiLineString") {
          if (o2.lineMetrics) {
            for (const o3 of s2)
              a2 = [], X(o3, a2, n2, false), e2.push(J(l2, "LineString", a2, t2.properties));
            return;
          }
          q(s2, a2, n2, false);
        } else if (r2 === "Polygon")
          q(s2, a2, n2, true);
        else {
          if (r2 !== "MultiPolygon") {
            if (r2 === "GeometryCollection") {
              for (const s3 of t2.geometry.geometries)
                Y(e2, { id: l2, geometry: s3, properties: t2.properties }, o2, i2);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const e3 of s2) {
            const t3 = [];
            q(e3, t3, n2, true), a2.push(t3);
          }
        }
        e2.push(J(l2, r2, a2, t2.properties));
      }
      function V(e2, t2) {
        t2.push(H(e2[0]), B2(e2[1]), 0);
      }
      function X(e2, t2, o2, i2) {
        let s2, r2, n2 = 0;
        for (let o3 = 0;o3 < e2.length; o3++) {
          const a3 = H(e2[o3][0]), l2 = B2(e2[o3][1]);
          t2.push(a3, l2, 0), o3 > 0 && (n2 += i2 ? (s2 * l2 - a3 * r2) / 2 : Math.sqrt(Math.pow(a3 - s2, 2) + Math.pow(l2 - r2, 2))), s2 = a3, r2 = l2;
        }
        const a2 = t2.length - 3;
        t2[2] = 1, Z(t2, 0, a2, o2), t2[a2 + 2] = 1, t2.size = Math.abs(n2), t2.start = 0, t2.end = t2.size;
      }
      function q(e2, t2, o2, i2) {
        for (let s2 = 0;s2 < e2.length; s2++) {
          const r2 = [];
          X(e2[s2], r2, o2, i2), t2.push(r2);
        }
      }
      function H(e2) {
        return e2 / 360 + 0.5;
      }
      function B2(e2) {
        const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
      }
      function U(e2, t2, o2, i2, s2, r2, n2, a2) {
        if (i2 /= t2, r2 >= (o2 /= t2) && n2 < i2)
          return e2;
        if (n2 < o2 || r2 >= i2)
          return null;
        const l2 = [];
        for (const t3 of e2) {
          const e3 = t3.geometry;
          let r3 = t3.type;
          const n3 = s2 === 0 ? t3.minX : t3.minY, c2 = s2 === 0 ? t3.maxX : t3.maxY;
          if (n3 >= o2 && c2 < i2) {
            l2.push(t3);
            continue;
          }
          if (c2 < o2 || n3 >= i2)
            continue;
          let u5 = [];
          if (r3 === "Point" || r3 === "MultiPoint")
            $(e3, u5, o2, i2, s2);
          else if (r3 === "LineString")
            K(e3, u5, o2, i2, s2, false, a2.lineMetrics);
          else if (r3 === "MultiLineString")
            ee(e3, u5, o2, i2, s2, false);
          else if (r3 === "Polygon")
            ee(e3, u5, o2, i2, s2, true);
          else if (r3 === "MultiPolygon")
            for (const t4 of e3) {
              const e4 = [];
              ee(t4, e4, o2, i2, s2, true), e4.length && u5.push(e4);
            }
          if (u5.length) {
            if (a2.lineMetrics && r3 === "LineString") {
              for (const e4 of u5)
                l2.push(J(t3.id, r3, e4, t3.tags));
              continue;
            }
            r3 !== "LineString" && r3 !== "MultiLineString" || (u5.length === 1 ? (r3 = "LineString", u5 = u5[0]) : r3 = "MultiLineString"), r3 !== "Point" && r3 !== "MultiPoint" || (r3 = u5.length === 3 ? "Point" : "MultiPoint"), l2.push(J(t3.id, r3, u5, t3.tags));
          }
        }
        return l2.length ? l2 : null;
      }
      function $(e2, t2, o2, i2, s2) {
        for (let r2 = 0;r2 < e2.length; r2 += 3) {
          const n2 = e2[r2 + s2];
          n2 >= o2 && n2 <= i2 && te(t2, e2[r2], e2[r2 + 1], e2[r2 + 2]);
        }
      }
      function K(e2, t2, o2, i2, s2, r2, n2) {
        let a2 = Q(e2);
        const l2 = s2 === 0 ? oe : ie;
        let c2, u5, h2 = e2.start;
        for (let d3 = 0;d3 < e2.length - 3; d3 += 3) {
          const f3 = e2[d3], g3 = e2[d3 + 1], p3 = e2[d3 + 2], m2 = e2[d3 + 3], y2 = e2[d3 + 4], v3 = s2 === 0 ? f3 : g3, w2 = s2 === 0 ? m2 : y2;
          let x2 = false;
          n2 && (c2 = Math.sqrt(Math.pow(f3 - m2, 2) + Math.pow(g3 - y2, 2))), v3 < o2 ? w2 > o2 && (u5 = l2(a2, f3, g3, m2, y2, o2), n2 && (a2.start = h2 + c2 * u5)) : v3 > i2 ? w2 < i2 && (u5 = l2(a2, f3, g3, m2, y2, i2), n2 && (a2.start = h2 + c2 * u5)) : te(a2, f3, g3, p3), w2 < o2 && v3 >= o2 && (u5 = l2(a2, f3, g3, m2, y2, o2), x2 = true), w2 > i2 && v3 <= i2 && (u5 = l2(a2, f3, g3, m2, y2, i2), x2 = true), !r2 && x2 && (n2 && (a2.end = h2 + c2 * u5), t2.push(a2), a2 = Q(e2)), n2 && (h2 += c2);
        }
        let d2 = e2.length - 3;
        const f2 = e2[d2], g2 = e2[d2 + 1], p2 = s2 === 0 ? f2 : g2;
        p2 >= o2 && p2 <= i2 && te(a2, f2, g2, e2[d2 + 2]), d2 = a2.length - 3, r2 && d2 >= 3 && (a2[d2] !== a2[0] || a2[d2 + 1] !== a2[1]) && te(a2, a2[0], a2[1], a2[2]), a2.length && t2.push(a2);
      }
      function Q(e2) {
        const t2 = [];
        return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
      }
      function ee(e2, t2, o2, i2, s2, r2) {
        for (const n2 of e2)
          K(n2, t2, o2, i2, s2, r2, false);
      }
      function te(e2, t2, o2, i2) {
        e2.push(t2, o2, i2);
      }
      function oe(e2, t2, o2, i2, s2, r2) {
        const n2 = (r2 - t2) / (i2 - t2);
        return te(e2, r2, o2 + (s2 - o2) * n2, 1), n2;
      }
      function ie(e2, t2, o2, i2, s2, r2) {
        const n2 = (r2 - o2) / (s2 - o2);
        return te(e2, t2 + (i2 - t2) * n2, r2, 1), n2;
      }
      function se(e2, t2) {
        const o2 = [];
        for (let i2 = 0;i2 < e2.length; i2++) {
          const s2 = e2[i2], r2 = s2.type;
          let n2;
          if (r2 === "Point" || r2 === "MultiPoint" || r2 === "LineString")
            n2 = re(s2.geometry, t2);
          else if (r2 === "MultiLineString" || r2 === "Polygon") {
            n2 = [];
            for (const e3 of s2.geometry)
              n2.push(re(e3, t2));
          } else if (r2 === "MultiPolygon") {
            n2 = [];
            for (const e3 of s2.geometry) {
              const o3 = [];
              for (const i3 of e3)
                o3.push(re(i3, t2));
              n2.push(o3);
            }
          }
          o2.push(J(s2.id, r2, n2, s2.tags));
        }
        return o2;
      }
      function re(e2, t2) {
        const o2 = [];
        o2.size = e2.size, e2.start !== undefined && (o2.start = e2.start, o2.end = e2.end);
        for (let i2 = 0;i2 < e2.length; i2 += 3)
          o2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
        return o2;
      }
      function ne(e2, t2) {
        if (e2.transformed)
          return e2;
        const o2 = 1 << e2.z, i2 = e2.x, s2 = e2.y;
        for (const r2 of e2.features) {
          const { geometry: e3, type: n2 } = r2;
          if (r2.geometry = [], n2 === 1)
            for (let n3 = 0;n3 < e3.length; n3 += 2)
              r2.geometry.push(ae(e3[n3], e3[n3 + 1], t2, o2, i2, s2));
          else
            for (let n3 = 0;n3 < e3.length; n3++) {
              const a2 = [];
              for (let r3 = 0;r3 < e3[n3].length; r3 += 2)
                a2.push(ae(e3[n3][r3], e3[n3][r3 + 1], t2, o2, i2, s2));
              r2.geometry.push(a2);
            }
        }
        return e2.transformed = true, e2;
      }
      function ae(e2, t2, o2, i2, s2, r2) {
        return [Math.round(o2 * (e2 * i2 - s2)), Math.round(o2 * (t2 * i2 - r2))];
      }
      function le(e2, t2, o2, i2, s2) {
        const r2 = t2 === s2.maxZoom ? 0 : s2.tolerance / ((1 << t2) * s2.extent), n2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e2.length, source: null, x: o2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const t3 of e2)
          ce2(n2, t3, r2, s2);
        return n2;
      }
      function ce2(e2, t2, o2, i2) {
        const { geometry: s2, type: r2 } = t2, n2 = [];
        if (e2.minX = Math.min(e2.minX, t2.minX), e2.minY = Math.min(e2.minY, t2.minY), e2.maxX = Math.max(e2.maxX, t2.maxX), e2.maxY = Math.max(e2.maxY, t2.maxY), r2 === "Point" || r2 === "MultiPoint")
          for (let t3 = 0;t3 < s2.length; t3 += 3)
            n2.push(s2[t3], s2[t3 + 1]), e2.numPoints++, e2.numSimplified++;
        else if (r2 === "LineString")
          ue(n2, s2, e2, o2, false, false);
        else if (r2 === "MultiLineString" || r2 === "Polygon")
          for (let t3 = 0;t3 < s2.length; t3++)
            ue(n2, s2[t3], e2, o2, r2 === "Polygon", t3 === 0);
        else if (r2 === "MultiPolygon")
          for (let t3 = 0;t3 < s2.length; t3++) {
            const i3 = s2[t3];
            for (let t4 = 0;t4 < i3.length; t4++)
              ue(n2, i3[t4], e2, o2, true, t4 === 0);
          }
        if (n2.length) {
          let o3 = t2.tags || null;
          if (r2 === "LineString" && i2.lineMetrics) {
            o3 = {};
            for (const e3 in t2.tags)
              o3[e3] = t2.tags[e3];
            o3.mapbox_clip_start = s2.start / s2.size, o3.mapbox_clip_end = s2.end / s2.size;
          }
          const a2 = { geometry: n2, type: r2 === "Polygon" || r2 === "MultiPolygon" ? 3 : r2 === "LineString" || r2 === "MultiLineString" ? 2 : 1, tags: o3 };
          t2.id !== null && (a2.id = t2.id), e2.features.push(a2);
        }
      }
      function ue(e2, t2, o2, i2, s2, r2) {
        const n2 = i2 * i2;
        if (i2 > 0 && t2.size < (s2 ? n2 : i2))
          return void (o2.numPoints += t2.length / 3);
        const a2 = [];
        for (let e3 = 0;e3 < t2.length; e3 += 3)
          (i2 === 0 || t2[e3 + 2] > n2) && (o2.numSimplified++, a2.push(t2[e3], t2[e3 + 1])), o2.numPoints++;
        s2 && function(e3, t3) {
          let o3 = 0;
          for (let t4 = 0, i3 = e3.length, s3 = i3 - 2;t4 < i3; s3 = t4, t4 += 2)
            o3 += (e3[t4] - e3[s3]) * (e3[t4 + 1] + e3[s3 + 1]);
          if (o3 > 0 === t3)
            for (let t4 = 0, o4 = e3.length;t4 < o4 / 2; t4 += 2) {
              const i3 = e3[t4], s3 = e3[t4 + 1];
              e3[t4] = e3[o4 - 2 - t4], e3[t4 + 1] = e3[o4 - 1 - t4], e3[o4 - 2 - t4] = i3, e3[o4 - 1 - t4] = s3;
            }
        }(a2, r2), e2.push(a2);
      }
      const he = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };

      class de2 {
        constructor(e2, t2) {
          const o2 = (t2 = this.options = function(e3, t3) {
            for (const o3 in t3)
              e3[o3] = t3[o3];
            return e3;
          }(Object.create(he), t2)).debug;
          if (o2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t2.promoteId && t2.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          let i2 = function(e3, t3) {
            const o3 = [];
            if (e3.type === "FeatureCollection")
              for (let i3 = 0;i3 < e3.features.length; i3++)
                Y(o3, e3.features[i3], t3, i3);
            else
              Y(o3, e3.type === "Feature" ? e3 : { geometry: e3 }, t3);
            return o3;
          }(e2, t2);
          this.tiles = {}, this.tileCoords = [], o2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i2 = function(e3, t3) {
            const o3 = t3.buffer / t3.extent;
            let i3 = e3;
            const s2 = U(e3, 1, -1 - o3, o3, 0, -1, 2, t3), r2 = U(e3, 1, 1 - o3, 2 + o3, 0, -1, 2, t3);
            return (s2 || r2) && (i3 = U(e3, 1, -o3, 1 + o3, 0, -1, 2, t3) || [], s2 && (i3 = se(s2, 1).concat(i3)), r2 && (i3 = i3.concat(se(r2, -1)))), i3;
          }(i2, t2), i2.length && this.splitTile(i2, 0, 0, 0), o2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(e2, t2, o2, i2, s2, r2, n2) {
          const a2 = [e2, t2, o2, i2], l2 = this.options, c2 = l2.debug;
          for (;a2.length; ) {
            i2 = a2.pop(), o2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
            const u5 = 1 << t2, h2 = fe(t2, o2, i2);
            let d2 = this.tiles[h2];
            if (!d2 && (c2 > 1 && console.time("creation"), d2 = this.tiles[h2] = le(e2, t2, o2, i2, l2), this.tileCoords.push({ z: t2, x: o2, y: i2 }), c2)) {
              c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, o2, i2, d2.numFeatures, d2.numPoints, d2.numSimplified), console.timeEnd("creation"));
              const e3 = `z${t2}`;
              this.stats[e3] = (this.stats[e3] || 0) + 1, this.total++;
            }
            if (d2.source = e2, s2 == null) {
              if (t2 === l2.indexMaxZoom || d2.numPoints <= l2.indexMaxPoints)
                continue;
            } else {
              if (t2 === l2.maxZoom || t2 === s2)
                continue;
              if (s2 != null) {
                const e3 = s2 - t2;
                if (o2 !== r2 >> e3 || i2 !== n2 >> e3)
                  continue;
              }
            }
            if (d2.source = null, e2.length === 0)
              continue;
            c2 > 1 && console.time("clipping");
            const f2 = 0.5 * l2.buffer / l2.extent, g2 = 0.5 - f2, p2 = 0.5 + f2, m2 = 1 + f2;
            let y2 = null, v3 = null, w2 = null, x2 = null, b2 = U(e2, u5, o2 - f2, o2 + p2, 0, d2.minX, d2.maxX, l2), S2 = U(e2, u5, o2 + g2, o2 + m2, 0, d2.minX, d2.maxX, l2);
            e2 = null, b2 && (y2 = U(b2, u5, i2 - f2, i2 + p2, 1, d2.minY, d2.maxY, l2), v3 = U(b2, u5, i2 + g2, i2 + m2, 1, d2.minY, d2.maxY, l2), b2 = null), S2 && (w2 = U(S2, u5, i2 - f2, i2 + p2, 1, d2.minY, d2.maxY, l2), x2 = U(S2, u5, i2 + g2, i2 + m2, 1, d2.minY, d2.maxY, l2), S2 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(y2 || [], t2 + 1, 2 * o2, 2 * i2), a2.push(v3 || [], t2 + 1, 2 * o2, 2 * i2 + 1), a2.push(w2 || [], t2 + 1, 2 * o2 + 1, 2 * i2), a2.push(x2 || [], t2 + 1, 2 * o2 + 1, 2 * i2 + 1);
          }
        }
        getTile(e2, t2, o2) {
          e2 = +e2, t2 = +t2, o2 = +o2;
          const i2 = this.options, { extent: s2, debug: r2 } = i2;
          if (e2 < 0 || e2 > 24)
            return null;
          const n2 = 1 << e2, a2 = fe(e2, t2 = t2 + n2 & n2 - 1, o2);
          if (this.tiles[a2])
            return ne(this.tiles[a2], s2);
          r2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, o2);
          let l2, c2 = e2, u5 = t2, h2 = o2;
          for (;!l2 && c2 > 0; )
            c2--, u5 >>= 1, h2 >>= 1, l2 = this.tiles[fe(c2, u5, h2)];
          return l2 && l2.source ? (r2 > 1 && (console.log("found parent tile z%d-%d-%d", c2, u5, h2), console.time("drilling down")), this.splitTile(l2.source, c2, u5, h2, e2, t2, o2), r2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? ne(this.tiles[a2], s2) : null) : null;
        }
      }
      function fe(e2, t2, o2) {
        return 32 * ((1 << e2) * o2 + t2) + e2;
      }
      function ge(e2, t2) {
        return t2 ? e2.properties[t2] : e2.id;
      }
      function pe(e2, t2) {
        if (e2 == null)
          return true;
        if (e2.type === "Feature")
          return ge(e2, t2) != null;
        if (e2.type === "FeatureCollection") {
          const o2 = new Set;
          for (const i2 of e2.features) {
            const e3 = ge(i2, t2);
            if (e3 == null)
              return false;
            if (o2.has(e3))
              return false;
            o2.add(e3);
          }
          return true;
        }
        return false;
      }
      function me(e2, t2) {
        const o2 = new Map;
        if (e2 == null)
          ;
        else if (e2.type === "Feature")
          o2.set(ge(e2, t2), e2);
        else
          for (const i2 of e2.features)
            o2.set(ge(i2, t2), i2);
        return o2;
      }

      class ye extends r {
        constructor() {
          super(...arguments), this._dataUpdateable = new Map;
        }
        loadVectorTile(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            const o3 = t2.tileID.canonical;
            if (!this._geoJSONIndex)
              throw new Error("Unable to parse the data into a cluster or geojson");
            const i2 = this._geoJSONIndex.getTile(o3.z, o3.x, o3.y);
            if (!i2)
              return null;
            const s2 = new class {
              constructor(t3) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.X, this.length = t3.length, this._features = t3;
              }
              feature(t3) {
                return new class {
                  constructor(t4) {
                    this._feature = t4, this.extent = e.X, this.type = t4.type, this.properties = t4.tags, "id" in t4 && !isNaN(t4.id) && (this.id = parseInt(t4.id, 10));
                  }
                  loadGeometry() {
                    if (this._feature.type === 1) {
                      const t4 = [];
                      for (const o4 of this._feature.geometry)
                        t4.push([new e.P(o4[0], o4[1])]);
                      return t4;
                    }
                    {
                      const t4 = [];
                      for (const o4 of this._feature.geometry) {
                        const i3 = [];
                        for (const t5 of o4)
                          i3.push(new e.P(t5[0], t5[1]));
                        t4.push(i3);
                      }
                      return t4;
                    }
                  }
                  toGeoJSON(e2, t4, o4) {
                    return u4.call(this, e2, t4, o4);
                  }
                }(this._features[t3]);
              }
            }(i2.features);
            let r2 = k(s2);
            return r2.byteOffset === 0 && r2.byteLength === r2.buffer.byteLength || (r2 = new Uint8Array(r2)), { vectorTile: s2, rawData: r2.buffer };
          });
        }
        loadData(t2) {
          return e._(this, undefined, undefined, function* () {
            var o2;
            (o2 = this._pendingRequest) === null || o2 === undefined || o2.abort();
            const i2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.bv(t2.request);
            this._pendingRequest = new AbortController;
            try {
              this._pendingData = this.loadAndProcessGeoJSON(t2, this._pendingRequest), this._geoJSONIndex = t2.cluster ? new z(function({ superclusterOptions: t3, clusterProperties: o4 }) {
                if (!o4 || !t3)
                  return t3;
                const i3 = {}, s3 = {}, r2 = { accumulated: null, zoom: 0 }, n2 = { properties: null }, a2 = Object.keys(o4);
                for (const t4 of a2) {
                  const [r3, n3] = o4[t4], a3 = e.bC(n3), l2 = e.bC(typeof r3 == "string" ? [r3, ["accumulated"], ["get", t4]] : r3);
                  i3[t4] = a3.value, s3[t4] = l2.value;
                }
                return t3.map = (e2) => {
                  n2.properties = e2;
                  const t4 = {};
                  for (const e3 of a2)
                    t4[e3] = i3[e3].evaluate(r2, n2);
                  return t4;
                }, t3.reduce = (e2, t4) => {
                  n2.properties = t4;
                  for (const t5 of a2)
                    r2.accumulated = e2[t5], e2[t5] = s3[t5].evaluate(r2, n2);
                }, t3;
              }(t2)).load((yield this._pendingData).features) : (s2 = yield this._pendingData, new de2(s2, t2.geojsonVtOptions)), this.loaded = {};
              const o3 = {};
              if (i2) {
                const e2 = i2.finish();
                e2 && (o3.resourceTiming = {}, o3.resourceTiming[t2.source] = JSON.parse(JSON.stringify(e2)));
              }
              return o3;
            } catch (t3) {
              if (delete this._pendingRequest, e.bB(t3))
                return { abandoned: true };
              throw t3;
            }
            var s2;
          });
        }
        getData() {
          return e._(this, undefined, undefined, function* () {
            return this._pendingData;
          });
        }
        reloadTile(e2) {
          const t2 = this.loaded;
          return t2 && t2[e2.uid] ? super.reloadTile(e2) : this.loadTile(e2);
        }
        loadAndProcessGeoJSON(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            let i2 = yield this.loadGeoJSON(t2, o2);
            if (delete this._pendingRequest, typeof i2 != "object")
              throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
            if (c(i2, true), t2.filter) {
              const o3 = e.bC(t2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
              if (o3.result === "error")
                throw new Error(o3.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
              const s2 = i2.features.filter((e2) => o3.value.evaluate({ zoom: 0 }, e2));
              i2 = { type: "FeatureCollection", features: s2 };
            }
            return i2;
          });
        }
        loadGeoJSON(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            const { promoteId: i2 } = t2;
            if (t2.request) {
              const s2 = yield e.h(t2.request, o2);
              return this._dataUpdateable = pe(s2.data, i2) ? me(s2.data, i2) : undefined, s2.data;
            }
            if (typeof t2.data == "string")
              try {
                const e2 = JSON.parse(t2.data);
                return this._dataUpdateable = pe(e2, i2) ? me(e2, i2) : undefined, e2;
              } catch (e2) {
                throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
              }
            if (!t2.dataDiff)
              throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable)
              throw new Error(`Cannot update existing geojson data in ${t2.source}`);
            return function(e2, t3, o3) {
              var i3, s2, r2, n2;
              if (t3.removeAll && e2.clear(), t3.remove)
                for (const o4 of t3.remove)
                  e2.delete(o4);
              if (t3.add)
                for (const i4 of t3.add) {
                  const t4 = ge(i4, o3);
                  t4 != null && e2.set(t4, i4);
                }
              if (t3.update)
                for (const o4 of t3.update) {
                  let t4 = e2.get(o4.id);
                  if (t4 == null)
                    continue;
                  const a2 = !o4.removeAllProperties && (((i3 = o4.removeProperties) === null || i3 === undefined ? undefined : i3.length) > 0 || ((s2 = o4.addOrUpdateProperties) === null || s2 === undefined ? undefined : s2.length) > 0);
                  if ((o4.newGeometry || o4.removeAllProperties || a2) && (t4 = Object.assign({}, t4), e2.set(o4.id, t4), a2 && (t4.properties = Object.assign({}, t4.properties))), o4.newGeometry && (t4.geometry = o4.newGeometry), o4.removeAllProperties)
                    t4.properties = {};
                  else if (((r2 = o4.removeProperties) === null || r2 === undefined ? undefined : r2.length) > 0)
                    for (const e3 of o4.removeProperties)
                      Object.prototype.hasOwnProperty.call(t4.properties, e3) && delete t4.properties[e3];
                  if (((n2 = o4.addOrUpdateProperties) === null || n2 === undefined ? undefined : n2.length) > 0)
                    for (const { key: e3, value: i4 } of o4.addOrUpdateProperties)
                      t4.properties[e3] = i4;
                }
            }(this._dataUpdateable, t2.dataDiff, i2), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
          });
        }
        removeSource(t2) {
          return e._(this, undefined, undefined, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom(e2) {
          return this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId);
        }
        getClusterChildren(e2) {
          return this._geoJSONIndex.getChildren(e2.clusterId);
        }
        getClusterLeaves(e2) {
          return this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset);
        }
      }

      class ve {
        constructor(t2) {
          this.self = t2, this.actor = new e.F(t2), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (e2, t3) => {
            if (this.externalWorkerSourceTypes[e2])
              throw new Error(`Worker source with name "${e2}" already registered.`);
            this.externalWorkerSourceTypes[e2] = t3;
          }, this.self.addProtocol = e.bi, this.self.removeProtocol = e.bj, this.self.registerRTLTextPlugin = (t3) => {
            if (e.bD.isParsed())
              throw new Error("RTL text plugin already registered.");
            e.bD.setMethods(t3);
          }, this.actor.registerMessageHandler("LDT", (e2, t3) => this._getDEMWorkerSource(e2, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RDT", (t3, o2) => e._(this, undefined, undefined, function* () {
            this._getDEMWorkerSource(t3, o2.source).removeTile(o2);
          })), this.actor.registerMessageHandler("GCEZ", (t3, o2) => e._(this, undefined, undefined, function* () {
            return this._getWorkerSource(t3, o2.type, o2.source).getClusterExpansionZoom(o2);
          })), this.actor.registerMessageHandler("GCC", (t3, o2) => e._(this, undefined, undefined, function* () {
            return this._getWorkerSource(t3, o2.type, o2.source).getClusterChildren(o2);
          })), this.actor.registerMessageHandler("GCL", (t3, o2) => e._(this, undefined, undefined, function* () {
            return this._getWorkerSource(t3, o2.type, o2.source).getClusterLeaves(o2);
          })), this.actor.registerMessageHandler("LD", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadData(t3)), this.actor.registerMessageHandler("GD", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).getData()), this.actor.registerMessageHandler("LT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).reloadTile(t3)), this.actor.registerMessageHandler("AT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).abortTile(t3)), this.actor.registerMessageHandler("RMT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).removeTile(t3)), this.actor.registerMessageHandler("RS", (t3, o2) => e._(this, undefined, undefined, function* () {
            if (!this.workerSources[t3] || !this.workerSources[t3][o2.type] || !this.workerSources[t3][o2.type][o2.source])
              return;
            const e2 = this.workerSources[t3][o2.type][o2.source];
            delete this.workerSources[t3][o2.type][o2.source], e2.removeSource !== undefined && e2.removeSource(o2);
          })), this.actor.registerMessageHandler("RM", (t3) => e._(this, undefined, undefined, function* () {
            delete this.layerIndexes[t3], delete this.availableImages[t3], delete this.workerSources[t3], delete this.demWorkerSources[t3];
          })), this.actor.registerMessageHandler("SR", (t3, o2) => e._(this, undefined, undefined, function* () {
            this.referrer = o2;
          })), this.actor.registerMessageHandler("SRPS", (e2, t3) => this._syncRTLPluginState(e2, t3)), this.actor.registerMessageHandler("IS", (t3, o2) => e._(this, undefined, undefined, function* () {
            this.self.importScripts(o2);
          })), this.actor.registerMessageHandler("SI", (e2, t3) => this._setImages(e2, t3)), this.actor.registerMessageHandler("UL", (t3, o2) => e._(this, undefined, undefined, function* () {
            this._getLayerIndex(t3).update(o2.layers, o2.removedIds);
          })), this.actor.registerMessageHandler("SL", (t3, o2) => e._(this, undefined, undefined, function* () {
            this._getLayerIndex(t3).replace(o2);
          }));
        }
        _setImages(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            this.availableImages[t2] = o2;
            for (const e2 in this.workerSources[t2]) {
              const i2 = this.workerSources[t2][e2];
              for (const e3 in i2)
                i2[e3].availableImages = o2;
            }
          });
        }
        _syncRTLPluginState(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            if (e.bD.isParsed())
              return e.bD.getState();
            if (o2.pluginStatus !== "loading")
              return e.bD.setState(o2), o2;
            const t3 = o2.pluginURL;
            if (this.self.importScripts(t3), e.bD.isParsed()) {
              const o3 = { pluginStatus: "loaded", pluginURL: t3 };
              return e.bD.setState(o3), o3;
            }
            throw e.bD.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${t3}`);
          });
        }
        _getAvailableImages(e2) {
          let t2 = this.availableImages[e2];
          return t2 || (t2 = []), t2;
        }
        _getLayerIndex(e2) {
          let o2 = this.layerIndexes[e2];
          return o2 || (o2 = this.layerIndexes[e2] = new t), o2;
        }
        _getWorkerSource(e2, t2, o2) {
          if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][o2]) {
            const i2 = { sendAsync: (t3, o3) => (t3.targetMapId = e2, this.actor.sendAsync(t3, o3)) };
            switch (t2) {
              case "vector":
                this.workerSources[e2][t2][o2] = new r(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                break;
              case "geojson":
                this.workerSources[e2][t2][o2] = new ye(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                break;
              default:
                this.workerSources[e2][t2][o2] = new this.externalWorkerSourceTypes[t2](i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
            }
          }
          return this.workerSources[e2][t2][o2];
        }
        _getDEMWorkerSource(e2, t2) {
          return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new n), this.demWorkerSources[e2][t2];
        }
      }
      return e.i(self) && (self.worker = new ve(self)), ve;
    });
    define2("index", ["exports", "./shared"], function(t, e) {
      var i = "4.7.1";
      let a, s;
      const o = { now: typeof performance != "undefined" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frameAsync: (t2) => new Promise((i2, a2) => {
        const s2 = requestAnimationFrame(i2);
        t2.signal.addEventListener("abort", () => {
          cancelAnimationFrame(s2), a2(e.c());
        });
      }), getImageData(t2, e2 = 0) {
        return this.getImageCanvasContext(t2).getImageData(-e2, -e2, t2.width + 2 * e2, t2.height + 2 * e2);
      }, getImageCanvasContext(t2) {
        const e2 = window.document.createElement("canvas"), i2 = e2.getContext("2d", { willReadFrequently: true });
        if (!i2)
          throw new Error("failed to create canvas 2d context");
        return e2.width = t2.width, e2.height = t2.height, i2.drawImage(t2, 0, 0, t2.width, t2.height), i2;
      }, resolveURL: (t2) => (a || (a = document.createElement("a")), a.href = t2, a.href), hardwareConcurrency: typeof navigator != "undefined" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (s == null && (s = matchMedia("(prefers-reduced-motion: reduce)")), s.matches);
      } };

      class r {
        static testProp(t2) {
          if (!r.docStyle)
            return t2[0];
          for (let e2 = 0;e2 < t2.length; e2++)
            if (t2[e2] in r.docStyle)
              return t2[e2];
          return t2[0];
        }
        static create(t2, e2, i2) {
          const a2 = window.document.createElement(t2);
          return e2 !== undefined && (a2.className = e2), i2 && i2.appendChild(a2), a2;
        }
        static createNS(t2, e2) {
          return window.document.createElementNS(t2, e2);
        }
        static disableDrag() {
          r.docStyle && r.selectProp && (r.userSelect = r.docStyle[r.selectProp], r.docStyle[r.selectProp] = "none");
        }
        static enableDrag() {
          r.docStyle && r.selectProp && (r.docStyle[r.selectProp] = r.userSelect);
        }
        static setTransform(t2, e2) {
          t2.style[r.transformProp] = e2;
        }
        static addEventListener(t2, e2, i2, a2 = {}) {
          t2.addEventListener(e2, i2, "passive" in a2 ? a2 : a2.capture);
        }
        static removeEventListener(t2, e2, i2, a2 = {}) {
          t2.removeEventListener(e2, i2, "passive" in a2 ? a2 : a2.capture);
        }
        static suppressClickInternal(t2) {
          t2.preventDefault(), t2.stopPropagation(), window.removeEventListener("click", r.suppressClickInternal, true);
        }
        static suppressClick() {
          window.addEventListener("click", r.suppressClickInternal, true), window.setTimeout(() => {
            window.removeEventListener("click", r.suppressClickInternal, true);
          }, 0);
        }
        static getScale(t2) {
          const e2 = t2.getBoundingClientRect();
          return { x: e2.width / t2.offsetWidth || 1, y: e2.height / t2.offsetHeight || 1, boundingClientRect: e2 };
        }
        static getPoint(t2, i2, a2) {
          const s2 = i2.boundingClientRect;
          return new e.P((a2.clientX - s2.left) / i2.x - t2.clientLeft, (a2.clientY - s2.top) / i2.y - t2.clientTop);
        }
        static mousePos(t2, e2) {
          const i2 = r.getScale(t2);
          return r.getPoint(t2, i2, e2);
        }
        static touchPos(t2, e2) {
          const i2 = [], a2 = r.getScale(t2);
          for (let s2 = 0;s2 < e2.length; s2++)
            i2.push(r.getPoint(t2, a2, e2[s2]));
          return i2;
        }
        static mouseButton(t2) {
          return t2.button;
        }
        static remove(t2) {
          t2.parentNode && t2.parentNode.removeChild(t2);
        }
      }
      r.docStyle = typeof window != "undefined" && window.document && window.document.documentElement.style, r.selectProp = r.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), r.transformProp = r.testProp(["transform", "WebkitTransform"]);
      const n = { supported: false, testSupport: function(t2) {
        !c && h && (u4 ? d(t2) : l = t2);
      } };
      let l, h, c = false, u4 = false;
      function d(t2) {
        const e2 = t2.createTexture();
        t2.bindTexture(t2.TEXTURE_2D, e2);
        try {
          if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, h), t2.isContextLost())
            return;
          n.supported = true;
        } catch (t3) {
        }
        t2.deleteTexture(e2), c = true;
      }
      var _;
      typeof document != "undefined" && (h = document.createElement("img"), h.onload = () => {
        l && d(l), l = null, u4 = true;
      }, h.onerror = () => {
        c = true, l = null;
      }, h.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(t2) {
        let i2, a2, s2, o2;
        t2.resetRequestQueue = () => {
          i2 = [], a2 = 0, s2 = 0, o2 = {};
        }, t2.addThrottleControl = (t3) => {
          const e2 = s2++;
          return o2[e2] = t3, e2;
        }, t2.removeThrottleControl = (t3) => {
          delete o2[t3], l2();
        }, t2.getImage = (t3, a3, s3 = true) => new Promise((o3, r3) => {
          n.supported && (t3.headers || (t3.headers = {}), t3.headers.accept = "image/webp,*/*"), e.e(t3, { type: "image" }), i2.push({ abortController: a3, requestParameters: t3, supportImageRefresh: s3, state: "queued", onError: (t4) => {
            r3(t4);
          }, onSuccess: (t4) => {
            o3(t4);
          } }), l2();
        });
        const r2 = (t3) => e._(this, undefined, undefined, function* () {
          t3.state = "running";
          const { requestParameters: i3, supportImageRefresh: s3, onError: o3, onSuccess: r3, abortController: n2 } = t3, c2 = s3 === false && !e.i(self) && !e.g(i3.url) && (!i3.headers || Object.keys(i3.headers).reduce((t4, e2) => t4 && e2 === "accept", true));
          a2++;
          const u5 = c2 ? h2(i3, n2) : e.m(i3, n2);
          try {
            const i4 = yield u5;
            delete t3.abortController, t3.state = "completed", i4.data instanceof HTMLImageElement || e.b(i4.data) ? r3(i4) : i4.data && r3({ data: yield (d2 = i4.data, typeof createImageBitmap == "function" ? e.d(d2) : e.f(d2)), cacheControl: i4.cacheControl, expires: i4.expires });
          } catch (e2) {
            delete t3.abortController, o3(e2);
          } finally {
            a2--, l2();
          }
          var d2;
        }), l2 = () => {
          const t3 = (() => {
            for (const t4 of Object.keys(o2))
              if (o2[t4]())
                return true;
            return false;
          })() ? e.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : e.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let e2 = a2;e2 < t3 && i2.length > 0; e2++) {
            const t4 = i2.shift();
            t4.abortController.signal.aborted ? e2-- : r2(t4);
          }
        }, h2 = (t3, i3) => new Promise((a3, s3) => {
          const o3 = new Image, r3 = t3.url, n2 = t3.credentials;
          n2 && n2 === "include" ? o3.crossOrigin = "use-credentials" : (n2 && n2 === "same-origin" || !e.s(r3)) && (o3.crossOrigin = "anonymous"), i3.signal.addEventListener("abort", () => {
            o3.src = "", s3(e.c());
          }), o3.fetchPriority = "high", o3.onload = () => {
            o3.onerror = o3.onload = null, a3({ data: o3 });
          }, o3.onerror = () => {
            o3.onerror = o3.onload = null, i3.signal.aborted || s3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }, o3.src = r3;
        });
      }(_ || (_ = {})), _.resetRequestQueue();

      class p {
        constructor(t2) {
          this._transformRequestFn = t2;
        }
        transformRequest(t2, e2) {
          return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
        }
        setTransformRequest(t2) {
          this._transformRequestFn = t2;
        }
      }
      function m(t2) {
        var i2 = new e.A(3);
        return i2[0] = t2[0], i2[1] = t2[1], i2[2] = t2[2], i2;
      }
      var f, g = function(t2, e2, i2) {
        return t2[0] = e2[0] - i2[0], t2[1] = e2[1] - i2[1], t2[2] = e2[2] - i2[2], t2;
      };
      f = new e.A(3), e.A != Float32Array && (f[0] = 0, f[1] = 0, f[2] = 0);
      var v2 = function(t2) {
        var e2 = t2[0], i2 = t2[1];
        return e2 * e2 + i2 * i2;
      };
      function x(t2) {
        const e2 = [];
        if (typeof t2 == "string")
          e2.push({ id: "default", url: t2 });
        else if (t2 && t2.length > 0) {
          const i2 = [];
          for (const { id: a2, url: s2 } of t2) {
            const t3 = `${a2}${s2}`;
            i2.indexOf(t3) === -1 && (i2.push(t3), e2.push({ id: a2, url: s2 }));
          }
        }
        return e2;
      }
      function y(t2, e2, i2) {
        const a2 = t2.split("?");
        return a2[0] += `${e2}${i2}`, a2.join("?");
      }
      (function() {
        var t2 = new e.A(2);
        e.A != Float32Array && (t2[0] = 0, t2[1] = 0);
      })();

      class b {
        constructor(t2, e2, i2, a2) {
          this.context = t2, this.format = i2, this.texture = t2.gl.createTexture(), this.update(e2, a2);
        }
        update(t2, i2, a2) {
          const { width: s2, height: o2 } = t2, r2 = !(this.size && this.size[0] === s2 && this.size[1] === o2 || a2), { context: n2 } = this, { gl: l2 } = n2;
          if (this.useMipmap = Boolean(i2 && i2.useMipmap), l2.bindTexture(l2.TEXTURE_2D, this.texture), n2.pixelStoreUnpackFlipY.set(false), n2.pixelStoreUnpack.set(1), n2.pixelStoreUnpackPremultiplyAlpha.set(this.format === l2.RGBA && (!i2 || i2.premultiply !== false)), r2)
            this.size = [s2, o2], t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || e.b(t2) ? l2.texImage2D(l2.TEXTURE_2D, 0, this.format, this.format, l2.UNSIGNED_BYTE, t2) : l2.texImage2D(l2.TEXTURE_2D, 0, this.format, s2, o2, 0, this.format, l2.UNSIGNED_BYTE, t2.data);
          else {
            const { x: i3, y: r3 } = a2 || { x: 0, y: 0 };
            t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || e.b(t2) ? l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, r3, l2.RGBA, l2.UNSIGNED_BYTE, t2) : l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, r3, s2, o2, l2.RGBA, l2.UNSIGNED_BYTE, t2.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && l2.generateMipmap(l2.TEXTURE_2D);
        }
        bind(t2, e2, i2) {
          const { context: a2 } = this, { gl: s2 } = a2;
          s2.bindTexture(s2.TEXTURE_2D, this.texture), i2 !== s2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i2 = s2.LINEAR), t2 !== this.filter && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MAG_FILTER, t2), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MIN_FILTER, i2 || t2), this.filter = t2), e2 !== this.wrap && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_S, e2), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_T, e2), this.wrap = e2);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: t2 } = this.context;
          t2.deleteTexture(this.texture), this.texture = null;
        }
      }
      function w(t2) {
        const { userImage: e2 } = t2;
        return !!(e2 && e2.render && e2.render()) && (t2.data.replace(new Uint8Array(e2.data.buffer)), true);
      }

      class T extends e.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new e.R({ width: 1, height: 1 }), this.dirty = true;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(t2) {
          if (this.loaded !== t2 && (this.loaded = t2, t2)) {
            for (const { ids: t3, promiseResolve: e2 } of this.requestors)
              e2(this._getImagesForIds(t3));
            this.requestors = [];
          }
        }
        getImage(t2) {
          const i2 = this.images[t2];
          if (i2 && !i2.data && i2.spriteData) {
            const t3 = i2.spriteData;
            i2.data = new e.R({ width: t3.width, height: t3.height }, t3.context.getImageData(t3.x, t3.y, t3.width, t3.height).data), i2.spriteData = null;
          }
          return i2;
        }
        addImage(t2, e2) {
          if (this.images[t2])
            throw new Error(`Image id ${t2} already exist, use updateImage instead`);
          this._validate(t2, e2) && (this.images[t2] = e2);
        }
        _validate(t2, i2) {
          let a2 = true;
          const s2 = i2.data || i2.spriteData;
          return this._validateStretch(i2.stretchX, s2 && s2.width) || (this.fire(new e.j(new Error(`Image "${t2}" has invalid "stretchX" value`))), a2 = false), this._validateStretch(i2.stretchY, s2 && s2.height) || (this.fire(new e.j(new Error(`Image "${t2}" has invalid "stretchY" value`))), a2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.j(new Error(`Image "${t2}" has invalid "content" value`))), a2 = false), a2;
        }
        _validateStretch(t2, e2) {
          if (!t2)
            return true;
          let i2 = 0;
          for (const a2 of t2) {
            if (a2[0] < i2 || a2[1] < a2[0] || e2 < a2[1])
              return false;
            i2 = a2[1];
          }
          return true;
        }
        _validateContent(t2, e2) {
          if (!t2)
            return true;
          if (t2.length !== 4)
            return false;
          const i2 = e2.spriteData, a2 = i2 && i2.width || e2.data.width, s2 = i2 && i2.height || e2.data.height;
          return !(t2[0] < 0 || a2 < t2[0] || t2[1] < 0 || s2 < t2[1] || t2[2] < 0 || a2 < t2[2] || t2[3] < 0 || s2 < t2[3] || t2[2] < t2[0] || t2[3] < t2[1]);
        }
        updateImage(t2, e2, i2 = true) {
          const a2 = this.getImage(t2);
          if (i2 && (a2.data.width !== e2.data.width || a2.data.height !== e2.data.height))
            throw new Error(`size mismatch between old image (${a2.data.width}x${a2.data.height}) and new image (${e2.data.width}x${e2.data.height}).`);
          e2.version = a2.version + 1, this.images[t2] = e2, this.updatedImages[t2] = true;
        }
        removeImage(t2) {
          const e2 = this.images[t2];
          delete this.images[t2], delete this.patterns[t2], e2.userImage && e2.userImage.onRemove && e2.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(t2) {
          return new Promise((e2, i2) => {
            let a2 = true;
            if (!this.isLoaded())
              for (const e3 of t2)
                this.images[e3] || (a2 = false);
            this.isLoaded() || a2 ? e2(this._getImagesForIds(t2)) : this.requestors.push({ ids: t2, promiseResolve: e2 });
          });
        }
        _getImagesForIds(t2) {
          const i2 = {};
          for (const a2 of t2) {
            let t3 = this.getImage(a2);
            t3 || (this.fire(new e.k("styleimagemissing", { id: a2 })), t3 = this.getImage(a2)), t3 ? i2[a2] = { data: t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, textFitWidth: t3.textFitWidth, textFitHeight: t3.textFitHeight, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) } : e.w(`Image "${a2}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return i2;
        }
        getPixelSize() {
          const { width: t2, height: e2 } = this.atlasImage;
          return { width: t2, height: e2 };
        }
        getPattern(t2) {
          const i2 = this.patterns[t2], a2 = this.getImage(t2);
          if (!a2)
            return null;
          if (i2 && i2.position.version === a2.version)
            return i2.position;
          if (i2)
            i2.position.version = a2.version;
          else {
            const i3 = { w: a2.data.width + 2, h: a2.data.height + 2, x: 0, y: 0 }, s2 = new e.I(i3, a2);
            this.patterns[t2] = { bin: i3, position: s2 };
          }
          return this._updatePatternAtlas(), this.patterns[t2].position;
        }
        bind(t2) {
          const e2 = t2.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new b(t2, this.atlasImage, e2.RGBA), this.atlasTexture.bind(e2.LINEAR, e2.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const t2 = [];
          for (const e2 in this.patterns)
            t2.push(this.patterns[e2].bin);
          const { w: i2, h: a2 } = e.p(t2), s2 = this.atlasImage;
          s2.resize({ width: i2 || 1, height: a2 || 1 });
          for (const t3 in this.patterns) {
            const { bin: i3 } = this.patterns[t3], a3 = i3.x + 1, o2 = i3.y + 1, r2 = this.getImage(t3).data, n2 = r2.width, l2 = r2.height;
            e.R.copy(r2, s2, { x: 0, y: 0 }, { x: a3, y: o2 }, { width: n2, height: l2 }), e.R.copy(r2, s2, { x: 0, y: l2 - 1 }, { x: a3, y: o2 - 1 }, { width: n2, height: 1 }), e.R.copy(r2, s2, { x: 0, y: 0 }, { x: a3, y: o2 + l2 }, { width: n2, height: 1 }), e.R.copy(r2, s2, { x: n2 - 1, y: 0 }, { x: a3 - 1, y: o2 }, { width: 1, height: l2 }), e.R.copy(r2, s2, { x: 0, y: 0 }, { x: a3 + n2, y: o2 }, { width: 1, height: l2 });
          }
          this.dirty = true;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(t2) {
          for (const i2 of t2) {
            if (this.callbackDispatchedThisFrame[i2])
              continue;
            this.callbackDispatchedThisFrame[i2] = true;
            const t3 = this.getImage(i2);
            t3 || e.w(`Image with ID: "${i2}" was not found`), w(t3) && this.updateImage(i2, t3);
          }
        }
      }
      const I = 100000000000000000000;
      function E(t2, e2, i2, a2, s2, o2, r2, n2, l2) {
        for (let h2 = e2;h2 < e2 + a2; h2++)
          P(t2, i2 * o2 + h2, o2, s2, r2, n2, l2);
        for (let h2 = i2;h2 < i2 + s2; h2++)
          P(t2, h2 * o2 + e2, 1, a2, r2, n2, l2);
      }
      function P(t2, e2, i2, a2, s2, o2, r2) {
        o2[0] = 0, r2[0] = -I, r2[1] = I, s2[0] = t2[e2];
        for (let n2 = 1, l2 = 0, h2 = 0;n2 < a2; n2++) {
          s2[n2] = t2[e2 + n2 * i2];
          const a3 = n2 * n2;
          do {
            const t3 = o2[l2];
            h2 = (s2[n2] - s2[t3] + a3 - t3 * t3) / (n2 - t3) / 2;
          } while (h2 <= r2[l2] && --l2 > -1);
          l2++, o2[l2] = n2, r2[l2] = h2, r2[l2 + 1] = I;
        }
        for (let n2 = 0, l2 = 0;n2 < a2; n2++) {
          for (;r2[l2 + 1] < n2; )
            l2++;
          const a3 = o2[l2], h2 = n2 - a3;
          t2[e2 + n2 * i2] = s2[a3] + h2 * h2;
        }
      }

      class C {
        constructor(t2, e2) {
          this.requestManager = t2, this.localIdeographFontFamily = e2, this.entries = {};
        }
        setURL(t2) {
          this.url = t2;
        }
        getGlyphs(t2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = [];
            for (const i3 in t2)
              for (const a3 of t2[i3])
                e2.push(this._getAndCacheGlyphsPromise(i3, a3));
            const i2 = yield Promise.all(e2), a2 = {};
            for (const { stack: t3, id: e3, glyph: s2 } of i2)
              a2[t3] || (a2[t3] = {}), a2[t3][e3] = s2 && { id: s2.id, bitmap: s2.bitmap.clone(), metrics: s2.metrics };
            return a2;
          });
        }
        _getAndCacheGlyphsPromise(t2, i2) {
          return e._(this, undefined, undefined, function* () {
            let e2 = this.entries[t2];
            e2 || (e2 = this.entries[t2] = { glyphs: {}, requests: {}, ranges: {} });
            let a2 = e2.glyphs[i2];
            if (a2 !== undefined)
              return { stack: t2, id: i2, glyph: a2 };
            if (a2 = this._tinySDF(e2, t2, i2), a2)
              return e2.glyphs[i2] = a2, { stack: t2, id: i2, glyph: a2 };
            const s2 = Math.floor(i2 / 256);
            if (256 * s2 > 65535)
              throw new Error("glyphs > 65535 not supported");
            if (e2.ranges[s2])
              return { stack: t2, id: i2, glyph: a2 };
            if (!this.url)
              throw new Error("glyphsUrl is not set");
            if (!e2.requests[s2]) {
              const i3 = C.loadGlyphRange(t2, s2, this.url, this.requestManager);
              e2.requests[s2] = i3;
            }
            const o2 = yield e2.requests[s2];
            for (const t3 in o2)
              this._doesCharSupportLocalGlyph(+t3) || (e2.glyphs[+t3] = o2[+t3]);
            return e2.ranges[s2] = true, { stack: t2, id: i2, glyph: o2[i2] || null };
          });
        }
        _doesCharSupportLocalGlyph(t2) {
          return !!this.localIdeographFontFamily && /\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(String.fromCodePoint(t2));
        }
        _tinySDF(t2, i2, a2) {
          const s2 = this.localIdeographFontFamily;
          if (!s2)
            return;
          if (!this._doesCharSupportLocalGlyph(a2))
            return;
          let o2 = t2.tinySDF;
          if (!o2) {
            let e2 = "400";
            /bold/i.test(i2) ? e2 = "900" : /medium/i.test(i2) ? e2 = "500" : /light/i.test(i2) && (e2 = "200"), o2 = t2.tinySDF = new C.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: s2, fontWeight: e2 });
          }
          const r2 = o2.draw(String.fromCharCode(a2));
          return { id: a2, bitmap: new e.o({ width: r2.width || 60, height: r2.height || 60 }, r2.data), metrics: { width: r2.glyphWidth / 2 || 24, height: r2.glyphHeight / 2 || 24, left: r2.glyphLeft / 2 + 0.5 || 0, top: r2.glyphTop / 2 - 27.5 || -8, advance: r2.glyphAdvance / 2 || 24, isDoubleResolution: true } };
        }
      }
      C.loadGlyphRange = function(t2, i2, a2, s2) {
        return e._(this, undefined, undefined, function* () {
          const o2 = 256 * i2, r2 = o2 + 255, n2 = s2.transformRequest(a2.replace("{fontstack}", t2).replace("{range}", `${o2}-${r2}`), "Glyphs"), l2 = yield e.l(n2, new AbortController);
          if (!l2 || !l2.data)
            throw new Error(`Could not load glyph range. range: ${i2}, ${o2}-${r2}`);
          const h2 = {};
          for (const t3 of e.n(l2.data))
            h2[t3.id] = t3;
          return h2;
        });
      }, C.TinySDF = class {
        constructor({ fontSize: t2 = 24, buffer: e2 = 3, radius: i2 = 8, cutoff: a2 = 0.25, fontFamily: s2 = "sans-serif", fontWeight: o2 = "normal", fontStyle: r2 = "normal" } = {}) {
          this.buffer = e2, this.cutoff = a2, this.radius = i2;
          const n2 = this.size = t2 + 4 * e2, l2 = this._createCanvas(n2), h2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
          h2.font = `${r2} ${o2} ${t2}px ${s2}`, h2.textBaseline = "alphabetic", h2.textAlign = "left", h2.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Uint16Array(n2);
        }
        _createCanvas(t2) {
          const e2 = document.createElement("canvas");
          return e2.width = e2.height = t2, e2;
        }
        draw(t2) {
          const { width: e2, actualBoundingBoxAscent: i2, actualBoundingBoxDescent: a2, actualBoundingBoxLeft: s2, actualBoundingBoxRight: o2 } = this.ctx.measureText(t2), r2 = Math.ceil(i2), n2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o2 - s2))), l2 = Math.min(this.size - this.buffer, r2 + Math.ceil(a2)), h2 = n2 + 2 * this.buffer, c2 = l2 + 2 * this.buffer, u5 = Math.max(h2 * c2, 0), d2 = new Uint8ClampedArray(u5), _2 = { data: d2, width: h2, height: c2, glyphWidth: n2, glyphHeight: l2, glyphTop: r2, glyphLeft: 0, glyphAdvance: e2 };
          if (n2 === 0 || l2 === 0)
            return _2;
          const { ctx: p2, buffer: m2, gridInner: f2, gridOuter: g2 } = this;
          p2.clearRect(m2, m2, n2, l2), p2.fillText(t2, m2, m2 + r2);
          const v3 = p2.getImageData(m2, m2, n2, l2);
          g2.fill(I, 0, u5), f2.fill(0, 0, u5);
          for (let t3 = 0;t3 < l2; t3++)
            for (let e3 = 0;e3 < n2; e3++) {
              const i3 = v3.data[4 * (t3 * n2 + e3) + 3] / 255;
              if (i3 === 0)
                continue;
              const a3 = (t3 + m2) * h2 + e3 + m2;
              if (i3 === 1)
                g2[a3] = 0, f2[a3] = I;
              else {
                const t4 = 0.5 - i3;
                g2[a3] = t4 > 0 ? t4 * t4 : 0, f2[a3] = t4 < 0 ? t4 * t4 : 0;
              }
            }
          E(g2, 0, 0, h2, c2, h2, this.f, this.v, this.z), E(f2, m2, m2, n2, l2, h2, this.f, this.v, this.z);
          for (let t3 = 0;t3 < u5; t3++) {
            const e3 = Math.sqrt(g2[t3]) - Math.sqrt(f2[t3]);
            d2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
          }
          return _2;
        }
      };

      class S {
        constructor() {
          this.specification = e.v.light.position;
        }
        possiblyEvaluate(t2, i2) {
          return e.x(t2.expression.evaluate(i2));
        }
        interpolate(t2, i2, a2) {
          return { x: e.y.number(t2.x, i2.x, a2), y: e.y.number(t2.y, i2.y, a2), z: e.y.number(t2.z, i2.z, a2) };
        }
      }
      let z;

      class D2 extends e.E {
        constructor(t2) {
          super(), z = z || new e.q({ anchor: new e.D(e.v.light.anchor), position: new S, color: new e.D(e.v.light.color), intensity: new e.D(e.v.light.intensity) }), this._transitionable = new e.T(z), this.setLight(t2), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(t2, i2 = {}) {
          if (!this._validate(e.r, t2, i2))
            for (const e2 in t2) {
              const i3 = t2[e2];
              e2.endsWith("-transition") ? this._transitionable.setTransition(e2.slice(0, -11), i3) : this._transitionable.setValue(e2, i3);
            }
        }
        updateTransitions(t2) {
          this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t2) {
          this.properties = this._transitioning.possiblyEvaluate(t2);
        }
        _validate(t2, i2, a2) {
          return (!a2 || a2.validate !== false) && e.t(this, t2.call(e.u, { value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.v }));
        }
      }
      const M = new e.q({ "sky-color": new e.D(e.v.sky["sky-color"]), "horizon-color": new e.D(e.v.sky["horizon-color"]), "fog-color": new e.D(e.v.sky["fog-color"]), "fog-ground-blend": new e.D(e.v.sky["fog-ground-blend"]), "horizon-fog-blend": new e.D(e.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new e.D(e.v.sky["sky-horizon-blend"]), "atmosphere-blend": new e.D(e.v.sky["atmosphere-blend"]) });

      class A extends e.E {
        constructor(t2) {
          super(), this._transitionable = new e.T(M), this.setSky(t2), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new e.z(0));
        }
        setSky(t2, i2 = {}) {
          if (!this._validate(e.B, t2, i2)) {
            t2 || (t2 = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
            for (const e2 in t2) {
              const i3 = t2[e2];
              e2.endsWith("-transition") ? this._transitionable.setTransition(e2.slice(0, -11), i3) : this._transitionable.setValue(e2, i3);
            }
          }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(t2) {
          this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t2) {
          this.properties = this._transitioning.possiblyEvaluate(t2);
        }
        _validate(t2, i2, a2 = {}) {
          return (a2 == null ? undefined : a2.validate) !== false && e.t(this, t2.call(e.u, e.e({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.v })));
        }
        calculateFogBlendOpacity(t2) {
          return t2 < 60 ? 0 : t2 < 70 ? (t2 - 60) / 10 : 1;
        }
      }

      class R {
        constructor(t2, e2) {
          this.width = t2, this.height = e2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(t2, e2) {
          const i2 = t2.join(",") + String(e2);
          return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(t2, e2)), this.dashEntry[i2];
        }
        getDashRanges(t2, e2, i2) {
          const a2 = [];
          let s2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * i2 : 0, o2 = t2[0] * i2, r2 = true;
          a2.push({ left: s2, right: o2, isDash: r2, zeroLength: t2[0] === 0 });
          let n2 = t2[0];
          for (let e3 = 1;e3 < t2.length; e3++) {
            r2 = !r2;
            const l2 = t2[e3];
            s2 = n2 * i2, n2 += l2, o2 = n2 * i2, a2.push({ left: s2, right: o2, isDash: r2, zeroLength: l2 === 0 });
          }
          return a2;
        }
        addRoundDash(t2, e2, i2) {
          const a2 = e2 / 2;
          for (let e3 = -i2;e3 <= i2; e3++) {
            const s2 = this.width * (this.nextRow + i2 + e3);
            let o2 = 0, r2 = t2[o2];
            for (let n2 = 0;n2 < this.width; n2++) {
              n2 / r2.right > 1 && (r2 = t2[++o2]);
              const l2 = Math.abs(n2 - r2.left), h2 = Math.abs(n2 - r2.right), c2 = Math.min(l2, h2);
              let u5;
              const d2 = e3 / i2 * (a2 + 1);
              if (r2.isDash) {
                const t3 = a2 - Math.abs(d2);
                u5 = Math.sqrt(c2 * c2 + t3 * t3);
              } else
                u5 = a2 - Math.sqrt(c2 * c2 + d2 * d2);
              this.data[s2 + n2] = Math.max(0, Math.min(255, u5 + 128));
            }
          }
        }
        addRegularDash(t2) {
          for (let e3 = t2.length - 1;e3 >= 0; --e3) {
            const i3 = t2[e3], a3 = t2[e3 + 1];
            i3.zeroLength ? t2.splice(e3, 1) : a3 && a3.isDash === i3.isDash && (a3.left = i3.left, t2.splice(e3, 1));
          }
          const e2 = t2[0], i2 = t2[t2.length - 1];
          e2.isDash === i2.isDash && (e2.left = i2.left - this.width, i2.right = e2.right + this.width);
          const a2 = this.width * this.nextRow;
          let s2 = 0, o2 = t2[s2];
          for (let e3 = 0;e3 < this.width; e3++) {
            e3 / o2.right > 1 && (o2 = t2[++s2]);
            const i3 = Math.abs(e3 - o2.left), r2 = Math.abs(e3 - o2.right), n2 = Math.min(i3, r2);
            this.data[a2 + e3] = Math.max(0, Math.min(255, (o2.isDash ? n2 : -n2) + 128));
          }
        }
        addDash(t2, i2) {
          const a2 = i2 ? 7 : 0, s2 = 2 * a2 + 1;
          if (this.nextRow + s2 > this.height)
            return e.w("LineAtlas out of space"), null;
          let o2 = 0;
          for (let e2 = 0;e2 < t2.length; e2++)
            o2 += t2[e2];
          if (o2 !== 0) {
            const e2 = this.width / o2, s3 = this.getDashRanges(t2, this.width, e2);
            i2 ? this.addRoundDash(s3, e2, a2) : this.addRegularDash(s3);
          }
          const r2 = { y: (this.nextRow + a2 + 0.5) / this.height, height: 2 * a2 / this.height, width: o2 };
          return this.nextRow += s2, this.dirty = true, r2;
        }
        bind(t2) {
          const e2 = t2.gl;
          this.texture ? (e2.bindTexture(e2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, this.width, this.height, e2.ALPHA, e2.UNSIGNED_BYTE, this.data))) : (this.texture = e2.createTexture(), e2.bindTexture(e2.TEXTURE_2D, this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR), e2.texImage2D(e2.TEXTURE_2D, 0, e2.ALPHA, this.width, this.height, 0, e2.ALPHA, e2.UNSIGNED_BYTE, this.data));
        }
      }
      const k = "maplibre_preloaded_worker_pool";

      class L {
        constructor() {
          this.active = {};
        }
        acquire(t2) {
          if (!this.workers)
            for (this.workers = [];this.workers.length < L.workerCount; )
              this.workers.push(new Worker(e.a.WORKER_URL));
          return this.active[t2] = true, this.workers.slice();
        }
        release(t2) {
          delete this.active[t2], this.numActive() === 0 && (this.workers.forEach((t3) => {
            t3.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[k];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const F = Math.floor(o.hardwareConcurrency / 2);
      let B2, O;
      function N() {
        return B2 || (B2 = new L), B2;
      }
      L.workerCount = e.C(globalThis) ? Math.max(Math.min(F, 3), 1) : 1;

      class U {
        constructor(t2, i2) {
          this.workerPool = t2, this.actors = [], this.currentActor = 0, this.id = i2;
          const a2 = this.workerPool.acquire(i2);
          for (let t3 = 0;t3 < a2.length; t3++) {
            const s2 = new e.F(a2[t3], i2);
            s2.name = `Worker ${t3}`, this.actors.push(s2);
          }
          if (!this.actors.length)
            throw new Error("No actors found");
        }
        broadcast(t2, e2) {
          const i2 = [];
          for (const a2 of this.actors)
            i2.push(a2.sendAsync({ type: t2, data: e2 }));
          return Promise.all(i2);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove(t2 = true) {
          this.actors.forEach((t3) => {
            t3.remove();
          }), this.actors = [], t2 && this.workerPool.release(this.id);
        }
        registerMessageHandler(t2, e2) {
          for (const i2 of this.actors)
            i2.registerMessageHandler(t2, e2);
        }
      }
      function j() {
        return O || (O = new U(N(), e.G), O.registerMessageHandler("GR", (t2, i2, a2) => e.m(i2, a2))), O;
      }
      function Z(t2, i2) {
        const a2 = e.H();
        return e.J(a2, a2, [1, 1, 0]), e.K(a2, a2, [0.5 * t2.width, 0.5 * t2.height, 1]), e.L(a2, a2, t2.calculatePosMatrix(i2.toUnwrapped()));
      }
      function q(t2, e2, i2, a2, s2, o2) {
        const r2 = function(t3, e3, i3) {
          if (t3)
            for (const a3 of t3) {
              const t4 = e3[a3];
              if (t4 && t4.source === i3 && t4.type === "fill-extrusion")
                return true;
            }
          else
            for (const t4 in e3) {
              const a3 = e3[t4];
              if (a3.source === i3 && a3.type === "fill-extrusion")
                return true;
            }
          return false;
        }(s2 && s2.layers, e2, t2.id), n2 = o2.maxPitchScaleFactor(), l2 = t2.tilesIn(a2, n2, r2);
        l2.sort(V);
        const h2 = [];
        for (const a3 of l2)
          h2.push({ wrappedTileID: a3.tileID.wrapped().key, queryResults: a3.tile.queryRenderedFeatures(e2, i2, t2._state, a3.queryGeometry, a3.cameraQueryGeometry, a3.scale, s2, o2, n2, Z(t2.transform, a3.tileID)) });
        const c2 = function(t3) {
          const e3 = {}, i3 = {};
          for (const a3 of t3) {
            const { queryResults: t4, wrappedTileID: s3 } = a3, o3 = i3[s3] = i3[s3] || {};
            for (const i4 in t4) {
              const a4 = t4[i4], s4 = o3[i4] = o3[i4] || {}, r3 = e3[i4] = e3[i4] || [];
              for (const t5 of a4)
                s4[t5.featureIndex] || (s4[t5.featureIndex] = true, r3.push(t5));
            }
          }
          return e3;
        }(h2);
        for (const e3 in c2)
          c2[e3].forEach((e4) => {
            const i3 = e4.feature, a3 = t2.getFeatureState(i3.layer["source-layer"], i3.id);
            i3.source = i3.layer.source, i3.layer["source-layer"] && (i3.sourceLayer = i3.layer["source-layer"]), i3.state = a3;
          });
        return c2;
      }
      function V(t2, e2) {
        const i2 = t2.tileID, a2 = e2.tileID;
        return i2.overscaledZ - a2.overscaledZ || i2.canonical.y - a2.canonical.y || i2.wrap - a2.wrap || i2.canonical.x - a2.canonical.x;
      }
      function G(t2, i2, a2) {
        return e._(this, undefined, undefined, function* () {
          let s2 = t2;
          if (t2.url ? s2 = (yield e.h(i2.transformRequest(t2.url, "Source"), a2)).data : yield o.frameAsync(a2), !s2)
            return null;
          const r2 = e.M(e.e(s2, t2), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
          return "vector_layers" in s2 && s2.vector_layers && (r2.vectorLayerIds = s2.vector_layers.map((t3) => t3.id)), r2;
        });
      }

      class H {
        constructor(t2, e2) {
          t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : Array.isArray(t2) && (t2.length === 4 ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1])));
        }
        setNorthEast(t2) {
          return this._ne = t2 instanceof e.N ? new e.N(t2.lng, t2.lat) : e.N.convert(t2), this;
        }
        setSouthWest(t2) {
          return this._sw = t2 instanceof e.N ? new e.N(t2.lng, t2.lat) : e.N.convert(t2), this;
        }
        extend(t2) {
          const i2 = this._sw, a2 = this._ne;
          let s2, o2;
          if (t2 instanceof e.N)
            s2 = t2, o2 = t2;
          else {
            if (!(t2 instanceof H))
              return Array.isArray(t2) ? t2.length === 4 || t2.every(Array.isArray) ? this.extend(H.convert(t2)) : this.extend(e.N.convert(t2)) : t2 && (("lng" in t2) || ("lon" in t2)) && ("lat" in t2) ? this.extend(e.N.convert(t2)) : this;
            if (s2 = t2._sw, o2 = t2._ne, !s2 || !o2)
              return this;
          }
          return i2 || a2 ? (i2.lng = Math.min(s2.lng, i2.lng), i2.lat = Math.min(s2.lat, i2.lat), a2.lng = Math.max(o2.lng, a2.lng), a2.lat = Math.max(o2.lat, a2.lat)) : (this._sw = new e.N(s2.lng, s2.lat), this._ne = new e.N(o2.lng, o2.lat)), this;
        }
        getCenter() {
          return new e.N((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new e.N(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new e.N(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(t2) {
          const { lng: i2, lat: a2 } = e.N.convert(t2);
          let s2 = this._sw.lng <= i2 && i2 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (s2 = this._sw.lng >= i2 && i2 >= this._ne.lng), this._sw.lat <= a2 && a2 <= this._ne.lat && s2;
        }
        static convert(t2) {
          return t2 instanceof H ? t2 : t2 ? new H(t2) : t2;
        }
        static fromLngLat(t2, i2 = 0) {
          const a2 = 360 * i2 / 40075017, s2 = a2 / Math.cos(Math.PI / 180 * t2.lat);
          return new H(new e.N(t2.lng - s2, t2.lat - a2), new e.N(t2.lng + s2, t2.lat + a2));
        }
        adjustAntiMeridian() {
          const t2 = new e.N(this._sw.lng, this._sw.lat), i2 = new e.N(this._ne.lng, this._ne.lat);
          return new H(t2, t2.lng > i2.lng ? new e.N(i2.lng + 360, i2.lat) : i2);
        }
      }

      class W {
        constructor(t2, e2, i2) {
          this.bounds = H.convert(this.validateBounds(t2)), this.minzoom = e2 || 0, this.maxzoom = i2 || 24;
        }
        validateBounds(t2) {
          return Array.isArray(t2) && t2.length === 4 ? [Math.max(-180, t2[0]), Math.max(-90, t2[1]), Math.min(180, t2[2]), Math.min(90, t2[3])] : [-180, -90, 180, 90];
        }
        contains(t2) {
          const i2 = Math.pow(2, t2.z), a2 = Math.floor(e.O(this.bounds.getWest()) * i2), s2 = Math.floor(e.Q(this.bounds.getNorth()) * i2), o2 = Math.ceil(e.O(this.bounds.getEast()) * i2), r2 = Math.ceil(e.Q(this.bounds.getSouth()) * i2);
          return t2.x >= a2 && t2.x < o2 && t2.y >= s2 && t2.y < r2;
        }
      }

      class $ extends e.E {
        constructor(t2, i2, a2, s2) {
          if (super(), this.id = t2, this.dispatcher = a2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e.e(this, e.M(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.e({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, this.tileSize !== 512)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(s2);
        }
        load() {
          return e._(this, undefined, undefined, function* () {
            this._loaded = false, this.fire(new e.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController;
            try {
              const t2 = yield G(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), t2 && (e.e(this, t2), t2.bounds && (this.tileBounds = new W(t2.bounds, this.minzoom, this.maxzoom)), this.fire(new e.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (t2) {
              this._tileJSONRequest = null, this.fire(new e.j(t2));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(t2) {
          return !this.tileBounds || this.tileBounds.contains(t2.canonical);
        }
        onAdd(t2) {
          this.map = t2, this.load();
        }
        setSourceProperty(t2) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), t2(), this.load();
        }
        setTiles(t2) {
          return this.setSourceProperty(() => {
            this._options.tiles = t2;
          }), this;
        }
        setUrl(t2) {
          return this.setSourceProperty(() => {
            this.url = t2, this._options.url = t2;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        serialize() {
          return e.e({}, this._options);
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = t2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i2 = { request: this.map._requestManager.transformRequest(e2, "Tile"), uid: t2.uid, tileID: t2.tileID, zoom: t2.tileID.overscaledZ, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            i2.request.collectResourceTiming = this._collectResourceTiming;
            let a2 = "RT";
            if (t2.actor && t2.state !== "expired") {
              if (t2.state === "loading")
                return new Promise((e3, i3) => {
                  t2.reloadPromise = { resolve: e3, reject: i3 };
                });
            } else
              t2.actor = this.dispatcher.getActor(), a2 = "LT";
            t2.abortController = new AbortController;
            try {
              const e3 = yield t2.actor.sendAsync({ type: a2, data: i2 }, t2.abortController);
              if (delete t2.abortController, t2.aborted)
                return;
              this._afterTileLoadWorkerResponse(t2, e3);
            } catch (e3) {
              if (delete t2.abortController, t2.aborted)
                return;
              if (e3 && e3.status !== 404)
                throw e3;
              this._afterTileLoadWorkerResponse(t2, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(t2, e2) {
          if (e2 && e2.resourceTiming && (t2.resourceTiming = e2.resourceTiming), e2 && this.map._refreshExpiredTiles && t2.setExpiryData(e2), t2.loadVectorData(e2, this.map.painter), t2.reloadPromise) {
            const e3 = t2.reloadPromise;
            t2.reloadPromise = null, this.loadTile(t2).then(e3.resolve).catch(e3.reject);
          }
        }
        abortTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.abortController && (t2.abortController.abort(), delete t2.abortController), t2.actor && (yield t2.actor.sendAsync({ type: "AT", data: { uid: t2.uid, type: this.type, source: this.id } }));
          });
        }
        unloadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.unloadVectorData(), t2.actor && (yield t2.actor.sendAsync({ type: "RMT", data: { uid: t2.uid, type: this.type, source: this.id } }));
          });
        }
        hasTransition() {
          return false;
        }
      }

      class X extends e.E {
        constructor(t2, i2, a2, s2) {
          super(), this.id = t2, this.dispatcher = a2, this.setEventedParent(s2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e.e({ type: "raster" }, i2), e.e(this, e.M(i2, ["url", "scheme", "tileSize"]));
        }
        load() {
          return e._(this, undefined, undefined, function* () {
            this._loaded = false, this.fire(new e.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController;
            try {
              const t2 = yield G(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = true, t2 && (e.e(this, t2), t2.bounds && (this.tileBounds = new W(t2.bounds, this.minzoom, this.maxzoom)), this.fire(new e.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (t2) {
              this._tileJSONRequest = null, this.fire(new e.j(t2));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t2) {
          this.map = t2, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        setSourceProperty(t2) {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), t2(), this.load();
        }
        setTiles(t2) {
          return this.setSourceProperty(() => {
            this._options.tiles = t2;
          }), this;
        }
        setUrl(t2) {
          return this.setSourceProperty(() => {
            this.url = t2, this._options.url = t2;
          }), this;
        }
        serialize() {
          return e.e({}, this._options);
        }
        hasTile(t2) {
          return !this.tileBounds || this.tileBounds.contains(t2.canonical);
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = t2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            t2.abortController = new AbortController;
            try {
              const i2 = yield _.getImage(this.map._requestManager.transformRequest(e2, "Tile"), t2.abortController, this.map._refreshExpiredTiles);
              if (delete t2.abortController, t2.aborted)
                return void (t2.state = "unloaded");
              if (i2 && i2.data) {
                this.map._refreshExpiredTiles && i2.cacheControl && i2.expires && t2.setExpiryData({ cacheControl: i2.cacheControl, expires: i2.expires });
                const e3 = this.map.painter.context, a2 = e3.gl, s2 = i2.data;
                t2.texture = this.map.painter.getTileTexture(s2.width), t2.texture ? t2.texture.update(s2, { useMipmap: true }) : (t2.texture = new b(e3, s2, a2.RGBA, { useMipmap: true }), t2.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST)), t2.state = "loaded";
              }
            } catch (e3) {
              if (delete t2.abortController, t2.aborted)
                t2.state = "unloaded";
              else if (e3)
                throw t2.state = "errored", e3;
            }
          });
        }
        abortTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.abortController && (t2.abortController.abort(), delete t2.abortController);
          });
        }
        unloadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.texture && this.map.painter.saveTileTexture(t2.texture);
          });
        }
        hasTransition() {
          return false;
        }
      }

      class K extends X {
        constructor(t2, i2, a2, s2) {
          super(t2, i2, a2, s2), this.type = "raster-dem", this.maxzoom = 22, this._options = e.e({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox", this.redFactor = i2.redFactor, this.greenFactor = i2.greenFactor, this.blueFactor = i2.blueFactor, this.baseShift = i2.baseShift;
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const i2 = t2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a2 = this.map._requestManager.transformRequest(i2, "Tile");
            t2.neighboringTiles = this._getNeighboringTiles(t2.tileID), t2.abortController = new AbortController;
            try {
              const i3 = yield _.getImage(a2, t2.abortController, this.map._refreshExpiredTiles);
              if (delete t2.abortController, t2.aborted)
                return void (t2.state = "unloaded");
              if (i3 && i3.data) {
                const a3 = i3.data;
                this.map._refreshExpiredTiles && i3.cacheControl && i3.expires && t2.setExpiryData({ cacheControl: i3.cacheControl, expires: i3.expires });
                const s2 = e.b(a3) && e.U() ? a3 : yield this.readImageNow(a3), o2 = { type: this.type, uid: t2.uid, source: this.id, rawImageData: s2, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                if (!t2.actor || t2.state === "expired") {
                  t2.actor = this.dispatcher.getActor();
                  const e2 = yield t2.actor.sendAsync({ type: "LDT", data: o2 });
                  t2.dem = e2, t2.needsHillshadePrepare = true, t2.needsTerrainPrepare = true, t2.state = "loaded";
                }
              }
            } catch (e2) {
              if (delete t2.abortController, t2.aborted)
                t2.state = "unloaded";
              else if (e2)
                throw t2.state = "errored", e2;
            }
          });
        }
        readImageNow(t2) {
          return e._(this, undefined, undefined, function* () {
            if (typeof VideoFrame != "undefined" && e.V()) {
              const i2 = t2.width + 2, a2 = t2.height + 2;
              try {
                return new e.R({ width: i2, height: a2 }, yield e.W(t2, -1, -1, i2, a2));
              } catch (t3) {
              }
            }
            return o.getImageData(t2, 1);
          });
        }
        _getNeighboringTiles(t2) {
          const i2 = t2.canonical, a2 = Math.pow(2, i2.z), s2 = (i2.x - 1 + a2) % a2, o2 = i2.x === 0 ? t2.wrap - 1 : t2.wrap, r2 = (i2.x + 1 + a2) % a2, n2 = i2.x + 1 === a2 ? t2.wrap + 1 : t2.wrap, l2 = {};
          return l2[new e.S(t2.overscaledZ, o2, i2.z, s2, i2.y).key] = { backfilled: false }, l2[new e.S(t2.overscaledZ, n2, i2.z, r2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new e.S(t2.overscaledZ, o2, i2.z, s2, i2.y - 1).key] = { backfilled: false }, l2[new e.S(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new e.S(t2.overscaledZ, n2, i2.z, r2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < a2 && (l2[new e.S(t2.overscaledZ, o2, i2.z, s2, i2.y + 1).key] = { backfilled: false }, l2[new e.S(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new e.S(t2.overscaledZ, n2, i2.z, r2, i2.y + 1).key] = { backfilled: false }), l2;
        }
        unloadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.demTexture && this.map.painter.saveTileTexture(t2.demTexture), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), t2.dem && delete t2.dem, delete t2.neighboringTiles, t2.state = "unloaded", t2.actor && (yield t2.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: t2.uid, source: this.id } }));
          });
        }
      }

      class J extends e.E {
        constructor(t2, i2, a2, s2) {
          super(), this.id = t2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = a2.getActor(), this.setEventedParent(s2), this._data = i2.data, this._options = e.e({}, i2), this._collectResourceTiming = i2.collectResourceTiming, i2.maxzoom !== undefined && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
          const o2 = e.X / this.tileSize;
          i2.clusterMaxZoom !== undefined && this.maxzoom <= i2.clusterMaxZoom && e.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i2.clusterMaxZoom}".`), this.workerOptions = e.e({ source: this.id, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (i2.buffer !== undefined ? i2.buffer : 128) * o2, tolerance: (i2.tolerance !== undefined ? i2.tolerance : 0.375) * o2, extent: e.X, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: i2.clusterMaxZoom !== undefined ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e.X, radius: (i2.clusterRadius || 50) * o2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter }, i2.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
        }
        load() {
          return e._(this, undefined, undefined, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(t2) {
          this.map = t2, this.load();
        }
        setData(t2) {
          return this._data = t2, this._updateWorkerData(), this;
        }
        updateData(t2) {
          return this._updateWorkerData(t2), this;
        }
        getData() {
          return e._(this, undefined, undefined, function* () {
            const t2 = e.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: "GD", data: t2 });
          });
        }
        setClusterOptions(t2) {
          return this.workerOptions.cluster = t2.cluster, t2 && (t2.clusterRadius !== undefined && (this.workerOptions.superclusterOptions.radius = t2.clusterRadius), t2.clusterMaxZoom !== undefined && (this.workerOptions.superclusterOptions.maxZoom = t2.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(t2) {
          return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: t2, source: this.id } });
        }
        getClusterChildren(t2) {
          return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: t2, source: this.id } });
        }
        getClusterLeaves(t2, e2, i2) {
          return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: t2, limit: e2, offset: i2 } });
        }
        _updateWorkerData(t2) {
          return e._(this, undefined, undefined, function* () {
            const i2 = e.e({ type: this.type }, this.workerOptions);
            t2 ? i2.dataDiff = t2 : typeof this._data == "string" ? (i2.request = this.map._requestManager.transformRequest(o.resolveURL(this._data), "Source"), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new e.k("dataloading", { dataType: "source" }));
            try {
              const t3 = yield this.actor.sendAsync({ type: "LD", data: i2 });
              if (this._pendingLoads--, this._removed || t3.abandoned)
                return void this.fire(new e.k("dataabort", { dataType: "source" }));
              let a2 = null;
              t3.resourceTiming && t3.resourceTiming[this.id] && (a2 = t3.resourceTiming[this.id].slice(0));
              const s2 = { dataType: "source" };
              this._collectResourceTiming && a2 && a2.length > 0 && e.e(s2, { resourceTiming: a2 }), this.fire(new e.k("data", Object.assign(Object.assign({}, s2), { sourceDataType: "metadata" }))), this.fire(new e.k("data", Object.assign(Object.assign({}, s2), { sourceDataType: "content" })));
            } catch (t3) {
              if (this._pendingLoads--, this._removed)
                return void this.fire(new e.k("dataabort", { dataType: "source" }));
              this.fire(new e.j(t3));
            }
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = t2.actor ? "RT" : "LT";
            t2.actor = this.actor;
            const i2 = { type: this.type, uid: t2.uid, tileID: t2.tileID, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
            t2.abortController = new AbortController;
            const a2 = yield this.actor.sendAsync({ type: e2, data: i2 }, t2.abortController);
            delete t2.abortController, t2.unloadVectorData(), t2.aborted || t2.loadVectorData(a2, this.map.painter, e2 === "RT");
          });
        }
        abortTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.abortController && (t2.abortController.abort(), delete t2.abortController), t2.aborted = true;
          });
        }
        unloadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: t2.uid, type: this.type, source: this.id } });
          });
        }
        onRemove() {
          this._removed = true, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
        }
        serialize() {
          return e.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return false;
        }
      }
      var Y = e.Y([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);

      class Q extends e.E {
        constructor(t2, e2, i2, a2) {
          super(), this.id = t2, this.dispatcher = i2, this.coordinates = e2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(a2), this.options = e2;
        }
        load(t2) {
          return e._(this, undefined, undefined, function* () {
            this._loaded = false, this.fire(new e.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController;
            try {
              const e2 = yield _.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
              this._request = null, this._loaded = true, e2 && e2.data && (this.image = e2.data, t2 && (this.coordinates = t2), this._finishLoading());
            } catch (t3) {
              this._request = null, this._loaded = true, this.fire(new e.j(t3));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(t2) {
          return t2.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = t2.url, this.load(t2.coordinates).finally(() => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new e.k("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(t2) {
          this.map = t2, this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), this._request = null);
        }
        setCoordinates(t2) {
          this.coordinates = t2;
          const i2 = t2.map(e.Z.fromLngLat);
          this.tileID = function(t3) {
            let i3 = 1 / 0, a3 = 1 / 0, s2 = -1 / 0, o2 = -1 / 0;
            for (const e2 of t3)
              i3 = Math.min(i3, e2.x), a3 = Math.min(a3, e2.y), s2 = Math.max(s2, e2.x), o2 = Math.max(o2, e2.y);
            const r2 = Math.max(s2 - i3, o2 - a3), n2 = Math.max(0, Math.floor(-Math.log(r2) / Math.LN2)), l2 = Math.pow(2, n2);
            return new e.a1(n2, Math.floor((i3 + s2) / 2 * l2), Math.floor((a3 + o2) / 2 * l2));
          }(i2), this.minzoom = this.maxzoom = this.tileID.z;
          const a2 = i2.map((t3) => this.tileID.getTilePoint(t3)._round());
          return this._boundsArray = new e.$, this._boundsArray.emplaceBack(a2[0].x, a2[0].y, 0, 0), this._boundsArray.emplaceBack(a2[1].x, a2[1].y, e.X, 0), this._boundsArray.emplaceBack(a2[3].x, a2[3].y, 0, e.X), this._boundsArray.emplaceBack(a2[2].x, a2[2].y, e.X, e.X), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new e.k("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image)
            return;
          const t2 = this.map.painter.context, i2 = t2.gl;
          this.boundsBuffer || (this.boundsBuffer = t2.createVertexBuffer(this._boundsArray, Y.members)), this.boundsSegments || (this.boundsSegments = e.a0.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new b(t2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
          let a2 = false;
          for (const t3 in this.tiles) {
            const e2 = this.tiles[t3];
            e2.state !== "loaded" && (e2.state = "loaded", e2.texture = this.texture, a2 = true);
          }
          a2 && this.fire(new e.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}) : t2.state = "errored";
          });
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return false;
        }
      }

      class tt extends Q {
        constructor(t2, e2, i2, a2) {
          super(t2, e2, i2, a2), this.roundZoom = true, this.type = "video", this.options = e2;
        }
        load() {
          return e._(this, undefined, undefined, function* () {
            this._loaded = false;
            const t2 = this.options;
            this.urls = [];
            for (const e2 of t2.urls)
              this.urls.push(this.map._requestManager.transformRequest(e2, "Source").url);
            try {
              const t3 = yield e.a3(this.urls);
              if (this._loaded = true, !t3)
                return;
              this.video = t3, this.video.loop = true, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading();
            } catch (t3) {
              this.fire(new e.j(t3));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(t2) {
          if (this.video) {
            const i2 = this.video.seekable;
            t2 < i2.start(0) || t2 > i2.end(0) ? this.fire(new e.j(new e.a2(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = t2;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(t2) {
          this.map || (this.map = t2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
            return;
          const t2 = this.map.painter.context, i2 = t2.gl;
          this.boundsBuffer || (this.boundsBuffer = t2.createVertexBuffer(this._boundsArray, Y.members)), this.boundsSegments || (this.boundsSegments = e.a0.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new b(t2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
          let a2 = false;
          for (const t3 in this.tiles) {
            const e2 = this.tiles[t3];
            e2.state !== "loaded" && (e2.state = "loaded", e2.texture = this.texture, a2 = true);
          }
          a2 && this.fire(new e.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }

      class et extends Q {
        constructor(t2, i2, a2, s2) {
          super(t2, i2, a2, s2), i2.coordinates ? Array.isArray(i2.coordinates) && i2.coordinates.length === 4 && !i2.coordinates.some((t3) => !Array.isArray(t3) || t3.length !== 2 || t3.some((t4) => typeof t4 != "number")) || this.fire(new e.j(new e.a2(`sources.${t2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.j(new e.a2(`sources.${t2}`, null, 'missing required property "coordinates"'))), i2.animate && typeof i2.animate != "boolean" && this.fire(new e.j(new e.a2(`sources.${t2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? typeof i2.canvas == "string" || i2.canvas instanceof HTMLCanvasElement || this.fire(new e.j(new e.a2(`sources.${t2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.j(new e.a2(`sources.${t2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = i2.animate === undefined || i2.animate;
        }
        load() {
          return e._(this, undefined, undefined, function* () {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(t2) {
          this.map = t2, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let t2 = false;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, t2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t2 = true), this._hasInvalidDimensions())
            return;
          if (Object.keys(this.tiles).length === 0)
            return;
          const i2 = this.map.painter.context, a2 = i2.gl;
          this.boundsBuffer || (this.boundsBuffer = i2.createVertexBuffer(this._boundsArray, Y.members)), this.boundsSegments || (this.boundsSegments = e.a0.simpleSegment(0, 0, 4, 2)), this.texture ? (t2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new b(i2, this.canvas, a2.RGBA, { premultiply: true });
          let s2 = false;
          for (const t3 in this.tiles) {
            const e2 = this.tiles[t3];
            e2.state !== "loaded" && (e2.state = "loaded", e2.texture = this.texture, s2 = true);
          }
          s2 && this.fire(new e.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const t2 of [this.canvas.width, this.canvas.height])
            if (isNaN(t2) || t2 <= 0)
              return true;
          return false;
        }
      }
      const it = {}, at = (t2) => {
        switch (t2) {
          case "geojson":
            return J;
          case "image":
            return Q;
          case "raster":
            return X;
          case "raster-dem":
            return K;
          case "vector":
            return $;
          case "video":
            return tt;
          case "canvas":
            return et;
        }
        return it[t2];
      }, st = "RTLPluginLoaded";

      class ot extends e.E {
        constructor() {
          super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = j();
        }
        _syncState(t2) {
          return this.status = t2, this.dispatcher.broadcast("SRPS", { pluginStatus: t2, pluginURL: this.url }).catch((t3) => {
            throw this.status = "error", t3;
          });
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = "unavailable", this.url = null;
        }
        setRTLTextPlugin(t2) {
          return e._(this, arguments, undefined, function* (t3, e2 = false) {
            if (this.url)
              throw new Error("setRTLTextPlugin cannot be called multiple times.");
            if (this.url = o.resolveURL(t3), !this.url)
              throw new Error(`requested url ${t3} is invalid`);
            if (this.status === "unavailable") {
              if (!e2)
                return this._requestImport();
              this.status = "deferred", this._syncState(this.status);
            } else if (this.status === "requested")
              return this._requestImport();
          });
        }
        _requestImport() {
          return e._(this, undefined, undefined, function* () {
            yield this._syncState("loading"), this.status = "loaded", this.fire(new e.k(st));
          });
        }
        lazyLoad() {
          this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
        }
      }
      let rt = null;
      function nt() {
        return rt || (rt = new ot), rt;
      }

      class lt {
        constructor(t2, i2) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = t2, this.uid = e.a4(), this.uses = 0, this.tileSize = i2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(t2) {
          const e2 = t2 + this.timeAdded;
          e2 < this.fadeEndTime || (this.fadeEndTime = e2);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(t2) {
          this.demTexture && t2.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(t2, i2, a2) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t2) {
            t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e2) {
              const i3 = {};
              if (!e2)
                return i3;
              for (const a3 of t3) {
                const t4 = a3.layerIds.map((t5) => e2.getLayer(t5)).filter(Boolean);
                if (t4.length !== 0) {
                  a3.layers = t4, a3.stateDependentLayerIds && (a3.stateDependentLayers = a3.stateDependentLayerIds.map((e3) => t4.filter((t5) => t5.id === e3)[0]));
                  for (const e3 of t4)
                    i3[e3.id] = a3;
                }
              }
              return i3;
            }(t2.buckets, i2.style), this.hasSymbolBuckets = false;
            for (const t3 in this.buckets) {
              const i3 = this.buckets[t3];
              if (i3 instanceof e.a6) {
                if (this.hasSymbolBuckets = true, !a2)
                  break;
                i3.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets)
              for (const t3 in this.buckets) {
                const i3 = this.buckets[t3];
                if (i3 instanceof e.a6 && i3.hasRTLText) {
                  this.hasRTLText = true, nt().lazyLoad();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const t3 in this.buckets) {
              const e2 = this.buckets[t3];
              this.queryPadding = Math.max(this.queryPadding, i2.style.getLayer(t3).queryRadius(e2));
            }
            t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage);
          } else
            this.collisionBoxArray = new e.a5;
        }
        unloadVectorData() {
          for (const t2 in this.buckets)
            this.buckets[t2].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(t2) {
          return this.buckets[t2.id];
        }
        upload(t2) {
          for (const e3 in this.buckets) {
            const i2 = this.buckets[e3];
            i2.uploadPending() && i2.upload(t2);
          }
          const e2 = t2.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new b(t2, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new b(t2, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(t2) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
        }
        queryRenderedFeatures(t2, e2, i2, a2, s2, o2, r2, n2, l2, h2) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: a2, cameraQueryGeometry: s2, scale: o2, tileSize: this.tileSize, pixelPosMatrix: h2, transform: n2, params: r2, queryPadding: this.queryPadding * l2 }, t2, e2, i2) : {};
        }
        querySourceFeatures(t2, i2) {
          const a2 = this.latestFeatureIndex;
          if (!a2 || !a2.rawTileData)
            return;
          const s2 = a2.loadVTLayers(), o2 = i2 && i2.sourceLayer ? i2.sourceLayer : "", r2 = s2._geojsonTileLayer || s2[o2];
          if (!r2)
            return;
          const n2 = e.a7(i2 && i2.filter), { z: l2, x: h2, y: c2 } = this.tileID.canonical, u5 = { z: l2, x: h2, y: c2 };
          for (let i3 = 0;i3 < r2.length; i3++) {
            const s3 = r2.feature(i3);
            if (n2.needGeometry) {
              const t3 = e.a8(s3, true);
              if (!n2.filter(new e.z(this.tileID.overscaledZ), t3, this.tileID.canonical))
                continue;
            } else if (!n2.filter(new e.z(this.tileID.overscaledZ), s3))
              continue;
            const d2 = a2.getId(s3, o2), _2 = new e.a9(s3, l2, h2, c2, d2);
            _2.tile = u5, t2.push(_2);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(t2) {
          const i2 = this.expirationTime;
          if (t2.cacheControl) {
            const i3 = e.aa(t2.cacheControl);
            i3["max-age"] && (this.expirationTime = Date.now() + 1000 * i3["max-age"]);
          } else
            t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
          if (this.expirationTime) {
            const t3 = Date.now();
            let e2 = false;
            if (this.expirationTime > t3)
              e2 = false;
            else if (i2)
              if (this.expirationTime < i2)
                e2 = true;
              else {
                const a2 = this.expirationTime - i2;
                a2 ? this.expirationTime = t3 + Math.max(a2, 30000) : e2 = true;
              }
            else
              e2 = true;
            e2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1000 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(t2, e2) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t2).length === 0)
            return;
          const i2 = this.latestFeatureIndex.loadVTLayers();
          for (const a2 in this.buckets) {
            if (!e2.style.hasLayer(a2))
              continue;
            const s2 = this.buckets[a2], o2 = s2.layers[0].sourceLayer || "_geojsonTileLayer", r2 = i2[o2], n2 = t2[o2];
            if (!r2 || !n2 || Object.keys(n2).length === 0)
              continue;
            s2.update(n2, r2, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const l2 = e2 && e2.style && e2.style.getLayer(a2);
            l2 && (this.queryPadding = Math.max(this.queryPadding, l2.queryRadius(s2)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== undefined;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < o.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = undefined;
        }
        setHoldDuration(t2) {
          this.symbolFadeHoldUntil = o.now() + t2;
        }
        setDependencies(t2, e2) {
          const i2 = {};
          for (const t3 of e2)
            i2[t3] = true;
          this.dependencies[t2] = i2;
        }
        hasDependency(t2, e2) {
          for (const i2 of t2) {
            const t3 = this.dependencies[i2];
            if (t3) {
              for (const i3 of e2)
                if (t3[i3])
                  return true;
            }
          }
          return false;
        }
      }

      class ht {
        constructor(t2, e2) {
          this.max = t2, this.onRemove = e2, this.reset();
        }
        reset() {
          for (const t2 in this.data)
            for (const e2 of this.data[t2])
              e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
          return this.data = {}, this.order = [], this;
        }
        add(t2, e2, i2) {
          const a2 = t2.wrapped().key;
          this.data[a2] === undefined && (this.data[a2] = []);
          const s2 = { value: e2, timeout: undefined };
          if (i2 !== undefined && (s2.timeout = setTimeout(() => {
            this.remove(t2, s2);
          }, i2)), this.data[a2].push(s2), this.order.push(a2), this.order.length > this.max) {
            const t3 = this._getAndRemoveByKey(this.order[0]);
            t3 && this.onRemove(t3);
          }
          return this;
        }
        has(t2) {
          return t2.wrapped().key in this.data;
        }
        getAndRemove(t2) {
          return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
        }
        _getAndRemoveByKey(t2) {
          const e2 = this.data[t2].shift();
          return e2.timeout && clearTimeout(e2.timeout), this.data[t2].length === 0 && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
        }
        getByKey(t2) {
          const e2 = this.data[t2];
          return e2 ? e2[0].value : null;
        }
        get(t2) {
          return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
        }
        remove(t2, e2) {
          if (!this.has(t2))
            return this;
          const i2 = t2.wrapped().key, a2 = e2 === undefined ? 0 : this.data[i2].indexOf(e2), s2 = this.data[i2][a2];
          return this.data[i2].splice(a2, 1), s2.timeout && clearTimeout(s2.timeout), this.data[i2].length === 0 && delete this.data[i2], this.onRemove(s2.value), this.order.splice(this.order.indexOf(i2), 1), this;
        }
        setMaxSize(t2) {
          for (this.max = t2;this.order.length > this.max; ) {
            const t3 = this._getAndRemoveByKey(this.order[0]);
            t3 && this.onRemove(t3);
          }
          return this;
        }
        filter(t2) {
          const e2 = [];
          for (const i2 in this.data)
            for (const a2 of this.data[i2])
              t2(a2.value) || e2.push(a2);
          for (const t3 of e2)
            this.remove(t3.value.tileID, t3);
        }
      }

      class ct {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(t2, i2, a2) {
          const s2 = String(i2);
          if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][s2] = this.stateChanges[t2][s2] || {}, e.e(this.stateChanges[t2][s2], a2), this.deletedStates[t2] === null) {
            this.deletedStates[t2] = {};
            for (const e2 in this.state[t2])
              e2 !== s2 && (this.deletedStates[t2][e2] = null);
          } else if (this.deletedStates[t2] && this.deletedStates[t2][s2] === null) {
            this.deletedStates[t2][s2] = {};
            for (const e2 in this.state[t2][s2])
              a2[e2] || (this.deletedStates[t2][s2][e2] = null);
          } else
            for (const e2 in a2)
              this.deletedStates[t2] && this.deletedStates[t2][s2] && this.deletedStates[t2][s2][e2] === null && delete this.deletedStates[t2][s2][e2];
        }
        removeFeatureState(t2, e2, i2) {
          if (this.deletedStates[t2] === null)
            return;
          const a2 = String(e2);
          if (this.deletedStates[t2] = this.deletedStates[t2] || {}, i2 && e2 !== undefined)
            this.deletedStates[t2][a2] !== null && (this.deletedStates[t2][a2] = this.deletedStates[t2][a2] || {}, this.deletedStates[t2][a2][i2] = null);
          else if (e2 !== undefined)
            if (this.stateChanges[t2] && this.stateChanges[t2][a2])
              for (i2 in this.deletedStates[t2][a2] = {}, this.stateChanges[t2][a2])
                this.deletedStates[t2][a2][i2] = null;
            else
              this.deletedStates[t2][a2] = null;
          else
            this.deletedStates[t2] = null;
        }
        getState(t2, i2) {
          const a2 = String(i2), s2 = e.e({}, (this.state[t2] || {})[a2], (this.stateChanges[t2] || {})[a2]);
          if (this.deletedStates[t2] === null)
            return {};
          if (this.deletedStates[t2]) {
            const e2 = this.deletedStates[t2][i2];
            if (e2 === null)
              return {};
            for (const t3 in e2)
              delete s2[t3];
          }
          return s2;
        }
        initializeTileState(t2, e2) {
          t2.setFeatureState(this.state, e2);
        }
        coalesceChanges(t2, i2) {
          const a2 = {};
          for (const t3 in this.stateChanges) {
            this.state[t3] = this.state[t3] || {};
            const i3 = {};
            for (const a3 in this.stateChanges[t3])
              this.state[t3][a3] || (this.state[t3][a3] = {}), e.e(this.state[t3][a3], this.stateChanges[t3][a3]), i3[a3] = this.state[t3][a3];
            a2[t3] = i3;
          }
          for (const t3 in this.deletedStates) {
            this.state[t3] = this.state[t3] || {};
            const i3 = {};
            if (this.deletedStates[t3] === null)
              for (const e2 in this.state[t3])
                i3[e2] = {}, this.state[t3][e2] = {};
            else
              for (const e2 in this.deletedStates[t3]) {
                if (this.deletedStates[t3][e2] === null)
                  this.state[t3][e2] = {};
                else
                  for (const i4 of Object.keys(this.deletedStates[t3][e2]))
                    delete this.state[t3][e2][i4];
                i3[e2] = this.state[t3][e2];
              }
            a2[t3] = a2[t3] || {}, e.e(a2[t3], i3);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(a2).length !== 0)
            for (const e2 in t2)
              t2[e2].setFeatureState(a2, i2);
        }
      }

      class ut extends e.E {
        constructor(t2, e2, i2) {
          super(), this.id = t2, this.dispatcher = i2, this.on("data", (t3) => this._dataHandler(t3)), this.on("dataloading", () => {
            this._sourceErrored = false;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((t3, e3, i3, a2) => {
            const s2 = new (at(e3.type))(t3, e3, i3, a2);
            if (s2.id !== t3)
              throw new Error(`Expected Source id to be ${t3} instead of ${s2.id}`);
            return s2;
          })(t2, e2, i2, this), this._tiles = {}, this._cache = new ht(0, (t3) => this._unloadTile(t3)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new ct, this._didEmitContent = false, this._updated = false;
        }
        onAdd(t2) {
          this.map = t2, this._maxTileCacheSize = t2 ? t2._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t2 ? t2._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t2);
        }
        onRemove(t2) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t2);
        }
        loaded() {
          if (this._sourceErrored)
            return true;
          if (!this._sourceLoaded)
            return false;
          if (!this._source.loaded())
            return false;
          if (!(this.used === undefined && this.usedForTerrain === undefined || this.used || this.usedForTerrain))
            return true;
          if (!this._updated)
            return false;
          for (const t2 in this._tiles) {
            const e2 = this._tiles[t2];
            if (e2.state !== "loaded" && e2.state !== "errored")
              return false;
          }
          return true;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused)
            return;
          const t2 = this._shouldReloadOnResume;
          this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(t2, i2, a2) {
          return e._(this, undefined, undefined, function* () {
            try {
              yield this._source.loadTile(t2), this._tileLoaded(t2, i2, a2);
            } catch (i3) {
              t2.state = "errored", i3.status !== 404 ? this._source.fire(new e.j(i3, { tile: t2 })) : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(t2) {
          this._source.unloadTile && this._source.unloadTile(t2);
        }
        _abortTile(t2) {
          this._source.abortTile && this._source.abortTile(t2), this._source.fire(new e.k("dataabort", { tile: t2, coord: t2.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t2) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const e2 in this._tiles) {
            const i2 = this._tiles[e2];
            i2.upload(t2), i2.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((t2) => t2.tileID).sort(dt).map((t2) => t2.key);
        }
        getRenderableIds(t2) {
          const i2 = [];
          for (const e2 in this._tiles)
            this._isIdRenderable(e2, t2) && i2.push(this._tiles[e2]);
          return t2 ? i2.sort((t3, i3) => {
            const a2 = t3.tileID, s2 = i3.tileID, o2 = new e.P(a2.canonical.x, a2.canonical.y)._rotate(this.transform.angle), r2 = new e.P(s2.canonical.x, s2.canonical.y)._rotate(this.transform.angle);
            return a2.overscaledZ - s2.overscaledZ || r2.y - o2.y || r2.x - o2.x;
          }).map((t3) => t3.tileID.key) : i2.map((t3) => t3.tileID).sort(dt).map((t3) => t3.key);
        }
        hasRenderableParent(t2) {
          const e2 = this.findLoadedParent(t2, 0);
          return !!e2 && this._isIdRenderable(e2.tileID.key);
        }
        _isIdRenderable(t2, e2) {
          return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e2 || !this._tiles[t2].holdingForFade());
        }
        reload() {
          if (this._paused)
            this._shouldReloadOnResume = true;
          else {
            this._cache.reset();
            for (const t2 in this._tiles)
              this._tiles[t2].state !== "errored" && this._reloadTile(t2, "reloading");
          }
        }
        _reloadTile(t2, i2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = this._tiles[t2];
            e2 && (e2.state !== "loading" && (e2.state = i2), yield this._loadTile(e2, t2, i2));
          });
        }
        _tileLoaded(t2, i2, a2) {
          t2.timeAdded = o.now(), a2 === "expired" && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(i2, t2), this.getSource().type === "raster-dem" && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null), t2.aborted || this._source.fire(new e.k("data", { dataType: "source", tile: t2, coord: t2.tileID }));
        }
        _backfillDEM(t2) {
          const e2 = this.getRenderableIds();
          for (let a2 = 0;a2 < e2.length; a2++) {
            const s2 = e2[a2];
            if (t2.neighboringTiles && t2.neighboringTiles[s2]) {
              const e3 = this.getTileByID(s2);
              i2(t2, e3), i2(e3, t2);
            }
          }
          function i2(t3, e3) {
            t3.needsHillshadePrepare = true, t3.needsTerrainPrepare = true;
            let i3 = e3.tileID.canonical.x - t3.tileID.canonical.x;
            const a2 = e3.tileID.canonical.y - t3.tileID.canonical.y, s2 = Math.pow(2, t3.tileID.canonical.z), o2 = e3.tileID.key;
            i3 === 0 && a2 === 0 || Math.abs(a2) > 1 || (Math.abs(i3) > 1 && (Math.abs(i3 + s2) === 1 ? i3 += s2 : Math.abs(i3 - s2) === 1 && (i3 -= s2)), e3.dem && t3.dem && (t3.dem.backfillBorder(e3.dem, i3, a2), t3.neighboringTiles && t3.neighboringTiles[o2] && (t3.neighboringTiles[o2].backfilled = true)));
          }
        }
        getTile(t2) {
          return this.getTileByID(t2.key);
        }
        getTileByID(t2) {
          return this._tiles[t2];
        }
        _retainLoadedChildren(t2, e2, i2, a2) {
          for (const s2 in this._tiles) {
            let o2 = this._tiles[s2];
            if (a2[s2] || !o2.hasData() || o2.tileID.overscaledZ <= e2 || o2.tileID.overscaledZ > i2)
              continue;
            let r2 = o2.tileID;
            for (;o2 && o2.tileID.overscaledZ > e2 + 1; ) {
              const t3 = o2.tileID.scaledTo(o2.tileID.overscaledZ - 1);
              o2 = this._tiles[t3.key], o2 && o2.hasData() && (r2 = t3);
            }
            let n2 = r2;
            for (;n2.overscaledZ > e2; )
              if (n2 = n2.scaledTo(n2.overscaledZ - 1), t2[n2.key]) {
                a2[r2.key] = r2;
                break;
              }
          }
        }
        findLoadedParent(t2, e2) {
          if (t2.key in this._loadedParentTiles) {
            const i2 = this._loadedParentTiles[t2.key];
            return i2 && i2.tileID.overscaledZ >= e2 ? i2 : null;
          }
          for (let i2 = t2.overscaledZ - 1;i2 >= e2; i2--) {
            const e3 = t2.scaledTo(i2), a2 = this._getLoadedTile(e3);
            if (a2)
              return a2;
          }
        }
        findLoadedSibling(t2) {
          return this._getLoadedTile(t2);
        }
        _getLoadedTile(t2) {
          const e2 = this._tiles[t2.key];
          return e2 && e2.hasData() ? e2 : this._cache.getByKey(t2.wrapped().key);
        }
        updateCacheSize(t2) {
          const i2 = Math.ceil(t2.width / this._source.tileSize) + 1, a2 = Math.ceil(t2.height / this._source.tileSize) + 1, s2 = Math.floor(i2 * a2 * (this._maxTileCacheZoomLevels === null ? e.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o2 = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, s2) : s2;
          this._cache.setMaxSize(o2);
        }
        handleWrapJump(t2) {
          const e2 = Math.round((t2 - (this._prevLng === undefined ? t2 : this._prevLng)) / 360);
          if (this._prevLng = t2, e2) {
            const t3 = {};
            for (const i2 in this._tiles) {
              const a2 = this._tiles[i2];
              a2.tileID = a2.tileID.unwrapTo(a2.tileID.wrap + e2), t3[a2.tileID.key] = a2;
            }
            this._tiles = t3;
            for (const t4 in this._timers)
              clearTimeout(this._timers[t4]), delete this._timers[t4];
            for (const t4 in this._tiles)
              this._setTileReloadTimer(t4, this._tiles[t4]);
          }
        }
        _updateCoveredAndRetainedTiles(t2, e2, i2, a2, s2, r2) {
          const n2 = {}, l2 = {}, h2 = Object.keys(t2), c2 = o.now();
          for (const i3 of h2) {
            const a3 = t2[i3], s3 = this._tiles[i3];
            if (!s3 || s3.fadeEndTime !== 0 && s3.fadeEndTime <= c2)
              continue;
            const o2 = this.findLoadedParent(a3, e2), r3 = this.findLoadedSibling(a3), h3 = o2 || r3 || null;
            h3 && (this._addTile(h3.tileID), n2[h3.tileID.key] = h3.tileID), l2[i3] = a3;
          }
          this._retainLoadedChildren(l2, a2, i2, t2);
          for (const e3 in n2)
            t2[e3] || (this._coveredTiles[e3] = true, t2[e3] = n2[e3]);
          if (r2) {
            const e3 = {}, i3 = {};
            for (const t3 of s2)
              this._tiles[t3.key].hasData() ? e3[t3.key] = t3 : i3[t3.key] = t3;
            for (const a3 in i3) {
              const s3 = i3[a3].children(this._source.maxzoom);
              this._tiles[s3[0].key] && this._tiles[s3[1].key] && this._tiles[s3[2].key] && this._tiles[s3[3].key] && (e3[s3[0].key] = t2[s3[0].key] = s3[0], e3[s3[1].key] = t2[s3[1].key] = s3[1], e3[s3[2].key] = t2[s3[2].key] = s3[2], e3[s3[3].key] = t2[s3[3].key] = s3[3], delete i3[a3]);
            }
            for (const a3 in i3) {
              const s3 = i3[a3], o2 = this.findLoadedParent(s3, this._source.minzoom), r3 = this.findLoadedSibling(s3), n3 = o2 || r3 || null;
              if (n3) {
                e3[n3.tileID.key] = t2[n3.tileID.key] = n3.tileID;
                for (const t3 in e3)
                  e3[t3].isChildOf(n3.tileID) && delete e3[t3];
              }
            }
            for (const t3 in this._tiles)
              e3[t3] || (this._coveredTiles[t3] = true);
          }
        }
        update(t2, i2) {
          if (!this._sourceLoaded || this._paused)
            return;
          let a2;
          this.transform = t2, this.terrain = i2, this.updateCacheSize(t2), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? a2 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new e.S(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y)) : (a2 = t2.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i2 }), this._source.hasTile && (a2 = a2.filter((t3) => this._source.hasTile(t3)))) : a2 = [];
          const s2 = t2.coveringZoomLevel(this._source), o2 = Math.max(s2 - ut.maxOverzooming, this._source.minzoom), r2 = Math.max(s2 + ut.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const t3 = {};
            for (const e2 of a2)
              if (e2.canonical.z > this._source.minzoom) {
                const i3 = e2.scaledTo(e2.canonical.z - 1);
                t3[i3.key] = i3;
                const a3 = e2.scaledTo(Math.max(this._source.minzoom, Math.min(e2.canonical.z, 5)));
                t3[a3.key] = a3;
              }
            a2 = a2.concat(Object.values(t3));
          }
          const n2 = a2.length === 0 && !this._updated && this._didEmitContent;
          this._updated = true, n2 && this.fire(new e.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
          const l2 = this._updateRetainedTiles(a2, s2);
          _t(this._source.type) && this._updateCoveredAndRetainedTiles(l2, o2, r2, s2, a2, i2);
          for (const t3 in l2)
            this._tiles[t3].clearFadeHold();
          const h2 = e.ab(this._tiles, l2);
          for (const t3 of h2) {
            const e2 = this._tiles[t3];
            e2.hasSymbolBuckets && !e2.holdingForFade() ? e2.setHoldDuration(this.map._fadeDuration) : e2.hasSymbolBuckets && !e2.symbolFadeFinished() || this._removeTile(t3);
          }
          this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const t2 in this._tiles)
            this._tiles[t2].holdingForFade() && this._removeTile(t2);
        }
        _updateRetainedTiles(t2, e2) {
          var i2;
          const a2 = {}, s2 = {}, o2 = Math.max(e2 - ut.maxOverzooming, this._source.minzoom), r2 = Math.max(e2 + ut.maxUnderzooming, this._source.minzoom), n2 = {};
          for (const i3 of t2) {
            const t3 = this._addTile(i3);
            a2[i3.key] = i3, t3.hasData() || e2 < this._source.maxzoom && (n2[i3.key] = i3);
          }
          this._retainLoadedChildren(n2, e2, r2, a2);
          for (const r3 of t2) {
            let t3 = this._tiles[r3.key];
            if (t3.hasData())
              continue;
            if (e2 + 1 > this._source.maxzoom) {
              const t4 = r3.children(this._source.maxzoom)[0], e3 = this.getTile(t4);
              if (e3 && e3.hasData()) {
                a2[t4.key] = t4;
                continue;
              }
            } else {
              const t4 = r3.children(this._source.maxzoom);
              if (a2[t4[0].key] && a2[t4[1].key] && a2[t4[2].key] && a2[t4[3].key])
                continue;
            }
            let n3 = t3.wasRequested();
            for (let e3 = r3.overscaledZ - 1;e3 >= o2; --e3) {
              const o3 = r3.scaledTo(e3);
              if (s2[o3.key])
                break;
              if (s2[o3.key] = true, t3 = this.getTile(o3), !t3 && n3 && (t3 = this._addTile(o3)), t3) {
                const e4 = t3.hasData();
                if ((e4 || !((i2 = this.map) === null || i2 === undefined ? undefined : i2.cancelPendingTileRequestsWhileZooming) || n3) && (a2[o3.key] = o3), n3 = t3.wasRequested(), e4)
                  break;
              }
            }
          }
          return a2;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const t2 in this._tiles) {
            const e2 = [];
            let i2, a2 = this._tiles[t2].tileID;
            for (;a2.overscaledZ > 0; ) {
              if (a2.key in this._loadedParentTiles) {
                i2 = this._loadedParentTiles[a2.key];
                break;
              }
              e2.push(a2.key);
              const t3 = a2.scaledTo(a2.overscaledZ - 1);
              if (i2 = this._getLoadedTile(t3), i2)
                break;
              a2 = t3;
            }
            for (const t3 of e2)
              this._loadedParentTiles[t3] = i2;
          }
        }
        _updateLoadedSiblingTileCache() {
          this._loadedSiblingTiles = {};
          for (const t2 in this._tiles) {
            const e2 = this._tiles[t2].tileID, i2 = this._getLoadedTile(e2);
            this._loadedSiblingTiles[e2.key] = i2;
          }
        }
        _addTile(t2) {
          let i2 = this._tiles[t2.key];
          if (i2)
            return i2;
          i2 = this._cache.getAndRemove(t2), i2 && (this._setTileReloadTimer(t2.key, i2), i2.tileID = t2, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, i2)));
          const a2 = i2;
          return i2 || (i2 = new lt(t2, this._source.tileSize * t2.overscaleFactor()), this._loadTile(i2, t2.key, i2.state)), i2.uses++, this._tiles[t2.key] = i2, a2 || this._source.fire(new e.k("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
        }
        _setTileReloadTimer(t2, e2) {
          t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
          const i2 = e2.getExpiryTimeout();
          i2 && (this._timers[t2] = setTimeout(() => {
            this._reloadTile(t2, "expired"), delete this._timers[t2];
          }, i2));
        }
        _removeTile(t2) {
          const e2 = this._tiles[t2];
          e2 && (e2.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e2.uses > 0 || (e2.hasData() && e2.state !== "reloading" ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
        }
        _dataHandler(t2) {
          const e2 = t2.sourceDataType;
          t2.dataType === "source" && e2 === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && t2.dataType === "source" && e2 === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
        }
        clearTiles() {
          this._shouldReloadOnResume = false, this._paused = false;
          for (const t2 in this._tiles)
            this._removeTile(t2);
          this._cache.reset();
        }
        tilesIn(t2, i2, a2) {
          const s2 = [], o2 = this.transform;
          if (!o2)
            return s2;
          const r2 = a2 ? o2.getCameraQueryGeometry(t2) : t2, n2 = t2.map((t3) => o2.pointCoordinate(t3, this.terrain)), l2 = r2.map((t3) => o2.pointCoordinate(t3, this.terrain)), h2 = this.getIds();
          let c2 = 1 / 0, u5 = 1 / 0, d2 = -1 / 0, _2 = -1 / 0;
          for (const t3 of l2)
            c2 = Math.min(c2, t3.x), u5 = Math.min(u5, t3.y), d2 = Math.max(d2, t3.x), _2 = Math.max(_2, t3.y);
          for (let t3 = 0;t3 < h2.length; t3++) {
            const a3 = this._tiles[h2[t3]];
            if (a3.holdingForFade())
              continue;
            const r3 = a3.tileID, p2 = Math.pow(2, o2.zoom - a3.tileID.overscaledZ), m2 = i2 * a3.queryPadding * e.X / a3.tileSize / p2, f2 = [r3.getTilePoint(new e.Z(c2, u5)), r3.getTilePoint(new e.Z(d2, _2))];
            if (f2[0].x - m2 < e.X && f2[0].y - m2 < e.X && f2[1].x + m2 >= 0 && f2[1].y + m2 >= 0) {
              const t4 = n2.map((t5) => r3.getTilePoint(t5)), e2 = l2.map((t5) => r3.getTilePoint(t5));
              s2.push({ tile: a3, tileID: r3, queryGeometry: t4, cameraQueryGeometry: e2, scale: p2 });
            }
          }
          return s2;
        }
        getVisibleCoordinates(t2) {
          const e2 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
          for (const t3 of e2)
            t3.posMatrix = this.transform.calculatePosMatrix(t3.toUnwrapped());
          return e2;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return true;
          if (_t(this._source.type)) {
            const t2 = o.now();
            for (const e2 in this._tiles)
              if (this._tiles[e2].fadeEndTime >= t2)
                return true;
          }
          return false;
        }
        setFeatureState(t2, e2, i2) {
          this._state.updateState(t2 = t2 || "_geojsonTileLayer", e2, i2);
        }
        removeFeatureState(t2, e2, i2) {
          this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e2, i2);
        }
        getFeatureState(t2, e2) {
          return this._state.getState(t2 = t2 || "_geojsonTileLayer", e2);
        }
        setDependencies(t2, e2, i2) {
          const a2 = this._tiles[t2];
          a2 && a2.setDependencies(e2, i2);
        }
        reloadTilesForDependencies(t2, e2) {
          for (const i2 in this._tiles)
            this._tiles[i2].hasDependency(t2, e2) && this._reloadTile(i2, "reloading");
          this._cache.filter((i2) => !i2.hasDependency(t2, e2));
        }
      }
      function dt(t2, e2) {
        const i2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), a2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
        return t2.overscaledZ - e2.overscaledZ || a2 - i2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
      }
      function _t(t2) {
        return t2 === "raster" || t2 === "image" || t2 === "video";
      }
      ut.maxOverzooming = 10, ut.maxUnderzooming = 3;

      class pt {
        constructor(t2, e2) {
          this.reset(t2, e2);
        }
        reset(t2, e2) {
          this.points = t2 || [], this._distances = [0];
          for (let t3 = 1;t3 < this.points.length; t3++)
            this._distances[t3] = this._distances[t3 - 1] + this.points[t3].dist(this.points[t3 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(t2) {
          if (this.points.length === 1)
            return this.points[0];
          t2 = e.ac(t2, 0, 1);
          let i2 = 1, a2 = this._distances[i2];
          const s2 = t2 * this.paddedLength + this.padding;
          for (;a2 < s2 && i2 < this._distances.length; )
            a2 = this._distances[++i2];
          const o2 = i2 - 1, r2 = this._distances[o2], n2 = a2 - r2, l2 = n2 > 0 ? (s2 - r2) / n2 : 0;
          return this.points[o2].mult(1 - l2).add(this.points[i2].mult(l2));
        }
      }
      function mt(t2, e2) {
        let i2 = true;
        return t2 === "always" || t2 !== "never" && e2 !== "never" || (i2 = false), i2;
      }

      class ft {
        constructor(t2, e2, i2) {
          const a2 = this.boxCells = [], s2 = this.circleCells = [];
          this.xCellCount = Math.ceil(t2 / i2), this.yCellCount = Math.ceil(e2 / i2);
          for (let t3 = 0;t3 < this.xCellCount * this.yCellCount; t3++)
            a2.push([]), s2.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t2, this.height = e2, this.xScale = this.xCellCount / t2, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(t2, e2, i2, a2, s2) {
          this._forEachCell(e2, i2, a2, s2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t2), this.bboxes.push(e2), this.bboxes.push(i2), this.bboxes.push(a2), this.bboxes.push(s2);
        }
        insertCircle(t2, e2, i2, a2) {
          this._forEachCell(e2 - a2, i2 - a2, e2 + a2, i2 + a2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t2), this.circles.push(e2), this.circles.push(i2), this.circles.push(a2);
        }
        _insertBoxCell(t2, e2, i2, a2, s2, o2) {
          this.boxCells[s2].push(o2);
        }
        _insertCircleCell(t2, e2, i2, a2, s2, o2) {
          this.circleCells[s2].push(o2);
        }
        _query(t2, e2, i2, a2, s2, o2, r2) {
          if (i2 < 0 || t2 > this.width || a2 < 0 || e2 > this.height)
            return [];
          const n2 = [];
          if (t2 <= 0 && e2 <= 0 && this.width <= i2 && this.height <= a2) {
            if (s2)
              return [{ key: null, x1: t2, y1: e2, x2: i2, y2: a2 }];
            for (let t3 = 0;t3 < this.boxKeys.length; t3++)
              n2.push({ key: this.boxKeys[t3], x1: this.bboxes[4 * t3], y1: this.bboxes[4 * t3 + 1], x2: this.bboxes[4 * t3 + 2], y2: this.bboxes[4 * t3 + 3] });
            for (let t3 = 0;t3 < this.circleKeys.length; t3++) {
              const e3 = this.circles[3 * t3], i3 = this.circles[3 * t3 + 1], a3 = this.circles[3 * t3 + 2];
              n2.push({ key: this.circleKeys[t3], x1: e3 - a3, y1: i3 - a3, x2: e3 + a3, y2: i3 + a3 });
            }
          } else
            this._forEachCell(t2, e2, i2, a2, this._queryCell, n2, { hitTest: s2, overlapMode: o2, seenUids: { box: {}, circle: {} } }, r2);
          return n2;
        }
        query(t2, e2, i2, a2) {
          return this._query(t2, e2, i2, a2, false, null);
        }
        hitTest(t2, e2, i2, a2, s2, o2) {
          return this._query(t2, e2, i2, a2, true, s2, o2).length > 0;
        }
        hitTestCircle(t2, e2, i2, a2, s2) {
          const o2 = t2 - i2, r2 = t2 + i2, n2 = e2 - i2, l2 = e2 + i2;
          if (r2 < 0 || o2 > this.width || l2 < 0 || n2 > this.height)
            return false;
          const h2 = [];
          return this._forEachCell(o2, n2, r2, l2, this._queryCellCircle, h2, { hitTest: true, overlapMode: a2, circle: { x: t2, y: e2, radius: i2 }, seenUids: { box: {}, circle: {} } }, s2), h2.length > 0;
        }
        _queryCell(t2, e2, i2, a2, s2, o2, r2, n2) {
          const { seenUids: l2, hitTest: h2, overlapMode: c2 } = r2, u5 = this.boxCells[s2];
          if (u5 !== null) {
            const s3 = this.bboxes;
            for (const r3 of u5)
              if (!l2.box[r3]) {
                l2.box[r3] = true;
                const u6 = 4 * r3, d3 = this.boxKeys[r3];
                if (t2 <= s3[u6 + 2] && e2 <= s3[u6 + 3] && i2 >= s3[u6 + 0] && a2 >= s3[u6 + 1] && (!n2 || n2(d3)) && (!h2 || !mt(c2, d3.overlapMode)) && (o2.push({ key: d3, x1: s3[u6], y1: s3[u6 + 1], x2: s3[u6 + 2], y2: s3[u6 + 3] }), h2))
                  return true;
              }
          }
          const d2 = this.circleCells[s2];
          if (d2 !== null) {
            const s3 = this.circles;
            for (const r3 of d2)
              if (!l2.circle[r3]) {
                l2.circle[r3] = true;
                const u6 = 3 * r3, d3 = this.circleKeys[r3];
                if (this._circleAndRectCollide(s3[u6], s3[u6 + 1], s3[u6 + 2], t2, e2, i2, a2) && (!n2 || n2(d3)) && (!h2 || !mt(c2, d3.overlapMode))) {
                  const t3 = s3[u6], e3 = s3[u6 + 1], i3 = s3[u6 + 2];
                  if (o2.push({ key: d3, x1: t3 - i3, y1: e3 - i3, x2: t3 + i3, y2: e3 + i3 }), h2)
                    return true;
                }
              }
          }
          return false;
        }
        _queryCellCircle(t2, e2, i2, a2, s2, o2, r2, n2) {
          const { circle: l2, seenUids: h2, overlapMode: c2 } = r2, u5 = this.boxCells[s2];
          if (u5 !== null) {
            const t3 = this.bboxes;
            for (const e3 of u5)
              if (!h2.box[e3]) {
                h2.box[e3] = true;
                const i3 = 4 * e3, a3 = this.boxKeys[e3];
                if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, t3[i3 + 0], t3[i3 + 1], t3[i3 + 2], t3[i3 + 3]) && (!n2 || n2(a3)) && !mt(c2, a3.overlapMode))
                  return o2.push(true), true;
              }
          }
          const d2 = this.circleCells[s2];
          if (d2 !== null) {
            const t3 = this.circles;
            for (const e3 of d2)
              if (!h2.circle[e3]) {
                h2.circle[e3] = true;
                const i3 = 3 * e3, a3 = this.circleKeys[e3];
                if (this._circlesCollide(t3[i3], t3[i3 + 1], t3[i3 + 2], l2.x, l2.y, l2.radius) && (!n2 || n2(a3)) && !mt(c2, a3.overlapMode))
                  return o2.push(true), true;
              }
          }
        }
        _forEachCell(t2, e2, i2, a2, s2, o2, r2, n2) {
          const l2 = this._convertToXCellCoord(t2), h2 = this._convertToYCellCoord(e2), c2 = this._convertToXCellCoord(i2), u5 = this._convertToYCellCoord(a2);
          for (let d2 = l2;d2 <= c2; d2++)
            for (let l3 = h2;l3 <= u5; l3++)
              if (s2.call(this, t2, e2, i2, a2, this.xCellCount * l3 + d2, o2, r2, n2))
                return;
        }
        _convertToXCellCoord(t2) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t2 * this.xScale)));
        }
        _convertToYCellCoord(t2) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t2 * this.yScale)));
        }
        _circlesCollide(t2, e2, i2, a2, s2, o2) {
          const r2 = a2 - t2, n2 = s2 - e2, l2 = i2 + o2;
          return l2 * l2 > r2 * r2 + n2 * n2;
        }
        _circleAndRectCollide(t2, e2, i2, a2, s2, o2, r2) {
          const n2 = (o2 - a2) / 2, l2 = Math.abs(t2 - (a2 + n2));
          if (l2 > n2 + i2)
            return false;
          const h2 = (r2 - s2) / 2, c2 = Math.abs(e2 - (s2 + h2));
          if (c2 > h2 + i2)
            return false;
          if (l2 <= n2 || c2 <= h2)
            return true;
          const u5 = l2 - n2, d2 = c2 - h2;
          return u5 * u5 + d2 * d2 <= i2 * i2;
        }
      }
      function gt(t2, i2, a2, s2, o2) {
        const r2 = e.H();
        return i2 ? (e.K(r2, r2, [1 / o2, 1 / o2, 1]), a2 || e.ad(r2, r2, s2.angle)) : e.L(r2, s2.labelPlaneMatrix, t2), r2;
      }
      function vt(t2, i2, a2, s2, o2) {
        if (i2) {
          const i3 = e.ae(t2);
          return e.K(i3, i3, [o2, o2, 1]), a2 || e.ad(i3, i3, -s2.angle), i3;
        }
        return s2.glCoordMatrix;
      }
      function xt(t2, i2, a2, s2) {
        let o2;
        s2 ? (o2 = [t2, i2, s2(t2, i2), 1], e.af(o2, o2, a2)) : (o2 = [t2, i2, 0, 1], kt(o2, o2, a2));
        const r2 = o2[3];
        return { point: new e.P(o2[0] / r2, o2[1] / r2), signedDistanceFromCamera: r2, isOccluded: false };
      }
      function yt(t2, e2) {
        return 0.5 + t2 / e2 * 0.5;
      }
      function bt(t2, e2) {
        return t2.x >= -e2[0] && t2.x <= e2[0] && t2.y >= -e2[1] && t2.y <= e2[1];
      }
      function wt(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u5, d2, _2, p2, m2) {
        const f2 = s2 ? t2.textSizeData : t2.iconSizeData, g2 = e.ag(f2, a2.transform.zoom), v3 = [256 / a2.width * 2 + 1, 256 / a2.height * 2 + 1], x2 = s2 ? t2.text.dynamicLayoutVertexArray : t2.icon.dynamicLayoutVertexArray;
        x2.clear();
        const y2 = t2.lineVertexArray, b2 = s2 ? t2.text.placedSymbolArray : t2.icon.placedSymbolArray, w2 = a2.transform.width / a2.transform.height;
        let T2 = false;
        for (let s3 = 0;s3 < b2.length; s3++) {
          const I2 = b2.get(s3);
          if (I2.hidden || I2.writingMode === e.ah.vertical && !T2) {
            Rt(I2.numGlyphs, x2);
            continue;
          }
          T2 = false;
          const E2 = xt(I2.anchorX, I2.anchorY, i2, m2);
          if (!bt(E2.point, v3)) {
            Rt(I2.numGlyphs, x2);
            continue;
          }
          const P2 = yt(a2.transform.cameraToCenterDistance, E2.signedDistanceFromCamera), C3 = e.ai(f2, g2, I2), S2 = n2 ? C3 / P2 : C3 * P2, z2 = { getElevation: m2, labelPlaneMatrix: o2, lineVertexArray: y2, pitchWithMap: n2, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: undefined, anyProjectionOccluded: false }, projection: c2, tileAnchorPoint: new e.P(I2.anchorX, I2.anchorY), unwrappedTileID: u5, width: d2, height: _2, translation: p2 }, D3 = Et(z2, I2, S2, false, l2, i2, r2, t2.glyphOffsetArray, x2, w2, h2);
          T2 = D3.useVertical, (D3.notEnoughRoom || T2 || D3.needsFlipping && Et(z2, I2, S2, true, l2, i2, r2, t2.glyphOffsetArray, x2, w2, h2).notEnoughRoom) && Rt(I2.numGlyphs, x2);
        }
        s2 ? t2.text.dynamicLayoutVertexBuffer.updateData(x2) : t2.icon.dynamicLayoutVertexBuffer.updateData(x2);
      }
      function Tt(t2, e2, i2, a2, s2, o2, r2, n2) {
        const l2 = o2.glyphStartIndex + o2.numGlyphs, h2 = o2.lineStartIndex, c2 = o2.lineStartIndex + o2.lineLength, u5 = e2.getoffsetX(o2.glyphStartIndex), d2 = e2.getoffsetX(l2 - 1), _2 = Mt(t2 * u5, i2, a2, s2, o2.segment, h2, c2, n2, r2);
        if (!_2)
          return null;
        const p2 = Mt(t2 * d2, i2, a2, s2, o2.segment, h2, c2, n2, r2);
        return p2 ? n2.projectionCache.anyProjectionOccluded ? null : { first: _2, last: p2 } : null;
      }
      function It(t2, i2, a2, s2) {
        return t2 === e.ah.horizontal && Math.abs(a2.y - i2.y) > Math.abs(a2.x - i2.x) * s2 ? { useVertical: true } : (t2 === e.ah.vertical ? i2.y < a2.y : i2.x > a2.x) ? { needsFlipping: true } : null;
      }
      function Et(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u5) {
        const d2 = a2 / 24, _2 = i2.lineOffsetX * d2, p2 = i2.lineOffsetY * d2;
        let m2;
        if (i2.numGlyphs > 1) {
          const e2 = i2.glyphStartIndex + i2.numGlyphs, a3 = i2.lineStartIndex, r3 = i2.lineStartIndex + i2.lineLength, h3 = Tt(d2, l2, _2, p2, s2, i2, u5, t2);
          if (!h3)
            return { notEnoughRoom: true };
          const f2 = xt(h3.first.point.x, h3.first.point.y, n2, t2.getElevation).point, g2 = xt(h3.last.point.x, h3.last.point.y, n2, t2.getElevation).point;
          if (o2 && !s2) {
            const t3 = It(i2.writingMode, f2, g2, c2);
            if (t3)
              return t3;
          }
          m2 = [h3.first];
          for (let o3 = i2.glyphStartIndex + 1;o3 < e2 - 1; o3++)
            m2.push(Mt(d2 * l2.getoffsetX(o3), _2, p2, s2, i2.segment, a3, r3, t2, u5));
          m2.push(h3.last);
        } else {
          if (o2 && !s2) {
            const a4 = xt(t2.tileAnchorPoint.x, t2.tileAnchorPoint.y, r2, t2.getElevation).point, s3 = i2.lineStartIndex + i2.segment + 1, o3 = new e.P(t2.lineVertexArray.getx(s3), t2.lineVertexArray.gety(s3)), n3 = xt(o3.x, o3.y, r2, t2.getElevation), l3 = n3.signedDistanceFromCamera > 0 ? n3.point : function(t3, e2, i3, a5, s4, o4) {
              return Pt(t3, e2, i3, 1, s4, o4);
            }(t2.tileAnchorPoint, o3, a4, 0, r2, t2), h3 = It(i2.writingMode, a4, l3, c2);
            if (h3)
              return h3;
          }
          const a3 = Mt(d2 * l2.getoffsetX(i2.glyphStartIndex), _2, p2, s2, i2.segment, i2.lineStartIndex, i2.lineStartIndex + i2.lineLength, t2, u5);
          if (!a3 || t2.projectionCache.anyProjectionOccluded)
            return { notEnoughRoom: true };
          m2 = [a3];
        }
        for (const t3 of m2)
          e.aj(h2, t3.point, t3.angle);
        return {};
      }
      function Pt(t2, e2, i2, a2, s2, o2) {
        const r2 = t2.add(t2.sub(e2)._unit()), n2 = s2 !== undefined ? xt(r2.x, r2.y, s2, o2.getElevation).point : St(r2.x, r2.y, o2).point, l2 = i2.sub(n2);
        return i2.add(l2._mult(a2 / l2.mag()));
      }
      function Ct(t2, i2, a2) {
        const s2 = i2.projectionCache;
        if (s2.projections[t2])
          return s2.projections[t2];
        const o2 = new e.P(i2.lineVertexArray.getx(t2), i2.lineVertexArray.gety(t2)), r2 = St(o2.x, o2.y, i2);
        if (r2.signedDistanceFromCamera > 0)
          return s2.projections[t2] = r2.point, s2.anyProjectionOccluded = s2.anyProjectionOccluded || r2.isOccluded, r2.point;
        const n2 = t2 - a2.direction;
        return function(t3, e2, i3, a3, s3) {
          return Pt(t3, e2, i3, a3, undefined, s3);
        }(a2.distanceFromAnchor === 0 ? i2.tileAnchorPoint : new e.P(i2.lineVertexArray.getx(n2), i2.lineVertexArray.gety(n2)), o2, a2.previousVertex, a2.absOffsetX - a2.distanceFromAnchor + 1, i2);
      }
      function St(t2, e2, i2) {
        const a2 = t2 + i2.translation[0], s2 = e2 + i2.translation[1];
        let o2;
        return !i2.pitchWithMap && i2.projection.useSpecialProjectionForSymbols ? (o2 = i2.projection.projectTileCoordinates(a2, s2, i2.unwrappedTileID, i2.getElevation), o2.point.x = (0.5 * o2.point.x + 0.5) * i2.width, o2.point.y = (0.5 * -o2.point.y + 0.5) * i2.height) : (o2 = xt(a2, s2, i2.labelPlaneMatrix, i2.getElevation), o2.isOccluded = false), o2;
      }
      function zt(t2, e2, i2) {
        return t2._unit()._perp()._mult(e2 * i2);
      }
      function Dt(t2, i2, a2, s2, o2, r2, n2, l2, h2) {
        if (l2.projectionCache.offsets[t2])
          return l2.projectionCache.offsets[t2];
        const c2 = a2.add(i2);
        if (t2 + h2.direction < s2 || t2 + h2.direction >= o2)
          return l2.projectionCache.offsets[t2] = c2, c2;
        const u5 = Ct(t2 + h2.direction, l2, h2), d2 = zt(u5.sub(a2), n2, h2.direction), _2 = a2.add(d2), p2 = u5.add(d2);
        return l2.projectionCache.offsets[t2] = e.ak(r2, c2, _2, p2) || c2, l2.projectionCache.offsets[t2];
      }
      function Mt(t2, e2, i2, a2, s2, o2, r2, n2, l2) {
        const h2 = a2 ? t2 - e2 : t2 + e2;
        let c2 = h2 > 0 ? 1 : -1, u5 = 0;
        a2 && (c2 *= -1, u5 = Math.PI), c2 < 0 && (u5 += Math.PI);
        let d2, _2 = c2 > 0 ? o2 + s2 : o2 + s2 + 1;
        n2.projectionCache.cachedAnchorPoint ? d2 = n2.projectionCache.cachedAnchorPoint : (d2 = St(n2.tileAnchorPoint.x, n2.tileAnchorPoint.y, n2).point, n2.projectionCache.cachedAnchorPoint = d2);
        let p2, m2, f2 = d2, g2 = d2, v3 = 0, x2 = 0;
        const y2 = Math.abs(h2), b2 = [];
        let w2;
        for (;v3 + x2 <= y2; ) {
          if (_2 += c2, _2 < o2 || _2 >= r2)
            return null;
          v3 += x2, g2 = f2, m2 = p2;
          const t3 = { absOffsetX: y2, direction: c2, distanceFromAnchor: v3, previousVertex: g2 };
          if (f2 = Ct(_2, n2, t3), i2 === 0)
            b2.push(g2), w2 = f2.sub(g2);
          else {
            let e3;
            const a3 = f2.sub(g2);
            e3 = a3.mag() === 0 ? zt(Ct(_2 + c2, n2, t3).sub(f2), i2, c2) : zt(a3, i2, c2), m2 || (m2 = g2.add(e3)), p2 = Dt(_2, e3, f2, o2, r2, m2, i2, n2, t3), b2.push(m2), w2 = p2.sub(m2);
          }
          x2 = w2.mag();
        }
        const T2 = w2._mult((y2 - v3) / x2)._add(m2 || g2), I2 = u5 + Math.atan2(f2.y - g2.y, f2.x - g2.x);
        return b2.push(T2), { point: T2, angle: l2 ? I2 : 0, path: b2 };
      }
      const At = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function Rt(t2, e2) {
        for (let i2 = 0;i2 < t2; i2++) {
          const t3 = e2.length;
          e2.resize(t3 + 4), e2.float32.set(At, 3 * t3);
        }
      }
      function kt(t2, e2, i2) {
        const a2 = e2[0], s2 = e2[1];
        return t2[0] = i2[0] * a2 + i2[4] * s2 + i2[12], t2[1] = i2[1] * a2 + i2[5] * s2 + i2[13], t2[3] = i2[3] * a2 + i2[7] * s2 + i2[15], t2;
      }
      const Lt = 100;

      class Ft {
        constructor(t2, e2, i2 = new ft(t2.width + 200, t2.height + 200, 25), a2 = new ft(t2.width + 200, t2.height + 200, 25)) {
          this.transform = t2, this.mapProjection = e2, this.grid = i2, this.ignoredGrid = a2, this.pitchFactor = Math.cos(t2._pitch) * t2.cameraToCenterDistance, this.screenRightBoundary = t2.width + Lt, this.screenBottomBoundary = t2.height + Lt, this.gridRightBoundary = t2.width + 200, this.gridBottomBoundary = t2.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(t2, e2, i2, a2, s2, o2, r2, n2, l2, h2, c2) {
          const u5 = t2.anchorPointX + n2[0], d2 = t2.anchorPointY + n2[1], _2 = this.projectAndGetPerspectiveRatio(a2, u5, d2, s2, h2), p2 = i2 * _2.perspectiveRatio;
          let m2;
          if (o2 || r2)
            m2 = this._projectCollisionBox(t2, p2, a2, s2, o2, r2, n2, _2, h2, c2);
          else {
            const e3 = _2.point.x + (c2 ? c2.x * p2 : 0), i3 = _2.point.y + (c2 ? c2.y * p2 : 0);
            m2 = { allPointsOccluded: false, box: [e3 + t2.x1 * p2, i3 + t2.y1 * p2, e3 + t2.x2 * p2, i3 + t2.y2 * p2] };
          }
          const [f2, g2, v3, x2] = m2.box;
          return this.mapProjection.useSpecialProjectionForSymbols && (o2 ? m2.allPointsOccluded : this.mapProjection.isOccluded(u5, d2, s2)) || _2.perspectiveRatio < this.perspectiveRatioCutoff || !this.isInsideGrid(f2, g2, v3, x2) || e2 !== "always" && this.grid.hitTest(f2, g2, v3, x2, e2, l2) ? { box: [f2, g2, v3, x2], placeable: false, offscreen: false } : { box: [f2, g2, v3, x2], placeable: true, offscreen: this.isOffscreen(f2, g2, v3, x2) };
        }
        placeCollisionCircles(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u5, d2, _2, p2, m2, f2) {
          const g2 = [], v3 = new e.P(i2.anchorX, i2.anchorY), x2 = this.getPerspectiveRatio(r2, v3.x, v3.y, n2, f2), y2 = (u5 ? o2 / x2 : o2 * x2) / e.ap, b2 = { getElevation: f2, labelPlaneMatrix: l2, lineVertexArray: a2, pitchWithMap: u5, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: undefined, anyProjectionOccluded: false }, projection: this.mapProjection, tileAnchorPoint: v3, unwrappedTileID: n2, width: this.transform.width, height: this.transform.height, translation: m2 }, w2 = Tt(y2, s2, i2.lineOffsetX * y2, i2.lineOffsetY * y2, false, i2, false, b2);
          let T2 = false, I2 = false, E2 = true;
          if (w2) {
            const i3 = 0.5 * _2 * x2 + p2, a3 = new e.P(-100, -100), s3 = new e.P(this.screenRightBoundary, this.screenBottomBoundary), o3 = new pt, r3 = w2.first, n3 = w2.last;
            let l3 = [];
            for (let t3 = r3.path.length - 1;t3 >= 1; t3--)
              l3.push(r3.path[t3]);
            for (let t3 = 1;t3 < n3.path.length; t3++)
              l3.push(n3.path[t3]);
            const u6 = 2.5 * i3;
            if (h2) {
              const t3 = this.projectPathToScreenSpace(l3, b2, h2);
              l3 = t3.some((t4) => t4.signedDistanceFromCamera <= 0) ? [] : t3.map((t4) => t4.point);
            }
            let m3 = [];
            if (l3.length > 0) {
              const t3 = l3[0].clone(), i4 = l3[0].clone();
              for (let e2 = 1;e2 < l3.length; e2++)
                t3.x = Math.min(t3.x, l3[e2].x), t3.y = Math.min(t3.y, l3[e2].y), i4.x = Math.max(i4.x, l3[e2].x), i4.y = Math.max(i4.y, l3[e2].y);
              m3 = t3.x >= a3.x && i4.x <= s3.x && t3.y >= a3.y && i4.y <= s3.y ? [l3] : i4.x < a3.x || t3.x > s3.x || i4.y < a3.y || t3.y > s3.y ? [] : e.al([l3], a3.x, a3.y, s3.x, s3.y);
            }
            for (const e2 of m3) {
              o3.reset(e2, 0.25 * i3);
              let a4 = 0;
              a4 = o3.length <= 0.5 * i3 ? 1 : Math.ceil(o3.paddedLength / u6) + 1;
              for (let e3 = 0;e3 < a4; e3++) {
                const s4 = e3 / Math.max(a4 - 1, 1), r4 = o3.lerp(s4), n4 = r4.x + Lt, l4 = r4.y + Lt;
                g2.push(n4, l4, i3, 0);
                const h3 = n4 - i3, u7 = l4 - i3, _3 = n4 + i3, p3 = l4 + i3;
                if (E2 = E2 && this.isOffscreen(h3, u7, _3, p3), I2 = I2 || this.isInsideGrid(h3, u7, _3, p3), t2 !== "always" && this.grid.hitTestCircle(n4, l4, i3, t2, d2) && (T2 = true, !c2))
                  return { circles: [], offscreen: false, collisionDetected: T2 };
              }
            }
          }
          return { circles: !c2 && T2 || !I2 || x2 < this.perspectiveRatioCutoff ? [] : g2, offscreen: E2, collisionDetected: T2 };
        }
        projectPathToScreenSpace(t2, e2, i2) {
          return t2.map((t3) => xt(t3.x, t3.y, i2, e2.getElevation));
        }
        queryRenderedSymbols(t2) {
          if (t2.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
            return {};
          const i2 = [];
          let a2 = 1 / 0, s2 = 1 / 0, o2 = -1 / 0, r2 = -1 / 0;
          for (const n3 of t2) {
            const t3 = new e.P(n3.x + Lt, n3.y + Lt);
            a2 = Math.min(a2, t3.x), s2 = Math.min(s2, t3.y), o2 = Math.max(o2, t3.x), r2 = Math.max(r2, t3.y), i2.push(t3);
          }
          const n2 = this.grid.query(a2, s2, o2, r2).concat(this.ignoredGrid.query(a2, s2, o2, r2)), l2 = {}, h2 = {};
          for (const t3 of n2) {
            const a3 = t3.key;
            if (l2[a3.bucketInstanceId] === undefined && (l2[a3.bucketInstanceId] = {}), l2[a3.bucketInstanceId][a3.featureIndex])
              continue;
            const s3 = [new e.P(t3.x1, t3.y1), new e.P(t3.x2, t3.y1), new e.P(t3.x2, t3.y2), new e.P(t3.x1, t3.y2)];
            e.am(i2, s3) && (l2[a3.bucketInstanceId][a3.featureIndex] = true, h2[a3.bucketInstanceId] === undefined && (h2[a3.bucketInstanceId] = []), h2[a3.bucketInstanceId].push(a3.featureIndex));
          }
          return h2;
        }
        insertCollisionBox(t2, e2, i2, a2, s2, o2) {
          (i2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: a2, featureIndex: s2, collisionGroupID: o2, overlapMode: e2 }, t2[0], t2[1], t2[2], t2[3]);
        }
        insertCollisionCircles(t2, e2, i2, a2, s2, o2) {
          const r2 = i2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: a2, featureIndex: s2, collisionGroupID: o2, overlapMode: e2 };
          for (let e3 = 0;e3 < t2.length; e3 += 4)
            r2.insertCircle(n2, t2[e3], t2[e3 + 1], t2[e3 + 2]);
        }
        projectAndGetPerspectiveRatio(t2, i2, a2, s2, o2) {
          let r2;
          o2 ? (r2 = [i2, a2, o2(i2, a2), 1], e.af(r2, r2, t2)) : (r2 = [i2, a2, 0, 1], kt(r2, r2, t2));
          const n2 = r2[3];
          return { point: new e.P((r2[0] / n2 + 1) / 2 * this.transform.width + Lt, (-r2[1] / n2 + 1) / 2 * this.transform.height + Lt), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / n2 * 0.5, isOccluded: false, signedDistanceFromCamera: n2 };
        }
        getPerspectiveRatio(t2, e2, i2, a2, s2) {
          const o2 = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(e2, i2, a2, s2) : xt(e2, i2, t2, s2);
          return 0.5 + this.transform.cameraToCenterDistance / o2.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(t2, e2, i2, a2) {
          return i2 < Lt || t2 >= this.screenRightBoundary || a2 < Lt || e2 > this.screenBottomBoundary;
        }
        isInsideGrid(t2, e2, i2, a2) {
          return i2 >= 0 && t2 < this.gridRightBoundary && a2 >= 0 && e2 < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t2 = e.an([]);
          return e.J(t2, t2, [-100, -100, 0]), t2;
        }
        _projectCollisionBox(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2) {
          let u5 = new e.P(1, 0), d2 = new e.P(0, 1);
          const _2 = new e.P(t2.anchorPointX + n2[0], t2.anchorPointY + n2[1]);
          if (r2 && !o2) {
            const t3 = this.projectAndGetPerspectiveRatio(a2, _2.x + 1, _2.y, s2, h2).point.sub(l2.point).unit(), i3 = Math.atan(t3.y / t3.x) + (t3.x < 0 ? Math.PI : 0), o3 = Math.sin(i3), r3 = Math.cos(i3);
            u5 = new e.P(r3, o3), d2 = new e.P(-o3, r3);
          } else if (!r2 && o2) {
            const t3 = -this.transform.angle, i3 = Math.sin(t3), a3 = Math.cos(t3);
            u5 = new e.P(a3, i3), d2 = new e.P(-i3, a3);
          }
          let p2 = l2.point, m2 = i2;
          if (o2) {
            p2 = _2;
            const t3 = this.transform.zoom - Math.floor(this.transform.zoom);
            m2 = Math.pow(2, -t3), m2 *= this.mapProjection.getPitchedTextCorrection(this.transform, _2, s2), c2 || (m2 *= e.ac(0.5 + l2.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4));
          }
          c2 && (p2 = p2.add(u5.mult(c2.x * m2)).add(d2.mult(c2.y * m2)));
          const f2 = t2.x1 * m2, g2 = t2.x2 * m2, v3 = (f2 + g2) / 2, x2 = t2.y1 * m2, y2 = t2.y2 * m2, b2 = (x2 + y2) / 2, w2 = [{ offsetX: f2, offsetY: x2 }, { offsetX: v3, offsetY: x2 }, { offsetX: g2, offsetY: x2 }, { offsetX: g2, offsetY: b2 }, { offsetX: g2, offsetY: y2 }, { offsetX: v3, offsetY: y2 }, { offsetX: f2, offsetY: y2 }, { offsetX: f2, offsetY: b2 }];
          let T2 = [];
          for (const { offsetX: t3, offsetY: i3 } of w2)
            T2.push(new e.P(p2.x + u5.x * t3 + d2.x * i3, p2.y + u5.y * t3 + d2.y * i3));
          let I2 = false;
          if (o2) {
            const t3 = T2.map((t4) => this.projectAndGetPerspectiveRatio(a2, t4.x, t4.y, s2, h2));
            I2 = t3.some((t4) => !t4.isOccluded), T2 = t3.map((t4) => t4.point);
          } else
            I2 = true;
          return { box: e.ao(T2), allPointsOccluded: !I2 };
        }
      }
      function Bt(t2, i2, a2) {
        return i2 * (e.X / (t2.tileSize * Math.pow(2, a2 - t2.tileID.overscaledZ)));
      }

      class Ot {
        constructor(t2, e2, i2, a2) {
          this.opacity = t2 ? Math.max(0, Math.min(1, t2.opacity + (t2.placed ? e2 : -e2))) : a2 && i2 ? 1 : 0, this.placed = i2;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }

      class Nt {
        constructor(t2, e2, i2, a2, s2) {
          this.text = new Ot(t2 ? t2.text : null, e2, i2, s2), this.icon = new Ot(t2 ? t2.icon : null, e2, a2, s2);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }

      class Ut {
        constructor(t2, e2, i2) {
          this.text = t2, this.icon = e2, this.skipFade = i2;
        }
      }

      class jt {
        constructor() {
          this.invProjMatrix = e.H(), this.viewportMatrix = e.H(), this.circles = [];
        }
      }

      class Zt {
        constructor(t2, e2, i2, a2, s2) {
          this.bucketInstanceId = t2, this.featureIndex = e2, this.sourceLayerIndex = i2, this.bucketIndex = a2, this.tileID = s2;
        }
      }

      class qt {
        constructor(t2) {
          this.crossSourceCollisions = t2, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(t2) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[t2]) {
            const e2 = ++this.maxGroupID;
            this.collisionGroups[t2] = { ID: e2, predicate: (t3) => t3.collisionGroupID === e2 };
          }
          return this.collisionGroups[t2];
        }
      }
      function Vt(t2, i2, a2, s2, o2) {
        const { horizontalAlign: r2, verticalAlign: n2 } = e.au(t2);
        return new e.P(-(r2 - 0.5) * i2 + s2[0] * o2, -(n2 - 0.5) * a2 + s2[1] * o2);
      }

      class Gt {
        constructor(t2, e2, i2, a2, s2, o2) {
          this.transform = t2.clone(), this.terrain = i2, this.collisionIndex = new Ft(this.transform, e2), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = a2, this.retainedQueryData = {}, this.collisionGroups = new qt(s2), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = o2, o2 && (o2.prevPlacement = undefined), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(t2) {
          const e2 = this.terrain;
          return e2 ? (i2, a2) => e2.getElevation(t2, i2, a2) : null;
        }
        getBucketParts(t2, i2, a2, s2) {
          const o2 = a2.getBucket(i2), r2 = a2.latestFeatureIndex;
          if (!o2 || !r2 || i2.id !== o2.layerIds[0])
            return;
          const n2 = a2.collisionBoxArray, l2 = o2.layers[0].layout, h2 = o2.layers[0].paint, c2 = Math.pow(2, this.transform.zoom - a2.tileID.overscaledZ), u5 = a2.tileSize / e.X, d2 = a2.tileID.toUnwrapped(), _2 = this.transform.calculatePosMatrix(d2), p2 = l2.get("text-pitch-alignment") === "map", m2 = l2.get("text-rotation-alignment") === "map", f2 = Bt(a2, 1, this.transform.zoom), g2 = this.collisionIndex.mapProjection.translatePosition(this.transform, a2, h2.get("text-translate"), h2.get("text-translate-anchor")), v3 = this.collisionIndex.mapProjection.translatePosition(this.transform, a2, h2.get("icon-translate"), h2.get("icon-translate-anchor")), x2 = gt(_2, p2, m2, this.transform, f2);
          let y2 = null;
          if (p2) {
            const t3 = vt(_2, p2, m2, this.transform, f2);
            y2 = e.L([], this.transform.labelPlaneMatrix, t3);
          }
          this.retainedQueryData[o2.bucketInstanceId] = new Zt(o2.bucketInstanceId, r2, o2.sourceLayerIndex, o2.index, a2.tileID);
          const b2 = { bucket: o2, layout: l2, translationText: g2, translationIcon: v3, posMatrix: _2, unwrappedTileID: d2, textLabelPlaneMatrix: x2, labelToScreenMatrix: y2, scale: c2, textPixelRatio: u5, holdingForFade: a2.holdingForFade(), collisionBoxArray: n2, partiallyEvaluatedTextSize: e.ag(o2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o2.sourceID) };
          if (s2)
            for (const e2 of o2.sortKeyRanges) {
              const { sortKey: i3, symbolInstanceStart: a3, symbolInstanceEnd: s3 } = e2;
              t2.push({ sortKey: i3, symbolInstanceStart: a3, symbolInstanceEnd: s3, parameters: b2 });
            }
          else
            t2.push({ symbolInstanceStart: 0, symbolInstanceEnd: o2.symbolInstances.length, parameters: b2 });
        }
        attemptAnchorPlacement(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u5, d2, _2, p2, m2, f2, g2, v3, x2) {
          const y2 = e.aq[t2.textAnchor], b2 = [t2.textOffset0, t2.textOffset1], w2 = Vt(y2, a2, s2, b2, o2), T2 = this.collisionIndex.placeCollisionBox(i2, d2, l2, h2, c2, n2, r2, f2, u5.predicate, x2, w2);
          if ((!v3 || this.collisionIndex.placeCollisionBox(v3, d2, l2, h2, c2, n2, r2, g2, u5.predicate, x2, w2).placeable) && T2.placeable) {
            let t3;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[_2.crossTileID] && this.prevPlacement.placements[_2.crossTileID] && this.prevPlacement.placements[_2.crossTileID].text && (t3 = this.prevPlacement.variableOffsets[_2.crossTileID].anchor), _2.crossTileID === 0)
              throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[_2.crossTileID] = { textOffset: b2, width: a2, height: s2, anchor: y2, textBoxScale: o2, prevAnchor: t3 }, this.markUsedJustification(p2, y2, _2, m2), p2.allowVerticalPlacement && (this.markUsedOrientation(p2, m2, _2), this.placedOrientations[_2.crossTileID] = m2), { shift: w2, placedGlyphBoxes: T2 };
          }
        }
        placeLayerBucketPart(t2, i2, a2) {
          const { bucket: s2, layout: o2, translationText: r2, translationIcon: n2, posMatrix: l2, unwrappedTileID: h2, textLabelPlaneMatrix: c2, labelToScreenMatrix: u5, textPixelRatio: d2, holdingForFade: _2, collisionBoxArray: p2, partiallyEvaluatedTextSize: m2, collisionGroup: f2 } = t2.parameters, g2 = o2.get("text-optional"), v3 = o2.get("icon-optional"), x2 = e.ar(o2, "text-overlap", "text-allow-overlap"), y2 = x2 === "always", b2 = e.ar(o2, "icon-overlap", "icon-allow-overlap"), w2 = b2 === "always", T2 = o2.get("text-rotation-alignment") === "map", I2 = o2.get("text-pitch-alignment") === "map", E2 = o2.get("icon-text-fit") !== "none", P2 = o2.get("symbol-z-order") === "viewport-y", C3 = y2 && (w2 || !s2.hasIconData() || v3), S2 = w2 && (y2 || !s2.hasTextData() || g2);
          !s2.collisionArrays && p2 && s2.deserializeCollisionBoxes(p2);
          const z2 = this._getTerrainElevationFunc(this.retainedQueryData[s2.bucketInstanceId].tileID), D3 = (t3, p3, w3) => {
            var P3, D4;
            if (i2[t3.crossTileID])
              return;
            if (_2)
              return void (this.placements[t3.crossTileID] = new Ut(false, false, false));
            let M2 = false, A2 = false, R2 = true, k2 = null, L2 = { box: null, placeable: false, offscreen: null }, F2 = { box: null, placeable: false, offscreen: null }, B3 = null, O2 = null, N2 = null, U2 = 0, j2 = 0, Z2 = 0;
            p3.textFeatureIndex ? U2 = p3.textFeatureIndex : t3.useRuntimeCollisionCircles && (U2 = t3.featureIndex), p3.verticalTextFeatureIndex && (j2 = p3.verticalTextFeatureIndex);
            const q2 = p3.textBox;
            if (q2) {
              const i3 = (i4) => {
                let a3 = e.ah.horizontal;
                if (s2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                  const e2 = this.prevPlacement.placedOrientations[t3.crossTileID];
                  e2 && (this.placedOrientations[t3.crossTileID] = e2, a3 = e2, this.markUsedOrientation(s2, a3, t3));
                }
                return a3;
              }, o3 = (i4, a3) => {
                if (s2.allowVerticalPlacement && t3.numVerticalGlyphVertices > 0 && p3.verticalTextBox) {
                  for (const t4 of s2.writingModes)
                    if (t4 === e.ah.vertical ? (L2 = a3(), F2 = L2) : L2 = i4(), L2 && L2.placeable)
                      break;
                } else
                  L2 = i4();
              }, c3 = t3.textAnchorOffsetStartIndex, u6 = t3.textAnchorOffsetEndIndex;
              if (u6 === c3) {
                const a3 = (e2, i4) => {
                  const a4 = this.collisionIndex.placeCollisionBox(e2, x2, d2, l2, h2, I2, T2, r2, f2.predicate, z2);
                  return a4 && a4.placeable && (this.markUsedOrientation(s2, i4, t3), this.placedOrientations[t3.crossTileID] = i4), a4;
                };
                o3(() => a3(q2, e.ah.horizontal), () => {
                  const i4 = p3.verticalTextBox;
                  return s2.allowVerticalPlacement && t3.numVerticalGlyphVertices > 0 && i4 ? a3(i4, e.ah.vertical) : { box: null, offscreen: null };
                }), i3(L2 && L2.placeable);
              } else {
                let _3 = e.aq[(D4 = (P3 = this.prevPlacement) === null || P3 === undefined ? undefined : P3.variableOffsets[t3.crossTileID]) === null || D4 === undefined ? undefined : D4.anchor];
                const m3 = (i4, o4, p4) => {
                  const m4 = i4.x2 - i4.x1, g4 = i4.y2 - i4.y1, v4 = t3.textBoxScale, y3 = E2 && b2 === "never" ? o4 : null;
                  let w4 = null, P4 = x2 === "never" ? 1 : 2, C4 = "never";
                  _3 && P4++;
                  for (let e2 = 0;e2 < P4; e2++) {
                    for (let e3 = c3;e3 < u6; e3++) {
                      const a3 = s2.textAnchorOffsets.get(e3);
                      if (_3 && a3.textAnchor !== _3)
                        continue;
                      const o5 = this.attemptAnchorPlacement(a3, i4, m4, g4, v4, T2, I2, d2, l2, h2, f2, C4, t3, s2, p4, r2, n2, y3, z2);
                      if (o5 && (w4 = o5.placedGlyphBoxes, w4 && w4.placeable))
                        return M2 = true, k2 = o5.shift, w4;
                    }
                    _3 ? _3 = null : C4 = x2;
                  }
                  return a2 && !w4 && (w4 = { box: this.collisionIndex.placeCollisionBox(q2, "always", d2, l2, h2, I2, T2, r2, f2.predicate, z2, new e.P(0, 0)).box, offscreen: false, placeable: false }), w4;
                };
                o3(() => m3(q2, p3.iconBox, e.ah.horizontal), () => {
                  const i4 = p3.verticalTextBox;
                  return s2.allowVerticalPlacement && (!L2 || !L2.placeable) && t3.numVerticalGlyphVertices > 0 && i4 ? m3(i4, p3.verticalIconBox, e.ah.vertical) : { box: null, occluded: true, offscreen: null };
                }), L2 && (M2 = L2.placeable, R2 = L2.offscreen);
                const g3 = i3(L2 && L2.placeable);
                if (!M2 && this.prevPlacement) {
                  const e2 = this.prevPlacement.variableOffsets[t3.crossTileID];
                  e2 && (this.variableOffsets[t3.crossTileID] = e2, this.markUsedJustification(s2, e2.anchor, t3, g3));
                }
              }
            }
            if (B3 = L2, M2 = B3 && B3.placeable, R2 = B3 && B3.offscreen, t3.useRuntimeCollisionCircles) {
              const i3 = s2.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex), n3 = e.ai(s2.textSizeData, m2, i3), d3 = o2.get("text-padding");
              O2 = this.collisionIndex.placeCollisionCircles(x2, i3, s2.lineVertexArray, s2.glyphOffsetArray, n3, l2, h2, c2, u5, a2, I2, f2.predicate, t3.collisionCircleDiameter, d3, r2, z2), O2.circles.length && O2.collisionDetected && !a2 && e.w("Collisions detected, but collision boxes are not shown"), M2 = y2 || O2.circles.length > 0 && !O2.collisionDetected, R2 = R2 && O2.offscreen;
            }
            if (p3.iconFeatureIndex && (Z2 = p3.iconFeatureIndex), p3.iconBox) {
              const t4 = (t5) => this.collisionIndex.placeCollisionBox(t5, b2, d2, l2, h2, I2, T2, n2, f2.predicate, z2, E2 && k2 ? k2 : undefined);
              F2 && F2.placeable && p3.verticalIconBox ? (N2 = t4(p3.verticalIconBox), A2 = N2.placeable) : (N2 = t4(p3.iconBox), A2 = N2.placeable), R2 = R2 && N2.offscreen;
            }
            const V2 = g2 || t3.numHorizontalGlyphVertices === 0 && t3.numVerticalGlyphVertices === 0, G2 = v3 || t3.numIconVertices === 0;
            V2 || G2 ? G2 ? V2 || (A2 = A2 && M2) : M2 = A2 && M2 : A2 = M2 = A2 && M2;
            const H2 = A2 && N2.placeable;
            if (M2 && B3.placeable && this.collisionIndex.insertCollisionBox(B3.box, x2, o2.get("text-ignore-placement"), s2.bucketInstanceId, F2 && F2.placeable && j2 ? j2 : U2, f2.ID), H2 && this.collisionIndex.insertCollisionBox(N2.box, b2, o2.get("icon-ignore-placement"), s2.bucketInstanceId, Z2, f2.ID), O2 && M2 && this.collisionIndex.insertCollisionCircles(O2.circles, x2, o2.get("text-ignore-placement"), s2.bucketInstanceId, U2, f2.ID), a2 && this.storeCollisionData(s2.bucketInstanceId, w3, p3, B3, N2, O2), t3.crossTileID === 0)
              throw new Error("symbolInstance.crossTileID can't be 0");
            if (s2.bucketInstanceId === 0)
              throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[t3.crossTileID] = new Ut(M2 || C3, A2 || S2, R2 || s2.justReloaded), i2[t3.crossTileID] = true;
          };
          if (P2) {
            if (t2.symbolInstanceStart !== 0)
              throw new Error("bucket.bucketInstanceId should be 0");
            const e2 = s2.getSortedSymbolIndexes(this.transform.angle);
            for (let t3 = e2.length - 1;t3 >= 0; --t3) {
              const i3 = e2[t3];
              D3(s2.symbolInstances.get(i3), s2.collisionArrays[i3], i3);
            }
          } else
            for (let e2 = t2.symbolInstanceStart;e2 < t2.symbolInstanceEnd; e2++)
              D3(s2.symbolInstances.get(e2), s2.collisionArrays[e2], e2);
          if (a2 && s2.bucketInstanceId in this.collisionCircleArrays) {
            const t3 = this.collisionCircleArrays[s2.bucketInstanceId];
            e.as(t3.invProjMatrix, l2), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          s2.justReloaded = false;
        }
        storeCollisionData(t2, e2, i2, a2, s2, o2) {
          if (i2.textBox || i2.iconBox) {
            let o3, r2;
            this.collisionBoxArrays.has(t2) ? o3 = this.collisionBoxArrays.get(t2) : (o3 = new Map, this.collisionBoxArrays.set(t2, o3)), o3.has(e2) ? r2 = o3.get(e2) : (r2 = { text: null, icon: null }, o3.set(e2, r2)), i2.textBox && (r2.text = a2.box), i2.iconBox && (r2.icon = s2.box);
          }
          if (o2) {
            let e3 = this.collisionCircleArrays[t2];
            e3 === undefined && (e3 = this.collisionCircleArrays[t2] = new jt);
            for (let t3 = 0;t3 < o2.circles.length; t3 += 4)
              e3.circles.push(o2.circles[t3 + 0]), e3.circles.push(o2.circles[t3 + 1]), e3.circles.push(o2.circles[t3 + 2]), e3.circles.push(o2.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(t2, i2, a2, s2) {
          let o2;
          o2 = s2 === e.ah.vertical ? a2.verticalPlacedTextSymbolIndex : { left: a2.leftJustifiedTextSymbolIndex, center: a2.centerJustifiedTextSymbolIndex, right: a2.rightJustifiedTextSymbolIndex }[e.at(i2)];
          const r2 = [a2.leftJustifiedTextSymbolIndex, a2.centerJustifiedTextSymbolIndex, a2.rightJustifiedTextSymbolIndex, a2.verticalPlacedTextSymbolIndex];
          for (const e2 of r2)
            e2 >= 0 && (t2.text.placedSymbolArray.get(e2).crossTileID = o2 >= 0 && e2 !== o2 ? 0 : a2.crossTileID);
        }
        markUsedOrientation(t2, i2, a2) {
          const s2 = i2 === e.ah.horizontal || i2 === e.ah.horizontalOnly ? i2 : 0, o2 = i2 === e.ah.vertical ? i2 : 0, r2 = [a2.leftJustifiedTextSymbolIndex, a2.centerJustifiedTextSymbolIndex, a2.rightJustifiedTextSymbolIndex];
          for (const e2 of r2)
            t2.text.placedSymbolArray.get(e2).placedOrientation = s2;
          a2.verticalPlacedTextSymbolIndex && (t2.text.placedSymbolArray.get(a2.verticalPlacedTextSymbolIndex).placedOrientation = o2);
        }
        commit(t2) {
          this.commitTime = t2, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const e2 = this.prevPlacement;
          let i2 = false;
          this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
          const a2 = e2 ? e2.symbolFadeChange(t2) : 1, s2 = e2 ? e2.opacities : {}, o2 = e2 ? e2.variableOffsets : {}, r2 = e2 ? e2.placedOrientations : {};
          for (const t3 in this.placements) {
            const e3 = this.placements[t3], o3 = s2[t3];
            o3 ? (this.opacities[t3] = new Nt(o3, a2, e3.text, e3.icon), i2 = i2 || e3.text !== o3.text.placed || e3.icon !== o3.icon.placed) : (this.opacities[t3] = new Nt(null, a2, e3.text, e3.icon, e3.skipFade), i2 = i2 || e3.text || e3.icon);
          }
          for (const t3 in s2) {
            const e3 = s2[t3];
            if (!this.opacities[t3]) {
              const s3 = new Nt(e3, a2, false, false);
              s3.isHidden() || (this.opacities[t3] = s3, i2 = i2 || e3.text.placed || e3.icon.placed);
            }
          }
          for (const t3 in o2)
            this.variableOffsets[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.variableOffsets[t3] = o2[t3]);
          for (const t3 in r2)
            this.placedOrientations[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.placedOrientations[t3] = r2[t3]);
          if (e2 && e2.lastPlacementChangeTime === undefined)
            throw new Error("Last placement time for previous placement is not defined");
          i2 ? this.lastPlacementChangeTime = t2 : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t2);
        }
        updateLayerOpacities(t2, e2) {
          const i2 = {};
          for (const a2 of e2) {
            const e3 = a2.getBucket(t2);
            e3 && a2.latestFeatureIndex && t2.id === e3.layerIds[0] && this.updateBucketOpacities(e3, a2.tileID, i2, a2.collisionBoxArray);
          }
        }
        updateBucketOpacities(t2, i2, a2, s2) {
          t2.hasTextData() && (t2.text.opacityVertexArray.clear(), t2.text.hasVisibleVertices = false), t2.hasIconData() && (t2.icon.opacityVertexArray.clear(), t2.icon.hasVisibleVertices = false), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexArray.clear(), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexArray.clear();
          const o2 = t2.layers[0], r2 = o2.layout, n2 = new Nt(null, 0, false, false, true), l2 = r2.get("text-allow-overlap"), h2 = r2.get("icon-allow-overlap"), c2 = o2._unevaluatedLayout.hasValue("text-variable-anchor") || o2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u5 = r2.get("text-rotation-alignment") === "map", d2 = r2.get("text-pitch-alignment") === "map", _2 = r2.get("icon-text-fit") !== "none", p2 = new Nt(null, 0, l2 && (h2 || !t2.hasIconData() || r2.get("icon-optional")), h2 && (l2 || !t2.hasTextData() || r2.get("text-optional")), true);
          !t2.collisionArrays && s2 && (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) && t2.deserializeCollisionBoxes(s2);
          const m2 = (t3, e2, i3) => {
            for (let a3 = 0;a3 < e2 / 4; a3++)
              t3.opacityVertexArray.emplaceBack(i3);
            t3.hasVisibleVertices = t3.hasVisibleVertices || i3 !== ee;
          }, f2 = this.collisionBoxArrays.get(t2.bucketInstanceId);
          for (let i3 = 0;i3 < t2.symbolInstances.length; i3++) {
            const s3 = t2.symbolInstances.get(i3), { numHorizontalGlyphVertices: o3, numVerticalGlyphVertices: r3, crossTileID: l3 } = s3;
            let h3 = this.opacities[l3];
            a2[l3] ? h3 = n2 : h3 || (h3 = p2, this.opacities[l3] = h3), a2[l3] = true;
            const g2 = s3.numIconVertices > 0, v3 = this.placedOrientations[s3.crossTileID], x2 = v3 === e.ah.vertical, y2 = v3 === e.ah.horizontal || v3 === e.ah.horizontalOnly;
            if (o3 > 0 || r3 > 0) {
              const e2 = te(h3.text);
              m2(t2.text, o3, x2 ? ee : e2), m2(t2.text, r3, y2 ? ee : e2);
              const i4 = h3.text.isHidden();
              [s3.rightJustifiedTextSymbolIndex, s3.centerJustifiedTextSymbolIndex, s3.leftJustifiedTextSymbolIndex].forEach((e3) => {
                e3 >= 0 && (t2.text.placedSymbolArray.get(e3).hidden = i4 || x2 ? 1 : 0);
              }), s3.verticalPlacedTextSymbolIndex >= 0 && (t2.text.placedSymbolArray.get(s3.verticalPlacedTextSymbolIndex).hidden = i4 || y2 ? 1 : 0);
              const a3 = this.variableOffsets[s3.crossTileID];
              a3 && this.markUsedJustification(t2, a3.anchor, s3, v3);
              const n3 = this.placedOrientations[s3.crossTileID];
              n3 && (this.markUsedJustification(t2, "left", s3, n3), this.markUsedOrientation(t2, n3, s3));
            }
            if (g2) {
              const e2 = te(h3.icon), i4 = !(_2 && s3.verticalPlacedIconSymbolIndex && x2);
              s3.placedIconSymbolIndex >= 0 && (m2(t2.icon, s3.numIconVertices, i4 ? e2 : ee), t2.icon.placedSymbolArray.get(s3.placedIconSymbolIndex).hidden = h3.icon.isHidden()), s3.verticalPlacedIconSymbolIndex >= 0 && (m2(t2.icon, s3.numVerticalIconVertices, i4 ? ee : e2), t2.icon.placedSymbolArray.get(s3.verticalPlacedIconSymbolIndex).hidden = h3.icon.isHidden());
            }
            const b2 = f2 && f2.has(i3) ? f2.get(i3) : { text: null, icon: null };
            if (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) {
              const a3 = t2.collisionArrays[i3];
              if (a3) {
                let i4 = new e.P(0, 0);
                if (a3.textBox || a3.verticalTextBox) {
                  let e2 = true;
                  if (c2) {
                    const t3 = this.variableOffsets[l3];
                    t3 ? (i4 = Vt(t3.anchor, t3.width, t3.height, t3.textOffset, t3.textBoxScale), u5 && i4._rotate(d2 ? this.transform.angle : -this.transform.angle)) : e2 = false;
                  }
                  if (a3.textBox || a3.verticalTextBox) {
                    let s4;
                    a3.textBox && (s4 = x2), a3.verticalTextBox && (s4 = y2), Ht(t2.textCollisionBox.collisionVertexArray, h3.text.placed, !e2 || s4, b2.text, i4.x, i4.y);
                  }
                }
                if (a3.iconBox || a3.verticalIconBox) {
                  const e2 = Boolean(!y2 && a3.verticalIconBox);
                  let s4;
                  a3.iconBox && (s4 = e2), a3.verticalIconBox && (s4 = !e2), Ht(t2.iconCollisionBox.collisionVertexArray, h3.icon.placed, s4, b2.icon, _2 ? i4.x : 0, _2 ? i4.y : 0);
                }
              }
            }
          }
          if (t2.sortFeatures(this.transform.angle), this.retainedQueryData[t2.bucketInstanceId] && (this.retainedQueryData[t2.bucketInstanceId].featureSortOrder = t2.featureSortOrder), t2.hasTextData() && t2.text.opacityVertexBuffer && t2.text.opacityVertexBuffer.updateData(t2.text.opacityVertexArray), t2.hasIconData() && t2.icon.opacityVertexBuffer && t2.icon.opacityVertexBuffer.updateData(t2.icon.opacityVertexArray), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexBuffer && t2.iconCollisionBox.collisionVertexBuffer.updateData(t2.iconCollisionBox.collisionVertexArray), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexBuffer && t2.textCollisionBox.collisionVertexBuffer.updateData(t2.textCollisionBox.collisionVertexArray), t2.text.opacityVertexArray.length !== t2.text.layoutVertexArray.length / 4)
            throw new Error(`bucket.text.opacityVertexArray.length (= ${t2.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${t2.text.layoutVertexArray.length}) / 4`);
          if (t2.icon.opacityVertexArray.length !== t2.icon.layoutVertexArray.length / 4)
            throw new Error(`bucket.icon.opacityVertexArray.length (= ${t2.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${t2.icon.layoutVertexArray.length}) / 4`);
          if (t2.bucketInstanceId in this.collisionCircleArrays) {
            const e2 = this.collisionCircleArrays[t2.bucketInstanceId];
            t2.placementInvProjMatrix = e2.invProjMatrix, t2.placementViewportMatrix = e2.viewportMatrix, t2.collisionCircleArray = e2.circles, delete this.collisionCircleArrays[t2.bucketInstanceId];
          }
        }
        symbolFadeChange(t2) {
          return this.fadeDuration === 0 ? 1 : (t2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(t2) {
          return Math.max(0, (this.transform.zoom - t2) / 1.5);
        }
        hasTransitions(t2) {
          return this.stale || t2 - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(t2, e2) {
          const i2 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
          return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i2 > t2;
        }
        setStale() {
          this.stale = true;
        }
      }
      function Ht(t2, e2, i2, a2, s2, o2) {
        a2 && a2.length !== 0 || (a2 = [0, 0, 0, 0]);
        const r2 = a2[0] - Lt, n2 = a2[1] - Lt, l2 = a2[2] - Lt, h2 = a2[3] - Lt;
        t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, o2 || 0, r2, n2), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, o2 || 0, l2, n2), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, o2 || 0, l2, h2), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, o2 || 0, r2, h2);
      }
      const Wt = Math.pow(2, 25), $t = Math.pow(2, 24), Xt = Math.pow(2, 17), Kt = Math.pow(2, 16), Jt = Math.pow(2, 9), Yt = Math.pow(2, 8), Qt = Math.pow(2, 1);
      function te(t2) {
        if (t2.opacity === 0 && !t2.placed)
          return 0;
        if (t2.opacity === 1 && t2.placed)
          return 4294967295;
        const e2 = t2.placed ? 1 : 0, i2 = Math.floor(127 * t2.opacity);
        return i2 * Wt + e2 * $t + i2 * Xt + e2 * Kt + i2 * Jt + e2 * Yt + i2 * Qt + e2;
      }
      const ee = 0;
      function ie() {
        return { isOccluded: (t2, e2, i2) => false, getPitchedTextCorrection: (t2, e2, i2) => 1, get useSpecialProjectionForSymbols() {
          return false;
        }, projectTileCoordinates(t2, e2, i2, a2) {
          throw new Error("Not implemented.");
        }, translatePosition: (t2, e2, i2, a2) => function(t3, e3, i3, a3, s2 = false) {
          if (!i3[0] && !i3[1])
            return [0, 0];
          const o2 = s2 ? a3 === "map" ? t3.angle : 0 : a3 === "viewport" ? -t3.angle : 0;
          if (o2) {
            const t4 = Math.sin(o2), e4 = Math.cos(o2);
            i3 = [i3[0] * e4 - i3[1] * t4, i3[0] * t4 + i3[1] * e4];
          }
          return [s2 ? i3[0] : Bt(e3, i3[0], t3.zoom), s2 ? i3[1] : Bt(e3, i3[1], t3.zoom)];
        }(t2, e2, i2, a2), getCircleRadiusCorrection: (t2) => 1 };
      }

      class ae {
        constructor(t2) {
          this._sortAcrossTiles = t2.layout.get("symbol-z-order") !== "viewport-y" && !t2.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(t2, e2, i2, a2, s2) {
          const o2 = this._bucketParts;
          for (;this._currentTileIndex < t2.length; )
            if (e2.getBucketParts(o2, a2, t2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, s2())
              return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o2.sort((t3, e3) => t3.sortKey - e3.sortKey));this._currentPartIndex < o2.length; )
            if (e2.placeLayerBucketPart(o2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, s2())
              return true;
          return false;
        }
      }

      class se {
        constructor(t2, e2, i2, a2, s2, o2, r2, n2) {
          this.placement = new Gt(t2, ie(), e2, o2, r2, n2), this._currentPlacementIndex = i2.length - 1, this._forceFullPlacement = a2, this._showCollisionBoxes = s2, this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t2, e2, i2) {
          const a2 = o.now(), s2 = () => !this._forceFullPlacement && o.now() - a2 > 2;
          for (;this._currentPlacementIndex >= 0; ) {
            const a3 = e2[t2[this._currentPlacementIndex]], o2 = this.placement.collisionIndex.transform.zoom;
            if (a3.type === "symbol" && (!a3.minzoom || a3.minzoom <= o2) && (!a3.maxzoom || a3.maxzoom > o2)) {
              if (this._inProgressLayer || (this._inProgressLayer = new ae(a3)), this._inProgressLayer.continuePlacement(i2[a3.source], this.placement, this._showCollisionBoxes, a3, s2))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(t2) {
          return this.placement.commit(t2), this.placement;
        }
      }
      const oe = 512 / e.X / 2;

      class re {
        constructor(t2, i2, a2) {
          this.tileID = t2, this.bucketInstanceId = a2, this._symbolsByKey = {};
          const s2 = new Map;
          for (let t3 = 0;t3 < i2.length; t3++) {
            const e2 = i2.get(t3), a3 = e2.key, o2 = s2.get(a3);
            o2 ? o2.push(e2) : s2.set(a3, [e2]);
          }
          for (const [t3, i3] of s2) {
            const a3 = { positions: i3.map((t4) => ({ x: Math.floor(t4.anchorX * oe), y: Math.floor(t4.anchorY * oe) })), crossTileIDs: i3.map((t4) => t4.crossTileID) };
            if (a3.positions.length > 128) {
              const t4 = new e.av(a3.positions.length, 16, Uint16Array);
              for (const { x: e2, y: i4 } of a3.positions)
                t4.add(e2, i4);
              t4.finish(), delete a3.positions, a3.index = t4;
            }
            this._symbolsByKey[t3] = a3;
          }
        }
        getScaledCoordinates(t2, i2) {
          const { x: a2, y: s2, z: o2 } = this.tileID.canonical, { x: r2, y: n2, z: l2 } = i2.canonical, h2 = oe / Math.pow(2, l2 - o2), c2 = (n2 * e.X + t2.anchorY) * h2, u5 = s2 * e.X * oe;
          return { x: Math.floor((r2 * e.X + t2.anchorX) * h2 - a2 * e.X * oe), y: Math.floor(c2 - u5) };
        }
        findMatches(t2, e2, i2) {
          const a2 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z);
          for (let s2 = 0;s2 < t2.length; s2++) {
            const o2 = t2.get(s2);
            if (o2.crossTileID)
              continue;
            const r2 = this._symbolsByKey[o2.key];
            if (!r2)
              continue;
            const n2 = this.getScaledCoordinates(o2, e2);
            if (r2.index) {
              const t3 = r2.index.range(n2.x - a2, n2.y - a2, n2.x + a2, n2.y + a2).sort();
              for (const e3 of t3) {
                const t4 = r2.crossTileIDs[e3];
                if (!i2[t4]) {
                  i2[t4] = true, o2.crossTileID = t4;
                  break;
                }
              }
            } else if (r2.positions)
              for (let t3 = 0;t3 < r2.positions.length; t3++) {
                const e3 = r2.positions[t3], s3 = r2.crossTileIDs[t3];
                if (Math.abs(e3.x - n2.x) <= a2 && Math.abs(e3.y - n2.y) <= a2 && !i2[s3]) {
                  i2[s3] = true, o2.crossTileID = s3;
                  break;
                }
              }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map(({ crossTileIDs: t2 }) => t2);
        }
      }

      class ne {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }

      class le {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(t2) {
          const e2 = Math.round((t2 - this.lng) / 360);
          if (e2 !== 0)
            for (const t3 in this.indexes) {
              const i2 = this.indexes[t3], a2 = {};
              for (const t4 in i2) {
                const s2 = i2[t4];
                s2.tileID = s2.tileID.unwrapTo(s2.tileID.wrap + e2), a2[s2.tileID.key] = s2;
              }
              this.indexes[t3] = a2;
            }
          this.lng = t2;
        }
        addBucket(t2, e2, i2) {
          if (this.indexes[t2.overscaledZ] && this.indexes[t2.overscaledZ][t2.key]) {
            if (this.indexes[t2.overscaledZ][t2.key].bucketInstanceId === e2.bucketInstanceId)
              return false;
            this.removeBucketCrossTileIDs(t2.overscaledZ, this.indexes[t2.overscaledZ][t2.key]);
          }
          for (let t3 = 0;t3 < e2.symbolInstances.length; t3++)
            e2.symbolInstances.get(t3).crossTileID = 0;
          this.usedCrossTileIDs[t2.overscaledZ] || (this.usedCrossTileIDs[t2.overscaledZ] = {});
          const a2 = this.usedCrossTileIDs[t2.overscaledZ];
          for (const i3 in this.indexes) {
            const s2 = this.indexes[i3];
            if (Number(i3) > t2.overscaledZ)
              for (const i4 in s2) {
                const o2 = s2[i4];
                o2.tileID.isChildOf(t2) && o2.findMatches(e2.symbolInstances, t2, a2);
              }
            else {
              const o2 = s2[t2.scaledTo(Number(i3)).key];
              o2 && o2.findMatches(e2.symbolInstances, t2, a2);
            }
          }
          for (let t3 = 0;t3 < e2.symbolInstances.length; t3++) {
            const s2 = e2.symbolInstances.get(t3);
            s2.crossTileID || (s2.crossTileID = i2.generate(), a2[s2.crossTileID] = true);
          }
          return this.indexes[t2.overscaledZ] === undefined && (this.indexes[t2.overscaledZ] = {}), this.indexes[t2.overscaledZ][t2.key] = new re(t2, e2.symbolInstances, e2.bucketInstanceId), true;
        }
        removeBucketCrossTileIDs(t2, e2) {
          for (const i2 of e2.getCrossTileIDsLists())
            for (const e3 of i2)
              delete this.usedCrossTileIDs[t2][e3];
        }
        removeStaleBuckets(t2) {
          let e2 = false;
          for (const i2 in this.indexes) {
            const a2 = this.indexes[i2];
            for (const s2 in a2)
              t2[a2[s2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, a2[s2]), delete a2[s2], e2 = true);
          }
          return e2;
        }
      }

      class he {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new ne, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(t2, e2, i2) {
          let a2 = this.layerIndexes[t2.id];
          a2 === undefined && (a2 = this.layerIndexes[t2.id] = new le);
          let s2 = false;
          const o2 = {};
          a2.handleWrapJump(i2);
          for (const i3 of e2) {
            const e3 = i3.getBucket(t2);
            e3 && t2.id === e3.layerIds[0] && (e3.bucketInstanceId || (e3.bucketInstanceId = ++this.maxBucketInstanceId), a2.addBucket(i3.tileID, e3, this.crossTileIDs) && (s2 = true), o2[e3.bucketInstanceId] = true);
          }
          return a2.removeStaleBuckets(o2) && (s2 = true), s2;
        }
        pruneUnusedLayers(t2) {
          const e2 = {};
          t2.forEach((t3) => {
            e2[t3] = true;
          });
          for (const t3 in this.layerIndexes)
            e2[t3] || delete this.layerIndexes[t3];
        }
      }
      const ce2 = (t2, i2) => e.t(t2, i2 && i2.filter((t3) => t3.identifier !== "source.canvas")), ue = e.aw();

      class de2 extends e.E {
        constructor(t2, i2 = {}) {
          super(), this._rtlPluginLoaded = () => {
            for (const t3 in this.sourceCaches) {
              const e2 = this.sourceCaches[t3].getSource().type;
              e2 !== "vector" && e2 !== "geojson" || this.sourceCaches[t3].reload();
            }
          }, this.map = t2, this.dispatcher = new U(N(), t2._getMapId()), this.dispatcher.registerMessageHandler("GG", (t3, e2) => this.getGlyphs(t3, e2)), this.dispatcher.registerMessageHandler("GI", (t3, e2) => this.getImages(t3, e2)), this.imageManager = new T, this.imageManager.setEventedParent(this), this.glyphManager = new C(t2._requestManager, i2.localIdeographFontFamily), this.lineAtlas = new R(256, 512), this.crossTileSymbolIndex = new he, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new e.ax, this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", e.ay()), nt().on(st, this._rtlPluginLoaded), this.on("data", (t3) => {
            if (t3.dataType !== "source" || t3.sourceDataType !== "metadata")
              return;
            const e2 = this.sourceCaches[t3.sourceId];
            if (!e2)
              return;
            const i3 = e2.getSource();
            if (i3 && i3.vectorLayerIds)
              for (const t4 in this._layers) {
                const e3 = this._layers[t4];
                e3.source === i3.id && this._validateLayer(e3);
              }
          });
        }
        loadURL(t2, i2 = {}, a2) {
          this.fire(new e.k("dataloading", { dataType: "style" })), i2.validate = typeof i2.validate != "boolean" || i2.validate;
          const s2 = this.map._requestManager.transformRequest(t2, "Style");
          this._loadStyleRequest = new AbortController;
          const o2 = this._loadStyleRequest;
          e.h(s2, this._loadStyleRequest).then((t3) => {
            this._loadStyleRequest = null, this._load(t3.data, i2, a2);
          }).catch((t3) => {
            this._loadStyleRequest = null, t3 && !o2.signal.aborted && this.fire(new e.j(t3));
          });
        }
        loadJSON(t2, i2 = {}, a2) {
          this.fire(new e.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController, o.frameAsync(this._frameRequest).then(() => {
            this._frameRequest = null, i2.validate = i2.validate !== false, this._load(t2, i2, a2);
          }).catch(() => {
          });
        }
        loadEmpty() {
          this.fire(new e.k("dataloading", { dataType: "style" })), this._load(ue, { validate: false });
        }
        _load(t2, i2, a2) {
          var s2;
          const o2 = i2.transformStyle ? i2.transformStyle(a2, t2) : t2;
          if (!i2.validate || !ce2(this, e.u(o2))) {
            this._loaded = true, this.stylesheet = o2;
            for (const t3 in o2.sources)
              this.addSource(t3, o2.sources[t3], { validate: false });
            o2.sprite ? this._loadSprite(o2.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(o2.glyphs), this._createLayers(), this.light = new D2(this.stylesheet.light), this.sky = new A(this.stylesheet.sky), this.map.setTerrain((s2 = this.stylesheet.terrain) !== null && s2 !== undefined ? s2 : null), this.fire(new e.k("data", { dataType: "style" })), this.fire(new e.k("style.load"));
          }
        }
        _createLayers() {
          const t2 = e.az(this.stylesheet.layers);
          this.dispatcher.broadcast("SL", t2), this._order = t2.map((t3) => t3.id), this._layers = {}, this._serializedLayers = null;
          for (const i2 of t2) {
            const t3 = e.aA(i2);
            t3.setEventedParent(this, { layer: { id: i2.id } }), this._layers[i2.id] = t3;
          }
        }
        _loadSprite(t2, i2 = false, a2 = undefined) {
          let s2;
          this.imageManager.setLoaded(false), this._spriteRequest = new AbortController, function(t3, i3, a3, s3) {
            return e._(this, undefined, undefined, function* () {
              const r2 = x(t3), n2 = a3 > 1 ? "@2x" : "", l2 = {}, h2 = {};
              for (const { id: t4, url: a4 } of r2) {
                const o2 = i3.transformRequest(y(a4, n2, ".json"), "SpriteJSON");
                l2[t4] = e.h(o2, s3);
                const r3 = i3.transformRequest(y(a4, n2, ".png"), "SpriteImage");
                h2[t4] = _.getImage(r3, s3);
              }
              return yield Promise.all([...Object.values(l2), ...Object.values(h2)]), function(t4, i4) {
                return e._(this, undefined, undefined, function* () {
                  const e2 = {};
                  for (const a4 in t4) {
                    e2[a4] = {};
                    const s4 = o.getImageCanvasContext((yield i4[a4]).data), r3 = (yield t4[a4]).data;
                    for (const t5 in r3) {
                      const { width: i5, height: o2, x: n3, y: l3, sdf: h3, pixelRatio: c2, stretchX: u5, stretchY: d2, content: _2, textFitWidth: p2, textFitHeight: m2 } = r3[t5];
                      e2[a4][t5] = { data: null, pixelRatio: c2, sdf: h3, stretchX: u5, stretchY: d2, content: _2, textFitWidth: p2, textFitHeight: m2, spriteData: { width: i5, height: o2, x: n3, y: l3, context: s4 } };
                    }
                  }
                  return e2;
                });
              }(l2, h2);
            });
          }(t2, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((t3) => {
            if (this._spriteRequest = null, t3)
              for (const e2 in t3) {
                this._spritesImagesIds[e2] = [];
                const a3 = this._spritesImagesIds[e2] ? this._spritesImagesIds[e2].filter((e3) => !(e3 in t3)) : [];
                for (const t4 of a3)
                  this.imageManager.removeImage(t4), this._changedImages[t4] = true;
                for (const a4 in t3[e2]) {
                  const s3 = e2 === "default" ? a4 : `${e2}:${a4}`;
                  this._spritesImagesIds[e2].push(s3), s3 in this.imageManager.images ? this.imageManager.updateImage(s3, t3[e2][a4], false) : this.imageManager.addImage(s3, t3[e2][a4]), i2 && (this._changedImages[s3] = true);
                }
              }
          }).catch((t3) => {
            this._spriteRequest = null, s2 = t3, this.fire(new e.j(s2));
          }).finally(() => {
            this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i2 && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" })), a2 && a2(s2);
          });
        }
        _unloadSprite() {
          for (const t2 of Object.values(this._spritesImagesIds).flat())
            this.imageManager.removeImage(t2), this._changedImages[t2] = true;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" }));
        }
        _validateLayer(t2) {
          const i2 = this.sourceCaches[t2.source];
          if (!i2)
            return;
          const a2 = t2.sourceLayer;
          if (!a2)
            return;
          const s2 = i2.getSource();
          (s2.type === "geojson" || s2.vectorLayerIds && s2.vectorLayerIds.indexOf(a2) === -1) && this.fire(new e.j(new Error(`Source layer "${a2}" does not exist on source "${s2.id}" as specified by style layer "${t2.id}".`)));
        }
        loaded() {
          if (!this._loaded)
            return false;
          if (Object.keys(this._updatedSources).length)
            return false;
          for (const t2 in this.sourceCaches)
            if (!this.sourceCaches[t2].loaded())
              return false;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(t2, i2 = false) {
          const a2 = this._serializedAllLayers();
          if (!t2 || t2.length === 0)
            return Object.values(i2 ? e.aB(a2) : a2);
          const s2 = [];
          for (const o2 of t2)
            if (a2[o2]) {
              const t3 = i2 ? e.aB(a2[o2]) : a2[o2];
              s2.push(t3);
            }
          return s2;
        }
        _serializedAllLayers() {
          let t2 = this._serializedLayers;
          if (t2)
            return t2;
          t2 = this._serializedLayers = {};
          const e2 = Object.keys(this._layers);
          for (const i2 of e2) {
            const e3 = this._layers[i2];
            e3.type !== "custom" && (t2[i2] = e3.serialize());
          }
          return t2;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition())
            return true;
          if (this.sky && this.sky.hasTransition())
            return true;
          for (const t2 in this.sourceCaches)
            if (this.sourceCaches[t2].hasTransition())
              return true;
          for (const t2 in this._layers)
            if (this._layers[t2].hasTransition())
              return true;
          return false;
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading.");
        }
        update(t2) {
          if (!this._loaded)
            return;
          const i2 = this._changed;
          if (i2) {
            const e2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
            (e2.length || i3.length) && this._updateWorkerLayers(e2, i3);
            for (const t3 in this._updatedSources) {
              const e3 = this._updatedSources[t3];
              if (e3 === "reload")
                this._reloadSource(t3);
              else {
                if (e3 !== "clear")
                  throw new Error(`Invalid action ${e3}`);
                this._clearSource(t3);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const e3 in this._updatedPaintProps)
              this._layers[e3].updateTransitions(t2);
            this.light.updateTransitions(t2), this.sky.updateTransitions(t2), this._resetUpdates();
          }
          const a2 = {};
          for (const t3 in this.sourceCaches) {
            const e2 = this.sourceCaches[t3];
            a2[t3] = e2.used, e2.used = false;
          }
          for (const e2 of this._order) {
            const i3 = this._layers[e2];
            i3.recalculate(t2, this._availableImages), !i3.isHidden(t2.zoom) && i3.source && (this.sourceCaches[i3.source].used = true);
          }
          for (const t3 in a2) {
            const i3 = this.sourceCaches[t3];
            !!a2[t3] != !!i3.used && i3.fire(new e.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: t3 }));
          }
          this.light.recalculate(t2), this.sky.recalculate(t2), this.z = t2.zoom, i2 && this.fire(new e.k("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const t2 = Object.keys(this._changedImages);
          if (t2.length) {
            for (const e2 in this.sourceCaches)
              this.sourceCaches[e2].reloadTilesForDependencies(["icons", "patterns"], t2);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const t2 in this.sourceCaches)
              this.sourceCaches[t2].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = false;
          }
        }
        _updateWorkerLayers(t2, e2) {
          this.dispatcher.broadcast("UL", { layers: this._serializeByIds(t2, false), removedIds: e2 });
        }
        _resetUpdates() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
        }
        setState(t2, i2 = {}) {
          var a2;
          this._checkLoaded();
          const s2 = this.serialize();
          if (t2 = i2.transformStyle ? i2.transformStyle(s2, t2) : t2, ((a2 = i2.validate) === null || a2 === undefined || a2) && ce2(this, e.u(t2)))
            return false;
          (t2 = e.aB(t2)).layers = e.az(t2.layers);
          const o2 = e.aC(s2, t2), r2 = this._getOperationsToPerform(o2);
          if (r2.unimplemented.length > 0)
            throw new Error(`Unimplemented: ${r2.unimplemented.join(", ")}.`);
          if (r2.operations.length === 0)
            return false;
          for (const t3 of r2.operations)
            t3();
          return this.stylesheet = t2, this._serializedLayers = null, true;
        }
        _getOperationsToPerform(t2) {
          const e2 = [], i2 = [];
          for (const a2 of t2)
            switch (a2.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
                continue;
              case "addLayer":
                e2.push(() => this.addLayer.apply(this, a2.args));
                break;
              case "removeLayer":
                e2.push(() => this.removeLayer.apply(this, a2.args));
                break;
              case "setPaintProperty":
                e2.push(() => this.setPaintProperty.apply(this, a2.args));
                break;
              case "setLayoutProperty":
                e2.push(() => this.setLayoutProperty.apply(this, a2.args));
                break;
              case "setFilter":
                e2.push(() => this.setFilter.apply(this, a2.args));
                break;
              case "addSource":
                e2.push(() => this.addSource.apply(this, a2.args));
                break;
              case "removeSource":
                e2.push(() => this.removeSource.apply(this, a2.args));
                break;
              case "setLayerZoomRange":
                e2.push(() => this.setLayerZoomRange.apply(this, a2.args));
                break;
              case "setLight":
                e2.push(() => this.setLight.apply(this, a2.args));
                break;
              case "setGeoJSONSourceData":
                e2.push(() => this.setGeoJSONSourceData.apply(this, a2.args));
                break;
              case "setGlyphs":
                e2.push(() => this.setGlyphs.apply(this, a2.args));
                break;
              case "setSprite":
                e2.push(() => this.setSprite.apply(this, a2.args));
                break;
              case "setSky":
                e2.push(() => this.setSky.apply(this, a2.args));
                break;
              case "setTerrain":
                e2.push(() => this.map.setTerrain.apply(this, a2.args));
                break;
              case "setTransition":
                e2.push(() => {
                });
                break;
              default:
                i2.push(a2.command);
            }
          return { operations: e2, unimplemented: i2 };
        }
        addImage(t2, i2) {
          if (this.getImage(t2))
            return this.fire(new e.j(new Error(`An image named "${t2}" already exists.`)));
          this.imageManager.addImage(t2, i2), this._afterImageUpdated(t2);
        }
        updateImage(t2, e2) {
          this.imageManager.updateImage(t2, e2);
        }
        getImage(t2) {
          return this.imageManager.getImage(t2);
        }
        removeImage(t2) {
          if (!this.getImage(t2))
            return this.fire(new e.j(new Error(`An image named "${t2}" does not exist.`)));
          this.imageManager.removeImage(t2), this._afterImageUpdated(t2);
        }
        _afterImageUpdated(t2) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[t2] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(t2, i2, a2 = {}) {
          if (this._checkLoaded(), this.sourceCaches[t2] !== undefined)
            throw new Error(`Source "${t2}" already exists.`);
          if (!i2.type)
            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(e.u.source, `sources.${t2}`, i2, null, a2))
            return;
          this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
          const s2 = this.sourceCaches[t2] = new ut(t2, i2, this.dispatcher);
          s2.style = this, s2.setEventedParent(this, () => ({ isSourceLoaded: s2.loaded(), source: s2.serialize(), sourceId: t2 })), s2.onAdd(this.map), this._changed = true;
        }
        removeSource(t2) {
          if (this._checkLoaded(), this.sourceCaches[t2] === undefined)
            throw new Error("There is no source with this ID");
          for (const i3 in this._layers)
            if (this._layers[i3].source === t2)
              return this.fire(new e.j(new Error(`Source "${t2}" cannot be removed while layer "${i3}" is using it.`)));
          const i2 = this.sourceCaches[t2];
          delete this.sourceCaches[t2], delete this._updatedSources[t2], i2.fire(new e.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: t2 })), i2.setEventedParent(null), i2.onRemove(this.map), this._changed = true;
        }
        setGeoJSONSourceData(t2, e2) {
          if (this._checkLoaded(), this.sourceCaches[t2] === undefined)
            throw new Error(`There is no source with this ID=${t2}`);
          const i2 = this.sourceCaches[t2].getSource();
          if (i2.type !== "geojson")
            throw new Error(`geojsonSource.type is ${i2.type}, which is !== 'geojson`);
          i2.setData(e2), this._changed = true;
        }
        getSource(t2) {
          return this.sourceCaches[t2] && this.sourceCaches[t2].getSource();
        }
        addLayer(t2, i2, a2 = {}) {
          this._checkLoaded();
          const s2 = t2.id;
          if (this.getLayer(s2))
            return void this.fire(new e.j(new Error(`Layer "${s2}" already exists on this map.`)));
          let o2;
          if (t2.type === "custom") {
            if (ce2(this, e.aD(t2)))
              return;
            o2 = e.aA(t2);
          } else {
            if ("source" in t2 && typeof t2.source == "object" && (this.addSource(s2, t2.source), t2 = e.aB(t2), t2 = e.e(t2, { source: s2 })), this._validate(e.u.layer, `layers.${s2}`, t2, { arrayIndex: -1 }, a2))
              return;
            o2 = e.aA(t2), this._validateLayer(o2), o2.setEventedParent(this, { layer: { id: s2 } });
          }
          const r2 = i2 ? this._order.indexOf(i2) : this._order.length;
          if (i2 && r2 === -1)
            this.fire(new e.j(new Error(`Cannot add layer "${s2}" before non-existing layer "${i2}".`)));
          else {
            if (this._order.splice(r2, 0, s2), this._layerOrderChanged = true, this._layers[s2] = o2, this._removedLayers[s2] && o2.source && o2.type !== "custom") {
              const t3 = this._removedLayers[s2];
              delete this._removedLayers[s2], t3.type !== o2.type ? this._updatedSources[o2.source] = "clear" : (this._updatedSources[o2.source] = "reload", this.sourceCaches[o2.source].pause());
            }
            this._updateLayer(o2), o2.onAdd && o2.onAdd(this.map);
          }
        }
        moveLayer(t2, i2) {
          if (this._checkLoaded(), this._changed = true, !this._layers[t2])
            return void this.fire(new e.j(new Error(`The layer '${t2}' does not exist in the map's style and cannot be moved.`)));
          if (t2 === i2)
            return;
          const a2 = this._order.indexOf(t2);
          this._order.splice(a2, 1);
          const s2 = i2 ? this._order.indexOf(i2) : this._order.length;
          i2 && s2 === -1 ? this.fire(new e.j(new Error(`Cannot move layer "${t2}" before non-existing layer "${i2}".`))) : (this._order.splice(s2, 0, t2), this._layerOrderChanged = true);
        }
        removeLayer(t2) {
          this._checkLoaded();
          const i2 = this._layers[t2];
          if (!i2)
            return void this.fire(new e.j(new Error(`Cannot remove non-existing layer "${t2}".`)));
          i2.setEventedParent(null);
          const a2 = this._order.indexOf(t2);
          this._order.splice(a2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t2] = i2, delete this._layers[t2], this._serializedLayers && delete this._serializedLayers[t2], delete this._updatedLayers[t2], delete this._updatedPaintProps[t2], i2.onRemove && i2.onRemove(this.map);
        }
        getLayer(t2) {
          return this._layers[t2];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(t2) {
          return t2 in this._layers;
        }
        setLayerZoomRange(t2, i2, a2) {
          this._checkLoaded();
          const s2 = this.getLayer(t2);
          s2 ? s2.minzoom === i2 && s2.maxzoom === a2 || (i2 != null && (s2.minzoom = i2), a2 != null && (s2.maxzoom = a2), this._updateLayer(s2)) : this.fire(new e.j(new Error(`Cannot set the zoom range of non-existing layer "${t2}".`)));
        }
        setFilter(t2, i2, a2 = {}) {
          this._checkLoaded();
          const s2 = this.getLayer(t2);
          if (s2) {
            if (!e.aE(s2.filter, i2))
              return i2 == null ? (s2.filter = undefined, void this._updateLayer(s2)) : void (this._validate(e.u.filter, `layers.${s2.id}.filter`, i2, null, a2) || (s2.filter = e.aB(i2), this._updateLayer(s2)));
          } else
            this.fire(new e.j(new Error(`Cannot filter non-existing layer "${t2}".`)));
        }
        getFilter(t2) {
          return e.aB(this.getLayer(t2).filter);
        }
        setLayoutProperty(t2, i2, a2, s2 = {}) {
          this._checkLoaded();
          const o2 = this.getLayer(t2);
          o2 ? e.aE(o2.getLayoutProperty(i2), a2) || (o2.setLayoutProperty(i2, a2, s2), this._updateLayer(o2)) : this.fire(new e.j(new Error(`Cannot style non-existing layer "${t2}".`)));
        }
        getLayoutProperty(t2, i2) {
          const a2 = this.getLayer(t2);
          if (a2)
            return a2.getLayoutProperty(i2);
          this.fire(new e.j(new Error(`Cannot get style of non-existing layer "${t2}".`)));
        }
        setPaintProperty(t2, i2, a2, s2 = {}) {
          this._checkLoaded();
          const o2 = this.getLayer(t2);
          o2 ? e.aE(o2.getPaintProperty(i2), a2) || (o2.setPaintProperty(i2, a2, s2) && this._updateLayer(o2), this._changed = true, this._updatedPaintProps[t2] = true, this._serializedLayers = null) : this.fire(new e.j(new Error(`Cannot style non-existing layer "${t2}".`)));
        }
        getPaintProperty(t2, e2) {
          return this.getLayer(t2).getPaintProperty(e2);
        }
        setFeatureState(t2, i2) {
          this._checkLoaded();
          const { source: a2, sourceLayer: s2 } = t2, o2 = this.sourceCaches[a2];
          if (o2 === undefined)
            return void this.fire(new e.j(new Error(`The source '${a2}' does not exist in the map's style.`)));
          const r2 = o2.getSource().type;
          r2 === "geojson" && s2 ? this.fire(new e.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : r2 !== "vector" || s2 ? (t2.id === undefined && this.fire(new e.j(new Error("The feature id parameter must be provided."))), o2.setFeatureState(s2, t2.id, i2)) : this.fire(new e.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(t2, i2) {
          this._checkLoaded();
          const a2 = t2.source, s2 = this.sourceCaches[a2];
          if (s2 === undefined)
            return void this.fire(new e.j(new Error(`The source '${a2}' does not exist in the map's style.`)));
          const o2 = s2.getSource().type, r2 = o2 === "vector" ? t2.sourceLayer : undefined;
          o2 !== "vector" || r2 ? i2 && typeof t2.id != "string" && typeof t2.id != "number" ? this.fire(new e.j(new Error("A feature id is required to remove its specific state property."))) : s2.removeFeatureState(r2, t2.id, i2) : this.fire(new e.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(t2) {
          this._checkLoaded();
          const { source: i2, sourceLayer: a2 } = t2, s2 = this.sourceCaches[i2];
          if (s2 !== undefined)
            return s2.getSource().type !== "vector" || a2 ? (t2.id === undefined && this.fire(new e.j(new Error("The feature id parameter must be provided."))), s2.getFeatureState(a2, t2.id)) : void this.fire(new e.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new e.j(new Error(`The source '${i2}' does not exist in the map's style.`)));
        }
        getTransition() {
          return e.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded)
            return;
          const t2 = e.aF(this.sourceCaches, (t3) => t3.serialize()), i2 = this._serializeByIds(this._order, true), a2 = this.map.getTerrain() || undefined, s2 = this.stylesheet;
          return e.aG({ version: s2.version, name: s2.name, metadata: s2.metadata, light: s2.light, sky: s2.sky, center: s2.center, zoom: s2.zoom, bearing: s2.bearing, pitch: s2.pitch, sprite: s2.sprite, glyphs: s2.glyphs, transition: s2.transition, sources: t2, layers: i2, terrain: a2 }, (t3) => t3 !== undefined);
        }
        _updateLayer(t2) {
          this._updatedLayers[t2.id] = true, t2.source && !this._updatedSources[t2.source] && this.sourceCaches[t2.source].getSource().type !== "raster" && (this._updatedSources[t2.source] = "reload", this.sourceCaches[t2.source].pause()), this._serializedLayers = null, this._changed = true;
        }
        _flattenAndSortRenderedFeatures(t2) {
          const e2 = (t3) => this._layers[t3].type === "fill-extrusion", i2 = {}, a2 = [];
          for (let s3 = this._order.length - 1;s3 >= 0; s3--) {
            const o2 = this._order[s3];
            if (e2(o2)) {
              i2[o2] = s3;
              for (const e3 of t2) {
                const t3 = e3[o2];
                if (t3)
                  for (const e4 of t3)
                    a2.push(e4);
              }
            }
          }
          a2.sort((t3, e3) => e3.intersectionZ - t3.intersectionZ);
          const s2 = [];
          for (let o2 = this._order.length - 1;o2 >= 0; o2--) {
            const r2 = this._order[o2];
            if (e2(r2))
              for (let t3 = a2.length - 1;t3 >= 0; t3--) {
                const e3 = a2[t3].feature;
                if (i2[e3.layer.id] < o2)
                  break;
                s2.push(e3), a2.pop();
              }
            else
              for (const e3 of t2) {
                const t3 = e3[r2];
                if (t3)
                  for (const e4 of t3)
                    s2.push(e4.feature);
              }
          }
          return s2;
        }
        queryRenderedFeatures(t2, i2, a2) {
          i2 && i2.filter && this._validate(e.u.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
          const s2 = {};
          if (i2 && i2.layers) {
            if (!Array.isArray(i2.layers))
              return this.fire(new e.j(new Error("parameters.layers must be an Array."))), [];
            for (const t3 of i2.layers) {
              const i3 = this._layers[t3];
              if (!i3)
                return this.fire(new e.j(new Error(`The layer '${t3}' does not exist in the map's style and cannot be queried for features.`))), [];
              s2[i3.source] = true;
            }
          }
          const o2 = [];
          i2.availableImages = this._availableImages;
          const r2 = this._serializedAllLayers();
          for (const e2 in this.sourceCaches)
            i2.layers && !s2[e2] || o2.push(q(this.sourceCaches[e2], this._layers, r2, t2, i2, a2));
          return this.placement && o2.push(function(t3, e2, i3, a3, s3, o3, r3) {
            const n2 = {}, l2 = o3.queryRenderedSymbols(a3), h2 = [];
            for (const t4 of Object.keys(l2).map(Number))
              h2.push(r3[t4]);
            h2.sort(V);
            for (const i4 of h2) {
              const a4 = i4.featureIndex.lookupSymbolFeatures(l2[i4.bucketInstanceId], e2, i4.bucketIndex, i4.sourceLayerIndex, s3.filter, s3.layers, s3.availableImages, t3);
              for (const t4 in a4) {
                const e3 = n2[t4] = n2[t4] || [], s4 = a4[t4];
                s4.sort((t5, e4) => {
                  const a5 = i4.featureSortOrder;
                  if (a5) {
                    const i5 = a5.indexOf(t5.featureIndex);
                    return a5.indexOf(e4.featureIndex) - i5;
                  }
                  return e4.featureIndex - t5.featureIndex;
                });
                for (const t5 of s4)
                  e3.push(t5);
              }
            }
            for (const e3 in n2)
              n2[e3].forEach((a4) => {
                const s4 = a4.feature, o4 = i3[t3[e3].source].getFeatureState(s4.layer["source-layer"], s4.id);
                s4.source = s4.layer.source, s4.layer["source-layer"] && (s4.sourceLayer = s4.layer["source-layer"]), s4.state = o4;
              });
            return n2;
          }(this._layers, r2, this.sourceCaches, t2, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o2);
        }
        querySourceFeatures(t2, i2) {
          i2 && i2.filter && this._validate(e.u.filter, "querySourceFeatures.filter", i2.filter, null, i2);
          const a2 = this.sourceCaches[t2];
          return a2 ? function(t3, e2) {
            const i3 = t3.getRenderableIds().map((e3) => t3.getTileByID(e3)), a3 = [], s2 = {};
            for (let t4 = 0;t4 < i3.length; t4++) {
              const o2 = i3[t4], r2 = o2.tileID.canonical.key;
              s2[r2] || (s2[r2] = true, o2.querySourceFeatures(a3, e2));
            }
            return a3;
          }(a2, i2) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(t2, i2 = {}) {
          this._checkLoaded();
          const a2 = this.light.getLight();
          let s2 = false;
          for (const i3 in t2)
            if (!e.aE(t2[i3], a2[i3])) {
              s2 = true;
              break;
            }
          if (!s2)
            return;
          const r2 = { now: o.now(), transition: e.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(t2, i2), this.light.updateTransitions(r2);
        }
        getSky() {
          var t2;
          return (t2 = this.stylesheet) === null || t2 === undefined ? undefined : t2.sky;
        }
        setSky(t2, i2 = {}) {
          const a2 = this.getSky();
          let s2 = false;
          if (!t2 && !a2)
            return;
          if (t2 && !a2)
            s2 = true;
          else if (!t2 && a2)
            s2 = true;
          else
            for (const i3 in t2)
              if (!e.aE(t2[i3], a2[i3])) {
                s2 = true;
                break;
              }
          if (!s2)
            return;
          const r2 = { now: o.now(), transition: e.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.stylesheet.sky = t2, this.sky.setSky(t2, i2), this.sky.updateTransitions(r2);
        }
        _validate(t2, i2, a2, s2, o2 = {}) {
          return (!o2 || o2.validate !== false) && ce2(this, t2.call(e.u, e.e({ key: i2, style: this.serialize(), value: a2, styleSpec: e.v }, s2)));
        }
        _remove(t2 = true) {
          this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), nt().off(st, this._rtlPluginLoaded);
          for (const t3 in this._layers)
            this._layers[t3].setEventedParent(null);
          for (const t3 in this.sourceCaches) {
            const e2 = this.sourceCaches[t3];
            e2.setEventedParent(null), e2.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), t2 && this.dispatcher.broadcast("RM", undefined), this.dispatcher.remove(t2);
        }
        _clearSource(t2) {
          this.sourceCaches[t2].clearTiles();
        }
        _reloadSource(t2) {
          this.sourceCaches[t2].resume(), this.sourceCaches[t2].reload();
        }
        _updateSources(t2) {
          for (const e2 in this.sourceCaches)
            this.sourceCaches[e2].update(t2, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const t2 in this.sourceCaches)
            this._reloadSource(t2);
        }
        _updatePlacement(t2, e2, i2, a2, s2 = false) {
          let r2 = false, n2 = false;
          const l2 = {};
          for (const e3 of this._order) {
            const i3 = this._layers[e3];
            if (i3.type !== "symbol")
              continue;
            if (!l2[i3.source]) {
              const t3 = this.sourceCaches[i3.source];
              l2[i3.source] = t3.getRenderableIds(true).map((e4) => t3.getTileByID(e4)).sort((t4, e4) => e4.tileID.overscaledZ - t4.tileID.overscaledZ || (t4.tileID.isLessThan(e4.tileID) ? -1 : 1));
            }
            const a3 = this.crossTileSymbolIndex.addLayer(i3, l2[i3.source], t2.center.lng);
            r2 = r2 || a3;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((s2 = s2 || this._layerOrderChanged || i2 === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(o.now(), t2.zoom)) && (this.pauseablePlacement = new se(t2, this.map.terrain, this._order, s2, e2, i2, a2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(o.now()), n2 = true), r2 && this.pauseablePlacement.placement.setStale()), n2 || r2)
            for (const t3 of this._order) {
              const e3 = this._layers[t3];
              e3.type === "symbol" && this.placement.updateLayerOpacities(e3, l2[e3.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(o.now());
        }
        _releaseSymbolFadeTiles() {
          for (const t2 in this.sourceCaches)
            this.sourceCaches[t2].releaseSymbolFadeTiles();
        }
        getImages(t2, i2) {
          return e._(this, undefined, undefined, function* () {
            const t3 = yield this.imageManager.getImages(i2.icons);
            this._updateTilesForChangedImages();
            const e2 = this.sourceCaches[i2.source];
            return e2 && e2.setDependencies(i2.tileID.key, i2.type, i2.icons), t3;
          });
        }
        getGlyphs(t2, i2) {
          return e._(this, undefined, undefined, function* () {
            const t3 = yield this.glyphManager.getGlyphs(i2.stacks), e2 = this.sourceCaches[i2.source];
            return e2 && e2.setDependencies(i2.tileID.key, i2.type, [""]), t3;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(t2, i2 = {}) {
          this._checkLoaded(), t2 && this._validate(e.u.glyphs, "glyphs", t2, null, i2) || (this._glyphsDidChange = true, this.stylesheet.glyphs = t2, this.glyphManager.entries = {}, this.glyphManager.setURL(t2));
        }
        addSprite(t2, i2, a2 = {}, s2) {
          this._checkLoaded();
          const o2 = [{ id: t2, url: i2 }], r2 = [...x(this.stylesheet.sprite), ...o2];
          this._validate(e.u.sprite, "sprite", r2, null, a2) || (this.stylesheet.sprite = r2, this._loadSprite(o2, true, s2));
        }
        removeSprite(t2) {
          this._checkLoaded();
          const i2 = x(this.stylesheet.sprite);
          if (i2.find((e2) => e2.id === t2)) {
            if (this._spritesImagesIds[t2])
              for (const e2 of this._spritesImagesIds[t2])
                this.imageManager.removeImage(e2), this._changedImages[e2] = true;
            i2.splice(i2.findIndex((e2) => e2.id === t2), 1), this.stylesheet.sprite = i2.length > 0 ? i2 : undefined, delete this._spritesImagesIds[t2], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" }));
          } else
            this.fire(new e.j(new Error(`Sprite "${t2}" doesn't exists on this map.`)));
        }
        getSprite() {
          return x(this.stylesheet.sprite);
        }
        setSprite(t2, i2 = {}, a2) {
          this._checkLoaded(), t2 && this._validate(e.u.sprite, "sprite", t2, null, i2) || (this.stylesheet.sprite = t2, t2 ? this._loadSprite(t2, true, a2) : (this._unloadSprite(), a2 && a2(null)));
        }
      }
      var _e = e.Y([{ name: "a_pos", type: "Int16", components: 2 }]);
      const pe = { prelude: me(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`), background: me(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: me(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: me(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: me("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: me(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,get_elevation(floor(a_pos*0.5)),1);gl_Position=u_matrix*pos;}`), heatmapTexture: me(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: me("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_anchor_pos;attribute vec2 a_placed;attribute vec2 a_box_real;uniform mat4 u_matrix;uniform vec2 u_pixel_extrude_scale;varying float v_placed;varying float v_notUsed;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: me("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: me("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: me(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`), fillOutline: me(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillOutlinePattern: me(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`), fillPattern: me(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: me(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: me(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: me(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: me(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: me(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: me(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: me(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: me(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: me(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: me(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_tex;varying float v_fade_opacity;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: me(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_data0;varying vec3 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: me(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec4 v_data0;varying vec4 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: me("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;varying vec2 v_texture_pos;varying float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture2D(u_texture,v_texture_pos);if (v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);gl_FragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {gl_FragColor=surface_color;}}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform mat4 u_fog_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: me("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: me("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);}"), sky: me("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform float u_horizon;uniform float u_sky_horizon_blend;void main() {float y=gl_FragCoord.y;if (y > u_horizon) {float blend=y-u_horizon;if (blend < u_sky_horizon_blend) {gl_FragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {gl_FragColor=u_sky_color;}}}", "attribute vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
      function me(t2, e2) {
        const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, a2 = e2.match(/attribute ([\w]+) ([\w]+)/g), s2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r2 = o2 ? o2.concat(s2) : s2, n2 = {};
        return { fragmentSource: t2 = t2.replace(i2, (t3, e3, i3, a3, s3) => (n2[s3] = true, e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${s3}
varying ${i3} ${a3} ${s3};
#else
uniform ${i3} ${a3} u_${s3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${s3}
    ${i3} ${a3} ${s3} = u_${s3};
#endif
`)), vertexSource: e2 = e2.replace(i2, (t3, e3, i3, a3, s3) => {
          const o3 = a3 === "float" ? "vec2" : "vec4", r3 = s3.match(/color/) ? "color" : o3;
          return n2[s3] ? e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${s3}
uniform lowp float u_${s3}_t;
attribute ${i3} ${o3} a_${s3};
varying ${i3} ${a3} ${s3};
#else
uniform ${i3} ${a3} u_${s3};
#endif
` : r3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${s3}
    ${s3} = a_${s3};
#else
    ${i3} ${a3} ${s3} = u_${s3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${s3}
    ${s3} = unpack_mix_${r3}(a_${s3}, u_${s3}_t);
#else
    ${i3} ${a3} ${s3} = u_${s3};
#endif
` : e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${s3}
uniform lowp float u_${s3}_t;
attribute ${i3} ${o3} a_${s3};
#else
uniform ${i3} ${a3} u_${s3};
#endif
` : r3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${s3}
    ${i3} ${a3} ${s3} = a_${s3};
#else
    ${i3} ${a3} ${s3} = u_${s3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${s3}
    ${i3} ${a3} ${s3} = unpack_mix_${r3}(a_${s3}, u_${s3}_t);
#else
    ${i3} ${a3} ${s3} = u_${s3};
#endif
`;
        }), staticAttributes: a2, staticUniforms: r2 };
      }

      class fe {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(t2, e2, i2, a2, s2, o2, r2, n2, l2) {
          this.context = t2;
          let h2 = this.boundPaintVertexBuffers.length !== a2.length;
          for (let t3 = 0;!h2 && t3 < a2.length; t3++)
            this.boundPaintVertexBuffers[t3] !== a2[t3] && (h2 = true);
          !this.vao || this.boundProgram !== e2 || this.boundLayoutVertexBuffer !== i2 || h2 || this.boundIndexBuffer !== s2 || this.boundVertexOffset !== o2 || this.boundDynamicVertexBuffer !== r2 || this.boundDynamicVertexBuffer2 !== n2 || this.boundDynamicVertexBuffer3 !== l2 ? this.freshBind(e2, i2, a2, s2, o2, r2, n2, l2) : (t2.bindVertexArray.set(this.vao), r2 && r2.bind(), s2 && s2.dynamicDraw && s2.bind(), n2 && n2.bind(), l2 && l2.bind());
        }
        freshBind(t2, e2, i2, a2, s2, o2, r2, n2) {
          const l2 = t2.numAttributes, h2 = this.context, c2 = h2.gl;
          this.vao && this.destroy(), this.vao = h2.createVertexArray(), h2.bindVertexArray.set(this.vao), this.boundProgram = t2, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = a2, this.boundVertexOffset = s2, this.boundDynamicVertexBuffer = o2, this.boundDynamicVertexBuffer2 = r2, this.boundDynamicVertexBuffer3 = n2, e2.enableAttributes(c2, t2);
          for (const e3 of i2)
            e3.enableAttributes(c2, t2);
          o2 && o2.enableAttributes(c2, t2), r2 && r2.enableAttributes(c2, t2), n2 && n2.enableAttributes(c2, t2), e2.bind(), e2.setVertexAttribPointers(c2, t2, s2);
          for (const e3 of i2)
            e3.bind(), e3.setVertexAttribPointers(c2, t2, s2);
          o2 && (o2.bind(), o2.setVertexAttribPointers(c2, t2, s2)), a2 && a2.bind(), r2 && (r2.bind(), r2.setVertexAttribPointers(c2, t2, s2)), n2 && (n2.bind(), n2.setVertexAttribPointers(c2, t2, s2)), h2.currentNumAttributes = l2;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      const ge = (t2, i2, a2, s2, o2) => ({ u_matrix: t2, u_texture: 0, u_ele_delta: i2, u_fog_matrix: a2, u_fog_color: s2 ? s2.properties.get("fog-color") : e.aM.white, u_fog_ground_blend: s2 ? s2.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: s2 ? s2.calculateFogBlendOpacity(o2) : 0, u_horizon_color: s2 ? s2.properties.get("horizon-color") : e.aM.white, u_horizon_fog_blend: s2 ? s2.properties.get("horizon-fog-blend") : 1 });
      function ve(t2) {
        const e2 = [];
        for (let i2 = 0;i2 < t2.length; i2++) {
          if (t2[i2] === null)
            continue;
          const a2 = t2[i2].split(" ");
          e2.push(a2.pop());
        }
        return e2;
      }

      class xe {
        constructor(t2, i2, a2, s2, o2, r2) {
          const n2 = t2.gl;
          this.program = n2.createProgram();
          const l2 = ve(i2.staticAttributes), h2 = a2 ? a2.getBinderAttributes() : [], c2 = l2.concat(h2), u5 = pe.prelude.staticUniforms ? ve(pe.prelude.staticUniforms) : [], d2 = i2.staticUniforms ? ve(i2.staticUniforms) : [], _2 = a2 ? a2.getBinderUniforms() : [], p2 = u5.concat(d2).concat(_2), m2 = [];
          for (const t3 of p2)
            m2.indexOf(t3) < 0 && m2.push(t3);
          const f2 = a2 ? a2.defines() : [];
          o2 && f2.push("#define OVERDRAW_INSPECTOR;"), r2 && f2.push("#define TERRAIN3D;");
          const g2 = f2.concat(pe.prelude.fragmentSource, i2.fragmentSource).join(`
`), v3 = f2.concat(pe.prelude.vertexSource, i2.vertexSource).join(`
`), x2 = n2.createShader(n2.FRAGMENT_SHADER);
          if (n2.isContextLost())
            return void (this.failedToCreate = true);
          if (n2.shaderSource(x2, g2), n2.compileShader(x2), !n2.getShaderParameter(x2, n2.COMPILE_STATUS))
            throw new Error(`Could not compile fragment shader: ${n2.getShaderInfoLog(x2)}`);
          n2.attachShader(this.program, x2);
          const y2 = n2.createShader(n2.VERTEX_SHADER);
          if (n2.isContextLost())
            return void (this.failedToCreate = true);
          if (n2.shaderSource(y2, v3), n2.compileShader(y2), !n2.getShaderParameter(y2, n2.COMPILE_STATUS))
            throw new Error(`Could not compile vertex shader: ${n2.getShaderInfoLog(y2)}`);
          n2.attachShader(this.program, y2), this.attributes = {};
          const b2 = {};
          this.numAttributes = c2.length;
          for (let t3 = 0;t3 < this.numAttributes; t3++)
            c2[t3] && (n2.bindAttribLocation(this.program, t3, c2[t3]), this.attributes[c2[t3]] = t3);
          if (n2.linkProgram(this.program), !n2.getProgramParameter(this.program, n2.LINK_STATUS))
            throw new Error(`Program failed to link: ${n2.getProgramInfoLog(this.program)}`);
          n2.deleteShader(y2), n2.deleteShader(x2);
          for (let t3 = 0;t3 < m2.length; t3++) {
            const e2 = m2[t3];
            if (e2 && !b2[e2]) {
              const t4 = n2.getUniformLocation(this.program, e2);
              t4 && (b2[e2] = t4);
            }
          }
          this.fixedUniforms = s2(t2, b2), this.terrainUniforms = ((t3, i3) => ({ u_depth: new e.aH(t3, i3.u_depth), u_terrain: new e.aH(t3, i3.u_terrain), u_terrain_dim: new e.aI(t3, i3.u_terrain_dim), u_terrain_matrix: new e.aJ(t3, i3.u_terrain_matrix), u_terrain_unpack: new e.aK(t3, i3.u_terrain_unpack), u_terrain_exaggeration: new e.aI(t3, i3.u_terrain_exaggeration) }))(t2, b2), this.binderUniforms = a2 ? a2.getUniforms(t2, b2) : [];
        }
        draw(t2, e2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u5, d2, _2, p2, m2, f2, g2) {
          const v3 = t2.gl;
          if (this.failedToCreate)
            return;
          if (t2.program.set(this.program), t2.setDepthMode(i2), t2.setStencilMode(a2), t2.setColorMode(s2), t2.setCullFace(o2), n2) {
            t2.activeTexture.set(v3.TEXTURE2), v3.bindTexture(v3.TEXTURE_2D, n2.depthTexture), t2.activeTexture.set(v3.TEXTURE3), v3.bindTexture(v3.TEXTURE_2D, n2.texture);
            for (const t3 in this.terrainUniforms)
              this.terrainUniforms[t3].set(n2[t3]);
          }
          for (const t3 in this.fixedUniforms)
            this.fixedUniforms[t3].set(r2[t3]);
          p2 && p2.setUniforms(t2, this.binderUniforms, d2, { zoom: _2 });
          let x2 = 0;
          switch (e2) {
            case v3.LINES:
              x2 = 2;
              break;
            case v3.TRIANGLES:
              x2 = 3;
              break;
            case v3.LINE_STRIP:
              x2 = 1;
          }
          for (const i3 of u5.get()) {
            const a3 = i3.vaos || (i3.vaos = {});
            (a3[l2] || (a3[l2] = new fe)).bind(t2, this, h2, p2 ? p2.getPaintVertexBuffers() : [], c2, i3.vertexOffset, m2, f2, g2), v3.drawElements(e2, i3.primitiveLength * x2, v3.UNSIGNED_SHORT, i3.primitiveOffset * x2 * 2);
          }
        }
      }
      function ye(t2, e2, i2) {
        const a2 = 1 / Bt(i2, 1, e2.transform.tileZoom), s2 = Math.pow(2, i2.tileID.overscaledZ), o2 = i2.tileSize * Math.pow(2, e2.transform.tileZoom) / s2, r2 = o2 * (i2.tileID.canonical.x + i2.tileID.wrap * s2), n2 = o2 * i2.tileID.canonical.y;
        return { u_image: 0, u_texsize: i2.imageAtlasTexture.size, u_scale: [a2, t2.fromScale, t2.toScale], u_fade: t2.t, u_pixel_coord_upper: [r2 >> 16, n2 >> 16], u_pixel_coord_lower: [65535 & r2, 65535 & n2] };
      }
      const be = (t2, i2, a2, s2) => {
        const o2 = i2.style.light, r2 = o2.properties.get("position"), n2 = [r2.x, r2.y, r2.z], l2 = function() {
          var t3 = new e.A(9);
          return e.A != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[0] = 1, t3[4] = 1, t3[8] = 1, t3;
        }();
        o2.properties.get("anchor") === "viewport" && function(t3, e2) {
          var i3 = Math.sin(e2), a3 = Math.cos(e2);
          t3[0] = a3, t3[1] = i3, t3[2] = 0, t3[3] = -i3, t3[4] = a3, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1;
        }(l2, -i2.transform.angle), function(t3, e2, i3) {
          var a3 = e2[0], s3 = e2[1], o3 = e2[2];
          t3[0] = a3 * i3[0] + s3 * i3[3] + o3 * i3[6], t3[1] = a3 * i3[1] + s3 * i3[4] + o3 * i3[7], t3[2] = a3 * i3[2] + s3 * i3[5] + o3 * i3[8];
        }(n2, n2, l2);
        const h2 = o2.properties.get("color");
        return { u_matrix: t2, u_lightpos: n2, u_lightintensity: o2.properties.get("intensity"), u_lightcolor: [h2.r, h2.g, h2.b], u_vertical_gradient: +a2, u_opacity: s2 };
      }, we = (t2, i2, a2, s2, o2, r2, n2) => e.e(be(t2, i2, a2, s2), ye(r2, i2, n2), { u_height_factor: -Math.pow(2, o2.overscaledZ) / n2.tileSize / 8 }), Te = (t2) => ({ u_matrix: t2 }), Ie = (t2, i2, a2, s2) => e.e(Te(t2), ye(a2, i2, s2)), Ee = (t2, e2) => ({ u_matrix: t2, u_world: e2 }), Pe = (t2, i2, a2, s2, o2) => e.e(Ie(t2, i2, a2, s2), { u_world: o2 }), Ce = (t2, e2, i2, a2) => {
        const s2 = t2.transform;
        let o2, r2;
        if (a2.paint.get("circle-pitch-alignment") === "map") {
          const t3 = Bt(i2, 1, s2.zoom);
          o2 = true, r2 = [t3, t3];
        } else
          o2 = false, r2 = s2.pixelsToGLUnits;
        return { u_camera_to_center_distance: s2.cameraToCenterDistance, u_scale_with_map: +(a2.paint.get("circle-pitch-scale") === "map"), u_matrix: t2.translatePosMatrix(e2.posMatrix, i2, a2.paint.get("circle-translate"), a2.paint.get("circle-translate-anchor")), u_pitch_with_map: +o2, u_device_pixel_ratio: t2.pixelRatio, u_extrude_scale: r2 };
      }, Se = (t2, e2, i2) => ({ u_matrix: t2, u_inv_matrix: e2, u_camera_to_center_distance: i2.cameraToCenterDistance, u_viewport_size: [i2.width, i2.height] }), ze = (t2, e2, i2 = 1) => ({ u_matrix: t2, u_color: e2, u_overlay: 0, u_overlay_scale: i2 }), De = (t2) => ({ u_matrix: t2 }), Me = (t2, e2, i2, a2) => ({ u_matrix: t2, u_extrude_scale: Bt(e2, 1, i2), u_intensity: a2 }), Ae = (t2, i2, a2, s2) => {
        const o2 = e.H();
        e.aP(o2, 0, t2.width, t2.height, 0, 0, 1);
        const r2 = t2.context.gl;
        return { u_matrix: o2, u_world: [r2.drawingBufferWidth, r2.drawingBufferHeight], u_image: a2, u_color_ramp: s2, u_opacity: i2.paint.get("heatmap-opacity") };
      };
      function Re(t2, i2) {
        const a2 = Math.pow(2, i2.canonical.z), s2 = i2.canonical.y;
        return [new e.Z(0, s2 / a2).toLngLat().lat, new e.Z(0, (s2 + 1) / a2).toLngLat().lat];
      }
      const ke = (t2, e2, i2, a2) => {
        const s2 = t2.transform;
        return { u_matrix: Ne(t2, e2, i2, a2), u_ratio: 1 / Bt(e2, 1, s2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_units_to_pixels: [1 / s2.pixelsToGLUnits[0], 1 / s2.pixelsToGLUnits[1]] };
      }, Le = (t2, i2, a2, s2, o2) => e.e(ke(t2, i2, a2, o2), { u_image: 0, u_image_height: s2 }), Fe = (t2, e2, i2, a2, s2) => {
        const o2 = t2.transform, r2 = Oe(e2, o2);
        return { u_matrix: Ne(t2, e2, i2, s2), u_texsize: e2.imageAtlasTexture.size, u_ratio: 1 / Bt(e2, 1, o2.zoom), u_device_pixel_ratio: t2.pixelRatio, u_image: 0, u_scale: [r2, a2.fromScale, a2.toScale], u_fade: a2.t, u_units_to_pixels: [1 / o2.pixelsToGLUnits[0], 1 / o2.pixelsToGLUnits[1]] };
      }, Be = (t2, i2, a2, s2, o2, r2) => {
        const n2 = t2.lineAtlas, l2 = Oe(i2, t2.transform), h2 = a2.layout.get("line-cap") === "round", c2 = n2.getDash(s2.from, h2), u5 = n2.getDash(s2.to, h2), d2 = c2.width * o2.fromScale, _2 = u5.width * o2.toScale;
        return e.e(ke(t2, i2, a2, r2), { u_patternscale_a: [l2 / d2, -c2.height / 2], u_patternscale_b: [l2 / _2, -u5.height / 2], u_sdfgamma: n2.width / (256 * Math.min(d2, _2) * t2.pixelRatio) / 2, u_image: 0, u_tex_y_a: c2.y, u_tex_y_b: u5.y, u_mix: o2.t });
      };
      function Oe(t2, e2) {
        return 1 / Bt(t2, 1, e2.tileZoom);
      }
      function Ne(t2, e2, i2, a2) {
        return t2.translatePosMatrix(a2 ? a2.posMatrix : e2.tileID.posMatrix, e2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
      }
      const Ue = (t2, e2, i2, a2, s2) => {
        return { u_matrix: t2, u_tl_parent: e2, u_scale_parent: i2, u_buffer_scale: 1, u_fade_t: a2.mix, u_opacity: a2.opacity * s2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: s2.paint.get("raster-brightness-min"), u_brightness_high: s2.paint.get("raster-brightness-max"), u_saturation_factor: (r2 = s2.paint.get("raster-saturation"), r2 > 0 ? 1 - 1 / (1.001 - r2) : -r2), u_contrast_factor: (o2 = s2.paint.get("raster-contrast"), o2 > 0 ? 1 / (1 - o2) : 1 + o2), u_spin_weights: je(s2.paint.get("raster-hue-rotate")) };
        var o2, r2;
      };
      function je(t2) {
        t2 *= Math.PI / 180;
        const e2 = Math.sin(t2), i2 = Math.cos(t2);
        return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * e2 - i2 + 1) / 3, (Math.sqrt(3) * e2 - i2 + 1) / 3];
      }
      const Ze = (t2, e2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u5, d2, _2) => {
        const p2 = r2.transform;
        return { u_is_size_zoom_constant: +(t2 === "constant" || t2 === "source"), u_is_size_feature_constant: +(t2 === "constant" || t2 === "camera"), u_size_t: e2 ? e2.uSizeT : 0, u_size: e2 ? e2.uSize : 0, u_camera_to_center_distance: p2.cameraToCenterDistance, u_pitch: p2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: p2.width / p2.height, u_fade_change: r2.options.fadeDuration ? r2.symbolFadeChange : 1, u_matrix: n2, u_label_plane_matrix: l2, u_coord_matrix: h2, u_is_text: +u5, u_pitch_with_map: +a2, u_is_along_line: s2, u_is_variable_anchor: o2, u_texsize: d2, u_texture: 0, u_translation: c2, u_pitched_scale: _2 };
      }, qe = (t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u5, d2, _2, p2, m2) => {
        const f2 = n2.transform;
        return e.e(Ze(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u5, d2, _2, m2), { u_gamma_scale: s2 ? Math.cos(f2._pitch) * f2.cameraToCenterDistance : 1, u_device_pixel_ratio: n2.pixelRatio, u_is_halo: +p2 });
      }, Ve = (t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u5, d2, _2, p2) => e.e(qe(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u5, true, d2, true, p2), { u_texsize_icon: _2, u_texture_icon: 1 }), Ge = (t2, e2, i2) => ({ u_matrix: t2, u_opacity: e2, u_color: i2 }), He = (t2, i2, a2, s2, o2, r2) => e.e(function(t3, e2, i3, a3) {
        const s3 = i3.imageManager.getPattern(t3.from.toString()), o3 = i3.imageManager.getPattern(t3.to.toString()), { width: r3, height: n2 } = i3.imageManager.getPixelSize(), l2 = Math.pow(2, a3.tileID.overscaledZ), h2 = a3.tileSize * Math.pow(2, i3.transform.tileZoom) / l2, c2 = h2 * (a3.tileID.canonical.x + a3.tileID.wrap * l2), u5 = h2 * a3.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: s3.tl, u_pattern_br_a: s3.br, u_pattern_tl_b: o3.tl, u_pattern_br_b: o3.br, u_texsize: [r3, n2], u_mix: e2.t, u_pattern_size_a: s3.displaySize, u_pattern_size_b: o3.displaySize, u_scale_a: e2.fromScale, u_scale_b: e2.toScale, u_tile_units_to_pixels: 1 / Bt(a3, 1, i3.transform.tileZoom), u_pixel_coord_upper: [c2 >> 16, u5 >> 16], u_pixel_coord_lower: [65535 & c2, 65535 & u5] };
      }(s2, r2, a2, o2), { u_matrix: t2, u_opacity: i2 }), We = { fillExtrusion: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_lightpos: new e.aN(t2, i2.u_lightpos), u_lightintensity: new e.aI(t2, i2.u_lightintensity), u_lightcolor: new e.aN(t2, i2.u_lightcolor), u_vertical_gradient: new e.aI(t2, i2.u_vertical_gradient), u_opacity: new e.aI(t2, i2.u_opacity) }), fillExtrusionPattern: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_lightpos: new e.aN(t2, i2.u_lightpos), u_lightintensity: new e.aI(t2, i2.u_lightintensity), u_lightcolor: new e.aN(t2, i2.u_lightcolor), u_vertical_gradient: new e.aI(t2, i2.u_vertical_gradient), u_height_factor: new e.aI(t2, i2.u_height_factor), u_image: new e.aH(t2, i2.u_image), u_texsize: new e.aO(t2, i2.u_texsize), u_pixel_coord_upper: new e.aO(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.aO(t2, i2.u_pixel_coord_lower), u_scale: new e.aN(t2, i2.u_scale), u_fade: new e.aI(t2, i2.u_fade), u_opacity: new e.aI(t2, i2.u_opacity) }), fill: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix) }), fillPattern: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_image: new e.aH(t2, i2.u_image), u_texsize: new e.aO(t2, i2.u_texsize), u_pixel_coord_upper: new e.aO(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.aO(t2, i2.u_pixel_coord_lower), u_scale: new e.aN(t2, i2.u_scale), u_fade: new e.aI(t2, i2.u_fade) }), fillOutline: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_world: new e.aO(t2, i2.u_world) }), fillOutlinePattern: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_world: new e.aO(t2, i2.u_world), u_image: new e.aH(t2, i2.u_image), u_texsize: new e.aO(t2, i2.u_texsize), u_pixel_coord_upper: new e.aO(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.aO(t2, i2.u_pixel_coord_lower), u_scale: new e.aN(t2, i2.u_scale), u_fade: new e.aI(t2, i2.u_fade) }), circle: (t2, i2) => ({ u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance), u_scale_with_map: new e.aH(t2, i2.u_scale_with_map), u_pitch_with_map: new e.aH(t2, i2.u_pitch_with_map), u_extrude_scale: new e.aO(t2, i2.u_extrude_scale), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_matrix: new e.aJ(t2, i2.u_matrix) }), collisionBox: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_pixel_extrude_scale: new e.aO(t2, i2.u_pixel_extrude_scale) }), collisionCircle: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_inv_matrix: new e.aJ(t2, i2.u_inv_matrix), u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance), u_viewport_size: new e.aO(t2, i2.u_viewport_size) }), debug: (t2, i2) => ({ u_color: new e.aL(t2, i2.u_color), u_matrix: new e.aJ(t2, i2.u_matrix), u_overlay: new e.aH(t2, i2.u_overlay), u_overlay_scale: new e.aI(t2, i2.u_overlay_scale) }), clippingMask: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix) }), heatmap: (t2, i2) => ({ u_extrude_scale: new e.aI(t2, i2.u_extrude_scale), u_intensity: new e.aI(t2, i2.u_intensity), u_matrix: new e.aJ(t2, i2.u_matrix) }), heatmapTexture: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_world: new e.aO(t2, i2.u_world), u_image: new e.aH(t2, i2.u_image), u_color_ramp: new e.aH(t2, i2.u_color_ramp), u_opacity: new e.aI(t2, i2.u_opacity) }), hillshade: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_image: new e.aH(t2, i2.u_image), u_latrange: new e.aO(t2, i2.u_latrange), u_light: new e.aO(t2, i2.u_light), u_shadow: new e.aL(t2, i2.u_shadow), u_highlight: new e.aL(t2, i2.u_highlight), u_accent: new e.aL(t2, i2.u_accent) }), hillshadePrepare: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_image: new e.aH(t2, i2.u_image), u_dimension: new e.aO(t2, i2.u_dimension), u_zoom: new e.aI(t2, i2.u_zoom), u_unpack: new e.aK(t2, i2.u_unpack) }), line: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_ratio: new e.aI(t2, i2.u_ratio), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_units_to_pixels: new e.aO(t2, i2.u_units_to_pixels) }), lineGradient: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_ratio: new e.aI(t2, i2.u_ratio), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_units_to_pixels: new e.aO(t2, i2.u_units_to_pixels), u_image: new e.aH(t2, i2.u_image), u_image_height: new e.aI(t2, i2.u_image_height) }), linePattern: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_texsize: new e.aO(t2, i2.u_texsize), u_ratio: new e.aI(t2, i2.u_ratio), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_image: new e.aH(t2, i2.u_image), u_units_to_pixels: new e.aO(t2, i2.u_units_to_pixels), u_scale: new e.aN(t2, i2.u_scale), u_fade: new e.aI(t2, i2.u_fade) }), lineSDF: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_ratio: new e.aI(t2, i2.u_ratio), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_units_to_pixels: new e.aO(t2, i2.u_units_to_pixels), u_patternscale_a: new e.aO(t2, i2.u_patternscale_a), u_patternscale_b: new e.aO(t2, i2.u_patternscale_b), u_sdfgamma: new e.aI(t2, i2.u_sdfgamma), u_image: new e.aH(t2, i2.u_image), u_tex_y_a: new e.aI(t2, i2.u_tex_y_a), u_tex_y_b: new e.aI(t2, i2.u_tex_y_b), u_mix: new e.aI(t2, i2.u_mix) }), raster: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_tl_parent: new e.aO(t2, i2.u_tl_parent), u_scale_parent: new e.aI(t2, i2.u_scale_parent), u_buffer_scale: new e.aI(t2, i2.u_buffer_scale), u_fade_t: new e.aI(t2, i2.u_fade_t), u_opacity: new e.aI(t2, i2.u_opacity), u_image0: new e.aH(t2, i2.u_image0), u_image1: new e.aH(t2, i2.u_image1), u_brightness_low: new e.aI(t2, i2.u_brightness_low), u_brightness_high: new e.aI(t2, i2.u_brightness_high), u_saturation_factor: new e.aI(t2, i2.u_saturation_factor), u_contrast_factor: new e.aI(t2, i2.u_contrast_factor), u_spin_weights: new e.aN(t2, i2.u_spin_weights) }), symbolIcon: (t2, i2) => ({ u_is_size_zoom_constant: new e.aH(t2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new e.aH(t2, i2.u_is_size_feature_constant), u_size_t: new e.aI(t2, i2.u_size_t), u_size: new e.aI(t2, i2.u_size), u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance), u_pitch: new e.aI(t2, i2.u_pitch), u_rotate_symbol: new e.aH(t2, i2.u_rotate_symbol), u_aspect_ratio: new e.aI(t2, i2.u_aspect_ratio), u_fade_change: new e.aI(t2, i2.u_fade_change), u_matrix: new e.aJ(t2, i2.u_matrix), u_label_plane_matrix: new e.aJ(t2, i2.u_label_plane_matrix), u_coord_matrix: new e.aJ(t2, i2.u_coord_matrix), u_is_text: new e.aH(t2, i2.u_is_text), u_pitch_with_map: new e.aH(t2, i2.u_pitch_with_map), u_is_along_line: new e.aH(t2, i2.u_is_along_line), u_is_variable_anchor: new e.aH(t2, i2.u_is_variable_anchor), u_texsize: new e.aO(t2, i2.u_texsize), u_texture: new e.aH(t2, i2.u_texture), u_translation: new e.aO(t2, i2.u_translation), u_pitched_scale: new e.aI(t2, i2.u_pitched_scale) }), symbolSDF: (t2, i2) => ({ u_is_size_zoom_constant: new e.aH(t2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new e.aH(t2, i2.u_is_size_feature_constant), u_size_t: new e.aI(t2, i2.u_size_t), u_size: new e.aI(t2, i2.u_size), u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance), u_pitch: new e.aI(t2, i2.u_pitch), u_rotate_symbol: new e.aH(t2, i2.u_rotate_symbol), u_aspect_ratio: new e.aI(t2, i2.u_aspect_ratio), u_fade_change: new e.aI(t2, i2.u_fade_change), u_matrix: new e.aJ(t2, i2.u_matrix), u_label_plane_matrix: new e.aJ(t2, i2.u_label_plane_matrix), u_coord_matrix: new e.aJ(t2, i2.u_coord_matrix), u_is_text: new e.aH(t2, i2.u_is_text), u_pitch_with_map: new e.aH(t2, i2.u_pitch_with_map), u_is_along_line: new e.aH(t2, i2.u_is_along_line), u_is_variable_anchor: new e.aH(t2, i2.u_is_variable_anchor), u_texsize: new e.aO(t2, i2.u_texsize), u_texture: new e.aH(t2, i2.u_texture), u_gamma_scale: new e.aI(t2, i2.u_gamma_scale), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_is_halo: new e.aH(t2, i2.u_is_halo), u_translation: new e.aO(t2, i2.u_translation), u_pitched_scale: new e.aI(t2, i2.u_pitched_scale) }), symbolTextAndIcon: (t2, i2) => ({ u_is_size_zoom_constant: new e.aH(t2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new e.aH(t2, i2.u_is_size_feature_constant), u_size_t: new e.aI(t2, i2.u_size_t), u_size: new e.aI(t2, i2.u_size), u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance), u_pitch: new e.aI(t2, i2.u_pitch), u_rotate_symbol: new e.aH(t2, i2.u_rotate_symbol), u_aspect_ratio: new e.aI(t2, i2.u_aspect_ratio), u_fade_change: new e.aI(t2, i2.u_fade_change), u_matrix: new e.aJ(t2, i2.u_matrix), u_label_plane_matrix: new e.aJ(t2, i2.u_label_plane_matrix), u_coord_matrix: new e.aJ(t2, i2.u_coord_matrix), u_is_text: new e.aH(t2, i2.u_is_text), u_pitch_with_map: new e.aH(t2, i2.u_pitch_with_map), u_is_along_line: new e.aH(t2, i2.u_is_along_line), u_is_variable_anchor: new e.aH(t2, i2.u_is_variable_anchor), u_texsize: new e.aO(t2, i2.u_texsize), u_texsize_icon: new e.aO(t2, i2.u_texsize_icon), u_texture: new e.aH(t2, i2.u_texture), u_texture_icon: new e.aH(t2, i2.u_texture_icon), u_gamma_scale: new e.aI(t2, i2.u_gamma_scale), u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio), u_is_halo: new e.aH(t2, i2.u_is_halo), u_translation: new e.aO(t2, i2.u_translation), u_pitched_scale: new e.aI(t2, i2.u_pitched_scale) }), background: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_opacity: new e.aI(t2, i2.u_opacity), u_color: new e.aL(t2, i2.u_color) }), backgroundPattern: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_opacity: new e.aI(t2, i2.u_opacity), u_image: new e.aH(t2, i2.u_image), u_pattern_tl_a: new e.aO(t2, i2.u_pattern_tl_a), u_pattern_br_a: new e.aO(t2, i2.u_pattern_br_a), u_pattern_tl_b: new e.aO(t2, i2.u_pattern_tl_b), u_pattern_br_b: new e.aO(t2, i2.u_pattern_br_b), u_texsize: new e.aO(t2, i2.u_texsize), u_mix: new e.aI(t2, i2.u_mix), u_pattern_size_a: new e.aO(t2, i2.u_pattern_size_a), u_pattern_size_b: new e.aO(t2, i2.u_pattern_size_b), u_scale_a: new e.aI(t2, i2.u_scale_a), u_scale_b: new e.aI(t2, i2.u_scale_b), u_pixel_coord_upper: new e.aO(t2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new e.aO(t2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new e.aI(t2, i2.u_tile_units_to_pixels) }), terrain: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_texture: new e.aH(t2, i2.u_texture), u_ele_delta: new e.aI(t2, i2.u_ele_delta), u_fog_matrix: new e.aJ(t2, i2.u_fog_matrix), u_fog_color: new e.aL(t2, i2.u_fog_color), u_fog_ground_blend: new e.aI(t2, i2.u_fog_ground_blend), u_fog_ground_blend_opacity: new e.aI(t2, i2.u_fog_ground_blend_opacity), u_horizon_color: new e.aL(t2, i2.u_horizon_color), u_horizon_fog_blend: new e.aI(t2, i2.u_horizon_fog_blend) }), terrainDepth: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_ele_delta: new e.aI(t2, i2.u_ele_delta) }), terrainCoords: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix), u_texture: new e.aH(t2, i2.u_texture), u_terrain_coords_id: new e.aI(t2, i2.u_terrain_coords_id), u_ele_delta: new e.aI(t2, i2.u_ele_delta) }), sky: (t2, i2) => ({ u_sky_color: new e.aL(t2, i2.u_sky_color), u_horizon_color: new e.aL(t2, i2.u_horizon_color), u_horizon: new e.aI(t2, i2.u_horizon), u_sky_horizon_blend: new e.aI(t2, i2.u_sky_horizon_blend) }) };

      class $e {
        constructor(t2, e2, i2) {
          this.context = t2;
          const a2 = t2.gl;
          this.buffer = a2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), t2.bindElementBuffer.set(this.buffer), a2.bufferData(a2.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? a2.DYNAMIC_DRAW : a2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(t2) {
          const e2 = this.context.gl;
          if (!this.dynamicDraw)
            throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t2.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Xe = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };

      class Ke {
        constructor(t2, e2, i2, a2) {
          this.length = e2.length, this.attributes = i2, this.itemSize = e2.bytesPerElement, this.dynamicDraw = a2, this.context = t2;
          const s2 = t2.gl;
          this.buffer = s2.createBuffer(), t2.bindVertexBuffer.set(this.buffer), s2.bufferData(s2.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? s2.DYNAMIC_DRAW : s2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(t2) {
          if (t2.length !== this.length)
            throw new Error(`Length of new data is ${t2.length}, which doesn't match current length of ${this.length}`);
          const e2 = this.context.gl;
          this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t2.arrayBuffer);
        }
        enableAttributes(t2, e2) {
          for (let i2 = 0;i2 < this.attributes.length; i2++) {
            const a2 = e2.attributes[this.attributes[i2].name];
            a2 !== undefined && t2.enableVertexAttribArray(a2);
          }
        }
        setVertexAttribPointers(t2, e2, i2) {
          for (let a2 = 0;a2 < this.attributes.length; a2++) {
            const s2 = this.attributes[a2], o2 = e2.attributes[s2.name];
            o2 !== undefined && t2.vertexAttribPointer(o2, s2.components, t2[Xe[s2.type]], false, this.itemSize, s2.offset + this.itemSize * (i2 || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Je = new WeakMap;
      function Ye(t2) {
        var e2;
        if (Je.has(t2))
          return Je.get(t2);
        {
          const i2 = (e2 = t2.getParameter(t2.VERSION)) === null || e2 === undefined ? undefined : e2.startsWith("WebGL 2.0");
          return Je.set(t2, i2), i2;
        }
      }

      class Qe {
        constructor(t2) {
          this.gl = t2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        }
        get() {
          return this.current;
        }
        set(t2) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }

      class ti extends Qe {
        getDefault() {
          return e.aM.transparent;
        }
        set(t2) {
          const e2 = this.current;
          (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.clearColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
        }
      }

      class ei extends Qe {
        getDefault() {
          return 1;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.clearDepth(t2), this.current = t2, this.dirty = false);
        }
      }

      class ii extends Qe {
        getDefault() {
          return 0;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.clearStencil(t2), this.current = t2, this.dirty = false);
        }
      }

      class ai extends Qe {
        getDefault() {
          return [true, true, true, true];
        }
        set(t2) {
          const e2 = this.current;
          (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.colorMask(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
        }
      }

      class si extends Qe {
        getDefault() {
          return true;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.depthMask(t2), this.current = t2, this.dirty = false);
        }
      }

      class oi extends Qe {
        getDefault() {
          return 255;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.stencilMask(t2), this.current = t2, this.dirty = false);
        }
      }

      class ri extends Qe {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(t2) {
          const e2 = this.current;
          (t2.func !== e2.func || t2.ref !== e2.ref || t2.mask !== e2.mask || this.dirty) && (this.gl.stencilFunc(t2.func, t2.ref, t2.mask), this.current = t2, this.dirty = false);
        }
      }

      class ni extends Qe {
        getDefault() {
          const t2 = this.gl;
          return [t2.KEEP, t2.KEEP, t2.KEEP];
        }
        set(t2) {
          const e2 = this.current;
          (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || this.dirty) && (this.gl.stencilOp(t2[0], t2[1], t2[2]), this.current = t2, this.dirty = false);
        }
      }

      class li extends Qe {
        getDefault() {
          return false;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          t2 ? e2.enable(e2.STENCIL_TEST) : e2.disable(e2.STENCIL_TEST), this.current = t2, this.dirty = false;
        }
      }

      class hi extends Qe {
        getDefault() {
          return [0, 1];
        }
        set(t2) {
          const e2 = this.current;
          (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.depthRange(t2[0], t2[1]), this.current = t2, this.dirty = false);
        }
      }

      class ci extends Qe {
        getDefault() {
          return false;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          t2 ? e2.enable(e2.DEPTH_TEST) : e2.disable(e2.DEPTH_TEST), this.current = t2, this.dirty = false;
        }
      }

      class ui extends Qe {
        getDefault() {
          return this.gl.LESS;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.depthFunc(t2), this.current = t2, this.dirty = false);
        }
      }

      class di extends Qe {
        getDefault() {
          return false;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          t2 ? e2.enable(e2.BLEND) : e2.disable(e2.BLEND), this.current = t2, this.dirty = false;
        }
      }

      class _i extends Qe {
        getDefault() {
          const t2 = this.gl;
          return [t2.ONE, t2.ZERO];
        }
        set(t2) {
          const e2 = this.current;
          (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.blendFunc(t2[0], t2[1]), this.current = t2, this.dirty = false);
        }
      }

      class pi extends Qe {
        getDefault() {
          return e.aM.transparent;
        }
        set(t2) {
          const e2 = this.current;
          (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.blendColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
        }
      }

      class mi extends Qe {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.blendEquation(t2), this.current = t2, this.dirty = false);
        }
      }

      class fi extends Qe {
        getDefault() {
          return false;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          t2 ? e2.enable(e2.CULL_FACE) : e2.disable(e2.CULL_FACE), this.current = t2, this.dirty = false;
        }
      }

      class gi extends Qe {
        getDefault() {
          return this.gl.BACK;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.cullFace(t2), this.current = t2, this.dirty = false);
        }
      }

      class vi extends Qe {
        getDefault() {
          return this.gl.CCW;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.frontFace(t2), this.current = t2, this.dirty = false);
        }
      }

      class xi extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.useProgram(t2), this.current = t2, this.dirty = false);
        }
      }

      class yi extends Qe {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.activeTexture(t2), this.current = t2, this.dirty = false);
        }
      }

      class bi extends Qe {
        getDefault() {
          const t2 = this.gl;
          return [0, 0, t2.drawingBufferWidth, t2.drawingBufferHeight];
        }
        set(t2) {
          const e2 = this.current;
          (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.viewport(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
        }
      }

      class wi extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.bindFramebuffer(e2.FRAMEBUFFER, t2), this.current = t2, this.dirty = false;
        }
      }

      class Ti extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.bindRenderbuffer(e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
        }
      }

      class Ii extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.bindTexture(e2.TEXTURE_2D, t2), this.current = t2, this.dirty = false;
        }
      }

      class Ei extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.bindBuffer(e2.ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
        }
      }

      class Pi extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          const e2 = this.gl;
          e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
        }
      }

      class Ci extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          var e2;
          if (t2 === this.current && !this.dirty)
            return;
          const i2 = this.gl;
          Ye(i2) ? i2.bindVertexArray(t2) : (e2 = i2.getExtension("OES_vertex_array_object")) === null || e2 === undefined || e2.bindVertexArrayOES(t2), this.current = t2, this.dirty = false;
        }
      }

      class Si extends Qe {
        getDefault() {
          return 4;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.pixelStorei(e2.UNPACK_ALIGNMENT, t2), this.current = t2, this.dirty = false;
        }
      }

      class zi extends Qe {
        getDefault() {
          return false;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.pixelStorei(e2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t2), this.current = t2, this.dirty = false;
        }
      }

      class Di extends Qe {
        getDefault() {
          return false;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.pixelStorei(e2.UNPACK_FLIP_Y_WEBGL, t2), this.current = t2, this.dirty = false;
        }
      }

      class Mi extends Qe {
        constructor(t2, e2) {
          super(t2), this.context = t2, this.parent = e2;
        }
        getDefault() {
          return null;
        }
      }

      class Ai extends Mi {
        setDirty() {
          this.dirty = true;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const e2 = this.gl;
          e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0), this.current = t2, this.dirty = false;
        }
      }

      class Ri extends Mi {
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const e2 = this.gl;
          e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_ATTACHMENT, e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
        }
      }

      class ki extends Mi {
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const e2 = this.gl;
          e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_STENCIL_ATTACHMENT, e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
        }
      }

      class Li {
        constructor(t2, e2, i2, a2, s2) {
          this.context = t2, this.width = e2, this.height = i2;
          const o2 = t2.gl, r2 = this.framebuffer = o2.createFramebuffer();
          if (this.colorAttachment = new Ai(t2, r2), a2)
            this.depthAttachment = s2 ? new ki(t2, r2) : new Ri(t2, r2);
          else if (s2)
            throw new Error("Stencil cannot be set without depth");
          if (o2.checkFramebufferStatus(o2.FRAMEBUFFER) !== o2.FRAMEBUFFER_COMPLETE)
            throw new Error("Framebuffer is not complete");
        }
        destroy() {
          const t2 = this.context.gl, e2 = this.colorAttachment.get();
          if (e2 && t2.deleteTexture(e2), this.depthAttachment) {
            const e3 = this.depthAttachment.get();
            e3 && t2.deleteRenderbuffer(e3);
          }
          t2.deleteFramebuffer(this.framebuffer);
        }
      }

      class Fi {
        constructor(t2, e2, i2) {
          this.blendFunction = t2, this.blendColor = e2, this.mask = i2;
        }
      }
      Fi.Replace = [1, 0], Fi.disabled = new Fi(Fi.Replace, e.aM.transparent, [false, false, false, false]), Fi.unblended = new Fi(Fi.Replace, e.aM.transparent, [true, true, true, true]), Fi.alphaBlended = new Fi([1, 771], e.aM.transparent, [true, true, true, true]);

      class Bi {
        constructor(t2) {
          var e2, i2;
          if (this.gl = t2, this.clearColor = new ti(this), this.clearDepth = new ei(this), this.clearStencil = new ii(this), this.colorMask = new ai(this), this.depthMask = new si(this), this.stencilMask = new oi(this), this.stencilFunc = new ri(this), this.stencilOp = new ni(this), this.stencilTest = new li(this), this.depthRange = new hi(this), this.depthTest = new ci(this), this.depthFunc = new ui(this), this.blend = new di(this), this.blendFunc = new _i(this), this.blendColor = new pi(this), this.blendEquation = new mi(this), this.cullFace = new fi(this), this.cullFaceSide = new gi(this), this.frontFace = new vi(this), this.program = new xi(this), this.activeTexture = new yi(this), this.viewport = new bi(this), this.bindFramebuffer = new wi(this), this.bindRenderbuffer = new Ti(this), this.bindTexture = new Ii(this), this.bindVertexBuffer = new Ei(this), this.bindElementBuffer = new Pi(this), this.bindVertexArray = new Ci(this), this.pixelStoreUnpack = new Si(this), this.pixelStoreUnpackPremultiplyAlpha = new zi(this), this.pixelStoreUnpackFlipY = new Di(this), this.extTextureFilterAnisotropic = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE), Ye(t2)) {
            this.HALF_FLOAT = t2.HALF_FLOAT;
            const a2 = t2.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = (e2 = t2.RGBA16F) !== null && e2 !== undefined ? e2 : a2 == null ? undefined : a2.RGBA16F_EXT, this.RGB16F = (i2 = t2.RGB16F) !== null && i2 !== undefined ? i2 : a2 == null ? undefined : a2.RGB16F_EXT, t2.getExtension("EXT_color_buffer_float");
          } else {
            t2.getExtension("EXT_color_buffer_half_float"), t2.getExtension("OES_texture_half_float_linear");
            const e3 = t2.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = e3 == null ? undefined : e3.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }
        createIndexBuffer(t2, e2) {
          return new $e(this, t2, e2);
        }
        createVertexBuffer(t2, e2, i2) {
          return new Ke(this, t2, e2, i2);
        }
        createRenderbuffer(t2, e2, i2) {
          const a2 = this.gl, s2 = a2.createRenderbuffer();
          return this.bindRenderbuffer.set(s2), a2.renderbufferStorage(a2.RENDERBUFFER, t2, e2, i2), this.bindRenderbuffer.set(null), s2;
        }
        createFramebuffer(t2, e2, i2, a2) {
          return new Li(this, t2, e2, i2, a2);
        }
        clear({ color: t2, depth: e2, stencil: i2 }) {
          const a2 = this.gl;
          let s2 = 0;
          t2 && (s2 |= a2.COLOR_BUFFER_BIT, this.clearColor.set(t2), this.colorMask.set([true, true, true, true])), e2 !== undefined && (s2 |= a2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e2), this.depthMask.set(true)), i2 !== undefined && (s2 |= a2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), a2.clear(s2);
        }
        setCullFace(t2) {
          t2.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t2.mode), this.frontFace.set(t2.frontFace));
        }
        setDepthMode(t2) {
          t2.func !== this.gl.ALWAYS || t2.mask ? (this.depthTest.set(true), this.depthFunc.set(t2.func), this.depthMask.set(t2.mask), this.depthRange.set(t2.range)) : this.depthTest.set(false);
        }
        setStencilMode(t2) {
          t2.test.func !== this.gl.ALWAYS || t2.mask ? (this.stencilTest.set(true), this.stencilMask.set(t2.mask), this.stencilOp.set([t2.fail, t2.depthFail, t2.pass]), this.stencilFunc.set({ func: t2.test.func, ref: t2.ref, mask: t2.test.mask })) : this.stencilTest.set(false);
        }
        setColorMode(t2) {
          e.aE(t2.blendFunction, Fi.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t2.blendFunction), this.blendColor.set(t2.blendColor)), this.colorMask.set(t2.mask);
        }
        createVertexArray() {
          var t2;
          return Ye(this.gl) ? this.gl.createVertexArray() : (t2 = this.gl.getExtension("OES_vertex_array_object")) === null || t2 === undefined ? undefined : t2.createVertexArrayOES();
        }
        deleteVertexArray(t2) {
          var e2;
          return Ye(this.gl) ? this.gl.deleteVertexArray(t2) : (e2 = this.gl.getExtension("OES_vertex_array_object")) === null || e2 === undefined ? undefined : e2.deleteVertexArrayOES(t2);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }

      class Oi {
        constructor(t2, e2, i2) {
          this.func = t2, this.mask = e2, this.range = i2;
        }
      }
      Oi.ReadOnly = false, Oi.ReadWrite = true, Oi.disabled = new Oi(519, Oi.ReadOnly, [0, 1]);
      const Ni = 7680;

      class Ui {
        constructor(t2, e2, i2, a2, s2, o2) {
          this.test = t2, this.ref = e2, this.mask = i2, this.fail = a2, this.depthFail = s2, this.pass = o2;
        }
      }
      Ui.disabled = new Ui({ func: 519, mask: 0 }, 0, 0, Ni, Ni, Ni);

      class ji {
        constructor(t2, e2, i2) {
          this.enable = t2, this.mode = e2, this.frontFace = i2;
        }
      }
      let Zi;
      function qi(t2, i2, a2, s2, o2) {
        const r2 = t2.context, n2 = r2.gl, l2 = t2.useProgram("collisionBox"), h2 = [];
        let c2 = 0, u5 = 0;
        for (let _3 = 0;_3 < s2.length; _3++) {
          const p3 = s2[_3], m3 = i2.getTile(p3).getBucket(a2);
          if (!m3)
            continue;
          const f3 = o2 ? m3.textCollisionBox : m3.iconCollisionBox, g3 = m3.collisionCircleArray;
          if (g3.length > 0) {
            const i3 = e.H();
            e.aQ(i3, m3.placementInvProjMatrix, t2.transform.glCoordMatrix), e.aQ(i3, i3, m3.placementViewportMatrix), h2.push({ circleArray: g3, circleOffset: u5, transform: p3.posMatrix, invTransform: i3, coord: p3 }), c2 += g3.length / 4, u5 = c2;
          }
          f3 && l2.draw(r2, n2.LINES, Oi.disabled, Ui.disabled, t2.colorModeForRenderPass(), ji.disabled, { u_matrix: p3.posMatrix, u_pixel_extrude_scale: [1 / (d2 = t2.transform).width, 1 / d2.height] }, t2.style.map.terrain && t2.style.map.terrain.getTerrainData(p3), a2.id, f3.layoutVertexBuffer, f3.indexBuffer, f3.segments, null, t2.transform.zoom, null, null, f3.collisionVertexBuffer);
        }
        var d2;
        if (!o2 || !h2.length)
          return;
        const _2 = t2.useProgram("collisionCircle"), p2 = new e.aR;
        p2.resize(4 * c2), p2._trim();
        let m2 = 0;
        for (const t3 of h2)
          for (let e2 = 0;e2 < t3.circleArray.length / 4; e2++) {
            const i3 = 4 * e2, a3 = t3.circleArray[i3 + 0], s3 = t3.circleArray[i3 + 1], o3 = t3.circleArray[i3 + 2], r3 = t3.circleArray[i3 + 3];
            p2.emplace(m2++, a3, s3, o3, r3, 0), p2.emplace(m2++, a3, s3, o3, r3, 1), p2.emplace(m2++, a3, s3, o3, r3, 2), p2.emplace(m2++, a3, s3, o3, r3, 3);
          }
        (!Zi || Zi.length < 2 * c2) && (Zi = function(t3) {
          const i3 = 2 * t3, a3 = new e.aT;
          a3.resize(i3), a3._trim();
          for (let t4 = 0;t4 < i3; t4++) {
            const e2 = 6 * t4;
            a3.uint16[e2 + 0] = 4 * t4 + 0, a3.uint16[e2 + 1] = 4 * t4 + 1, a3.uint16[e2 + 2] = 4 * t4 + 2, a3.uint16[e2 + 3] = 4 * t4 + 2, a3.uint16[e2 + 4] = 4 * t4 + 3, a3.uint16[e2 + 5] = 4 * t4 + 0;
          }
          return a3;
        }(c2));
        const f2 = r2.createIndexBuffer(Zi, true), g2 = r2.createVertexBuffer(p2, e.aS.members, true);
        for (const i3 of h2) {
          const s3 = Se(i3.transform, i3.invTransform, t2.transform);
          _2.draw(r2, n2.TRIANGLES, Oi.disabled, Ui.disabled, t2.colorModeForRenderPass(), ji.disabled, s3, t2.style.map.terrain && t2.style.map.terrain.getTerrainData(i3.coord), a2.id, g2, f2, e.a0.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, t2.transform.zoom, null, null, null);
        }
        g2.destroy(), f2.destroy();
      }
      ji.disabled = new ji(false, 1029, 2305), ji.backCCW = new ji(true, 1029, 2305);
      const Vi = e.an(new Float32Array(16));
      function Gi(t2, i2, a2, s2, o2, r2) {
        const { horizontalAlign: n2, verticalAlign: l2 } = e.au(t2);
        return new e.P((-(n2 - 0.5) * i2 / o2 + s2[0]) * r2, (-(l2 - 0.5) * a2 / o2 + s2[1]) * r2);
      }
      function Hi(t2, i2, a2, s2, o2, r2) {
        const n2 = i2.tileAnchorPoint.add(new e.P(i2.translation[0], i2.translation[1]));
        if (i2.pitchWithMap) {
          let t3 = s2.mult(r2);
          a2 || (t3 = t3.rotate(-o2));
          const e2 = n2.add(t3);
          return xt(e2.x, e2.y, i2.labelPlaneMatrix, i2.getElevation).point;
        }
        if (a2) {
          const e2 = St(i2.tileAnchorPoint.x + 1, i2.tileAnchorPoint.y, i2).point.sub(t2), a3 = Math.atan(e2.y / e2.x) + (e2.x < 0 ? Math.PI : 0);
          return t2.add(s2.rotate(a3));
        }
        return t2.add(s2);
      }
      function Wi(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u5, d2, _2, p2) {
        const m2 = t2.text.placedSymbolArray, f2 = t2.text.dynamicLayoutVertexArray, g2 = t2.icon.dynamicLayoutVertexArray, v3 = {};
        f2.clear();
        for (let g3 = 0;g3 < m2.length; g3++) {
          const x2 = m2.get(g3), y2 = x2.hidden || !x2.crossTileID || t2.allowVerticalPlacement && !x2.placedOrientation ? null : s2[x2.crossTileID];
          if (y2) {
            const s3 = new e.P(x2.anchorX, x2.anchorY), m3 = { getElevation: p2, width: o2.width, height: o2.height, labelPlaneMatrix: r2, lineVertexArray: null, pitchWithMap: a2, projection: u5, projectionCache: null, tileAnchorPoint: s3, translation: d2, unwrappedTileID: _2 }, g4 = a2 ? xt(s3.x, s3.y, n2, p2) : St(s3.x, s3.y, m3), b2 = yt(o2.cameraToCenterDistance, g4.signedDistanceFromCamera);
            let w2 = e.ai(t2.textSizeData, h2, x2) * b2 / e.ap;
            a2 && (w2 *= t2.tilePixelRatio / l2);
            const { width: T2, height: I2, anchor: E2, textOffset: P2, textBoxScale: C3 } = y2, S2 = Gi(E2, T2, I2, P2, C3, w2), z2 = u5.getPitchedTextCorrection(o2, s3.add(new e.P(d2[0], d2[1])), _2), D3 = Hi(g4.point, m3, i2, S2, o2.angle, z2), M2 = t2.allowVerticalPlacement && x2.placedOrientation === e.ah.vertical ? Math.PI / 2 : 0;
            for (let t3 = 0;t3 < x2.numGlyphs; t3++)
              e.aj(f2, D3, M2);
            c2 && x2.associatedIconIndex >= 0 && (v3[x2.associatedIconIndex] = { shiftedAnchor: D3, angle: M2 });
          } else
            Rt(x2.numGlyphs, f2);
        }
        if (c2) {
          g2.clear();
          const i3 = t2.icon.placedSymbolArray;
          for (let t3 = 0;t3 < i3.length; t3++) {
            const a3 = i3.get(t3);
            if (a3.hidden)
              Rt(a3.numGlyphs, g2);
            else {
              const i4 = v3[t3];
              if (i4)
                for (let t4 = 0;t4 < a3.numGlyphs; t4++)
                  e.aj(g2, i4.shiftedAnchor, i4.angle);
              else
                Rt(a3.numGlyphs, g2);
            }
          }
          t2.icon.dynamicLayoutVertexBuffer.updateData(g2);
        }
        t2.text.dynamicLayoutVertexBuffer.updateData(f2);
      }
      function $i(t2, e2, i2) {
        return i2.iconsInText && e2 ? "symbolTextAndIcon" : t2 ? "symbolSDF" : "symbolIcon";
      }
      function Xi(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u5, d2) {
        const _2 = t2.context, p2 = _2.gl, m2 = t2.transform, f2 = ie(), g2 = l2 === "map", v3 = h2 === "map", x2 = l2 !== "viewport" && a2.layout.get("symbol-placement") !== "point", y2 = g2 && !v3 && !x2, b2 = !v3 && x2, w2 = !a2.layout.get("symbol-sort-key").isConstant();
        let T2 = false;
        const I2 = t2.depthModeForSublayer(0, Oi.ReadOnly), E2 = a2._unevaluatedLayout.hasValue("text-variable-anchor") || a2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), P2 = [], C3 = f2.getCircleRadiusCorrection(m2);
        for (const l3 of s2) {
          const s3 = i2.getTile(l3), h3 = s3.getBucket(a2);
          if (!h3)
            continue;
          const u6 = o2 ? h3.text : h3.icon;
          if (!u6 || !u6.segments.get().length || !u6.hasVisibleVertices)
            continue;
          const d3 = u6.programConfigurations.get(a2.id), _3 = o2 || h3.sdfIcons, I3 = o2 ? h3.textSizeData : h3.iconSizeData, S2 = v3 || m2.pitch !== 0, z2 = t2.useProgram($i(_3, o2, h3), d3), D3 = e.ag(I3, m2.zoom), M2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(l3);
          let A2, R2, k2, L2, F2 = [0, 0], B3 = null;
          if (o2)
            R2 = s3.glyphAtlasTexture, k2 = p2.LINEAR, A2 = s3.glyphAtlasTexture.size, h3.iconsInText && (F2 = s3.imageAtlasTexture.size, B3 = s3.imageAtlasTexture, L2 = S2 || t2.options.rotating || t2.options.zooming || I3.kind === "composite" || I3.kind === "camera" ? p2.LINEAR : p2.NEAREST);
          else {
            const e2 = a2.layout.get("icon-size").constantOr(0) !== 1 || h3.iconsNeedLinear;
            R2 = s3.imageAtlasTexture, k2 = _3 || t2.options.rotating || t2.options.zooming || e2 || S2 ? p2.LINEAR : p2.NEAREST, A2 = s3.imageAtlasTexture.size;
          }
          const O2 = Bt(s3, 1, t2.transform.zoom), N2 = b2 ? l3.posMatrix : Vi, U2 = gt(N2, v3, g2, t2.transform, O2), j2 = vt(N2, v3, g2, t2.transform, O2), Z2 = vt(l3.posMatrix, v3, g2, t2.transform, O2), q2 = f2.translatePosition(t2.transform, s3, r2, n2), V2 = E2 && h3.hasTextData(), G2 = a2.layout.get("icon-text-fit") !== "none" && V2 && h3.hasIconData();
          if (x2) {
            const e2 = t2.style.map.terrain ? (e3, i4) => t2.style.map.terrain.getElevation(l3, e3, i4) : null, i3 = a2.layout.get("text-rotation-alignment") === "map";
            wt(h3, l3.posMatrix, t2, o2, U2, Z2, v3, c2, i3, f2, l3.toUnwrapped(), m2.width, m2.height, q2, e2);
          }
          const H2 = l3.posMatrix, W2 = o2 && E2 || G2, $2 = x2 || W2 ? Vi : U2, X2 = j2, K2 = _3 && a2.paint.get(o2 ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let J2;
          J2 = _3 ? h3.iconsInText ? Ve(I3.kind, D3, y2, v3, x2, W2, t2, H2, $2, X2, q2, A2, F2, C3) : qe(I3.kind, D3, y2, v3, x2, W2, t2, H2, $2, X2, q2, o2, A2, true, C3) : Ze(I3.kind, D3, y2, v3, x2, W2, t2, H2, $2, X2, q2, o2, A2, C3);
          const Y2 = { program: z2, buffers: u6, uniformValues: J2, atlasTexture: R2, atlasTextureIcon: B3, atlasInterpolation: k2, atlasInterpolationIcon: L2, isSDF: _3, hasHalo: K2 };
          if (w2 && h3.canOverlap) {
            T2 = true;
            const t3 = u6.segments.get();
            for (const i3 of t3)
              P2.push({ segments: new e.a0([i3]), sortKey: i3.sortKey, state: Y2, terrainData: M2 });
          } else
            P2.push({ segments: u6.segments, sortKey: 0, state: Y2, terrainData: M2 });
        }
        T2 && P2.sort((t3, e2) => t3.sortKey - e2.sortKey);
        for (const e2 of P2) {
          const i3 = e2.state;
          if (_2.activeTexture.set(p2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, p2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (_2.activeTexture.set(p2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, p2.CLAMP_TO_EDGE)), i3.isSDF) {
            const s3 = i3.uniformValues;
            i3.hasHalo && (s3.u_is_halo = 1, Ki(i3.buffers, e2.segments, a2, t2, i3.program, I2, u5, d2, s3, e2.terrainData)), s3.u_is_halo = 0;
          }
          Ki(i3.buffers, e2.segments, a2, t2, i3.program, I2, u5, d2, i3.uniformValues, e2.terrainData);
        }
      }
      function Ki(t2, e2, i2, a2, s2, o2, r2, n2, l2, h2) {
        const c2 = a2.context;
        s2.draw(c2, c2.gl.TRIANGLES, o2, r2, n2, ji.disabled, l2, h2, i2.id, t2.layoutVertexBuffer, t2.indexBuffer, e2, i2.paint, a2.transform.zoom, t2.programConfigurations.get(i2.id), t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer);
      }
      function Ji(t2, i2, a2, s2) {
        const o2 = t2.context, r2 = o2.gl, n2 = Ui.disabled, l2 = new Fi([r2.ONE, r2.ONE], e.aM.transparent, [true, true, true, true]), h2 = i2.getBucket(a2);
        if (!h2)
          return;
        const c2 = s2.key;
        let u5 = a2.heatmapFbos.get(c2);
        u5 || (u5 = Qi(o2, i2.tileSize, i2.tileSize), a2.heatmapFbos.set(c2, u5)), o2.bindFramebuffer.set(u5.framebuffer), o2.viewport.set([0, 0, i2.tileSize, i2.tileSize]), o2.clear({ color: e.aM.transparent });
        const d2 = h2.programConfigurations.get(a2.id), _2 = t2.useProgram("heatmap", d2), p2 = t2.style.map.terrain.getTerrainData(s2);
        _2.draw(o2, r2.TRIANGLES, Oi.disabled, n2, l2, ji.disabled, Me(s2.posMatrix, i2, t2.transform.zoom, a2.paint.get("heatmap-intensity")), p2, a2.id, h2.layoutVertexBuffer, h2.indexBuffer, h2.segments, a2.paint, t2.transform.zoom, d2);
      }
      function Yi(t2, e2, i2) {
        const a2 = t2.context, s2 = a2.gl;
        a2.setColorMode(t2.colorModeForRenderPass());
        const o2 = ta(a2, e2), r2 = i2.key, n2 = e2.heatmapFbos.get(r2);
        n2 && (a2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, n2.colorAttachment.get()), a2.activeTexture.set(s2.TEXTURE1), o2.bind(s2.LINEAR, s2.CLAMP_TO_EDGE), t2.useProgram("heatmapTexture").draw(a2, s2.TRIANGLES, Oi.disabled, Ui.disabled, t2.colorModeForRenderPass(), ji.disabled, Ae(t2, e2, 0, 1), null, e2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments, e2.paint, t2.transform.zoom), n2.destroy(), e2.heatmapFbos.delete(r2));
      }
      function Qi(t2, e2, i2) {
        var a2, s2;
        const o2 = t2.gl, r2 = o2.createTexture();
        o2.bindTexture(o2.TEXTURE_2D, r2), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_S, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_T, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MIN_FILTER, o2.LINEAR), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MAG_FILTER, o2.LINEAR);
        const n2 = (a2 = t2.HALF_FLOAT) !== null && a2 !== undefined ? a2 : o2.UNSIGNED_BYTE, l2 = (s2 = t2.RGBA16F) !== null && s2 !== undefined ? s2 : o2.RGBA;
        o2.texImage2D(o2.TEXTURE_2D, 0, l2, e2, i2, 0, o2.RGBA, n2, null);
        const h2 = t2.createFramebuffer(e2, i2, false, false);
        return h2.colorAttachment.set(r2), h2;
      }
      function ta(t2, e2) {
        return e2.colorRampTexture || (e2.colorRampTexture = new b(t2, e2.colorRamp, t2.gl.RGBA)), e2.colorRampTexture;
      }
      function ea2(t2, e2, i2, a2, s2) {
        if (!i2 || !a2 || !a2.imageAtlas)
          return;
        const o2 = a2.imageAtlas.patternPositions;
        let r2 = o2[i2.to.toString()], n2 = o2[i2.from.toString()];
        if (!r2 && n2 && (r2 = n2), !n2 && r2 && (n2 = r2), !r2 || !n2) {
          const t3 = s2.getPaintProperty(e2);
          r2 = o2[t3], n2 = o2[t3];
        }
        r2 && n2 && t2.setConstantPatternPositions(r2, n2);
      }
      function ia(t2, e2, i2, a2, s2, o2, r2) {
        const n2 = t2.context.gl, l2 = "fill-pattern", h2 = i2.paint.get(l2), c2 = h2 && h2.constantOr(1), u5 = i2.getCrossfadeParameters();
        let d2, _2, p2, m2, f2;
        r2 ? (_2 = c2 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", d2 = n2.LINES) : (_2 = c2 ? "fillPattern" : "fill", d2 = n2.TRIANGLES);
        const g2 = h2.constantOr(null);
        for (const h3 of a2) {
          const a3 = e2.getTile(h3);
          if (c2 && !a3.patternsLoaded())
            continue;
          const v3 = a3.getBucket(i2);
          if (!v3)
            continue;
          const x2 = v3.programConfigurations.get(i2.id), y2 = t2.useProgram(_2, x2), b2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(h3);
          c2 && (t2.context.activeTexture.set(n2.TEXTURE0), a3.imageAtlasTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), x2.updatePaintBuffers(u5)), ea2(x2, l2, g2, a3, i2);
          const w2 = b2 ? h3 : null, T2 = t2.translatePosMatrix(w2 ? w2.posMatrix : h3.posMatrix, a3, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor"));
          if (r2) {
            m2 = v3.indexBuffer2, f2 = v3.segments2;
            const e3 = [n2.drawingBufferWidth, n2.drawingBufferHeight];
            p2 = _2 === "fillOutlinePattern" && c2 ? Pe(T2, t2, u5, a3, e3) : Ee(T2, e3);
          } else
            m2 = v3.indexBuffer, f2 = v3.segments, p2 = c2 ? Ie(T2, t2, u5, a3) : Te(T2);
          y2.draw(t2.context, d2, s2, t2.stencilModeForClipping(h3), o2, ji.disabled, p2, b2, i2.id, v3.layoutVertexBuffer, m2, f2, i2.paint, t2.transform.zoom, x2);
        }
      }
      function aa2(t2, e2, i2, a2, s2, o2, r2) {
        const n2 = t2.context, l2 = n2.gl, h2 = "fill-extrusion-pattern", c2 = i2.paint.get(h2), u5 = c2.constantOr(1), d2 = i2.getCrossfadeParameters(), _2 = i2.paint.get("fill-extrusion-opacity"), p2 = c2.constantOr(null);
        for (const c3 of a2) {
          const a3 = e2.getTile(c3), m2 = a3.getBucket(i2);
          if (!m2)
            continue;
          const f2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(c3), g2 = m2.programConfigurations.get(i2.id), v3 = t2.useProgram(u5 ? "fillExtrusionPattern" : "fillExtrusion", g2);
          u5 && (t2.context.activeTexture.set(l2.TEXTURE0), a3.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), g2.updatePaintBuffers(d2)), ea2(g2, h2, p2, a3, i2);
          const x2 = t2.translatePosMatrix(c3.posMatrix, a3, i2.paint.get("fill-extrusion-translate"), i2.paint.get("fill-extrusion-translate-anchor")), y2 = i2.paint.get("fill-extrusion-vertical-gradient"), b2 = u5 ? we(x2, t2, y2, _2, c3, d2, a3) : be(x2, t2, y2, _2);
          v3.draw(n2, n2.gl.TRIANGLES, s2, o2, r2, ji.backCCW, b2, f2, i2.id, m2.layoutVertexBuffer, m2.indexBuffer, m2.segments, i2.paint, t2.transform.zoom, g2, t2.style.map.terrain && m2.centroidVertexBuffer);
        }
      }
      function sa(t2, e2, i2, a2, s2, o2, r2) {
        const n2 = t2.context, l2 = n2.gl, h2 = i2.fbo;
        if (!h2)
          return;
        const c2 = t2.useProgram("hillshade"), u5 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(e2);
        n2.activeTexture.set(l2.TEXTURE0), l2.bindTexture(l2.TEXTURE_2D, h2.colorAttachment.get()), c2.draw(n2, l2.TRIANGLES, s2, o2, r2, ji.disabled, ((t3, e3, i3, a3) => {
          const s3 = i3.paint.get("hillshade-shadow-color"), o3 = i3.paint.get("hillshade-highlight-color"), r3 = i3.paint.get("hillshade-accent-color");
          let n3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          i3.paint.get("hillshade-illumination-anchor") === "viewport" && (n3 -= t3.transform.angle);
          const l3 = !t3.options.moving;
          return { u_matrix: a3 ? a3.posMatrix : t3.transform.calculatePosMatrix(e3.tileID.toUnwrapped(), l3), u_image: 0, u_latrange: Re(0, e3.tileID), u_light: [i3.paint.get("hillshade-exaggeration"), n3], u_shadow: s3, u_highlight: o3, u_accent: r3 };
        })(t2, i2, a2, u5 ? e2 : null), u5, a2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
      }
      function oa(t2, i2, a2, s2, o2, r2) {
        const n2 = t2.context, l2 = n2.gl, h2 = i2.dem;
        if (h2 && h2.data) {
          const { dim: c2, stride: u5 } = h2, d2 = h2.getPixels();
          if (n2.activeTexture.set(l2.TEXTURE1), n2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t2.getTileTexture(u5), i2.demTexture) {
            const t3 = i2.demTexture;
            t3.update(d2, { premultiply: false }), t3.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
          } else
            i2.demTexture = new b(n2, d2, l2.RGBA, { premultiply: false }), i2.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
          n2.activeTexture.set(l2.TEXTURE0);
          let _2 = i2.fbo;
          if (!_2) {
            const t3 = new b(n2, { width: c2, height: c2, data: null }, l2.RGBA);
            t3.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), _2 = i2.fbo = n2.createFramebuffer(c2, c2, true, false), _2.colorAttachment.set(t3.texture);
          }
          n2.bindFramebuffer.set(_2.framebuffer), n2.viewport.set([0, 0, c2, c2]), t2.useProgram("hillshadePrepare").draw(n2, l2.TRIANGLES, s2, o2, r2, ji.disabled, ((t3, i3) => {
            const a3 = i3.stride, s3 = e.H();
            return e.aP(s3, 0, e.X, -e.X, 0, 0, 1), e.J(s3, s3, [0, -e.X, 0]), { u_matrix: s3, u_image: 1, u_dimension: [a3, a3], u_zoom: t3.overscaledZ, u_unpack: i3.getUnpackVector() };
          })(i2.tileID, h2), null, a2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments), i2.needsHillshadePrepare = false;
        }
      }
      function ra(t2, i2, a2, s2, r2, n2) {
        const l2 = s2.paint.get("raster-fade-duration");
        if (!n2 && l2 > 0) {
          const s3 = o.now(), n3 = (s3 - t2.timeAdded) / l2, h2 = i2 ? (s3 - i2.timeAdded) / l2 : -1, c2 = a2.getSource(), u5 = r2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), d2 = !i2 || Math.abs(i2.tileID.overscaledZ - u5) > Math.abs(t2.tileID.overscaledZ - u5), _2 = d2 && t2.refreshedUponExpiration ? 1 : e.ac(d2 ? n3 : 1 - h2, 0, 1);
          return t2.refreshedUponExpiration && n3 >= 1 && (t2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - _2 } : { opacity: _2, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const na = new e.aM(1, 0, 0, 1), la = new e.aM(0, 1, 0, 1), ha = new e.aM(0, 0, 1, 1), ca3 = new e.aM(1, 0, 1, 1), ua = new e.aM(0, 1, 1, 1);
      function da2(t2, e2, i2, a2) {
        pa(t2, 0, e2 + i2 / 2, t2.transform.width, i2, a2);
      }
      function _a(t2, e2, i2, a2) {
        pa(t2, e2 - i2 / 2, 0, i2, t2.transform.height, a2);
      }
      function pa(t2, e2, i2, a2, s2, o2) {
        const r2 = t2.context, n2 = r2.gl;
        n2.enable(n2.SCISSOR_TEST), n2.scissor(e2 * t2.pixelRatio, i2 * t2.pixelRatio, a2 * t2.pixelRatio, s2 * t2.pixelRatio), r2.clear({ color: o2 }), n2.disable(n2.SCISSOR_TEST);
      }
      function ma(t2, i2, a2) {
        const s2 = t2.context, o2 = s2.gl, r2 = a2.posMatrix, n2 = t2.useProgram("debug"), l2 = Oi.disabled, h2 = Ui.disabled, c2 = t2.colorModeForRenderPass(), u5 = "$debug", d2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(a2);
        s2.activeTexture.set(o2.TEXTURE0);
        const _2 = i2.getTileByID(a2.key).latestRawTileData, p2 = Math.floor((_2 && _2.byteLength || 0) / 1024), m2 = i2.getTile(a2).tileSize, f2 = 512 / Math.min(m2, 512) * (a2.overscaledZ / t2.transform.zoom) * 0.5;
        let g2 = a2.canonical.toString();
        a2.overscaledZ !== a2.canonical.z && (g2 += ` => ${a2.overscaledZ}`), function(t3, e2) {
          t3.initDebugOverlayCanvas();
          const i3 = t3.debugOverlayCanvas, a3 = t3.context.gl, s3 = t3.debugOverlayCanvas.getContext("2d");
          s3.clearRect(0, 0, i3.width, i3.height), s3.shadowColor = "white", s3.shadowBlur = 2, s3.lineWidth = 1.5, s3.strokeStyle = "white", s3.textBaseline = "top", s3.font = "bold 36px Open Sans, sans-serif", s3.fillText(e2, 5, 5), s3.strokeText(e2, 5, 5), t3.debugOverlayTexture.update(i3), t3.debugOverlayTexture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
        }(t2, `${g2} ${p2}kB`), n2.draw(s2, o2.TRIANGLES, l2, h2, Fi.alphaBlended, ji.disabled, ze(r2, e.aM.transparent, f2), null, u5, t2.debugBuffer, t2.quadTriangleIndexBuffer, t2.debugSegments), n2.draw(s2, o2.LINE_STRIP, l2, h2, c2, ji.disabled, ze(r2, e.aM.red), d2, u5, t2.debugBuffer, t2.tileBorderIndexBuffer, t2.debugSegments);
      }
      function fa(t2, e2, i2) {
        const a2 = t2.context, s2 = a2.gl, o2 = t2.colorModeForRenderPass(), r2 = new Oi(s2.LEQUAL, Oi.ReadWrite, t2.depthRangeFor3D), n2 = t2.useProgram("terrain"), l2 = e2.getTerrainMesh();
        a2.bindFramebuffer.set(null), a2.viewport.set([0, 0, t2.width, t2.height]);
        for (const h2 of i2) {
          const i3 = t2.renderToTexture.getTexture(h2), c2 = e2.getTerrainData(h2.tileID);
          a2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, i3.texture);
          const u5 = t2.transform.calculatePosMatrix(h2.tileID.toUnwrapped()), d2 = e2.getMeshFrameDelta(t2.transform.zoom), _2 = t2.transform.calculateFogMatrix(h2.tileID.toUnwrapped()), p2 = ge(u5, d2, _2, t2.style.sky, t2.transform.pitch);
          n2.draw(a2, s2.TRIANGLES, r2, Ui.disabled, o2, ji.backCCW, p2, c2, "terrain", l2.vertexBuffer, l2.indexBuffer, l2.segments);
        }
      }

      class ga {
        constructor(t2, e2, i2) {
          this.vertexBuffer = t2, this.indexBuffer = e2, this.segments = i2;
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
        }
      }

      class va {
        constructor(t2, i2) {
          this.context = new Bi(t2), this.transform = i2, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: e.an(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = ut.maxUnderzooming + ut.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new he;
        }
        resize(t2, e2, i2) {
          if (this.width = Math.floor(t2 * i2), this.height = Math.floor(e2 * i2), this.pixelRatio = i2, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const t3 of this.style._order)
              this.style._layers[t3].resize();
        }
        setup() {
          const t2 = this.context, i2 = new e.aX;
          i2.emplaceBack(0, 0), i2.emplaceBack(e.X, 0), i2.emplaceBack(0, e.X), i2.emplaceBack(e.X, e.X), this.tileExtentBuffer = t2.createVertexBuffer(i2, _e.members), this.tileExtentSegments = e.a0.simpleSegment(0, 0, 4, 2);
          const a2 = new e.aX;
          a2.emplaceBack(0, 0), a2.emplaceBack(e.X, 0), a2.emplaceBack(0, e.X), a2.emplaceBack(e.X, e.X), this.debugBuffer = t2.createVertexBuffer(a2, _e.members), this.debugSegments = e.a0.simpleSegment(0, 0, 4, 5);
          const s2 = new e.$;
          s2.emplaceBack(0, 0, 0, 0), s2.emplaceBack(e.X, 0, e.X, 0), s2.emplaceBack(0, e.X, 0, e.X), s2.emplaceBack(e.X, e.X, e.X, e.X), this.rasterBoundsBuffer = t2.createVertexBuffer(s2, Y.members), this.rasterBoundsSegments = e.a0.simpleSegment(0, 0, 4, 2);
          const o2 = new e.aX;
          o2.emplaceBack(0, 0), o2.emplaceBack(1, 0), o2.emplaceBack(0, 1), o2.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(o2, _e.members), this.viewportSegments = e.a0.simpleSegment(0, 0, 4, 2);
          const r2 = new e.aZ;
          r2.emplaceBack(0), r2.emplaceBack(1), r2.emplaceBack(3), r2.emplaceBack(2), r2.emplaceBack(0), this.tileBorderIndexBuffer = t2.createIndexBuffer(r2);
          const n2 = new e.aY;
          n2.emplaceBack(0, 1, 2), n2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(n2);
          const l2 = this.context.gl;
          this.stencilClearMode = new Ui({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO);
        }
        clearStencil() {
          const t2 = this.context, i2 = t2.gl;
          this.nextStencilID = 1, this.currentStencilSource = undefined;
          const a2 = e.H();
          e.aP(a2, 0, this.width, this.height, 0, 0, 1), e.K(a2, a2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(t2, i2.TRIANGLES, Oi.disabled, this.stencilClearMode, Fi.disabled, ji.disabled, De(a2), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(t2, e2) {
          if (this.currentStencilSource === t2.source || !t2.isTileClipped() || !e2 || !e2.length)
            return;
          this.currentStencilSource = t2.source;
          const i2 = this.context, a2 = i2.gl;
          this.nextStencilID + e2.length > 256 && this.clearStencil(), i2.setColorMode(Fi.disabled), i2.setDepthMode(Oi.disabled);
          const s2 = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const t3 of e2) {
            const e3 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++, o2 = this.style.map.terrain && this.style.map.terrain.getTerrainData(t3);
            s2.draw(i2, a2.TRIANGLES, Oi.disabled, new Ui({ func: a2.ALWAYS, mask: 0 }, e3, 255, a2.KEEP, a2.KEEP, a2.REPLACE), Fi.disabled, ji.disabled, De(t3.posMatrix), o2, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = undefined, this.nextStencilID + 1 > 256 && this.clearStencil();
          const t2 = this.nextStencilID++, e2 = this.context.gl;
          return new Ui({ func: e2.NOTEQUAL, mask: 255 }, t2, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
        }
        stencilModeForClipping(t2) {
          const e2 = this.context.gl;
          return new Ui({ func: e2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, e2.KEEP, e2.KEEP, e2.REPLACE);
        }
        stencilConfigForOverlap(t2) {
          const e2 = this.context.gl, i2 = t2.sort((t3, e3) => e3.overscaledZ - t3.overscaledZ), a2 = i2[i2.length - 1].overscaledZ, s2 = i2[0].overscaledZ - a2 + 1;
          if (s2 > 1) {
            this.currentStencilSource = undefined, this.nextStencilID + s2 > 256 && this.clearStencil();
            const t3 = {};
            for (let i3 = 0;i3 < s2; i3++)
              t3[i3 + a2] = new Ui({ func: e2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
            return this.nextStencilID += s2, [t3, i2];
          }
          return [{ [a2]: Ui.disabled }, i2];
        }
        colorModeForRenderPass() {
          const t2 = this.context.gl;
          if (this._showOverdrawInspector) {
            const i2 = 1 / 8;
            return new Fi([t2.CONSTANT_COLOR, t2.ONE], new e.aM(i2, i2, i2, 0), [true, true, true, true]);
          }
          return this.renderPass === "opaque" ? Fi.unblended : Fi.alphaBlended;
        }
        depthModeForSublayer(t2, e2, i2) {
          if (!this.opaquePassEnabledForLayer())
            return Oi.disabled;
          const a2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
          return new Oi(i2 || this.context.gl.LEQUAL, e2, [a2, a2]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(t2, i2) {
          this.style = t2, this.options = i2, this.lineAtlas = t2.lineAtlas, this.imageManager = t2.imageManager, this.glyphManager = t2.glyphManager, this.symbolFadeChange = t2.placement.symbolFadeChange(o.now()), this.imageManager.beginFrame();
          const a2 = this.style._order, s2 = this.style.sourceCaches, r2 = {}, n2 = {}, l2 = {};
          for (const t3 in s2) {
            const e2 = s2[t3];
            e2.used && e2.prepare(this.context), r2[t3] = e2.getVisibleCoordinates(), n2[t3] = r2[t3].slice().reverse(), l2[t3] = e2.getVisibleCoordinates(true).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let t3 = 0;t3 < a2.length; t3++)
            if (this.style._layers[a2[t3]].is3D()) {
              this.opaquePassCutoff = t3;
              break;
            }
          this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
          for (const t3 of a2) {
            const e2 = this.style._layers[t3];
            if (!e2.hasOffscreenPass() || e2.isHidden(this.transform.zoom))
              continue;
            const i3 = n2[e2.source];
            (e2.type === "custom" || i3.length) && this.renderLayer(this, s2[e2.source], e2, i3);
          }
          if (this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? e.aM.black : e.aM.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(t3, i3) {
            const a3 = t3.context, s3 = a3.gl, o2 = ((t4, e2, i4) => ({ u_sky_color: t4.properties.get("sky-color"), u_horizon_color: t4.properties.get("horizon-color"), u_horizon: (e2.height / 2 + e2.getHorizon()) * i4, u_sky_horizon_blend: t4.properties.get("sky-horizon-blend") * e2.height / 2 * i4 }))(i3, t3.style.map.transform, t3.pixelRatio), r3 = new Oi(s3.LEQUAL, Oi.ReadWrite, [0, 1]), n3 = Ui.disabled, l3 = t3.colorModeForRenderPass(), h2 = t3.useProgram("sky");
            if (!i3.mesh) {
              const t4 = new e.aX;
              t4.emplaceBack(-1, -1), t4.emplaceBack(1, -1), t4.emplaceBack(1, 1), t4.emplaceBack(-1, 1);
              const s4 = new e.aY;
              s4.emplaceBack(0, 1, 2), s4.emplaceBack(0, 2, 3), i3.mesh = new ga(a3.createVertexBuffer(t4, _e.members), a3.createIndexBuffer(s4), e.a0.simpleSegment(0, 0, t4.length, s4.length));
            }
            h2.draw(a3, s3.TRIANGLES, r3, n3, l3, ji.disabled, o2, undefined, "sky", i3.mesh.vertexBuffer, i3.mesh.indexBuffer, i3.mesh.segments);
          }(this, this.style.sky), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (t2._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
            for (this.renderPass = "opaque", this.currentLayer = a2.length - 1;this.currentLayer >= 0; this.currentLayer--) {
              const t3 = this.style._layers[a2[this.currentLayer]], e2 = s2[t3.source], i3 = r2[t3.source];
              this._renderTileClippingMasks(t3, i3), this.renderLayer(this, e2, t3, i3);
            }
          for (this.renderPass = "translucent", this.currentLayer = 0;this.currentLayer < a2.length; this.currentLayer++) {
            const t3 = this.style._layers[a2[this.currentLayer]], e2 = s2[t3.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(t3))
              continue;
            const i3 = (t3.type === "symbol" ? l2 : n2)[t3.source];
            this._renderTileClippingMasks(t3, r2[t3.source]), this.renderLayer(this, e2, t3, i3);
          }
          if (this.options.showTileBoundaries) {
            const t3 = function(t4, e2) {
              let i3 = null;
              const a3 = Object.values(t4._layers).flatMap((i4) => i4.source && !i4.isHidden(e2) ? [t4.sourceCaches[i4.source]] : []), s3 = a3.filter((t5) => t5.getSource().type === "vector"), o2 = a3.filter((t5) => t5.getSource().type !== "vector"), r3 = (t5) => {
                (!i3 || i3.getSource().maxzoom < t5.getSource().maxzoom) && (i3 = t5);
              };
              return s3.forEach((t5) => r3(t5)), i3 || o2.forEach((t5) => r3(t5)), i3;
            }(this.style, this.transform.zoom);
            t3 && function(t4, e2, i3) {
              for (let a3 = 0;a3 < i3.length; a3++)
                ma(t4, e2, i3[a3]);
            }(this, t3, t3.getVisibleCoordinates());
          }
          this.options.showPadding && function(t3) {
            const e2 = t3.transform.padding;
            da2(t3, t3.transform.height - (e2.top || 0), 3, na), da2(t3, e2.bottom || 0, 3, la), _a(t3, e2.left || 0, 3, ha), _a(t3, t3.transform.width - (e2.right || 0), 3, ca3);
            const i3 = t3.transform.centerPoint;
            (function(t4, e3, i4, a3) {
              pa(t4, e3 - 1, i4 - 10, 2, 20, a3), pa(t4, e3 - 10, i4 - 1, 20, 2, a3);
            })(t3, i3.x, t3.transform.height - i3.y, ua);
          }(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(t2) {
          if (!this.style || !this.style.map || !this.style.map.terrain)
            return;
          const i2 = this.terrainFacilitator.matrix, a2 = this.transform.modelViewProjectionMatrix;
          let s2 = this.terrainFacilitator.dirty;
          s2 || (s2 = t2 ? !e.a_(i2, a2) : !e.a$(i2, a2)), s2 || (s2 = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), s2 && (e.b0(i2, a2), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(t3, i3) {
            const a3 = t3.context, s3 = a3.gl, o2 = Fi.unblended, r2 = new Oi(s3.LEQUAL, Oi.ReadWrite, [0, 1]), n2 = i3.getTerrainMesh(), l2 = i3.sourceCache.getRenderableTiles(), h2 = t3.useProgram("terrainDepth");
            a3.bindFramebuffer.set(i3.getFramebuffer("depth").framebuffer), a3.viewport.set([0, 0, t3.width / devicePixelRatio, t3.height / devicePixelRatio]), a3.clear({ color: e.aM.transparent, depth: 1 });
            for (const e2 of l2) {
              const l3 = i3.getTerrainData(e2.tileID), c2 = { u_matrix: t3.transform.calculatePosMatrix(e2.tileID.toUnwrapped()), u_ele_delta: i3.getMeshFrameDelta(t3.transform.zoom) };
              h2.draw(a3, s3.TRIANGLES, r2, Ui.disabled, o2, ji.backCCW, c2, l3, "terrain", n2.vertexBuffer, n2.indexBuffer, n2.segments);
            }
            a3.bindFramebuffer.set(null), a3.viewport.set([0, 0, t3.width, t3.height]);
          }(this, this.style.map.terrain), function(t3, i3) {
            const a3 = t3.context, s3 = a3.gl, o2 = Fi.unblended, r2 = new Oi(s3.LEQUAL, Oi.ReadWrite, [0, 1]), n2 = i3.getTerrainMesh(), l2 = i3.getCoordsTexture(), h2 = i3.sourceCache.getRenderableTiles(), c2 = t3.useProgram("terrainCoords");
            a3.bindFramebuffer.set(i3.getFramebuffer("coords").framebuffer), a3.viewport.set([0, 0, t3.width / devicePixelRatio, t3.height / devicePixelRatio]), a3.clear({ color: e.aM.transparent, depth: 1 }), i3.coordsIndex = [];
            for (const e2 of h2) {
              const h3 = i3.getTerrainData(e2.tileID);
              a3.activeTexture.set(s3.TEXTURE0), s3.bindTexture(s3.TEXTURE_2D, l2.texture);
              const u5 = { u_matrix: t3.transform.calculatePosMatrix(e2.tileID.toUnwrapped()), u_terrain_coords_id: (255 - i3.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i3.getMeshFrameDelta(t3.transform.zoom) };
              c2.draw(a3, s3.TRIANGLES, r2, Ui.disabled, o2, ji.backCCW, u5, h3, "terrain", n2.vertexBuffer, n2.indexBuffer, n2.segments), i3.coordsIndex.push(e2.tileID.key);
            }
            a3.bindFramebuffer.set(null), a3.viewport.set([0, 0, t3.width, t3.height]);
          }(this, this.style.map.terrain));
        }
        renderLayer(t2, i2, a2, s2) {
          if (!a2.isHidden(this.transform.zoom) && (a2.type === "background" || a2.type === "custom" || (s2 || []).length))
            switch (this.id = a2.id, a2.type) {
              case "symbol":
                (function(t3, i3, a3, s3, o2) {
                  if (t3.renderPass !== "translucent")
                    return;
                  const r2 = Ui.disabled, n2 = t3.colorModeForRenderPass();
                  (a3._unevaluatedLayout.hasValue("text-variable-anchor") || a3._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(t4, i4, a4, s4, o3, r3, n3, l2, h2) {
                    const c2 = i4.transform, u5 = ie(), d2 = o3 === "map", _2 = r3 === "map";
                    for (const o4 of t4) {
                      const t5 = s4.getTile(o4), r4 = t5.getBucket(a4);
                      if (!r4 || !r4.text || !r4.text.segments.get().length)
                        continue;
                      const p2 = e.ag(r4.textSizeData, c2.zoom), m2 = Bt(t5, 1, i4.transform.zoom), f2 = gt(o4.posMatrix, _2, d2, i4.transform, m2), g2 = a4.layout.get("icon-text-fit") !== "none" && r4.hasIconData();
                      if (p2) {
                        const e2 = Math.pow(2, c2.zoom - t5.tileID.overscaledZ), a5 = i4.style.map.terrain ? (t6, e3) => i4.style.map.terrain.getElevation(o4, t6, e3) : null, s5 = u5.translatePosition(c2, t5, n3, l2);
                        Wi(r4, d2, _2, h2, c2, f2, o4.posMatrix, e2, p2, g2, u5, s5, o4.toUnwrapped(), a5);
                      }
                    }
                  }(s3, t3, a3, i3, a3.layout.get("text-rotation-alignment"), a3.layout.get("text-pitch-alignment"), a3.paint.get("text-translate"), a3.paint.get("text-translate-anchor"), o2), a3.paint.get("icon-opacity").constantOr(1) !== 0 && Xi(t3, i3, a3, s3, false, a3.paint.get("icon-translate"), a3.paint.get("icon-translate-anchor"), a3.layout.get("icon-rotation-alignment"), a3.layout.get("icon-pitch-alignment"), a3.layout.get("icon-keep-upright"), r2, n2), a3.paint.get("text-opacity").constantOr(1) !== 0 && Xi(t3, i3, a3, s3, true, a3.paint.get("text-translate"), a3.paint.get("text-translate-anchor"), a3.layout.get("text-rotation-alignment"), a3.layout.get("text-pitch-alignment"), a3.layout.get("text-keep-upright"), r2, n2), i3.map.showCollisionBoxes && (qi(t3, i3, a3, s3, true), qi(t3, i3, a3, s3, false));
                })(t2, i2, a2, s2, this.style.placement.variableOffsets);
                break;
              case "circle":
                (function(t3, i3, a3, s3) {
                  if (t3.renderPass !== "translucent")
                    return;
                  const o2 = a3.paint.get("circle-opacity"), r2 = a3.paint.get("circle-stroke-width"), n2 = a3.paint.get("circle-stroke-opacity"), l2 = !a3.layout.get("circle-sort-key").isConstant();
                  if (o2.constantOr(1) === 0 && (r2.constantOr(1) === 0 || n2.constantOr(1) === 0))
                    return;
                  const h2 = t3.context, c2 = h2.gl, u5 = t3.depthModeForSublayer(0, Oi.ReadOnly), d2 = Ui.disabled, _2 = t3.colorModeForRenderPass(), p2 = [];
                  for (let o3 = 0;o3 < s3.length; o3++) {
                    const r3 = s3[o3], n3 = i3.getTile(r3), h3 = n3.getBucket(a3);
                    if (!h3)
                      continue;
                    const c3 = h3.programConfigurations.get(a3.id), u6 = t3.useProgram("circle", c3), d3 = h3.layoutVertexBuffer, _3 = h3.indexBuffer, m2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(r3), f2 = { programConfiguration: c3, program: u6, layoutVertexBuffer: d3, indexBuffer: _3, uniformValues: Ce(t3, r3, n3, a3), terrainData: m2 };
                    if (l2) {
                      const t4 = h3.segments.get();
                      for (const i4 of t4)
                        p2.push({ segments: new e.a0([i4]), sortKey: i4.sortKey, state: f2 });
                    } else
                      p2.push({ segments: h3.segments, sortKey: 0, state: f2 });
                  }
                  l2 && p2.sort((t4, e2) => t4.sortKey - e2.sortKey);
                  for (const e2 of p2) {
                    const { programConfiguration: i4, program: s4, layoutVertexBuffer: o3, indexBuffer: r3, uniformValues: n3, terrainData: l3 } = e2.state;
                    s4.draw(h2, c2.TRIANGLES, u5, d2, _2, ji.disabled, n3, l3, a3.id, o3, r3, e2.segments, a3.paint, t3.transform.zoom, i4);
                  }
                })(t2, i2, a2, s2);
                break;
              case "heatmap":
                (function(t3, i3, a3, s3) {
                  if (a3.paint.get("heatmap-opacity") === 0)
                    return;
                  const o2 = t3.context;
                  if (t3.style.map.terrain) {
                    for (const e2 of s3) {
                      const s4 = i3.getTile(e2);
                      i3.hasRenderableParent(e2) || (t3.renderPass === "offscreen" ? Ji(t3, s4, a3, e2) : t3.renderPass === "translucent" && Yi(t3, a3, e2));
                    }
                    o2.viewport.set([0, 0, t3.width, t3.height]);
                  } else
                    t3.renderPass === "offscreen" ? function(t4, i4, a4, s4) {
                      const o3 = t4.context, r2 = o3.gl, n2 = Ui.disabled, l2 = new Fi([r2.ONE, r2.ONE], e.aM.transparent, [true, true, true, true]);
                      (function(t5, i5, a5) {
                        const s5 = t5.gl;
                        t5.activeTexture.set(s5.TEXTURE1), t5.viewport.set([0, 0, i5.width / 4, i5.height / 4]);
                        let o4 = a5.heatmapFbos.get(e.aU);
                        o4 ? (s5.bindTexture(s5.TEXTURE_2D, o4.colorAttachment.get()), t5.bindFramebuffer.set(o4.framebuffer)) : (o4 = Qi(t5, i5.width / 4, i5.height / 4), a5.heatmapFbos.set(e.aU, o4));
                      })(o3, t4, a4), o3.clear({ color: e.aM.transparent });
                      for (let e2 = 0;e2 < s4.length; e2++) {
                        const h2 = s4[e2];
                        if (i4.hasRenderableParent(h2))
                          continue;
                        const c2 = i4.getTile(h2), u5 = c2.getBucket(a4);
                        if (!u5)
                          continue;
                        const d2 = u5.programConfigurations.get(a4.id), _2 = t4.useProgram("heatmap", d2), { zoom: p2 } = t4.transform;
                        _2.draw(o3, r2.TRIANGLES, Oi.disabled, n2, l2, ji.disabled, Me(h2.posMatrix, c2, p2, a4.paint.get("heatmap-intensity")), null, a4.id, u5.layoutVertexBuffer, u5.indexBuffer, u5.segments, a4.paint, t4.transform.zoom, d2);
                      }
                      o3.viewport.set([0, 0, t4.width, t4.height]);
                    }(t3, i3, a3, s3) : t3.renderPass === "translucent" && function(t4, i4) {
                      const a4 = t4.context, s4 = a4.gl;
                      a4.setColorMode(t4.colorModeForRenderPass());
                      const o3 = i4.heatmapFbos.get(e.aU);
                      o3 && (a4.activeTexture.set(s4.TEXTURE0), s4.bindTexture(s4.TEXTURE_2D, o3.colorAttachment.get()), a4.activeTexture.set(s4.TEXTURE1), ta(a4, i4).bind(s4.LINEAR, s4.CLAMP_TO_EDGE), t4.useProgram("heatmapTexture").draw(a4, s4.TRIANGLES, Oi.disabled, Ui.disabled, t4.colorModeForRenderPass(), ji.disabled, Ae(t4, i4, 0, 1), null, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments, i4.paint, t4.transform.zoom));
                    }(t3, a3);
                })(t2, i2, a2, s2);
                break;
              case "line":
                (function(t3, i3, a3, s3) {
                  if (t3.renderPass !== "translucent")
                    return;
                  const o2 = a3.paint.get("line-opacity"), r2 = a3.paint.get("line-width");
                  if (o2.constantOr(1) === 0 || r2.constantOr(1) === 0)
                    return;
                  const n2 = t3.depthModeForSublayer(0, Oi.ReadOnly), l2 = t3.colorModeForRenderPass(), h2 = a3.paint.get("line-dasharray"), c2 = a3.paint.get("line-pattern"), u5 = c2.constantOr(1), d2 = a3.paint.get("line-gradient"), _2 = a3.getCrossfadeParameters(), p2 = u5 ? "linePattern" : h2 ? "lineSDF" : d2 ? "lineGradient" : "line", m2 = t3.context, f2 = m2.gl;
                  let g2 = true;
                  for (const o3 of s3) {
                    const s4 = i3.getTile(o3);
                    if (u5 && !s4.patternsLoaded())
                      continue;
                    const r3 = s4.getBucket(a3);
                    if (!r3)
                      continue;
                    const v3 = r3.programConfigurations.get(a3.id), x2 = t3.context.program.get(), y2 = t3.useProgram(p2, v3), w2 = g2 || y2.program !== x2, T2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(o3), I2 = c2.constantOr(null);
                    if (I2 && s4.imageAtlas) {
                      const t4 = s4.imageAtlas, e2 = t4.patternPositions[I2.to.toString()], i4 = t4.patternPositions[I2.from.toString()];
                      e2 && i4 && v3.setConstantPatternPositions(e2, i4);
                    }
                    const E2 = T2 ? o3 : null, P2 = u5 ? Fe(t3, s4, a3, _2, E2) : h2 ? Be(t3, s4, a3, h2, _2, E2) : d2 ? Le(t3, s4, a3, r3.lineClipsArray.length, E2) : ke(t3, s4, a3, E2);
                    if (u5)
                      m2.activeTexture.set(f2.TEXTURE0), s4.imageAtlasTexture.bind(f2.LINEAR, f2.CLAMP_TO_EDGE), v3.updatePaintBuffers(_2);
                    else if (h2 && (w2 || t3.lineAtlas.dirty))
                      m2.activeTexture.set(f2.TEXTURE0), t3.lineAtlas.bind(m2);
                    else if (d2) {
                      const s5 = r3.gradients[a3.id];
                      let n3 = s5.texture;
                      if (a3.gradientVersion !== s5.version) {
                        let l3 = 256;
                        if (a3.stepInterpolant) {
                          const a4 = i3.getSource().maxzoom, s6 = o3.canonical.z === a4 ? Math.ceil(1 << t3.transform.maxZoom - o3.canonical.z) : 1;
                          l3 = e.ac(e.aV(r3.maxLineLength / e.X * 1024 * s6), 256, m2.maxTextureSize);
                        }
                        s5.gradient = e.aW({ expression: a3.gradientExpression(), evaluationKey: "lineProgress", resolution: l3, image: s5.gradient || undefined, clips: r3.lineClipsArray }), s5.texture ? s5.texture.update(s5.gradient) : s5.texture = new b(m2, s5.gradient, f2.RGBA), s5.version = a3.gradientVersion, n3 = s5.texture;
                      }
                      m2.activeTexture.set(f2.TEXTURE0), n3.bind(a3.stepInterpolant ? f2.NEAREST : f2.LINEAR, f2.CLAMP_TO_EDGE);
                    }
                    y2.draw(m2, f2.TRIANGLES, n2, t3.stencilModeForClipping(o3), l2, ji.disabled, P2, T2, a3.id, r3.layoutVertexBuffer, r3.indexBuffer, r3.segments, a3.paint, t3.transform.zoom, v3, r3.layoutVertexBuffer2), g2 = false;
                  }
                })(t2, i2, a2, s2);
                break;
              case "fill":
                (function(t3, i3, a3, s3) {
                  const o2 = a3.paint.get("fill-color"), r2 = a3.paint.get("fill-opacity");
                  if (r2.constantOr(1) === 0)
                    return;
                  const n2 = t3.colorModeForRenderPass(), l2 = a3.paint.get("fill-pattern"), h2 = t3.opaquePassEnabledForLayer() && !l2.constantOr(1) && o2.constantOr(e.aM.transparent).a === 1 && r2.constantOr(0) === 1 ? "opaque" : "translucent";
                  if (t3.renderPass === h2) {
                    const e2 = t3.depthModeForSublayer(1, t3.renderPass === "opaque" ? Oi.ReadWrite : Oi.ReadOnly);
                    ia(t3, i3, a3, s3, e2, n2, false);
                  }
                  if (t3.renderPass === "translucent" && a3.paint.get("fill-antialias")) {
                    const e2 = t3.depthModeForSublayer(a3.getPaintProperty("fill-outline-color") ? 2 : 0, Oi.ReadOnly);
                    ia(t3, i3, a3, s3, e2, n2, true);
                  }
                })(t2, i2, a2, s2);
                break;
              case "fill-extrusion":
                (function(t3, e2, i3, a3) {
                  const s3 = i3.paint.get("fill-extrusion-opacity");
                  if (s3 !== 0 && t3.renderPass === "translucent") {
                    const o2 = new Oi(t3.context.gl.LEQUAL, Oi.ReadWrite, t3.depthRangeFor3D);
                    if (s3 !== 1 || i3.paint.get("fill-extrusion-pattern").constantOr(1))
                      aa2(t3, e2, i3, a3, o2, Ui.disabled, Fi.disabled), aa2(t3, e2, i3, a3, o2, t3.stencilModeFor3D(), t3.colorModeForRenderPass());
                    else {
                      const s4 = t3.colorModeForRenderPass();
                      aa2(t3, e2, i3, a3, o2, Ui.disabled, s4);
                    }
                  }
                })(t2, i2, a2, s2);
                break;
              case "hillshade":
                (function(t3, e2, i3, a3) {
                  if (t3.renderPass !== "offscreen" && t3.renderPass !== "translucent")
                    return;
                  const s3 = t3.context, o2 = t3.depthModeForSublayer(0, Oi.ReadOnly), r2 = t3.colorModeForRenderPass(), [n2, l2] = t3.renderPass === "translucent" ? t3.stencilConfigForOverlap(a3) : [{}, a3];
                  for (const a4 of l2) {
                    const s4 = e2.getTile(a4);
                    s4.needsHillshadePrepare !== undefined && s4.needsHillshadePrepare && t3.renderPass === "offscreen" ? oa(t3, s4, i3, o2, Ui.disabled, r2) : t3.renderPass === "translucent" && sa(t3, a4, s4, i3, o2, n2[a4.overscaledZ], r2);
                  }
                  s3.viewport.set([0, 0, t3.width, t3.height]);
                })(t2, i2, a2, s2);
                break;
              case "raster":
                (function(t3, e2, i3, a3) {
                  if (t3.renderPass !== "translucent")
                    return;
                  if (i3.paint.get("raster-opacity") === 0)
                    return;
                  if (!a3.length)
                    return;
                  const s3 = t3.context, o2 = s3.gl, r2 = e2.getSource(), n2 = t3.useProgram("raster"), l2 = t3.colorModeForRenderPass(), [h2, c2] = r2 instanceof Q ? [{}, a3] : t3.stencilConfigForOverlap(a3), u5 = c2[c2.length - 1].overscaledZ, d2 = !t3.options.moving;
                  for (const a4 of c2) {
                    const c3 = t3.depthModeForSublayer(a4.overscaledZ - u5, i3.paint.get("raster-opacity") === 1 ? Oi.ReadWrite : Oi.ReadOnly, o2.LESS), _2 = e2.getTile(a4);
                    _2.registerFadeDuration(i3.paint.get("raster-fade-duration"));
                    const p2 = e2.findLoadedParent(a4, 0), m2 = e2.findLoadedSibling(a4), f2 = ra(_2, p2 || m2 || null, e2, i3, t3.transform, t3.style.map.terrain);
                    let g2, v3;
                    const x2 = i3.paint.get("raster-resampling") === "nearest" ? o2.NEAREST : o2.LINEAR;
                    s3.activeTexture.set(o2.TEXTURE0), _2.texture.bind(x2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), s3.activeTexture.set(o2.TEXTURE1), p2 ? (p2.texture.bind(x2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), g2 = Math.pow(2, p2.tileID.overscaledZ - _2.tileID.overscaledZ), v3 = [_2.tileID.canonical.x * g2 % 1, _2.tileID.canonical.y * g2 % 1]) : _2.texture.bind(x2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), _2.texture.useMipmap && s3.extTextureFilterAnisotropic && t3.transform.pitch > 20 && o2.texParameterf(o2.TEXTURE_2D, s3.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s3.extTextureFilterAnisotropicMax);
                    const y2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(a4), b2 = y2 ? a4 : null, w2 = b2 ? b2.posMatrix : t3.transform.calculatePosMatrix(a4.toUnwrapped(), d2), T2 = Ue(w2, v3 || [0, 0], g2 || 1, f2, i3);
                    r2 instanceof Q ? n2.draw(s3, o2.TRIANGLES, c3, Ui.disabled, l2, ji.disabled, T2, y2, i3.id, r2.boundsBuffer, t3.quadTriangleIndexBuffer, r2.boundsSegments) : n2.draw(s3, o2.TRIANGLES, c3, h2[a4.overscaledZ], l2, ji.disabled, T2, y2, i3.id, t3.rasterBoundsBuffer, t3.quadTriangleIndexBuffer, t3.rasterBoundsSegments);
                  }
                })(t2, i2, a2, s2);
                break;
              case "background":
                (function(t3, e2, i3, a3) {
                  const s3 = i3.paint.get("background-color"), o2 = i3.paint.get("background-opacity");
                  if (o2 === 0)
                    return;
                  const r2 = t3.context, n2 = r2.gl, l2 = t3.transform, h2 = l2.tileSize, c2 = i3.paint.get("background-pattern");
                  if (t3.isPatternMissing(c2))
                    return;
                  const u5 = !c2 && s3.a === 1 && o2 === 1 && t3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                  if (t3.renderPass !== u5)
                    return;
                  const d2 = Ui.disabled, _2 = t3.depthModeForSublayer(0, u5 === "opaque" ? Oi.ReadWrite : Oi.ReadOnly), p2 = t3.colorModeForRenderPass(), m2 = t3.useProgram(c2 ? "backgroundPattern" : "background"), f2 = a3 || l2.coveringTiles({ tileSize: h2, terrain: t3.style.map.terrain });
                  c2 && (r2.activeTexture.set(n2.TEXTURE0), t3.imageManager.bind(t3.context));
                  const g2 = i3.getCrossfadeParameters();
                  for (const e3 of f2) {
                    const l3 = a3 ? e3.posMatrix : t3.transform.calculatePosMatrix(e3.toUnwrapped()), u6 = c2 ? He(l3, o2, t3, c2, { tileID: e3, tileSize: h2 }, g2) : Ge(l3, o2, s3), f3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(e3);
                    m2.draw(r2, n2.TRIANGLES, _2, d2, p2, ji.disabled, u6, f3, i3.id, t3.tileExtentBuffer, t3.quadTriangleIndexBuffer, t3.tileExtentSegments);
                  }
                })(t2, 0, a2, s2);
                break;
              case "custom":
                (function(t3, e2, i3) {
                  const a3 = t3.context, s3 = i3.implementation;
                  if (t3.renderPass === "offscreen") {
                    const e3 = s3.prerender;
                    e3 && (t3.setCustomLayerDefaults(), a3.setColorMode(t3.colorModeForRenderPass()), e3.call(s3, a3.gl, t3.transform.customLayerMatrix()), a3.setDirty(), t3.setBaseState());
                  } else if (t3.renderPass === "translucent") {
                    t3.setCustomLayerDefaults(), a3.setColorMode(t3.colorModeForRenderPass()), a3.setStencilMode(Ui.disabled);
                    const e3 = s3.renderingMode === "3d" ? new Oi(t3.context.gl.LEQUAL, Oi.ReadWrite, t3.depthRangeFor3D) : t3.depthModeForSublayer(0, Oi.ReadOnly);
                    a3.setDepthMode(e3), s3.render(a3.gl, t3.transform.customLayerMatrix(), { farZ: t3.transform.farZ, nearZ: t3.transform.nearZ, fov: t3.transform._fov, modelViewProjectionMatrix: t3.transform.modelViewProjectionMatrix, projectionMatrix: t3.transform.projectionMatrix }), a3.setDirty(), t3.setBaseState(), a3.bindFramebuffer.set(null);
                  }
                })(t2, 0, a2);
            }
        }
        translatePosMatrix(t2, i2, a2, s2, o2) {
          if (!a2[0] && !a2[1])
            return t2;
          const r2 = o2 ? s2 === "map" ? this.transform.angle : 0 : s2 === "viewport" ? -this.transform.angle : 0;
          if (r2) {
            const t3 = Math.sin(r2), e2 = Math.cos(r2);
            a2 = [a2[0] * e2 - a2[1] * t3, a2[0] * t3 + a2[1] * e2];
          }
          const n2 = [o2 ? a2[0] : Bt(i2, a2[0], this.transform.zoom), o2 ? a2[1] : Bt(i2, a2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
          return e.J(l2, t2, n2), l2;
        }
        saveTileTexture(t2) {
          const e2 = this._tileTextures[t2.size[0]];
          e2 ? e2.push(t2) : this._tileTextures[t2.size[0]] = [t2];
        }
        getTileTexture(t2) {
          const e2 = this._tileTextures[t2];
          return e2 && e2.length > 0 ? e2.pop() : null;
        }
        isPatternMissing(t2) {
          if (!t2)
            return false;
          if (!t2.from || !t2.to)
            return true;
          const e2 = this.imageManager.getPattern(t2.from.toString()), i2 = this.imageManager.getPattern(t2.to.toString());
          return !e2 || !i2;
        }
        useProgram(t2, e2) {
          this.cache = this.cache || {};
          const i2 = t2 + (e2 ? e2.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
          return this.cache[i2] || (this.cache[i2] = new xe(this.context, pe[t2], e2, We[t2], this._showOverdrawInspector, this.style.map.terrain)), this.cache[i2];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const t2 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t2.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new b(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: t2, drawingBufferHeight: e2 } = this.context.gl;
          return this.width !== t2 || this.height !== e2;
        }
      }

      class xa {
        constructor(t2, e2) {
          this.points = t2, this.planes = e2;
        }
        static fromInvProjectionMatrix(t2, i2, a2) {
          const s2 = Math.pow(2, a2), o2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((a3) => {
            const o3 = 1 / (a3 = e.af([], a3, t2))[3] / i2 * s2;
            return e.b1(a3, a3, [o3, o3, 1 / a3[3], o3]);
          }), r2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
            const e2 = function(t4, e3) {
              var i4 = e3[0], a4 = e3[1], s4 = e3[2], o3 = i4 * i4 + a4 * a4 + s4 * s4;
              return o3 > 0 && (o3 = 1 / Math.sqrt(o3)), t4[0] = e3[0] * o3, t4[1] = e3[1] * o3, t4[2] = e3[2] * o3, t4;
            }([], function(t4, e3, i4) {
              var a4 = e3[0], s4 = e3[1], o3 = e3[2], r3 = i4[0], n2 = i4[1], l2 = i4[2];
              return t4[0] = s4 * l2 - o3 * n2, t4[1] = o3 * r3 - a4 * l2, t4[2] = a4 * n2 - s4 * r3, t4;
            }([], g([], o2[t3[0]], o2[t3[1]]), g([], o2[t3[2]], o2[t3[1]]))), i3 = -((a3 = e2)[0] * (s3 = o2[t3[1]])[0] + a3[1] * s3[1] + a3[2] * s3[2]);
            var a3, s3;
            return e2.concat(i3);
          });
          return new xa(o2, r2);
        }
      }

      class ya {
        constructor(t2, e2) {
          this.min = t2, this.max = e2, this.center = function(t3, e3, i2) {
            return t3[0] = 0.5 * e3[0], t3[1] = 0.5 * e3[1], t3[2] = 0.5 * e3[2], t3;
          }([], function(t3, e3, i2) {
            return t3[0] = e3[0] + i2[0], t3[1] = e3[1] + i2[1], t3[2] = e3[2] + i2[2], t3;
          }([], this.min, this.max));
        }
        quadrant(t2) {
          const e2 = [t2 % 2 == 0, t2 < 2], i2 = m(this.min), a2 = m(this.max);
          for (let t3 = 0;t3 < e2.length; t3++)
            i2[t3] = e2[t3] ? this.min[t3] : this.center[t3], a2[t3] = e2[t3] ? this.center[t3] : this.max[t3];
          return a2[2] = this.max[2], new ya(i2, a2);
        }
        distanceX(t2) {
          return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
        }
        distanceY(t2) {
          return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
        }
        intersects(t2) {
          const i2 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
          let a2 = true;
          for (let s2 = 0;s2 < t2.planes.length; s2++) {
            const o2 = t2.planes[s2];
            let r2 = 0;
            for (let t3 = 0;t3 < i2.length; t3++)
              e.b2(o2, i2[t3]) >= 0 && r2++;
            if (r2 === 0)
              return 0;
            r2 !== i2.length && (a2 = false);
          }
          if (a2)
            return 2;
          for (let e2 = 0;e2 < 3; e2++) {
            let i3 = Number.MAX_VALUE, a3 = -Number.MAX_VALUE;
            for (let s2 = 0;s2 < t2.points.length; s2++) {
              const o2 = t2.points[s2][e2] - this.min[e2];
              i3 = Math.min(i3, o2), a3 = Math.max(a3, o2);
            }
            if (a3 < 0 || i3 > this.max[e2] - this.min[e2])
              return 0;
          }
          return 1;
        }
      }

      class ba {
        constructor(t2 = 0, e2 = 0, i2 = 0, a2 = 0) {
          if (isNaN(t2) || t2 < 0 || isNaN(e2) || e2 < 0 || isNaN(i2) || i2 < 0 || isNaN(a2) || a2 < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = t2, this.bottom = e2, this.left = i2, this.right = a2;
        }
        interpolate(t2, i2, a2) {
          return i2.top != null && t2.top != null && (this.top = e.y.number(t2.top, i2.top, a2)), i2.bottom != null && t2.bottom != null && (this.bottom = e.y.number(t2.bottom, i2.bottom, a2)), i2.left != null && t2.left != null && (this.left = e.y.number(t2.left, i2.left, a2)), i2.right != null && t2.right != null && (this.right = e.y.number(t2.right, i2.right, a2)), this;
        }
        getCenter(t2, i2) {
          const a2 = e.ac((this.left + t2 - this.right) / 2, 0, t2), s2 = e.ac((this.top + i2 - this.bottom) / 2, 0, i2);
          return new e.P(a2, s2);
        }
        equals(t2) {
          return this.top === t2.top && this.bottom === t2.bottom && this.left === t2.left && this.right === t2.right;
        }
        clone() {
          return new ba(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      const wa = 85.051129;

      class Ta {
        constructor(t2, i2, a2, s2, o2) {
          this.tileSize = 512, this._renderWorldCopies = o2 === undefined || !!o2, this._minZoom = t2 || 0, this._maxZoom = i2 || 22, this._minPitch = a2 == null ? 0 : a2, this._maxPitch = s2 == null ? 60 : s2, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new e.N(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new ba, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {}, this.minElevationForCurrentTile = 0;
        }
        clone() {
          const t2 = new Ta(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return t2.apply(this), t2;
        }
        apply(t2) {
          this.tileSize = t2.tileSize, this.latRange = t2.latRange, this.lngRange = t2.lngRange, this.width = t2.width, this.height = t2.height, this._center = t2._center, this._elevation = t2._elevation, this.minElevationForCurrentTile = t2.minElevationForCurrentTile, this.zoom = t2.zoom, this.angle = t2.angle, this._fov = t2._fov, this._pitch = t2._pitch, this._unmodified = t2._unmodified, this._edgeInsets = t2._edgeInsets.clone(), this._calcMatrices();
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(t2) {
          this._minZoom !== t2 && (this._minZoom = t2, this.zoom = Math.max(this.zoom, t2));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(t2) {
          this._maxZoom !== t2 && (this._maxZoom = t2, this.zoom = Math.min(this.zoom, t2));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(t2) {
          this._minPitch !== t2 && (this._minPitch = t2, this.pitch = Math.max(this.pitch, t2));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(t2) {
          this._maxPitch !== t2 && (this._maxPitch = t2, this.pitch = Math.min(this.pitch, t2));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(t2) {
          t2 === undefined ? t2 = true : t2 === null && (t2 = false), this._renderWorldCopies = t2;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new e.P(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(t2) {
          const i2 = -e.b3(t2, -180, 180) * Math.PI / 180;
          this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = function() {
            var t3 = new e.A(4);
            return e.A != Float32Array && (t3[1] = 0, t3[2] = 0), t3[0] = 1, t3[3] = 1, t3;
          }(), function(t3, e2, i3) {
            var a2 = e2[0], s2 = e2[1], o2 = e2[2], r2 = e2[3], n2 = Math.sin(i3), l2 = Math.cos(i3);
            t3[0] = a2 * l2 + o2 * n2, t3[1] = s2 * l2 + r2 * n2, t3[2] = a2 * -n2 + o2 * l2, t3[3] = s2 * -n2 + r2 * l2;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(t2) {
          const i2 = e.ac(t2, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(t2) {
          t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = t2 / 180 * Math.PI, this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(t2) {
          const e2 = Math.min(Math.max(t2, this.minZoom), this.maxZoom);
          this._zoom !== e2 && (this._unmodified = false, this._zoom = e2, this.tileZoom = Math.max(0, Math.floor(e2)), this.scale = this.zoomScale(e2), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        set center(t2) {
          t2.lat === this._center.lat && t2.lng === this._center.lng || (this._unmodified = false, this._center = t2, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(t2) {
          t2 !== this._elevation && (this._elevation = t2, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(t2) {
          this._edgeInsets.equals(t2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t2, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        isPaddingEqual(t2) {
          return this._edgeInsets.equals(t2);
        }
        interpolatePadding(t2, e2, i2) {
          this._unmodified = false, this._edgeInsets.interpolate(t2, e2, i2), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(t2) {
          const e2 = (t2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t2.tileSize));
          return Math.max(0, e2);
        }
        getVisibleUnwrappedCoordinates(t2) {
          const i2 = [new e.b4(0, t2)];
          if (this._renderWorldCopies) {
            const a2 = this.pointCoordinate(new e.P(0, 0)), s2 = this.pointCoordinate(new e.P(this.width, 0)), o2 = this.pointCoordinate(new e.P(this.width, this.height)), r2 = this.pointCoordinate(new e.P(0, this.height)), n2 = Math.floor(Math.min(a2.x, s2.x, o2.x, r2.x)), l2 = Math.floor(Math.max(a2.x, s2.x, o2.x, r2.x)), h2 = 1;
            for (let a3 = n2 - h2;a3 <= l2 + h2; a3++)
              a3 !== 0 && i2.push(new e.b4(a3, t2));
          }
          return i2;
        }
        coveringTiles(t2) {
          var i2, a2;
          let s2 = this.coveringZoomLevel(t2);
          const o2 = s2;
          if (t2.minzoom !== undefined && s2 < t2.minzoom)
            return [];
          t2.maxzoom !== undefined && s2 > t2.maxzoom && (s2 = t2.maxzoom);
          const r2 = this.pointCoordinate(this.getCameraPoint()), n2 = e.Z.fromLngLat(this.center), l2 = Math.pow(2, s2), h2 = [l2 * r2.x, l2 * r2.y, 0], c2 = [l2 * n2.x, l2 * n2.y, 0], u5 = xa.fromInvProjectionMatrix(this.invModelViewProjectionMatrix, this.worldSize, s2);
          let d2 = t2.minzoom || 0;
          !t2.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (d2 = s2);
          const _2 = t2.terrain ? 2 / Math.min(this.tileSize, t2.tileSize) * this.tileSize : 3, p2 = (t3) => ({ aabb: new ya([t3 * l2, 0, 0], [(t3 + 1) * l2, l2, 0]), zoom: 0, x: 0, y: 0, wrap: t3, fullyVisible: false }), m2 = [], f2 = [], g2 = s2, x2 = t2.reparseOverscaled ? o2 : s2;
          if (this._renderWorldCopies)
            for (let t3 = 1;t3 <= 3; t3++)
              m2.push(p2(-t3)), m2.push(p2(t3));
          for (m2.push(p2(0));m2.length > 0; ) {
            const s3 = m2.pop(), o3 = s3.x, r3 = s3.y;
            let n3 = s3.fullyVisible;
            if (!n3) {
              const t3 = s3.aabb.intersects(u5);
              if (t3 === 0)
                continue;
              n3 = t3 === 2;
            }
            const l3 = t2.terrain ? h2 : c2, p3 = s3.aabb.distanceX(l3), y2 = s3.aabb.distanceY(l3), b2 = Math.max(Math.abs(p3), Math.abs(y2));
            if (s3.zoom === g2 || b2 > _2 + (1 << g2 - s3.zoom) - 2 && s3.zoom >= d2) {
              const t3 = g2 - s3.zoom, i3 = h2[0] - 0.5 - (o3 << t3), a3 = h2[1] - 0.5 - (r3 << t3);
              f2.push({ tileID: new e.S(s3.zoom === g2 ? x2 : s3.zoom, s3.wrap, s3.zoom, o3, r3), distanceSq: v2([c2[0] - 0.5 - o3, c2[1] - 0.5 - r3]), tileDistanceToCamera: Math.sqrt(i3 * i3 + a3 * a3) });
            } else
              for (let l4 = 0;l4 < 4; l4++) {
                const h3 = (o3 << 1) + l4 % 2, c3 = (r3 << 1) + (l4 >> 1), u6 = s3.zoom + 1;
                let d3 = s3.aabb.quadrant(l4);
                if (t2.terrain) {
                  const o4 = new e.S(u6, s3.wrap, u6, h3, c3), r4 = t2.terrain.getMinMaxElevation(o4), n4 = (i2 = r4.minElevation) !== null && i2 !== undefined ? i2 : this.elevation, l5 = (a2 = r4.maxElevation) !== null && a2 !== undefined ? a2 : this.elevation;
                  d3 = new ya([d3.min[0], d3.min[1], n4], [d3.max[0], d3.max[1], l5]);
                }
                m2.push({ aabb: d3, zoom: u6, x: h3, y: c3, wrap: s3.wrap, fullyVisible: n3 });
              }
          }
          return f2.sort((t3, e2) => t3.distanceSq - e2.distanceSq).map((t3) => t3.tileID);
        }
        resize(t2, e2) {
          this.width = t2, this.height = e2, this.pixelsToGLUnits = [2 / t2, -2 / e2], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(t2) {
          return Math.pow(2, t2);
        }
        scaleZoom(t2) {
          return Math.log(t2) / Math.LN2;
        }
        project(t2) {
          const i2 = e.ac(t2.lat, -85.051129, wa);
          return new e.P(e.O(t2.lng) * this.worldSize, e.Q(i2) * this.worldSize);
        }
        unproject(t2) {
          return new e.Z(t2.x / this.worldSize, t2.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        getCameraPosition() {
          return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
        }
        recalculateZoom(t2) {
          const i2 = this.elevation, a2 = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, s2 = this.pointLocation(this.centerPoint, t2), o2 = t2.getElevationForLngLatZoom(s2, this.tileZoom);
          if (!(this.elevation - o2))
            return;
          const r2 = a2 + i2 - o2, n2 = Math.cos(this._pitch) * this.cameraToCenterDistance / r2 / e.b5(1, s2.lat), l2 = this.scaleZoom(n2 / this.tileSize);
          this._elevation = o2, this._center = s2, this.zoom = l2;
        }
        setLocationAtPoint(t2, i2) {
          const a2 = this.pointCoordinate(i2), s2 = this.pointCoordinate(this.centerPoint), o2 = this.locationCoordinate(t2), r2 = new e.Z(o2.x - (a2.x - s2.x), o2.y - (a2.y - s2.y));
          this.center = this.coordinateLocation(r2), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(t2, e2) {
          return e2 ? this.coordinatePoint(this.locationCoordinate(t2), e2.getElevationForLngLatZoom(t2, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t2));
        }
        pointLocation(t2, e2) {
          return this.coordinateLocation(this.pointCoordinate(t2, e2));
        }
        locationCoordinate(t2) {
          return e.Z.fromLngLat(t2);
        }
        coordinateLocation(t2) {
          return t2 && t2.toLngLat();
        }
        pointCoordinate(t2, i2) {
          if (i2) {
            const e2 = i2.pointCoordinate(t2);
            if (e2 != null)
              return e2;
          }
          const a2 = [t2.x, t2.y, 0, 1], s2 = [t2.x, t2.y, 1, 1];
          e.af(a2, a2, this.pixelMatrixInverse), e.af(s2, s2, this.pixelMatrixInverse);
          const o2 = a2[3], r2 = s2[3], n2 = a2[1] / o2, l2 = s2[1] / r2, h2 = a2[2] / o2, c2 = s2[2] / r2, u5 = h2 === c2 ? 0 : (0 - h2) / (c2 - h2);
          return new e.Z(e.y.number(a2[0] / o2, s2[0] / r2, u5) / this.worldSize, e.y.number(n2, l2, u5) / this.worldSize);
        }
        coordinatePoint(t2, i2 = 0, a2 = this.pixelMatrix) {
          const s2 = [t2.x * this.worldSize, t2.y * this.worldSize, i2, 1];
          return e.af(s2, s2, a2), new e.P(s2[0] / s2[3], s2[1] / s2[3]);
        }
        getBounds() {
          const t2 = Math.max(0, this.height / 2 - this.getHorizon());
          return new H().extend(this.pointLocation(new e.P(0, t2))).extend(this.pointLocation(new e.P(this.width, t2))).extend(this.pointLocation(new e.P(this.width, this.height))).extend(this.pointLocation(new e.P(0, this.height)));
        }
        getMaxBounds() {
          return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new H([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        getHorizon() {
          return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
        }
        setMaxBounds(t2) {
          t2 ? (this.lngRange = [t2.getWest(), t2.getEast()], this.latRange = [t2.getSouth(), t2.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-85.051129, wa]);
        }
        calculateTileMatrix(t2) {
          const i2 = t2.canonical, a2 = this.worldSize / this.zoomScale(i2.z), s2 = i2.x + Math.pow(2, i2.z) * t2.wrap, o2 = e.an(new Float64Array(16));
          return e.J(o2, o2, [s2 * a2, i2.y * a2, 0]), e.K(o2, o2, [a2 / e.X, a2 / e.X, 1]), o2;
        }
        calculatePosMatrix(t2, i2 = false) {
          const a2 = t2.key, s2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (s2[a2])
            return s2[a2];
          const o2 = this.calculateTileMatrix(t2);
          return e.L(o2, i2 ? this.alignedModelViewProjectionMatrix : this.modelViewProjectionMatrix, o2), s2[a2] = new Float32Array(o2), s2[a2];
        }
        calculateFogMatrix(t2) {
          const i2 = t2.key, a2 = this._fogMatrixCache;
          if (a2[i2])
            return a2[i2];
          const s2 = this.calculateTileMatrix(t2);
          return e.L(s2, this.fogMatrix, s2), a2[i2] = new Float32Array(s2), a2[i2];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        getConstrained(t2, i2) {
          i2 = e.ac(+i2, this.minZoom, this.maxZoom);
          const a2 = { center: new e.N(t2.lng, t2.lat), zoom: i2 };
          let s2 = this.lngRange;
          if (!this._renderWorldCopies && s2 === null) {
            const t3 = 180 - 0.0000000001;
            s2 = [-t3, t3];
          }
          const o2 = this.tileSize * this.zoomScale(a2.zoom);
          let r2 = 0, n2 = o2, l2 = 0, h2 = o2, c2 = 0, u5 = 0;
          const { x: d2, y: _2 } = this.size;
          if (this.latRange) {
            const t3 = this.latRange;
            r2 = e.Q(t3[1]) * o2, n2 = e.Q(t3[0]) * o2, n2 - r2 < _2 && (c2 = _2 / (n2 - r2));
          }
          s2 && (l2 = e.b3(e.O(s2[0]) * o2, 0, o2), h2 = e.b3(e.O(s2[1]) * o2, 0, o2), h2 < l2 && (h2 += o2), h2 - l2 < d2 && (u5 = d2 / (h2 - l2)));
          const { x: p2, y: m2 } = this.project.call({ worldSize: o2 }, t2);
          let f2, g2;
          const v3 = Math.max(u5 || 0, c2 || 0);
          if (v3) {
            const t3 = new e.P(u5 ? (h2 + l2) / 2 : p2, c2 ? (n2 + r2) / 2 : m2);
            return a2.center = this.unproject.call({ worldSize: o2 }, t3).wrap(), a2.zoom += this.scaleZoom(v3), a2;
          }
          if (this.latRange) {
            const t3 = _2 / 2;
            m2 - t3 < r2 && (g2 = r2 + t3), m2 + t3 > n2 && (g2 = n2 - t3);
          }
          if (s2) {
            const t3 = (l2 + h2) / 2;
            let i3 = p2;
            this._renderWorldCopies && (i3 = e.b3(p2, t3 - o2 / 2, t3 + o2 / 2));
            const a3 = d2 / 2;
            i3 - a3 < l2 && (f2 = l2 + a3), i3 + a3 > h2 && (f2 = h2 - a3);
          }
          if (f2 !== undefined || g2 !== undefined) {
            const t3 = new e.P(f2 != null ? f2 : p2, g2 != null ? g2 : m2);
            a2.center = this.unproject.call({ worldSize: o2 }, t3).wrap();
          }
          return a2;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining)
            return;
          this._constraining = true;
          const t2 = this._unmodified, { center: e2, zoom: i2 } = this.getConstrained(this.center, this.zoom);
          this.center = e2, this.zoom = i2, this._unmodified = t2, this._constraining = false;
        }
        _calcMatrices() {
          if (!this.height)
            return;
          const t2 = this.centerOffset, i2 = this.point.x, a2 = this.point.y;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = e.b5(1, this.center.lat) * this.worldSize;
          let s2 = e.an(new Float64Array(16));
          e.K(s2, s2, [this.width / 2, -this.height / 2, 1]), e.J(s2, s2, [1, -1, 0]), this.labelPlaneMatrix = s2, s2 = e.an(new Float64Array(16)), e.K(s2, s2, [1, -1, 1]), e.J(s2, s2, [-1, -1, 0]), e.K(s2, s2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = s2;
          const o2 = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), r2 = Math.min(this.elevation, this.minElevationForCurrentTile), n2 = o2 - r2 * this._pixelPerMeter / Math.cos(this._pitch), l2 = r2 < 0 ? n2 : o2, h2 = Math.PI / 2 + this._pitch, c2 = this._fov * (0.5 + t2.y / this.height), u5 = Math.sin(c2) * l2 / Math.sin(e.ac(Math.PI - h2 - c2, 0.01, Math.PI - 0.01)), d2 = this.getHorizon(), _2 = 2 * Math.atan(d2 / this.cameraToCenterDistance) * (0.5 + t2.y / (2 * d2)), p2 = Math.sin(_2) * l2 / Math.sin(e.ac(Math.PI - h2 - _2, 0.01, Math.PI - 0.01)), m2 = Math.min(u5, p2);
          this.farZ = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * m2 + l2), this.nearZ = this.height / 50, s2 = new Float64Array(16), e.b6(s2, this._fov, this.width / this.height, this.nearZ, this.farZ), s2[8] = 2 * -t2.x / this.width, s2[9] = 2 * t2.y / this.height, this.projectionMatrix = e.ae(s2), e.K(s2, s2, [1, -1, 1]), e.J(s2, s2, [0, 0, -this.cameraToCenterDistance]), e.b7(s2, s2, this._pitch), e.ad(s2, s2, this.angle), e.J(s2, s2, [-i2, -a2, 0]), this.mercatorMatrix = e.K([], s2, [this.worldSize, this.worldSize, this.worldSize]), e.K(s2, s2, [1, 1, this._pixelPerMeter]), this.pixelMatrix = e.L(new Float64Array(16), this.labelPlaneMatrix, s2), e.J(s2, s2, [0, 0, -this.elevation]), this.modelViewProjectionMatrix = s2, this.invModelViewProjectionMatrix = e.as([], s2), this.fogMatrix = new Float64Array(16), e.b6(this.fogMatrix, this._fov, this.width / this.height, o2, this.farZ), this.fogMatrix[8] = 2 * -t2.x / this.width, this.fogMatrix[9] = 2 * t2.y / this.height, e.K(this.fogMatrix, this.fogMatrix, [1, -1, 1]), e.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.cameraToCenterDistance]), e.b7(this.fogMatrix, this.fogMatrix, this._pitch), e.ad(this.fogMatrix, this.fogMatrix, this.angle), e.J(this.fogMatrix, this.fogMatrix, [-i2, -a2, 0]), e.K(this.fogMatrix, this.fogMatrix, [1, 1, this._pixelPerMeter]), e.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.elevation]), this.pixelMatrix3D = e.L(new Float64Array(16), this.labelPlaneMatrix, s2);
          const f2 = this.width % 2 / 2, g2 = this.height % 2 / 2, v3 = Math.cos(this.angle), x2 = Math.sin(this.angle), y2 = i2 - Math.round(i2) + v3 * f2 + x2 * g2, b2 = a2 - Math.round(a2) + v3 * g2 + x2 * f2, w2 = new Float64Array(s2);
          if (e.J(w2, w2, [y2 > 0.5 ? y2 - 1 : y2, b2 > 0.5 ? b2 - 1 : b2, 0]), this.alignedModelViewProjectionMatrix = w2, s2 = e.as(new Float64Array(16), this.pixelMatrix), !s2)
            throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = s2, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse)
            return 1;
          const t2 = this.pointCoordinate(new e.P(0, 0)), i2 = [t2.x * this.worldSize, t2.y * this.worldSize, 0, 1];
          return e.af(i2, i2, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }
        getCameraPoint() {
          const t2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new e.P(0, t2));
        }
        getCameraQueryGeometry(t2) {
          const i2 = this.getCameraPoint();
          if (t2.length === 1)
            return [t2[0], i2];
          {
            let { x: a2, y: s2, x: o2, y: r2 } = i2;
            for (const e2 of t2)
              a2 = Math.min(a2, e2.x), s2 = Math.min(s2, e2.y), o2 = Math.max(o2, e2.x), r2 = Math.max(r2, e2.y);
            return [new e.P(a2, s2), new e.P(o2, s2), new e.P(o2, r2), new e.P(a2, r2), new e.P(a2, s2)];
          }
        }
        lngLatToCameraDepth(t2, i2) {
          const a2 = this.locationCoordinate(t2), s2 = [a2.x * this.worldSize, a2.y * this.worldSize, i2, 1];
          return e.af(s2, s2, this.modelViewProjectionMatrix), s2[2] / s2[3];
        }
      }
      function Ia(t2, e2) {
        let i2, a2 = false, s2 = null, o2 = null;
        const r2 = () => {
          s2 = null, a2 && (t2.apply(o2, i2), s2 = setTimeout(r2, e2), a2 = false);
        };
        return (...t3) => (a2 = true, o2 = this, i2 = t3, s2 || r2(), s2);
      }

      class Ea {
        constructor(t2) {
          this._getCurrentHash = () => {
            const t3 = window.location.hash.replace("#", "");
            if (this._hashName) {
              let e2;
              return t3.split("&").map((t4) => t4.split("=")).forEach((t4) => {
                t4[0] === this._hashName && (e2 = t4);
              }), (e2 && e2[1] || "").split("/");
            }
            return t3.split("/");
          }, this._onHashChange = () => {
            const t3 = this._getCurrentHash();
            if (t3.length >= 3 && !t3.some((t4) => isNaN(t4))) {
              const e2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t3[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+t3[2], +t3[1]], zoom: +t3[0], bearing: e2, pitch: +(t3[4] || 0) }), true;
            }
            return false;
          }, this._updateHashUnthrottled = () => {
            const t3 = window.location.href.replace(/(#.*)?$/, this.getHashString());
            window.history.replaceState(window.history.state, null, t3);
          }, this._removeHash = () => {
            const t3 = this._getCurrentHash();
            if (t3.length === 0)
              return;
            const e2 = t3.join("/");
            let i2 = e2;
            i2.split("&").length > 0 && (i2 = i2.split("&")[0]), this._hashName && (i2 = `${this._hashName}=${e2}`);
            let a2 = window.location.hash.replace(i2, "");
            a2.startsWith("#&") ? a2 = a2.slice(0, 1) + a2.slice(2) : a2 === "#" && (a2 = "");
            let s2 = window.location.href.replace(/(#.+)?$/, a2);
            s2 = s2.replace("&&", "&"), window.history.replaceState(window.history.state, null, s2);
          }, this._updateHash = Ia(this._updateHashUnthrottled, 300), this._hashName = t2 && encodeURIComponent(t2);
        }
        addTo(t2) {
          return this._map = t2, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
        }
        getHashString(t2) {
          const e2 = this._map.getCenter(), i2 = Math.round(100 * this._map.getZoom()) / 100, a2 = Math.ceil((i2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), s2 = Math.pow(10, a2), o2 = Math.round(e2.lng * s2) / s2, r2 = Math.round(e2.lat * s2) / s2, n2 = this._map.getBearing(), l2 = this._map.getPitch();
          let h2 = "";
          if (h2 += t2 ? `/${o2}/${r2}/${i2}` : `${i2}/${r2}/${o2}`, (n2 || l2) && (h2 += "/" + Math.round(10 * n2) / 10), l2 && (h2 += `/${Math.round(l2)}`), this._hashName) {
            const t3 = this._hashName;
            let e3 = false;
            const i3 = window.location.hash.slice(1).split("&").map((i4) => {
              const a3 = i4.split("=")[0];
              return a3 === t3 ? (e3 = true, `${a3}=${h2}`) : i4;
            }).filter((t4) => t4);
            return e3 || i3.push(`${t3}=${h2}`), `#${i3.join("&")}`;
          }
          return `#${h2}`;
        }
      }
      const Pa = { linearity: 0.3, easing: e.b8(0, 0, 0.3, 1) }, Ca = e.e({ deceleration: 2500, maxSpeed: 1400 }, Pa), Sa = e.e({ deceleration: 20, maxSpeed: 1400 }, Pa), za = e.e({ deceleration: 1000, maxSpeed: 360 }, Pa), Da = e.e({ deceleration: 1000, maxSpeed: 90 }, Pa);

      class Ma {
        constructor(t2) {
          this._map = t2, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t2) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: o.now(), settings: t2 });
        }
        _drainInertiaBuffer() {
          const t2 = this._inertiaBuffer, e2 = o.now();
          for (;t2.length > 0 && e2 - t2[0].time > 160; )
            t2.shift();
        }
        _onMoveEnd(t2) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
            return;
          const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e.P(0, 0), pinchAround: undefined, around: undefined };
          for (const { settings: t3 } of this._inertiaBuffer)
            i2.zoom += t3.zoomDelta || 0, i2.bearing += t3.bearingDelta || 0, i2.pitch += t3.pitchDelta || 0, t3.panDelta && i2.pan._add(t3.panDelta), t3.around && (i2.around = t3.around), t3.pinchAround && (i2.pinchAround = t3.pinchAround);
          const a2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s2 = {};
          if (i2.pan.mag()) {
            const o2 = Ra(i2.pan.mag(), a2, e.e({}, Ca, t2 || {}));
            s2.offset = i2.pan.mult(o2.amount / i2.pan.mag()), s2.center = this._map.transform.center, Aa(s2, o2);
          }
          if (i2.zoom) {
            const t3 = Ra(i2.zoom, a2, Sa);
            s2.zoom = this._map.transform.zoom + t3.amount, Aa(s2, t3);
          }
          if (i2.bearing) {
            const t3 = Ra(i2.bearing, a2, za);
            s2.bearing = this._map.transform.bearing + e.ac(t3.amount, -179, 179), Aa(s2, t3);
          }
          if (i2.pitch) {
            const t3 = Ra(i2.pitch, a2, Da);
            s2.pitch = this._map.transform.pitch + t3.amount, Aa(s2, t3);
          }
          if (s2.zoom || s2.bearing) {
            const t3 = i2.pinchAround === undefined ? i2.around : i2.pinchAround;
            s2.around = t3 ? this._map.unproject(t3) : this._map.getCenter();
          }
          return this.clear(), e.e(s2, { noMoveStart: true });
        }
      }
      function Aa(t2, e2) {
        (!t2.duration || t2.duration < e2.duration) && (t2.duration = e2.duration, t2.easing = e2.easing);
      }
      function Ra(t2, i2, a2) {
        const { maxSpeed: s2, linearity: o2, deceleration: r2 } = a2, n2 = e.ac(t2 * o2 / (i2 / 1000), -s2, s2), l2 = Math.abs(n2) / (r2 * o2);
        return { easing: a2.easing, duration: 1000 * l2, amount: n2 * (l2 / 2) };
      }

      class ka extends e.k {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t2, i2, a2, s2 = {}) {
          const o2 = r.mousePos(i2.getCanvas(), a2), n2 = i2.unproject(o2);
          super(t2, e.e({ point: o2, lngLat: n2, originalEvent: a2 }, s2)), this._defaultPrevented = false, this.target = i2;
        }
      }

      class La extends e.k {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t2, i2, a2) {
          const s2 = t2 === "touchend" ? a2.changedTouches : a2.touches, o2 = r.touchPos(i2.getCanvasContainer(), s2), n2 = o2.map((t3) => i2.unproject(t3)), l2 = o2.reduce((t3, e2, i3, a3) => t3.add(e2.div(a3.length)), new e.P(0, 0));
          super(t2, { points: o2, point: l2, lngLats: n2, lngLat: i2.unproject(l2), originalEvent: a2 }), this._defaultPrevented = false;
        }
      }

      class Fa extends e.k {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t2, e2, i2) {
          super(t2, { originalEvent: i2 }), this._defaultPrevented = false;
        }
      }

      class Ba {
        constructor(t2, e2) {
          this._map = t2, this._clickTolerance = e2.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(t2) {
          return this._firePreventable(new Fa(t2.type, this._map, t2));
        }
        mousedown(t2, e2) {
          return this._mousedownPos = e2, this._firePreventable(new ka(t2.type, this._map, t2));
        }
        mouseup(t2) {
          this._map.fire(new ka(t2.type, this._map, t2));
        }
        click(t2, e2) {
          this._mousedownPos && this._mousedownPos.dist(e2) >= this._clickTolerance || this._map.fire(new ka(t2.type, this._map, t2));
        }
        dblclick(t2) {
          return this._firePreventable(new ka(t2.type, this._map, t2));
        }
        mouseover(t2) {
          this._map.fire(new ka(t2.type, this._map, t2));
        }
        mouseout(t2) {
          this._map.fire(new ka(t2.type, this._map, t2));
        }
        touchstart(t2) {
          return this._firePreventable(new La(t2.type, this._map, t2));
        }
        touchmove(t2) {
          this._map.fire(new La(t2.type, this._map, t2));
        }
        touchend(t2) {
          this._map.fire(new La(t2.type, this._map, t2));
        }
        touchcancel(t2) {
          this._map.fire(new La(t2.type, this._map, t2));
        }
        _firePreventable(t2) {
          if (this._map.fire(t2), t2.defaultPrevented)
            return {};
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }

      class Oa {
        constructor(t2) {
          this._map = t2;
        }
        reset() {
          this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
        }
        mousemove(t2) {
          this._map.fire(new ka(t2.type, this._map, t2));
        }
        mousedown() {
          this._delayContextMenu = true, this._ignoreContextMenu = false;
        }
        mouseup() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new ka("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(t2) {
          this._delayContextMenu ? this._contextMenuEvent = t2 : this._ignoreContextMenu || this._map.fire(new ka(t2.type, this._map, t2)), this._map.listens("contextmenu") && t2.preventDefault();
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }

      class Na {
        constructor(t2) {
          this._map = t2;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(t2) {
          return this.transform.pointLocation(e.P.convert(t2), this._map.terrain);
        }
      }

      class Ua {
        constructor(t2, e2) {
          this._map = t2, this._tr = new Na(t2), this._el = t2.getCanvasContainer(), this._container = t2.getContainer(), this._clickTolerance = e2.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = true);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        mousedown(t2, e2) {
          this.isEnabled() && t2.shiftKey && t2.button === 0 && (r.disableDrag(), this._startPos = this._lastPos = e2, this._active = true);
        }
        mousemoveWindow(t2, e2) {
          if (!this._active)
            return;
          const i2 = e2;
          if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance)
            return;
          const a2 = this._startPos;
          this._lastPos = i2, this._box || (this._box = r.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t2));
          const s2 = Math.min(a2.x, i2.x), o2 = Math.max(a2.x, i2.x), n2 = Math.min(a2.y, i2.y), l2 = Math.max(a2.y, i2.y);
          r.setTransform(this._box, `translate(${s2}px,${n2}px)`), this._box.style.width = o2 - s2 + "px", this._box.style.height = l2 - n2 + "px";
        }
        mouseupWindow(t2, i2) {
          if (!this._active)
            return;
          if (t2.button !== 0)
            return;
          const a2 = this._startPos, s2 = i2;
          if (this.reset(), r.suppressClick(), a2.x !== s2.x || a2.y !== s2.y)
            return this._map.fire(new e.k("boxzoomend", { originalEvent: t2 })), { cameraAnimation: (t3) => t3.fitScreenCoordinates(a2, s2, this._tr.bearing, { linear: true }) };
          this._fireEvent("boxzoomcancel", t2);
        }
        keydown(t2) {
          this._active && t2.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t2));
        }
        reset() {
          this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (r.remove(this._box), this._box = null), r.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t2, i2) {
          return this._map.fire(new e.k(t2, { originalEvent: i2 }));
        }
      }
      function ja(t2, e2) {
        if (t2.length !== e2.length)
          throw new Error(`The number of touches and points are not equal - touches ${t2.length}, points ${e2.length}`);
        const i2 = {};
        for (let a2 = 0;a2 < t2.length; a2++)
          i2[t2[a2].identifier] = e2[a2];
        return i2;
      }

      class Za {
        constructor(t2) {
          this.reset(), this.numTouches = t2.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
        }
        touchstart(t2, i2, a2) {
          (this.centroid || a2.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === undefined && (this.startTime = t2.timeStamp), a2.length === this.numTouches && (this.centroid = function(t3) {
            const i3 = new e.P(0, 0);
            for (const e2 of t3)
              i3._add(e2);
            return i3.div(t3.length);
          }(i2), this.touches = ja(a2, i2)));
        }
        touchmove(t2, e2, i2) {
          if (this.aborted || !this.centroid)
            return;
          const a2 = ja(i2, e2);
          for (const t3 in this.touches) {
            const e3 = a2[t3];
            (!e3 || e3.dist(this.touches[t3]) > 30) && (this.aborted = true);
          }
        }
        touchend(t2, e2, i2) {
          if ((!this.centroid || t2.timeStamp - this.startTime > 500) && (this.aborted = true), i2.length === 0) {
            const t3 = !this.aborted && this.centroid;
            if (this.reset(), t3)
              return t3;
          }
        }
      }

      class qa {
        constructor(t2) {
          this.singleTap = new Za(t2), this.numTaps = t2.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(t2, e2, i2) {
          this.singleTap.touchstart(t2, e2, i2);
        }
        touchmove(t2, e2, i2) {
          this.singleTap.touchmove(t2, e2, i2);
        }
        touchend(t2, e2, i2) {
          const a2 = this.singleTap.touchend(t2, e2, i2);
          if (a2) {
            const e3 = t2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(a2) < 30;
            if (e3 && i3 || this.reset(), this.count++, this.lastTime = t2.timeStamp, this.lastTap = a2, this.count === this.numTaps)
              return this.reset(), a2;
          }
        }
      }

      class Va {
        constructor(t2) {
          this._tr = new Na(t2), this._zoomIn = new qa({ numTouches: 1, numTaps: 2 }), this._zoomOut = new qa({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(t2, e2, i2) {
          this._zoomIn.touchstart(t2, e2, i2), this._zoomOut.touchstart(t2, e2, i2);
        }
        touchmove(t2, e2, i2) {
          this._zoomIn.touchmove(t2, e2, i2), this._zoomOut.touchmove(t2, e2, i2);
        }
        touchend(t2, e2, i2) {
          const a2 = this._zoomIn.touchend(t2, e2, i2), s2 = this._zoomOut.touchend(t2, e2, i2), o2 = this._tr;
          return a2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o2.zoom + 1, around: o2.unproject(a2) }, { originalEvent: t2 }) }) : s2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o2.zoom - 1, around: o2.unproject(s2) }, { originalEvent: t2 }) }) : undefined;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }

      class Ga {
        constructor(t2) {
          this._enabled = !!t2.enable, this._moveStateManager = t2.moveStateManager, this._clickTolerance = t2.clickTolerance || 1, this._moveFunction = t2.move, this._activateOnStart = !!t2.activateOnStart, t2.assignEvents(this), this.reset();
        }
        reset(t2) {
          this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(t2);
        }
        _move(...t2) {
          const e2 = this._moveFunction(...t2);
          if (e2.bearingDelta || e2.pitchDelta || e2.around || e2.panDelta)
            return this._active = true, e2;
        }
        dragStart(t2, e2) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t2) && (this._moveStateManager.startMove(t2), this._lastPoint = e2.length ? e2[0] : e2, this._activateOnStart && this._lastPoint && (this._active = true));
        }
        dragMove(t2, e2) {
          if (!this.isEnabled())
            return;
          const i2 = this._lastPoint;
          if (!i2)
            return;
          if (t2.preventDefault(), !this._moveStateManager.isValidMoveEvent(t2))
            return void this.reset(t2);
          const a2 = e2.length ? e2[0] : e2;
          return !this._moved && a2.dist(i2) < this._clickTolerance ? undefined : (this._moved = true, this._lastPoint = a2, this._move(i2, a2));
        }
        dragEnd(t2) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t2) && (this._moved && r.suppressClick(), this.reset(t2));
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const Ha = { 0: 1, 2: 2 };

      class Wa {
        constructor(t2) {
          this._correctEvent = t2.checkCorrectEvent;
        }
        startMove(t2) {
          const e2 = r.mouseButton(t2);
          this._eventButton = e2;
        }
        endMove(t2) {
          delete this._eventButton;
        }
        isValidStartEvent(t2) {
          return this._correctEvent(t2);
        }
        isValidMoveEvent(t2) {
          return !function(t3, e2) {
            const i2 = Ha[e2];
            return t3.buttons === undefined || (t3.buttons & i2) !== i2;
          }(t2, this._eventButton);
        }
        isValidEndEvent(t2) {
          return r.mouseButton(t2) === this._eventButton;
        }
      }

      class $a {
        constructor() {
          this._firstTouch = undefined;
        }
        _isOneFingerTouch(t2) {
          return t2.targetTouches.length === 1;
        }
        _isSameTouchEvent(t2) {
          return t2.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(t2) {
          this._firstTouch = t2.targetTouches[0].identifier;
        }
        endMove(t2) {
          delete this._firstTouch;
        }
        isValidStartEvent(t2) {
          return this._isOneFingerTouch(t2);
        }
        isValidMoveEvent(t2) {
          return this._isOneFingerTouch(t2) && this._isSameTouchEvent(t2);
        }
        isValidEndEvent(t2) {
          return this._isOneFingerTouch(t2) && this._isSameTouchEvent(t2);
        }
      }
      const Xa = (t2) => {
        t2.mousedown = t2.dragStart, t2.mousemoveWindow = t2.dragMove, t2.mouseup = t2.dragEnd, t2.contextmenu = (t3) => {
          t3.preventDefault();
        };
      }, Ka = ({ enable: t2, clickTolerance: e2, bearingDegreesPerPixelMoved: i2 = 0.8 }) => {
        const a2 = new Wa({ checkCorrectEvent: (t3) => r.mouseButton(t3) === 0 && t3.ctrlKey || r.mouseButton(t3) === 2 });
        return new Ga({ clickTolerance: e2, move: (t3, e3) => ({ bearingDelta: (e3.x - t3.x) * i2 }), moveStateManager: a2, enable: t2, assignEvents: Xa });
      }, Ja = ({ enable: t2, clickTolerance: e2, pitchDegreesPerPixelMoved: i2 = -0.5 }) => {
        const a2 = new Wa({ checkCorrectEvent: (t3) => r.mouseButton(t3) === 0 && t3.ctrlKey || r.mouseButton(t3) === 2 });
        return new Ga({ clickTolerance: e2, move: (t3, e3) => ({ pitchDelta: (e3.y - t3.y) * i2 }), moveStateManager: a2, enable: t2, assignEvents: Xa });
      };

      class Ya {
        constructor(t2, e2) {
          this._clickTolerance = t2.clickTolerance || 1, this._map = e2, this.reset();
        }
        reset() {
          this._active = false, this._touches = {}, this._sum = new e.P(0, 0);
        }
        _shouldBePrevented(t2) {
          return t2 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
        }
        touchstart(t2, e2, i2) {
          return this._calculateTransform(t2, e2, i2);
        }
        touchmove(t2, e2, i2) {
          if (this._active) {
            if (!this._shouldBePrevented(i2.length))
              return t2.preventDefault(), this._calculateTransform(t2, e2, i2);
            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", t2);
          }
        }
        touchend(t2, e2, i2) {
          this._calculateTransform(t2, e2, i2), this._active && this._shouldBePrevented(i2.length) && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t2, i2, a2) {
          a2.length > 0 && (this._active = true);
          const s2 = ja(a2, i2), o2 = new e.P(0, 0), r2 = new e.P(0, 0);
          let n2 = 0;
          for (const t3 in s2) {
            const e2 = s2[t3], i3 = this._touches[t3];
            i3 && (o2._add(e2), r2._add(e2.sub(i3)), n2++, s2[t3] = e2);
          }
          if (this._touches = s2, this._shouldBePrevented(n2) || !r2.mag())
            return;
          const l2 = r2.div(n2);
          return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? undefined : { around: o2.div(n2), panDelta: l2 };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }

      class Qa {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false, delete this._firstTwoTouches;
        }
        touchstart(t2, e2, i2) {
          this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([e2[0], e2[1]]));
        }
        touchmove(t2, e2, i2) {
          if (!this._firstTwoTouches)
            return;
          t2.preventDefault();
          const [a2, s2] = this._firstTwoTouches, o2 = ts(i2, e2, a2), r2 = ts(i2, e2, s2);
          if (!o2 || !r2)
            return;
          const n2 = this._aroundCenter ? null : o2.add(r2).div(2);
          return this._move([o2, r2], n2, t2);
        }
        touchend(t2, e2, i2) {
          if (!this._firstTwoTouches)
            return;
          const [a2, s2] = this._firstTwoTouches, o2 = ts(i2, e2, a2), n2 = ts(i2, e2, s2);
          o2 && n2 || (this._active && r.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(t2) {
          this._enabled = true, this._aroundCenter = !!t2 && t2.around === "center";
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function ts(t2, e2, i2) {
        for (let a2 = 0;a2 < t2.length; a2++)
          if (t2[a2].identifier === i2)
            return e2[a2];
      }
      function es(t2, e2) {
        return Math.log(t2 / e2) / Math.LN2;
      }

      class is extends Qa {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(t2) {
          this._startDistance = this._distance = t2[0].dist(t2[1]);
        }
        _move(t2, e2) {
          const i2 = this._distance;
          if (this._distance = t2[0].dist(t2[1]), this._active || !(Math.abs(es(this._distance, this._startDistance)) < 0.1))
            return this._active = true, { zoomDelta: es(this._distance, i2), pinchAround: e2 };
        }
      }
      function as(t2, e2) {
        return 180 * t2.angleWith(e2) / Math.PI;
      }

      class ss extends Qa {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(t2) {
          this._startVector = this._vector = t2[0].sub(t2[1]), this._minDiameter = t2[0].dist(t2[1]);
        }
        _move(t2, e2, i2) {
          const a2 = this._vector;
          if (this._vector = t2[0].sub(t2[1]), this._active || !this._isBelowThreshold(this._vector))
            return this._active = true, { bearingDelta: as(this._vector, a2), pinchAround: e2 };
        }
        _isBelowThreshold(t2) {
          this._minDiameter = Math.min(this._minDiameter, t2.mag());
          const e2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = as(t2, this._startVector);
          return Math.abs(i2) < e2;
        }
      }
      function os(t2) {
        return Math.abs(t2.y) > Math.abs(t2.x);
      }

      class rs extends Qa {
        constructor(t2) {
          super(), this._currentTouchCount = 0, this._map = t2;
        }
        reset() {
          super.reset(), this._valid = undefined, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(t2, e2, i2) {
          super.touchstart(t2, e2, i2), this._currentTouchCount = i2.length;
        }
        _start(t2) {
          this._lastPoints = t2, os(t2[0].sub(t2[1])) && (this._valid = false);
        }
        _move(t2, e2, i2) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3)
            return;
          const a2 = t2[0].sub(this._lastPoints[0]), s2 = t2[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(a2, s2, i2.timeStamp), this._valid ? (this._lastPoints = t2, this._active = true, { pitchDelta: (a2.y + s2.y) / 2 * -0.5 }) : undefined;
        }
        gestureBeginsVertically(t2, e2, i2) {
          if (this._valid !== undefined)
            return this._valid;
          const a2 = t2.mag() >= 2, s2 = e2.mag() >= 2;
          if (!a2 && !s2)
            return;
          if (!a2 || !s2)
            return this._firstMove === undefined && (this._firstMove = i2), i2 - this._firstMove < 100 && undefined;
          const o2 = t2.y > 0 == e2.y > 0;
          return os(t2) && os(e2) && o2;
        }
      }
      const ns = { panStep: 100, bearingStep: 15, pitchStep: 10 };

      class ls {
        constructor(t2) {
          this._tr = new Na(t2);
          const e2 = ns;
          this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
        }
        reset() {
          this._active = false;
        }
        keydown(t2) {
          if (t2.altKey || t2.ctrlKey || t2.metaKey)
            return;
          let e2 = 0, i2 = 0, a2 = 0, s2 = 0, o2 = 0;
          switch (t2.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              e2 = 1;
              break;
            case 189:
            case 109:
            case 173:
              e2 = -1;
              break;
            case 37:
              t2.shiftKey ? i2 = -1 : (t2.preventDefault(), s2 = -1);
              break;
            case 39:
              t2.shiftKey ? i2 = 1 : (t2.preventDefault(), s2 = 1);
              break;
            case 38:
              t2.shiftKey ? a2 = 1 : (t2.preventDefault(), o2 = -1);
              break;
            case 40:
              t2.shiftKey ? a2 = -1 : (t2.preventDefault(), o2 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (i2 = 0, a2 = 0), { cameraAnimation: (r2) => {
            const n2 = this._tr;
            r2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: hs, zoom: e2 ? Math.round(n2.zoom) + e2 * (t2.shiftKey ? 2 : 1) : n2.zoom, bearing: n2.bearing + i2 * this._bearingStep, pitch: n2.pitch + a2 * this._pitchStep, offset: [-s2 * this._panStep, -o2 * this._panStep], center: n2.center }, { originalEvent: t2 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = true;
        }
        enableRotation() {
          this._rotationDisabled = false;
        }
      }
      function hs(t2) {
        return t2 * (2 - t2);
      }
      const cs = 4.000244140625;

      class us {
        constructor(t2, e2) {
          this._onTimeout = (t3) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t3);
          }, this._map = t2, this._tr = new Na(t2), this._triggerRenderFrame = e2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(t2) {
          this._defaultZoomRate = t2;
        }
        setWheelZoomRate(t2) {
          this._wheelZoomRate = t2;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== undefined;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(t2) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = !!t2 && t2.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        _shouldBePrevented(t2) {
          return !!this._map.cooperativeGestures.isEnabled() && !(t2.ctrlKey || this._map.cooperativeGestures.isBypassed(t2));
        }
        wheel(t2) {
          if (!this.isEnabled())
            return;
          if (this._shouldBePrevented(t2))
            return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", t2);
          let e2 = t2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
          const i2 = o.now(), a2 = i2 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = i2, e2 !== 0 && e2 % cs == 0 ? this._type = "wheel" : e2 !== 0 && Math.abs(e2) < 4 ? this._type = "trackpad" : a2 > 400 ? (this._type = null, this._lastValue = e2, this._timeout = setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(a2 * e2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, e2 += this._lastValue)), t2.shiftKey && e2 && (e2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= e2, this._active || this._start(t2)), t2.preventDefault();
        }
        _start(t2) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const i2 = r.mousePos(this._map.getCanvas(), t2), a2 = this._tr;
          this._around = i2.y > a2.transform.height / 2 - a2.transform.getHorizon() ? e.N.convert(this._aroundCenter ? a2.center : a2.unproject(i2)) : e.N.convert(a2.center), this._aroundPoint = a2.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId)
            return;
          if (this._frameId = null, !this.isActive())
            return;
          const t2 = this._tr.transform;
          if (this._delta !== 0) {
            const e2 = this._type === "wheel" && Math.abs(this._delta) > cs ? this._wheelZoomRate : this._defaultZoomRate;
            let i3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e2)));
            this._delta < 0 && i3 !== 0 && (i3 = 1 / i3);
            const a3 = typeof this._targetZoom == "number" ? t2.zoomScale(this._targetZoom) : t2.scale;
            this._targetZoom = Math.min(t2.maxZoom, Math.max(t2.minZoom, t2.scaleZoom(a3 * i3))), this._type === "wheel" && (this._startZoom = t2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const i2 = typeof this._targetZoom == "number" ? this._targetZoom : t2.zoom, a2 = this._startZoom, s2 = this._easing;
          let r2, n2 = false;
          const l2 = o.now() - this._lastWheelEventTime;
          if (this._type === "wheel" && a2 && s2 && l2) {
            const t3 = Math.min(l2 / 200, 1), o2 = s2(t3);
            r2 = e.y.number(a2, i2, o2), t3 < 1 ? this._frameId || (this._frameId = true) : n2 = true;
          } else
            r2 = i2, n2 = true;
          return this._active = true, n2 && (this._active = false, this._finishTimeout = setTimeout(() => {
            this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), { noInertia: true, needsRenderFrame: !n2, zoomDelta: r2 - t2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(t2) {
          let i2 = e.b9;
          if (this._prevEase) {
            const t3 = this._prevEase, a2 = (o.now() - t3.start) / t3.duration, s2 = t3.easing(a2 + 0.01) - t3.easing(a2), r2 = 0.27 / Math.sqrt(s2 * s2 + 0.0001) * 0.01, n2 = Math.sqrt(0.0729 - r2 * r2);
            i2 = e.b8(r2, n2, 0.25, 1);
          }
          return this._prevEase = { start: o.now(), duration: t2, easing: i2 }, i2;
        }
        reset() {
          this._active = false, this._zooming = false, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }

      class ds {
        constructor(t2, e2) {
          this._clickZoom = t2, this._tapZoom = e2;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }

      class _s {
        constructor(t2) {
          this._tr = new Na(t2), this.reset();
        }
        reset() {
          this._active = false;
        }
        dblclick(t2, e2) {
          return t2.preventDefault(), { cameraAnimation: (i2) => {
            i2.easeTo({ duration: 300, zoom: this._tr.zoom + (t2.shiftKey ? -1 : 1), around: this._tr.unproject(e2) }, { originalEvent: t2 });
          } };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }

      class ps {
        constructor() {
          this._tap = new qa({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(t2, e2, i2) {
          if (!this._swipePoint)
            if (this._tapTime) {
              const a2 = e2[0], s2 = t2.timeStamp - this._tapTime < 500, o2 = this._tapPoint.dist(a2) < 30;
              s2 && o2 ? i2.length > 0 && (this._swipePoint = a2, this._swipeTouch = i2[0].identifier) : this.reset();
            } else
              this._tap.touchstart(t2, e2, i2);
        }
        touchmove(t2, e2, i2) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i2[0].identifier !== this._swipeTouch)
                return;
              const a2 = e2[0], s2 = a2.y - this._swipePoint.y;
              return this._swipePoint = a2, t2.preventDefault(), this._active = true, { zoomDelta: s2 / 128 };
            }
          } else
            this._tap.touchmove(t2, e2, i2);
        }
        touchend(t2, e2, i2) {
          if (this._tapTime)
            this._swipePoint && i2.length === 0 && this.reset();
          else {
            const a2 = this._tap.touchend(t2, e2, i2);
            a2 && (this._tapTime = t2.timeStamp, this._tapPoint = a2);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }

      class ms {
        constructor(t2, e2, i2) {
          this._el = t2, this._mousePan = e2, this._touchPan = i2;
        }
        enable(t2) {
          this._inertiaOptions = t2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }

      class fs {
        constructor(t2, e2, i2) {
          this._pitchWithRotate = t2.pitchWithRotate, this._mouseRotate = e2, this._mousePitch = i2;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }

      class gs {
        constructor(t2, e2, i2, a2) {
          this._el = t2, this._touchZoom = e2, this._touchRotate = i2, this._tapDragZoom = a2, this._rotationDisabled = false, this._enabled = true;
        }
        enable(t2) {
          this._touchZoom.enable(t2), this._rotationDisabled || this._touchRotate.enable(t2), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }

      class vs {
        constructor(t2, e2) {
          this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = t2, this._options = e2, this._enabled = false;
        }
        isActive() {
          return false;
        }
        reset() {
        }
        _setupUI() {
          if (this._container)
            return;
          const t2 = this._map.getCanvasContainer();
          t2.classList.add("maplibregl-cooperative-gestures"), this._container = r.create("div", "maplibregl-cooperative-gesture-screen", t2);
          let e2 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
          this._bypassKey === "metaKey" && (e2 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
          const i2 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), a2 = document.createElement("div");
          a2.className = "maplibregl-desktop-message", a2.textContent = e2, this._container.appendChild(a2);
          const s2 = document.createElement("div");
          s2.className = "maplibregl-mobile-message", s2.textContent = i2, this._container.appendChild(s2), this._container.setAttribute("aria-hidden", "true");
        }
        _destroyUI() {
          this._container && (r.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = true;
        }
        disable() {
          this._enabled = false, this._destroyUI();
        }
        isEnabled() {
          return this._enabled;
        }
        isBypassed(t2) {
          return t2[this._bypassKey];
        }
        notifyGestureBlocked(t2, i2) {
          this._enabled && (this._map.fire(new e.k("cooperativegestureprevented", { gestureType: t2, originalEvent: i2 })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
            this._container.classList.remove("maplibregl-show");
          }, 100));
        }
      }
      const xs = (t2) => t2.zoom || t2.drag || t2.pitch || t2.rotate;

      class ys extends e.k {
      }
      function bs(t2) {
        return t2.panDelta && t2.panDelta.mag() || t2.zoomDelta || t2.bearingDelta || t2.pitchDelta;
      }

      class ws {
        constructor(t2, e2) {
          this.handleWindowEvent = (t3) => {
            this.handleEvent(t3, `${t3.type}Window`);
          }, this.handleEvent = (t3, e3) => {
            if (t3.type === "blur")
              return void this.stop(true);
            this._updatingCamera = true;
            const i3 = t3.type === "renderFrame" ? undefined : t3, a2 = { needsRenderFrame: false }, s2 = {}, o2 = {}, n2 = t3.touches, l2 = n2 ? this._getMapTouches(n2) : undefined, h2 = l2 ? r.touchPos(this._map.getCanvas(), l2) : r.mousePos(this._map.getCanvas(), t3);
            for (const { handlerName: r2, handler: n3, allowed: c3 } of this._handlers) {
              if (!n3.isEnabled())
                continue;
              let u6;
              this._blockedByActive(o2, c3, r2) ? n3.reset() : n3[e3 || t3.type] && (u6 = n3[e3 || t3.type](t3, h2, l2), this.mergeHandlerResult(a2, s2, u6, r2, i3), u6 && u6.needsRenderFrame && this._triggerRenderFrame()), (u6 || n3.isActive()) && (o2[r2] = n3);
            }
            const c2 = {};
            for (const t4 in this._previousActiveHandlers)
              o2[t4] || (c2[t4] = i3);
            this._previousActiveHandlers = o2, (Object.keys(c2).length || bs(a2)) && (this._changes.push([a2, s2, c2]), this._triggerRenderFrame()), (Object.keys(o2).length || bs(a2)) && this._map._stop(true), this._updatingCamera = false;
            const { cameraAnimation: u5 } = a2;
            u5 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u5(this._map));
          }, this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ma(t2), this._bearingSnap = e2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(e2);
          const i2 = this._el;
          this._listeners = [[i2, "touchstart", { passive: true }], [i2, "touchmove", { passive: false }], [i2, "touchend", undefined], [i2, "touchcancel", undefined], [i2, "mousedown", undefined], [i2, "mousemove", undefined], [i2, "mouseup", undefined], [document, "mousemove", { capture: true }], [document, "mouseup", undefined], [i2, "mouseover", undefined], [i2, "mouseout", undefined], [i2, "dblclick", undefined], [i2, "click", undefined], [i2, "keydown", { capture: false }], [i2, "keyup", undefined], [i2, "wheel", { passive: false }], [i2, "contextmenu", undefined], [window, "blur", undefined]];
          for (const [t3, e3, i3] of this._listeners)
            r.addEventListener(t3, e3, t3 === document ? this.handleWindowEvent : this.handleEvent, i3);
        }
        destroy() {
          for (const [t2, e2, i2] of this._listeners)
            r.removeEventListener(t2, e2, t2 === document ? this.handleWindowEvent : this.handleEvent, i2);
        }
        _addDefaultHandlers(t2) {
          const e2 = this._map, i2 = e2.getCanvasContainer();
          this._add("mapEvent", new Ba(e2, t2));
          const a2 = e2.boxZoom = new Ua(e2, t2);
          this._add("boxZoom", a2), t2.interactive && t2.boxZoom && a2.enable();
          const s2 = e2.cooperativeGestures = new vs(e2, t2.cooperativeGestures);
          this._add("cooperativeGestures", s2), t2.cooperativeGestures && s2.enable();
          const o2 = new Va(e2), n2 = new _s(e2);
          e2.doubleClickZoom = new ds(n2, o2), this._add("tapZoom", o2), this._add("clickZoom", n2), t2.interactive && t2.doubleClickZoom && e2.doubleClickZoom.enable();
          const l2 = new ps;
          this._add("tapDragZoom", l2);
          const h2 = e2.touchPitch = new rs(e2);
          this._add("touchPitch", h2), t2.interactive && t2.touchPitch && e2.touchPitch.enable(t2.touchPitch);
          const c2 = Ka(t2), u5 = Ja(t2);
          e2.dragRotate = new fs(t2, c2, u5), this._add("mouseRotate", c2, ["mousePitch"]), this._add("mousePitch", u5, ["mouseRotate"]), t2.interactive && t2.dragRotate && e2.dragRotate.enable();
          const d2 = (({ enable: t3, clickTolerance: e3 }) => {
            const i3 = new Wa({ checkCorrectEvent: (t4) => r.mouseButton(t4) === 0 && !t4.ctrlKey });
            return new Ga({ clickTolerance: e3, move: (t4, e4) => ({ around: e4, panDelta: e4.sub(t4) }), activateOnStart: true, moveStateManager: i3, enable: t3, assignEvents: Xa });
          })(t2), _2 = new Ya(t2, e2);
          e2.dragPan = new ms(i2, d2, _2), this._add("mousePan", d2), this._add("touchPan", _2, ["touchZoom", "touchRotate"]), t2.interactive && t2.dragPan && e2.dragPan.enable(t2.dragPan);
          const p2 = new ss, m2 = new is;
          e2.touchZoomRotate = new gs(i2, m2, p2, l2), this._add("touchRotate", p2, ["touchPan", "touchZoom"]), this._add("touchZoom", m2, ["touchPan", "touchRotate"]), t2.interactive && t2.touchZoomRotate && e2.touchZoomRotate.enable(t2.touchZoomRotate);
          const f2 = e2.scrollZoom = new us(e2, () => this._triggerRenderFrame());
          this._add("scrollZoom", f2, ["mousePan"]), t2.interactive && t2.scrollZoom && e2.scrollZoom.enable(t2.scrollZoom);
          const g2 = e2.keyboard = new ls(e2);
          this._add("keyboard", g2), t2.interactive && t2.keyboard && e2.keyboard.enable(), this._add("blockableMapEvent", new Oa(e2));
        }
        _add(t2, e2, i2) {
          this._handlers.push({ handlerName: t2, handler: e2, allowed: i2 }), this._handlersById[t2] = e2;
        }
        stop(t2) {
          if (!this._updatingCamera) {
            for (const { handler: t3 } of this._handlers)
              t3.reset();
            this._inertia.clear(), this._fireEvents({}, {}, t2), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: t2 } of this._handlers)
            if (t2.isActive())
              return true;
          return false;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return Boolean(xs(this._eventsInProgress)) || this.isZooming();
        }
        _blockedByActive(t2, e2, i2) {
          for (const a2 in t2)
            if (a2 !== i2 && (!e2 || e2.indexOf(a2) < 0))
              return true;
          return false;
        }
        _getMapTouches(t2) {
          const e2 = [];
          for (const i2 of t2)
            this._el.contains(i2.target) && e2.push(i2);
          return e2;
        }
        mergeHandlerResult(t2, i2, a2, s2, o2) {
          if (!a2)
            return;
          e.e(t2, a2);
          const r2 = { handlerName: s2, originalEvent: a2.originalEvent || o2 };
          a2.zoomDelta !== undefined && (i2.zoom = r2), a2.panDelta !== undefined && (i2.drag = r2), a2.pitchDelta !== undefined && (i2.pitch = r2), a2.bearingDelta !== undefined && (i2.rotate = r2);
        }
        _applyChanges() {
          const t2 = {}, i2 = {}, a2 = {};
          for (const [s2, o2, r2] of this._changes)
            s2.panDelta && (t2.panDelta = (t2.panDelta || new e.P(0, 0))._add(s2.panDelta)), s2.zoomDelta && (t2.zoomDelta = (t2.zoomDelta || 0) + s2.zoomDelta), s2.bearingDelta && (t2.bearingDelta = (t2.bearingDelta || 0) + s2.bearingDelta), s2.pitchDelta && (t2.pitchDelta = (t2.pitchDelta || 0) + s2.pitchDelta), s2.around !== undefined && (t2.around = s2.around), s2.pinchAround !== undefined && (t2.pinchAround = s2.pinchAround), s2.noInertia && (t2.noInertia = s2.noInertia), e.e(i2, o2), e.e(a2, r2);
          this._updateMapTransform(t2, i2, a2), this._changes = [];
        }
        _updateMapTransform(t2, e2, i2) {
          const a2 = this._map, s2 = a2._getTransformForUpdate(), o2 = a2.terrain;
          if (!(bs(t2) || o2 && this._terrainMovement))
            return this._fireEvents(e2, i2, true);
          let { panDelta: r2, zoomDelta: n2, bearingDelta: l2, pitchDelta: h2, around: c2, pinchAround: u5 } = t2;
          u5 !== undefined && (c2 = u5), a2._stop(true), c2 = c2 || a2.transform.centerPoint;
          const d2 = s2.pointLocation(r2 ? c2.sub(r2) : c2);
          l2 && (s2.bearing += l2), h2 && (s2.pitch += h2), n2 && (s2.zoom += n2), o2 ? this._terrainMovement || !e2.drag && !e2.zoom ? e2.drag && this._terrainMovement ? s2.center = s2.pointLocation(s2.centerPoint.sub(r2)) : s2.setLocationAtPoint(d2, c2) : (this._terrainMovement = true, this._map._elevationFreeze = true, s2.setLocationAtPoint(d2, c2)) : s2.setLocationAtPoint(d2, c2), a2._applyUpdatedTransform(s2), this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(e2, i2, true);
        }
        _fireEvents(t2, i2, a2) {
          const s2 = xs(this._eventsInProgress), r2 = xs(t2), n2 = {};
          for (const e2 in t2) {
            const { originalEvent: i3 } = t2[e2];
            this._eventsInProgress[e2] || (n2[`${e2}start`] = i3), this._eventsInProgress[e2] = t2[e2];
          }
          !s2 && r2 && this._fireEvent("movestart", r2.originalEvent);
          for (const t3 in n2)
            this._fireEvent(t3, n2[t3]);
          r2 && this._fireEvent("move", r2.originalEvent);
          for (const e2 in t2) {
            const { originalEvent: i3 } = t2[e2];
            this._fireEvent(e2, i3);
          }
          const l2 = {};
          let h2;
          for (const t3 in this._eventsInProgress) {
            const { handlerName: e2, originalEvent: a3 } = this._eventsInProgress[t3];
            this._handlersById[e2].isActive() || (delete this._eventsInProgress[t3], h2 = i2[e2] || a3, l2[`${t3}end`] = h2);
          }
          for (const t3 in l2)
            this._fireEvent(t3, l2[t3]);
          const c2 = xs(this._eventsInProgress), u5 = (s2 || r2) && !c2;
          if (u5 && this._terrainMovement) {
            this._map._elevationFreeze = false, this._terrainMovement = false;
            const t3 = this._map._getTransformForUpdate();
            t3.recalculateZoom(this._map.terrain), this._map._applyUpdatedTransform(t3);
          }
          if (a2 && u5) {
            this._updatingCamera = true;
            const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (t4) => t4 !== 0 && -this._bearingSnap < t4 && t4 < this._bearingSnap;
            !t3 || !t3.essential && o.prefersReducedMotion ? (this._map.fire(new e.k("moveend", { originalEvent: h2 })), i3(this._map.getBearing()) && this._map.resetNorth()) : (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), t3.freezeElevation = true, this._map.easeTo(t3, { originalEvent: h2 })), this._updatingCamera = false;
          }
        }
        _fireEvent(t2, i2) {
          this._map.fire(new e.k(t2, i2 ? { originalEvent: i2 } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t2) => {
            delete this._frameId, this.handleEvent(new ys("renderFrame", { timeStamp: t2 })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === undefined && (this._frameId = this._requestFrame());
        }
      }

      class Ts extends e.E {
        constructor(t2, e2) {
          super(), this._renderFrameCallback = () => {
            const t3 = Math.min((o.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(t3)), t3 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = false, this._zooming = false, this.transform = t2, this._bearingSnap = e2.bearingSnap, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        getCenter() {
          return new e.N(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(t2, e2) {
          return this.jumpTo({ center: t2 }, e2);
        }
        panBy(t2, i2, a2) {
          return t2 = e.P.convert(t2).mult(-1), this.panTo(this.transform.center, e.e({ offset: t2 }, i2), a2);
        }
        panTo(t2, i2, a2) {
          return this.easeTo(e.e({ center: t2 }, i2), a2);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(t2, e2) {
          return this.jumpTo({ zoom: t2 }, e2), this;
        }
        zoomTo(t2, i2, a2) {
          return this.easeTo(e.e({ zoom: t2 }, i2), a2);
        }
        zoomIn(t2, e2) {
          return this.zoomTo(this.getZoom() + 1, t2, e2), this;
        }
        zoomOut(t2, e2) {
          return this.zoomTo(this.getZoom() - 1, t2, e2), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(t2, e2) {
          return this.jumpTo({ bearing: t2 }, e2), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(t2, e2) {
          return this.jumpTo({ padding: t2 }, e2), this;
        }
        rotateTo(t2, i2, a2) {
          return this.easeTo(e.e({ bearing: t2 }, i2), a2);
        }
        resetNorth(t2, i2) {
          return this.rotateTo(0, e.e({ duration: 1000 }, t2), i2), this;
        }
        resetNorthPitch(t2, i2) {
          return this.easeTo(e.e({ bearing: 0, pitch: 0, duration: 1000 }, t2), i2), this;
        }
        snapToNorth(t2, e2) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t2, e2) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(t2, e2) {
          return this.jumpTo({ pitch: t2 }, e2), this;
        }
        cameraForBounds(t2, e2) {
          t2 = H.convert(t2).adjustAntiMeridian();
          const i2 = e2 && e2.bearing || 0;
          return this._cameraForBoxAndBearing(t2.getNorthWest(), t2.getSouthEast(), i2, e2);
        }
        _cameraForBoxAndBearing(t2, i2, a2, s2) {
          const o2 = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (s2 = e.e({ padding: o2, offset: [0, 0], maxZoom: this.transform.maxZoom }, s2)).padding == "number") {
            const t3 = s2.padding;
            s2.padding = { top: t3, bottom: t3, right: t3, left: t3 };
          }
          s2.padding = e.e(o2, s2.padding);
          const r2 = this.transform, n2 = r2.padding, l2 = new H(t2, i2), h2 = r2.project(l2.getNorthWest()), c2 = r2.project(l2.getNorthEast()), u5 = r2.project(l2.getSouthEast()), d2 = r2.project(l2.getSouthWest()), _2 = e.ba(-a2), p2 = h2.rotate(_2), m2 = c2.rotate(_2), f2 = u5.rotate(_2), g2 = d2.rotate(_2), v3 = new e.P(Math.max(p2.x, m2.x, g2.x, f2.x), Math.max(p2.y, m2.y, g2.y, f2.y)), x2 = new e.P(Math.min(p2.x, m2.x, g2.x, f2.x), Math.min(p2.y, m2.y, g2.y, f2.y)), y2 = v3.sub(x2), b2 = (r2.width - (n2.left + n2.right + s2.padding.left + s2.padding.right)) / y2.x, w2 = (r2.height - (n2.top + n2.bottom + s2.padding.top + s2.padding.bottom)) / y2.y;
          if (w2 < 0 || b2 < 0)
            return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const T2 = Math.min(r2.scaleZoom(r2.scale * Math.min(b2, w2)), s2.maxZoom), I2 = e.P.convert(s2.offset), E2 = new e.P((s2.padding.left - s2.padding.right) / 2, (s2.padding.top - s2.padding.bottom) / 2).rotate(e.ba(a2)), P2 = I2.add(E2).mult(r2.scale / r2.zoomScale(T2));
          return { center: r2.unproject(h2.add(u5).div(2).sub(P2)), zoom: T2, bearing: a2 };
        }
        fitBounds(t2, e2, i2) {
          return this._fitInternal(this.cameraForBounds(t2, e2), e2, i2);
        }
        fitScreenCoordinates(t2, i2, a2, s2, o2) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(e.P.convert(t2)), this.transform.pointLocation(e.P.convert(i2)), a2, s2), s2, o2);
        }
        _fitInternal(t2, i2, a2) {
          return t2 ? (delete (i2 = e.e(t2, i2)).padding, i2.linear ? this.easeTo(i2, a2) : this.flyTo(i2, a2)) : this;
        }
        jumpTo(t2, i2) {
          this.stop();
          const a2 = this._getTransformForUpdate();
          let s2 = false, o2 = false, r2 = false;
          return "zoom" in t2 && a2.zoom !== +t2.zoom && (s2 = true, a2.zoom = +t2.zoom), t2.center !== undefined && (a2.center = e.N.convert(t2.center)), "bearing" in t2 && a2.bearing !== +t2.bearing && (o2 = true, a2.bearing = +t2.bearing), "pitch" in t2 && a2.pitch !== +t2.pitch && (r2 = true, a2.pitch = +t2.pitch), t2.padding == null || a2.isPaddingEqual(t2.padding) || (a2.padding = t2.padding), this._applyUpdatedTransform(a2), this.fire(new e.k("movestart", i2)).fire(new e.k("move", i2)), s2 && this.fire(new e.k("zoomstart", i2)).fire(new e.k("zoom", i2)).fire(new e.k("zoomend", i2)), o2 && this.fire(new e.k("rotatestart", i2)).fire(new e.k("rotate", i2)).fire(new e.k("rotateend", i2)), r2 && this.fire(new e.k("pitchstart", i2)).fire(new e.k("pitch", i2)).fire(new e.k("pitchend", i2)), this.fire(new e.k("moveend", i2));
        }
        calculateCameraOptionsFromTo(t2, i2, a2, s2 = 0) {
          const o2 = e.Z.fromLngLat(t2, i2), r2 = e.Z.fromLngLat(a2, s2), n2 = r2.x - o2.x, l2 = r2.y - o2.y, h2 = r2.z - o2.z, c2 = Math.hypot(n2, l2, h2);
          if (c2 === 0)
            throw new Error("Can't calculate camera options with same From and To");
          const u5 = Math.hypot(n2, l2), d2 = this.transform.scaleZoom(this.transform.cameraToCenterDistance / c2 / this.transform.tileSize), _2 = 180 * Math.atan2(n2, -l2) / Math.PI;
          let p2 = 180 * Math.acos(u5 / c2) / Math.PI;
          return p2 = h2 < 0 ? 90 - p2 : 90 + p2, { center: r2.toLngLat(), zoom: d2, pitch: p2, bearing: _2 };
        }
        easeTo(t2, i2) {
          var a2;
          this._stop(false, t2.easeId), ((t2 = e.e({ offset: [0, 0], duration: 500, easing: e.b9 }, t2)).animate === false || !t2.essential && o.prefersReducedMotion) && (t2.duration = 0);
          const s2 = this._getTransformForUpdate(), r2 = s2.zoom, n2 = s2.bearing, l2 = s2.pitch, h2 = s2.padding, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, u5 = "pitch" in t2 ? +t2.pitch : l2, d2 = "padding" in t2 ? t2.padding : s2.padding, _2 = e.P.convert(t2.offset);
          let p2 = s2.centerPoint.add(_2);
          const m2 = s2.pointLocation(p2), { center: f2, zoom: g2 } = s2.getConstrained(e.N.convert(t2.center || m2), (a2 = t2.zoom) !== null && a2 !== undefined ? a2 : r2);
          this._normalizeCenter(f2, s2);
          const v3 = s2.project(m2), x2 = s2.project(f2).sub(v3), y2 = s2.zoomScale(g2 - r2);
          let b2, w2;
          t2.around && (b2 = e.N.convert(t2.around), w2 = s2.locationPoint(b2));
          const T2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return this._zooming = this._zooming || g2 !== r2, this._rotating = this._rotating || n2 !== c2, this._pitching = this._pitching || u5 !== l2, this._padding = !s2.isPaddingEqual(d2), this._easeId = t2.easeId, this._prepareEase(i2, t2.noMoveStart, T2), this.terrain && this._prepareElevation(f2), this._ease((a3) => {
            if (this._zooming && (s2.zoom = e.y.number(r2, g2, a3)), this._rotating && (s2.bearing = e.y.number(n2, c2, a3)), this._pitching && (s2.pitch = e.y.number(l2, u5, a3)), this._padding && (s2.interpolatePadding(h2, d2, a3), p2 = s2.centerPoint.add(_2)), this.terrain && !t2.freezeElevation && this._updateElevation(a3), b2)
              s2.setLocationAtPoint(b2, w2);
            else {
              const t3 = s2.zoomScale(s2.zoom - r2), e2 = g2 > r2 ? Math.min(2, y2) : Math.max(0.5, y2), i3 = Math.pow(e2, 1 - a3), o2 = s2.unproject(v3.add(x2.mult(a3 * i3)).mult(t3));
              s2.setLocationAtPoint(s2.renderWorldCopies ? o2.wrap() : o2, p2);
            }
            this._applyUpdatedTransform(s2), this._fireMoveEvents(i2);
          }, (e2) => {
            this.terrain && t2.freezeElevation && this._finalizeElevation(), this._afterEase(i2, e2);
          }, t2), this;
        }
        _prepareEase(t2, i2, a2 = {}) {
          this._moving = true, i2 || a2.moving || this.fire(new e.k("movestart", t2)), this._zooming && !a2.zooming && this.fire(new e.k("zoomstart", t2)), this._rotating && !a2.rotating && this.fire(new e.k("rotatestart", t2)), this._pitching && !a2.pitching && this.fire(new e.k("pitchstart", t2));
        }
        _prepareElevation(t2) {
          this._elevationCenter = t2, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t2, this.transform.tileZoom), this._elevationFreeze = true;
        }
        _updateElevation(t2) {
          this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          const i2 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (t2 < 1 && i2 !== this._elevationTarget) {
            const e2 = this._elevationTarget - this._elevationStart;
            this._elevationStart += t2 * (e2 - (i2 - (e2 * t2 + this._elevationStart)) / (1 - t2)), this._elevationTarget = i2;
          }
          this.transform.elevation = e.y.number(this._elevationStart, this._elevationTarget, t2);
        }
        _finalizeElevation() {
          this._elevationFreeze = false, this.transform.recalculateZoom(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _elevateCameraIfInsideTerrain(t2) {
          const e2 = t2.getCameraPosition(), i2 = this.terrain.getElevationForLngLatZoom(e2.lngLat, t2.zoom);
          if (e2.altitude < i2) {
            const a2 = this.calculateCameraOptionsFromTo(e2.lngLat, i2, t2.center, t2.elevation);
            return { pitch: a2.pitch, zoom: a2.zoom };
          }
          return {};
        }
        _applyUpdatedTransform(t2) {
          const e2 = [];
          if (this.terrain && e2.push((t3) => this._elevateCameraIfInsideTerrain(t3)), this.transformCameraUpdate && e2.push((t3) => this.transformCameraUpdate(t3)), !e2.length)
            return;
          const i2 = t2.clone();
          for (const t3 of e2) {
            const e3 = i2.clone(), { center: a2, zoom: s2, pitch: o2, bearing: r2, elevation: n2 } = t3(e3);
            a2 && (e3.center = a2), s2 !== undefined && (e3.zoom = s2), o2 !== undefined && (e3.pitch = o2), r2 !== undefined && (e3.bearing = r2), n2 !== undefined && (e3.elevation = n2), i2.apply(e3);
          }
          this.transform.apply(i2);
        }
        _fireMoveEvents(t2) {
          this.fire(new e.k("move", t2)), this._zooming && this.fire(new e.k("zoom", t2)), this._rotating && this.fire(new e.k("rotate", t2)), this._pitching && this.fire(new e.k("pitch", t2));
        }
        _afterEase(t2, i2) {
          if (this._easeId && i2 && this._easeId === i2)
            return;
          delete this._easeId;
          const a2 = this._zooming, s2 = this._rotating, o2 = this._pitching;
          this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, a2 && this.fire(new e.k("zoomend", t2)), s2 && this.fire(new e.k("rotateend", t2)), o2 && this.fire(new e.k("pitchend", t2)), this.fire(new e.k("moveend", t2));
        }
        flyTo(t2, i2) {
          var a2;
          if (!t2.essential && o.prefersReducedMotion) {
            const a3 = e.M(t2, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(a3, i2);
          }
          this.stop(), t2 = e.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.b9 }, t2);
          const s2 = this._getTransformForUpdate(), r2 = s2.zoom, n2 = s2.bearing, l2 = s2.pitch, h2 = s2.padding, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, u5 = "pitch" in t2 ? +t2.pitch : l2, d2 = "padding" in t2 ? t2.padding : s2.padding, _2 = e.P.convert(t2.offset);
          let p2 = s2.centerPoint.add(_2);
          const m2 = s2.pointLocation(p2), { center: f2, zoom: g2 } = s2.getConstrained(e.N.convert(t2.center || m2), (a2 = t2.zoom) !== null && a2 !== undefined ? a2 : r2);
          this._normalizeCenter(f2, s2);
          const v3 = s2.zoomScale(g2 - r2), x2 = s2.project(m2), y2 = s2.project(f2).sub(x2);
          let b2 = t2.curve;
          const w2 = Math.max(s2.width, s2.height), T2 = w2 / v3, I2 = y2.mag();
          if ("minZoom" in t2) {
            const i3 = e.ac(Math.min(t2.minZoom, r2, g2), s2.minZoom, s2.maxZoom), a3 = w2 / s2.zoomScale(i3 - r2);
            b2 = Math.sqrt(a3 / I2 * 2);
          }
          const E2 = b2 * b2;
          function P2(t3) {
            const e2 = (T2 * T2 - w2 * w2 + (t3 ? -1 : 1) * E2 * E2 * I2 * I2) / (2 * (t3 ? T2 : w2) * E2 * I2);
            return Math.log(Math.sqrt(e2 * e2 + 1) - e2);
          }
          function C3(t3) {
            return (Math.exp(t3) - Math.exp(-t3)) / 2;
          }
          function S2(t3) {
            return (Math.exp(t3) + Math.exp(-t3)) / 2;
          }
          const z2 = P2(false);
          let D3 = function(t3) {
            return S2(z2) / S2(z2 + b2 * t3);
          }, M2 = function(t3) {
            return w2 * ((S2(z2) * (C3(e2 = z2 + b2 * t3) / S2(e2)) - C3(z2)) / E2) / I2;
            var e2;
          }, A2 = (P2(true) - z2) / b2;
          if (Math.abs(I2) < 0.000001 || !isFinite(A2)) {
            if (Math.abs(w2 - T2) < 0.000001)
              return this.easeTo(t2, i2);
            const e2 = T2 < w2 ? -1 : 1;
            A2 = Math.abs(Math.log(T2 / w2)) / b2, M2 = () => 0, D3 = (t3) => Math.exp(e2 * b2 * t3);
          }
          return t2.duration = "duration" in t2 ? +t2.duration : 1000 * A2 / ("screenSpeed" in t2 ? +t2.screenSpeed / b2 : +t2.speed), t2.maxDuration && t2.duration > t2.maxDuration && (t2.duration = 0), this._zooming = true, this._rotating = n2 !== c2, this._pitching = u5 !== l2, this._padding = !s2.isPaddingEqual(d2), this._prepareEase(i2, false), this.terrain && this._prepareElevation(f2), this._ease((a3) => {
            const o2 = a3 * A2, m3 = 1 / D3(o2);
            s2.zoom = a3 === 1 ? g2 : r2 + s2.scaleZoom(m3), this._rotating && (s2.bearing = e.y.number(n2, c2, a3)), this._pitching && (s2.pitch = e.y.number(l2, u5, a3)), this._padding && (s2.interpolatePadding(h2, d2, a3), p2 = s2.centerPoint.add(_2)), this.terrain && !t2.freezeElevation && this._updateElevation(a3);
            const v4 = a3 === 1 ? f2 : s2.unproject(x2.add(y2.mult(M2(o2))).mult(m3));
            s2.setLocationAtPoint(s2.renderWorldCopies ? v4.wrap() : v4, p2), this._applyUpdatedTransform(s2), this._fireMoveEvents(i2);
          }, () => {
            this.terrain && t2.freezeElevation && this._finalizeElevation(), this._afterEase(i2);
          }, t2), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(t2, e2) {
          var i2;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const t3 = this._onEaseEnd;
            delete this._onEaseEnd, t3.call(this, e2);
          }
          return t2 || (i2 = this.handlers) === null || i2 === undefined || i2.stop(false), this;
        }
        _ease(t2, e2, i2) {
          i2.animate === false || i2.duration === 0 ? (t2(1), e2()) : (this._easeStart = o.now(), this._easeOptions = i2, this._onEaseFrame = t2, this._onEaseEnd = e2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(t2, i2) {
          t2 = e.b3(t2, -180, 180);
          const a2 = Math.abs(t2 - i2);
          return Math.abs(t2 - 360 - i2) < a2 && (t2 -= 360), Math.abs(t2 + 360 - i2) < a2 && (t2 += 360), t2;
        }
        _normalizeCenter(t2, e2) {
          if (!e2.renderWorldCopies || e2.lngRange)
            return;
          const i2 = t2.lng - e2.center.lng;
          t2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
        }
        queryTerrainElevation(t2) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(e.N.convert(t2), this.transform.tileZoom) - this.transform.elevation : null;
        }
      }
      const Is = { compact: true, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };

      class Es {
        constructor(t2 = Is) {
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (t3) => {
            !t3 || t3.sourceDataType !== "metadata" && t3.sourceDataType !== "visibility" && t3.dataType !== "style" && t3.type !== "terrain" || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = t2;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(t2) {
          return this._map = t2, this._compact = this.options.compact, this._container = r.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = r.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = r.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          r.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = undefined, this._compact = undefined, this._attribHTML = undefined;
        }
        _setElementTitle(t2, e2) {
          const i2 = this._map._getUIString(`AttributionControl.${e2}`);
          t2.title = i2, t2.setAttribute("aria-label", i2);
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let t2 = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t2 = t2.concat(this.options.customAttribution.map((t3) => typeof t3 != "string" ? "" : t3)) : typeof this.options.customAttribution == "string" && t2.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const t3 = this._map.style.stylesheet;
            this.styleOwner = t3.owner, this.styleId = t3.id;
          }
          const e2 = this._map.style.sourceCaches;
          for (const i3 in e2) {
            const a2 = e2[i3];
            if (a2.used || a2.usedForTerrain) {
              const e3 = a2.getSource();
              e3.attribution && t2.indexOf(e3.attribution) < 0 && t2.push(e3.attribution);
            }
          }
          t2 = t2.filter((t3) => String(t3).trim()), t2.sort((t3, e3) => t3.length - e3.length), t2 = t2.filter((e3, i3) => {
            for (let a2 = i3 + 1;a2 < t2.length; a2++)
              if (t2[a2].indexOf(e3) >= 0)
                return false;
            return true;
          });
          const i2 = t2.join(" | ");
          i2 !== this._attribHTML && (this._attribHTML = i2, t2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }

      class Ps {
        constructor(t2 = {}) {
          this._updateCompact = () => {
            const t3 = this._container.children;
            if (t3.length) {
              const e2 = t3[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && e2.classList.add("maplibregl-compact") : e2.classList.remove("maplibregl-compact");
            }
          }, this.options = t2;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(t2) {
          this._map = t2, this._compact = this.options && this.options.compact, this._container = r.create("div", "maplibregl-ctrl");
          const e2 = r.create("a", "maplibregl-ctrl-logo");
          return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://maplibre.org/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          r.remove(this._container), this._map.off("resize", this._updateCompact), this._map = undefined, this._compact = undefined;
        }
      }

      class Cs {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        }
        add(t2) {
          const e2 = ++this._id;
          return this._queue.push({ callback: t2, id: e2, cancelled: false }), e2;
        }
        remove(t2) {
          const e2 = this._currentlyRunning, i2 = e2 ? this._queue.concat(e2) : this._queue;
          for (const e3 of i2)
            if (e3.id === t2)
              return void (e3.cancelled = true);
        }
        run(t2 = 0) {
          if (this._currentlyRunning)
            throw new Error("Attempting to run(), but is already running.");
          const e2 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const i2 of e2)
            if (!i2.cancelled && (i2.callback(t2), this._cleared))
              break;
          this._cleared = false, this._currentlyRunning = false;
        }
        clear() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        }
      }
      var Ss = e.Y([{ name: "a_pos3d", type: "Int16", components: 3 }]);

      class zs extends e.E {
        constructor(t2) {
          super(), this.sourceCache = t2, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, t2.usedForTerrain = true, t2.tileSize = this.tileSize * 2 ** this.deltaZoom;
        }
        destruct() {
          this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
        }
        update(t2, i2) {
          this.sourceCache.update(t2, i2), this._renderableTilesKeys = [];
          const a2 = {};
          for (const s2 of t2.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i2 }))
            a2[s2.key] = true, this._renderableTilesKeys.push(s2.key), this._tiles[s2.key] || (s2.posMatrix = new Float64Array(16), e.aP(s2.posMatrix, 0, e.X, 0, e.X, 0, 1), this._tiles[s2.key] = new lt(s2, this.tileSize));
          for (const t3 in this._tiles)
            a2[t3] || delete this._tiles[t3];
        }
        freeRtt(t2) {
          for (const e2 in this._tiles) {
            const i2 = this._tiles[e2];
            (!t2 || i2.tileID.equals(t2) || i2.tileID.isChildOf(t2) || t2.isChildOf(i2.tileID)) && (i2.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((t2) => this.getTileByID(t2));
        }
        getTileByID(t2) {
          return this._tiles[t2];
        }
        getTerrainCoords(t2) {
          const i2 = {};
          for (const a2 of this._renderableTilesKeys) {
            const s2 = this._tiles[a2].tileID;
            if (s2.canonical.equals(t2.canonical)) {
              const s3 = t2.clone();
              s3.posMatrix = new Float64Array(16), e.aP(s3.posMatrix, 0, e.X, 0, e.X, 0, 1), i2[a2] = s3;
            } else if (s2.canonical.isChildOf(t2.canonical)) {
              const o2 = t2.clone();
              o2.posMatrix = new Float64Array(16);
              const r2 = s2.canonical.z - t2.canonical.z, n2 = s2.canonical.x - (s2.canonical.x >> r2 << r2), l2 = s2.canonical.y - (s2.canonical.y >> r2 << r2), h2 = e.X >> r2;
              e.aP(o2.posMatrix, 0, h2, 0, h2, 0, 1), e.J(o2.posMatrix, o2.posMatrix, [-n2 * h2, -l2 * h2, 0]), i2[a2] = o2;
            } else if (t2.canonical.isChildOf(s2.canonical)) {
              const o2 = t2.clone();
              o2.posMatrix = new Float64Array(16);
              const r2 = t2.canonical.z - s2.canonical.z, n2 = t2.canonical.x - (t2.canonical.x >> r2 << r2), l2 = t2.canonical.y - (t2.canonical.y >> r2 << r2), h2 = e.X >> r2;
              e.aP(o2.posMatrix, 0, e.X, 0, e.X, 0, 1), e.J(o2.posMatrix, o2.posMatrix, [n2 * h2, l2 * h2, 0]), e.K(o2.posMatrix, o2.posMatrix, [1 / 2 ** r2, 1 / 2 ** r2, 0]), i2[a2] = o2;
            }
          }
          return i2;
        }
        getSourceTile(t2, e2) {
          const i2 = this.sourceCache._source;
          let a2 = t2.overscaledZ - this.deltaZoom;
          if (a2 > i2.maxzoom && (a2 = i2.maxzoom), a2 < i2.minzoom)
            return null;
          this._sourceTileCache[t2.key] || (this._sourceTileCache[t2.key] = t2.scaledTo(a2).key);
          let s2 = this.sourceCache.getTileByID(this._sourceTileCache[t2.key]);
          if ((!s2 || !s2.dem) && e2)
            for (;a2 >= i2.minzoom && (!s2 || !s2.dem); )
              s2 = this.sourceCache.getTileByID(t2.scaledTo(a2--).key);
          return s2;
        }
        tilesAfterTime(t2 = Date.now()) {
          return Object.values(this._tiles).filter((e2) => e2.timeAdded >= t2);
        }
      }

      class Ds {
        constructor(t2, e2, i2) {
          this.painter = t2, this.sourceCache = new zs(e2), this.options = i2, this.exaggeration = typeof i2.exaggeration == "number" ? i2.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(t2, i2, a2, s2 = e.X) {
          var o2;
          if (!(i2 >= 0 && i2 < s2 && a2 >= 0 && a2 < s2))
            return 0;
          const r2 = this.getTerrainData(t2), n2 = (o2 = r2.tile) === null || o2 === undefined ? undefined : o2.dem;
          if (!n2)
            return 0;
          const l2 = function(t3, e2, i3) {
            var a3 = e2[0], s3 = e2[1];
            return t3[0] = i3[0] * a3 + i3[4] * s3 + i3[12], t3[1] = i3[1] * a3 + i3[5] * s3 + i3[13], t3;
          }([], [i2 / s2 * e.X, a2 / s2 * e.X], r2.u_terrain_matrix), h2 = [l2[0] * n2.dim, l2[1] * n2.dim], c2 = Math.floor(h2[0]), u5 = Math.floor(h2[1]), d2 = h2[0] - c2, _2 = h2[1] - u5;
          return n2.get(c2, u5) * (1 - d2) * (1 - _2) + n2.get(c2 + 1, u5) * d2 * (1 - _2) + n2.get(c2, u5 + 1) * (1 - d2) * _2 + n2.get(c2 + 1, u5 + 1) * d2 * _2;
        }
        getElevationForLngLatZoom(t2, i2) {
          if (!e.bb(i2, t2.wrap()))
            return 0;
          const { tileID: a2, mercatorX: s2, mercatorY: o2 } = this._getOverscaledTileIDFromLngLatZoom(t2, i2);
          return this.getElevation(a2, s2 % e.X, o2 % e.X, e.X);
        }
        getElevation(t2, i2, a2, s2 = e.X) {
          return this.getDEMElevation(t2, i2, a2, s2) * this.exaggeration;
        }
        getTerrainData(t2) {
          if (!this._emptyDemTexture) {
            const t3 = this.painter.context, i3 = new e.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new b(t3, i3, t3.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new b(t3, new e.R({ width: 1, height: 1 }), t3.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(t3.gl.NEAREST, t3.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = e.an([]);
          }
          const i2 = this.sourceCache.getSourceTile(t2, true);
          if (i2 && i2.dem && (!i2.demTexture || i2.needsTerrainPrepare)) {
            const t3 = this.painter.context;
            i2.demTexture = this.painter.getTileTexture(i2.dem.stride), i2.demTexture ? i2.demTexture.update(i2.dem.getPixels(), { premultiply: false }) : i2.demTexture = new b(t3, i2.dem.getPixels(), t3.gl.RGBA, { premultiply: false }), i2.demTexture.bind(t3.gl.NEAREST, t3.gl.CLAMP_TO_EDGE), i2.needsTerrainPrepare = false;
          }
          const a2 = i2 && i2 + i2.tileID.key + t2.key;
          if (a2 && !this._demMatrixCache[a2]) {
            const a3 = this.sourceCache.sourceCache._source.maxzoom;
            let s2 = t2.canonical.z - i2.tileID.canonical.z;
            t2.overscaledZ > t2.canonical.z && (t2.canonical.z >= a3 ? s2 = t2.canonical.z - a3 : e.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const o2 = t2.canonical.x - (t2.canonical.x >> s2 << s2), r2 = t2.canonical.y - (t2.canonical.y >> s2 << s2), n2 = e.bc(new Float64Array(16), [1 / (e.X << s2), 1 / (e.X << s2), 0]);
            e.J(n2, n2, [o2 * e.X, r2 * e.X, 0]), this._demMatrixCache[t2.key] = { matrix: n2, coord: t2 };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: i2 && i2.dem && i2.dem.dim || 1, u_terrain_matrix: a2 ? this._demMatrixCache[t2.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i2 && i2.dem && i2.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i2 && i2.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i2 };
        }
        getFramebuffer(t2) {
          const e2 = this.painter, i2 = e2.width / devicePixelRatio, a2 = e2.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === i2 && this._fbo.height === a2 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new b(e2.context, { width: i2, height: a2, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new b(e2.context, { width: i2, height: a2, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e2.context.createFramebuffer(i2, a2, true, false), this._fbo.depthAttachment.set(e2.context.createRenderbuffer(e2.context.gl.DEPTH_COMPONENT16, i2, a2))), this._fbo.colorAttachment.set(t2 === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const t2 = this.painter.context;
          if (this._coordsTexture)
            return this._coordsTexture;
          const i2 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let t3 = 0, e2 = 0;t3 < this._coordsTextureSize; t3++)
            for (let a3 = 0;a3 < this._coordsTextureSize; a3++, e2 += 4)
              i2[e2 + 0] = 255 & a3, i2[e2 + 1] = 255 & t3, i2[e2 + 2] = a3 >> 8 << 4 | t3 >> 8, i2[e2 + 3] = 0;
          const a2 = new e.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i2.buffer)), s2 = new b(t2, a2, t2.gl.RGBA, { premultiply: false });
          return s2.bind(t2.gl.NEAREST, t2.gl.CLAMP_TO_EDGE), this._coordsTexture = s2, s2;
        }
        pointCoordinate(t2) {
          this.painter.maybeDrawDepthAndCoords(true);
          const i2 = new Uint8Array(4), a2 = this.painter.context, s2 = a2.gl, o2 = Math.round(t2.x * this.painter.pixelRatio / devicePixelRatio), r2 = Math.round(t2.y * this.painter.pixelRatio / devicePixelRatio), n2 = Math.round(this.painter.height / devicePixelRatio);
          a2.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), s2.readPixels(o2, n2 - r2 - 1, 1, 1, s2.RGBA, s2.UNSIGNED_BYTE, i2), a2.bindFramebuffer.set(null);
          const l2 = i2[0] + (i2[2] >> 4 << 8), h2 = i2[1] + ((15 & i2[2]) << 8), c2 = this.coordsIndex[255 - i2[3]], u5 = c2 && this.sourceCache.getTileByID(c2);
          if (!u5)
            return null;
          const d2 = this._coordsTextureSize, _2 = (1 << u5.tileID.canonical.z) * d2;
          return new e.Z((u5.tileID.canonical.x * d2 + l2) / _2 + u5.tileID.wrap, (u5.tileID.canonical.y * d2 + h2) / _2, this.getElevation(u5.tileID, l2, h2, d2));
        }
        depthAtPoint(t2) {
          const e2 = new Uint8Array(4), i2 = this.painter.context, a2 = i2.gl;
          return i2.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), a2.readPixels(t2.x, this.painter.height / devicePixelRatio - t2.y - 1, 1, 1, a2.RGBA, a2.UNSIGNED_BYTE, e2), i2.bindFramebuffer.set(null), (e2[0] / 16777216 + e2[1] / 65536 + e2[2] / 256 + e2[3]) / 256;
        }
        getTerrainMesh() {
          if (this._mesh)
            return this._mesh;
          const t2 = this.painter.context, i2 = new e.bd, a2 = new e.aY, s2 = this.meshSize, o2 = e.X / s2, r2 = s2 * s2;
          for (let t3 = 0;t3 <= s2; t3++)
            for (let e2 = 0;e2 <= s2; e2++)
              i2.emplaceBack(e2 * o2, t3 * o2, 0);
          for (let t3 = 0;t3 < r2; t3 += s2 + 1)
            for (let e2 = 0;e2 < s2; e2++)
              a2.emplaceBack(e2 + t3, s2 + e2 + t3 + 1, s2 + e2 + t3 + 2), a2.emplaceBack(e2 + t3, s2 + e2 + t3 + 2, e2 + t3 + 1);
          const n2 = i2.length, l2 = n2 + 2 * (s2 + 1);
          for (const t3 of [0, 1])
            for (let a3 = 0;a3 <= s2; a3++)
              for (const s3 of [0, 1])
                i2.emplaceBack(a3 * o2, t3 * e.X, s3);
          for (let t3 = 0;t3 < 2 * s2; t3 += 2)
            a2.emplaceBack(l2 + t3, l2 + t3 + 1, l2 + t3 + 3), a2.emplaceBack(l2 + t3, l2 + t3 + 3, l2 + t3 + 2), a2.emplaceBack(n2 + t3, n2 + t3 + 3, n2 + t3 + 1), a2.emplaceBack(n2 + t3, n2 + t3 + 2, n2 + t3 + 3);
          const h2 = i2.length, c2 = h2 + 2 * (s2 + 1);
          for (const t3 of [0, 1])
            for (let a3 = 0;a3 <= s2; a3++)
              for (const s3 of [0, 1])
                i2.emplaceBack(t3 * e.X, a3 * o2, s3);
          for (let t3 = 0;t3 < 2 * s2; t3 += 2)
            a2.emplaceBack(h2 + t3, h2 + t3 + 1, h2 + t3 + 3), a2.emplaceBack(h2 + t3, h2 + t3 + 3, h2 + t3 + 2), a2.emplaceBack(c2 + t3, c2 + t3 + 3, c2 + t3 + 1), a2.emplaceBack(c2 + t3, c2 + t3 + 2, c2 + t3 + 3);
          return this._mesh = new ga(t2.createVertexBuffer(i2, Ss.members), t2.createIndexBuffer(a2), e.a0.simpleSegment(0, 0, i2.length, a2.length)), this._mesh;
        }
        getMeshFrameDelta(t2) {
          return 2 * Math.PI * e.be / Math.pow(2, t2) / 5;
        }
        getMinTileElevationForLngLatZoom(t2, e2) {
          var i2;
          const { tileID: a2 } = this._getOverscaledTileIDFromLngLatZoom(t2, e2);
          return (i2 = this.getMinMaxElevation(a2).minElevation) !== null && i2 !== undefined ? i2 : 0;
        }
        getMinMaxElevation(t2) {
          const e2 = this.getTerrainData(t2).tile, i2 = { minElevation: null, maxElevation: null };
          return e2 && e2.dem && (i2.minElevation = e2.dem.min * this.exaggeration, i2.maxElevation = e2.dem.max * this.exaggeration), i2;
        }
        _getOverscaledTileIDFromLngLatZoom(t2, i2) {
          const a2 = e.Z.fromLngLat(t2.wrap()), s2 = (1 << i2) * e.X, o2 = a2.x * s2, r2 = a2.y * s2, n2 = Math.floor(o2 / e.X), l2 = Math.floor(r2 / e.X);
          return { tileID: new e.S(i2, 0, i2, n2, l2), mercatorX: o2, mercatorY: r2 };
        }
      }

      class Ms {
        constructor(t2, e2, i2) {
          this._context = t2, this._size = e2, this._tileSize = i2, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const t2 of this._objects)
            t2.texture.destroy(), t2.fbo.destroy();
        }
        _createObject(t2) {
          const e2 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i2 = new b(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return i2.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), e2.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), e2.colorAttachment.set(i2.texture), { id: t2, fbo: e2, texture: i2, stamp: -1, inUse: false };
        }
        getObjectForId(t2) {
          return this._objects[t2];
        }
        useObject(t2) {
          t2.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((e2) => t2.id !== e2), this._recentlyUsed.push(t2.id);
        }
        stampObject(t2) {
          t2.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const t3 of this._recentlyUsed)
            if (!this._objects[t3].inUse)
              return this._objects[t3];
          if (this._objects.length >= this._size)
            throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const t2 = this._createObject(this._objects.length);
          return this._objects.push(t2), t2;
        }
        freeObject(t2) {
          t2.inUse = false;
        }
        freeAllObjects() {
          for (const t2 of this._objects)
            this.freeObject(t2);
        }
        isFull() {
          return !(this._objects.length < this._size) && this._objects.some((t2) => !t2.inUse) === false;
        }
      }
      const As = { background: true, fill: true, line: true, raster: true, hillshade: true };

      class Rs {
        constructor(t2, e2) {
          this.painter = t2, this.terrain = e2, this.pool = new Ms(t2.context, 30, e2.sourceCache.tileSize * e2.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(t2) {
          return this.pool.getObjectForId(t2.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(t2, e2) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t2._order.filter((i2) => !t2._layers[i2].isHidden(e2)), this._coordsDescendingInv = {};
          for (const e3 in t2.sourceCaches) {
            this._coordsDescendingInv[e3] = {};
            const i2 = t2.sourceCaches[e3].getVisibleCoordinates();
            for (const t3 of i2) {
              const i3 = this.terrain.sourceCache.getTerrainCoords(t3);
              for (const t4 in i3)
                this._coordsDescendingInv[e3][t4] || (this._coordsDescendingInv[e3][t4] = []), this._coordsDescendingInv[e3][t4].push(i3[t4]);
            }
          }
          this._coordsDescendingInvStr = {};
          for (const e3 of t2._order) {
            const i2 = t2._layers[e3], a2 = i2.source;
            if (As[i2.type] && !this._coordsDescendingInvStr[a2]) {
              this._coordsDescendingInvStr[a2] = {};
              for (const t3 in this._coordsDescendingInv[a2])
                this._coordsDescendingInvStr[a2][t3] = this._coordsDescendingInv[a2][t3].map((t4) => t4.key).sort().join();
            }
          }
          for (const t3 of this._renderableTiles)
            for (const e3 in this._coordsDescendingInvStr) {
              const i2 = this._coordsDescendingInvStr[e3][t3.tileID.key];
              i2 && i2 !== t3.rttCoords[e3] && (t3.rtt = []);
            }
        }
        renderLayer(t2) {
          if (t2.isHidden(this.painter.transform.zoom))
            return false;
          const i2 = t2.type, a2 = this.painter, s2 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === t2.id;
          if (As[i2] && (this._prevType && As[this._prevType] || this._stacks.push([]), this._prevType = i2, this._stacks[this._stacks.length - 1].push(t2.id), !s2))
            return true;
          if (As[this._prevType] || As[i2] && s2) {
            this._prevType = i2;
            const t3 = this._stacks.length - 1, s3 = this._stacks[t3] || [];
            for (const i3 of this._renderableTiles) {
              if (this.pool.isFull() && (fa(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(i3), i3.rtt[t3]) {
                const e2 = this.pool.getObjectForId(i3.rtt[t3].id);
                if (e2.stamp === i3.rtt[t3].stamp) {
                  this.pool.useObject(e2);
                  continue;
                }
              }
              const o2 = this.pool.getOrCreateFreeObject();
              this.pool.useObject(o2), this.pool.stampObject(o2), i3.rtt[t3] = { id: o2.id, stamp: o2.stamp }, a2.context.bindFramebuffer.set(o2.fbo.framebuffer), a2.context.clear({ color: e.aM.transparent, stencil: 0 }), a2.currentStencilSource = undefined;
              for (let t4 = 0;t4 < s3.length; t4++) {
                const e2 = a2.style._layers[s3[t4]], r2 = e2.source ? this._coordsDescendingInv[e2.source][i3.tileID.key] : [i3.tileID];
                a2.context.viewport.set([0, 0, o2.fbo.width, o2.fbo.height]), a2._renderTileClippingMasks(e2, r2), a2.renderLayer(a2, a2.style.sourceCaches[e2.source], e2, r2), e2.source && (i3.rttCoords[e2.source] = this._coordsDescendingInvStr[e2.source][i3.tileID.key]);
              }
            }
            return fa(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), As[i2];
          }
          return false;
        }
      }
      const ks = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Ls = i, Fs = { hash: false, interactive: true, bearingSnap: 7, attributionControl: Is, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, refreshExpiredTiles: true, scrollZoom: true, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, trackResize: true, center: [0, 0], zoom: 0, bearing: 0, pitch: 0, renderWorldCopies: true, maxTileCacheSize: null, maxTileCacheZoomLevels: e.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: true, validateStyle: true, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: true }, Bs = (t2) => {
        t2.touchstart = t2.dragStart, t2.touchmoveWindow = t2.dragMove, t2.touchend = t2.dragEnd;
      }, Os = { showCompass: true, showZoom: true, visualizePitch: false };

      class Ns {
        constructor(t2, i2, a2 = false) {
          this.mousedown = (t3) => {
            this.startMouse(e.e({}, t3, { ctrlKey: true, preventDefault: () => t3.preventDefault() }), r.mousePos(this.element, t3)), r.addEventListener(window, "mousemove", this.mousemove), r.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (t3) => {
            this.moveMouse(t3, r.mousePos(this.element, t3));
          }, this.mouseup = (t3) => {
            this.mouseRotate.dragEnd(t3), this.mousePitch && this.mousePitch.dragEnd(t3), this.offTemp();
          }, this.touchstart = (t3) => {
            t3.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = r.touchPos(this.element, t3.targetTouches)[0], this.startTouch(t3, this._startPos), r.addEventListener(window, "touchmove", this.touchmove, { passive: false }), r.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (t3) => {
            t3.targetTouches.length !== 1 ? this.reset() : (this._lastPos = r.touchPos(this.element, t3.targetTouches)[0], this.moveTouch(t3, this._lastPos));
          }, this.touchend = (t3) => {
            t3.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10;
          const s2 = t2.dragRotate._mouseRotate.getClickTolerance(), o2 = t2.dragRotate._mousePitch.getClickTolerance();
          this.element = i2, this.mouseRotate = Ka({ clickTolerance: s2, enable: true }), this.touchRotate = (({ enable: t3, clickTolerance: e2, bearingDegreesPerPixelMoved: i3 = 0.8 }) => {
            const a3 = new $a;
            return new Ga({ clickTolerance: e2, move: (t4, e3) => ({ bearingDelta: (e3.x - t4.x) * i3 }), moveStateManager: a3, enable: t3, assignEvents: Bs });
          })({ clickTolerance: s2, enable: true }), this.map = t2, a2 && (this.mousePitch = Ja({ clickTolerance: o2, enable: true }), this.touchPitch = (({ enable: t3, clickTolerance: e2, pitchDegreesPerPixelMoved: i3 = -0.5 }) => {
            const a3 = new $a;
            return new Ga({ clickTolerance: e2, move: (t4, e3) => ({ pitchDelta: (e3.y - t4.y) * i3 }), moveStateManager: a3, enable: t3, assignEvents: Bs });
          })({ clickTolerance: o2, enable: true })), r.addEventListener(i2, "mousedown", this.mousedown), r.addEventListener(i2, "touchstart", this.touchstart, { passive: false }), r.addEventListener(i2, "touchcancel", this.reset);
        }
        startMouse(t2, e2) {
          this.mouseRotate.dragStart(t2, e2), this.mousePitch && this.mousePitch.dragStart(t2, e2), r.disableDrag();
        }
        startTouch(t2, e2) {
          this.touchRotate.dragStart(t2, e2), this.touchPitch && this.touchPitch.dragStart(t2, e2), r.disableDrag();
        }
        moveMouse(t2, e2) {
          const i2 = this.map, { bearingDelta: a2 } = this.mouseRotate.dragMove(t2, e2) || {};
          if (a2 && i2.setBearing(i2.getBearing() + a2), this.mousePitch) {
            const { pitchDelta: a3 } = this.mousePitch.dragMove(t2, e2) || {};
            a3 && i2.setPitch(i2.getPitch() + a3);
          }
        }
        moveTouch(t2, e2) {
          const i2 = this.map, { bearingDelta: a2 } = this.touchRotate.dragMove(t2, e2) || {};
          if (a2 && i2.setBearing(i2.getBearing() + a2), this.touchPitch) {
            const { pitchDelta: a3 } = this.touchPitch.dragMove(t2, e2) || {};
            a3 && i2.setPitch(i2.getPitch() + a3);
          }
        }
        off() {
          const t2 = this.element;
          r.removeEventListener(t2, "mousedown", this.mousedown), r.removeEventListener(t2, "touchstart", this.touchstart, { passive: false }), r.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), r.removeEventListener(window, "touchend", this.touchend), r.removeEventListener(t2, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          r.enableDrag(), r.removeEventListener(window, "mousemove", this.mousemove), r.removeEventListener(window, "mouseup", this.mouseup), r.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), r.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let Us;
      function js(t2, i2, a2) {
        const s2 = new e.N(t2.lng, t2.lat);
        if (t2 = new e.N(t2.lng, t2.lat), i2) {
          const s3 = new e.N(t2.lng - 360, t2.lat), o2 = new e.N(t2.lng + 360, t2.lat), r2 = a2.locationPoint(t2).distSqr(i2);
          a2.locationPoint(s3).distSqr(i2) < r2 ? t2 = s3 : a2.locationPoint(o2).distSqr(i2) < r2 && (t2 = o2);
        }
        for (;Math.abs(t2.lng - a2.center.lng) > 180; ) {
          const e2 = a2.locationPoint(t2);
          if (e2.x >= 0 && e2.y >= 0 && e2.x <= a2.width && e2.y <= a2.height)
            break;
          t2.lng > a2.center.lng ? t2.lng -= 360 : t2.lng += 360;
        }
        return t2.lng !== s2.lng && a2.locationPoint(t2).y > a2.height / 2 - a2.getHorizon() ? t2 : s2;
      }
      const Zs = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function qs(t2, e2, i2) {
        const a2 = t2.classList;
        for (const t3 in Zs)
          a2.remove(`maplibregl-${i2}-anchor-${t3}`);
        a2.add(`maplibregl-${i2}-anchor-${e2}`);
      }

      class Vs extends e.E {
        constructor(t2) {
          if (super(), this._onKeyPress = (t3) => {
            const e2 = t3.code, i2 = t3.charCode || t3.keyCode;
            e2 !== "Space" && e2 !== "Enter" && i2 !== 32 && i2 !== 13 || this.togglePopup();
          }, this._onMapClick = (t3) => {
            const e2 = t3.originalEvent.target, i2 = this._element;
            this._popup && (e2 === i2 || i2.contains(e2)) && this.togglePopup();
          }, this._update = (t3) => {
            var e2;
            if (!this._map)
              return;
            const i2 = this._map.loaded() && !this._map.isMoving();
            ((t3 == null ? undefined : t3.type) === "terrain" || (t3 == null ? undefined : t3.type) === "render" && !i2) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? js(this._lngLat, this._flatPos, this._map.transform) : (e2 = this._lngLat) === null || e2 === undefined ? undefined : e2.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
            let a2 = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? a2 = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (a2 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let s2 = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? s2 = "rotateX(0deg)" : this._pitchAlignment === "map" && (s2 = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || t3 && t3.type !== "moveend" || (this._pos = this._pos.round()), r.setTransform(this._element, `${Zs[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${s2} ${a2}`), o.frameAsync(new AbortController).then(() => {
              this._updateOpacity(t3 && t3.type === "moveend");
            }).catch(() => {
            });
          }, this._onMove = (t3) => {
            if (!this._isDragging) {
              const e2 = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = t3.point.dist(this._pointerdownPos) >= e2;
            }
            this._isDragging && (this._pos = t3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new e.k("dragstart"))), this.fire(new e.k("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new e.k("dragend")), this._state = "inactive";
          }, this._addDragHandler = (t3) => {
            this._element.contains(t3.originalEvent.target) && (t3.preventDefault(), this._positionDelta = t3.point.sub(this._pos).add(this._offset), this._pointerdownPos = t3.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = t2 && t2.anchor || "center", this._color = t2 && t2.color || "#3FB1CE", this._scale = t2 && t2.scale || 1, this._draggable = t2 && t2.draggable || false, this._clickTolerance = t2 && t2.clickTolerance || 0, this._subpixelPositioning = t2 && t2.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = t2 && t2.rotation || 0, this._rotationAlignment = t2 && t2.rotationAlignment || "auto", this._pitchAlignment = t2 && t2.pitchAlignment && t2.pitchAlignment !== "auto" ? t2.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(t2 == null ? undefined : t2.opacity, t2 == null ? undefined : t2.opacityWhenCovered), t2 && t2.element)
            this._element = t2.element, this._offset = e.P.convert(t2 && t2.offset || [0, 0]);
          else {
            this._defaultMarker = true, this._element = r.create("div");
            const i2 = r.createNS("http://www.w3.org/2000/svg", "svg"), a2 = 41, s2 = 27;
            i2.setAttributeNS(null, "display", "block"), i2.setAttributeNS(null, "height", `${a2}px`), i2.setAttributeNS(null, "width", `${s2}px`), i2.setAttributeNS(null, "viewBox", `0 0 ${s2} ${a2}`);
            const o2 = r.createNS("http://www.w3.org/2000/svg", "g");
            o2.setAttributeNS(null, "stroke", "none"), o2.setAttributeNS(null, "stroke-width", "1"), o2.setAttributeNS(null, "fill", "none"), o2.setAttributeNS(null, "fill-rule", "evenodd");
            const n2 = r.createNS("http://www.w3.org/2000/svg", "g");
            n2.setAttributeNS(null, "fill-rule", "nonzero");
            const l2 = r.createNS("http://www.w3.org/2000/svg", "g");
            l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
            const h2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const t3 of h2) {
              const e2 = r.createNS("http://www.w3.org/2000/svg", "ellipse");
              e2.setAttributeNS(null, "opacity", "0.04"), e2.setAttributeNS(null, "cx", "10.5"), e2.setAttributeNS(null, "cy", "5.80029008"), e2.setAttributeNS(null, "rx", t3.rx), e2.setAttributeNS(null, "ry", t3.ry), l2.appendChild(e2);
            }
            const c2 = r.createNS("http://www.w3.org/2000/svg", "g");
            c2.setAttributeNS(null, "fill", this._color);
            const u5 = r.createNS("http://www.w3.org/2000/svg", "path");
            u5.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), c2.appendChild(u5);
            const d2 = r.createNS("http://www.w3.org/2000/svg", "g");
            d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
            const _2 = r.createNS("http://www.w3.org/2000/svg", "path");
            _2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(_2);
            const p2 = r.createNS("http://www.w3.org/2000/svg", "g");
            p2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p2.setAttributeNS(null, "fill", "#FFFFFF");
            const m2 = r.createNS("http://www.w3.org/2000/svg", "g");
            m2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const f2 = r.createNS("http://www.w3.org/2000/svg", "circle");
            f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
            const g2 = r.createNS("http://www.w3.org/2000/svg", "circle");
            g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), m2.appendChild(f2), m2.appendChild(g2), n2.appendChild(l2), n2.appendChild(c2), n2.appendChild(d2), n2.appendChild(p2), n2.appendChild(m2), i2.appendChild(n2), i2.setAttributeNS(null, "height", a2 * this._scale + "px"), i2.setAttributeNS(null, "width", s2 * this._scale + "px"), this._element.appendChild(i2), this._offset = e.P.convert(t2 && t2.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (t3) => {
            t3.preventDefault();
          }), this._element.addEventListener("mousedown", (t3) => {
            t3.preventDefault();
          }), qs(this._element, this._anchor, "marker"), t2 && t2.className)
            for (const e2 of t2.className.split(" "))
              this._element.classList.add(e2);
          this._popup = null;
        }
        addTo(t2) {
          return this.remove(), this._map = t2, this._element.setAttribute("aria-label", t2._getUIString("Marker.Title")), t2.getCanvasContainer().appendChild(this._element), t2.on("move", this._update), t2.on("moveend", this._update), t2.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), r.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t2) {
          return this._lngLat = e.N.convert(t2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(t2) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t2) {
            if (!("offset" in t2.options)) {
              const e2 = 38.1, i2 = 13.5, a2 = Math.abs(i2) / Math.SQRT2;
              t2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -e2], "bottom-left": [a2, -1 * (e2 - i2 + a2)], "bottom-right": [-a2, -1 * (e2 - i2 + a2)], left: [i2, -1 * (e2 - i2)], right: [-i2, -1 * (e2 - i2)] } : this._offset;
            }
            this._popup = t2, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        setSubpixelPositioning(t2) {
          return this._subpixelPositioning = t2, this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const t2 = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered ? this : t2 ? (t2.isOpen() ? t2.remove() : (t2.setLngLat(this._lngLat), t2.addTo(this._map)), this) : this;
        }
        _updateOpacity(t2 = false) {
          var i2, a2;
          if (!((i2 = this._map) === null || i2 === undefined ? undefined : i2.terrain))
            return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
          if (t2)
            this._opacityTimeout = null;
          else {
            if (this._opacityTimeout)
              return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const s2 = this._map, o2 = s2.terrain.depthAtPoint(this._pos), r2 = s2.terrain.getElevationForLngLatZoom(this._lngLat, s2.transform.tileZoom);
          if (s2.transform.lngLatToCameraDepth(this._lngLat, r2) - o2 < 0.006)
            return void (this._element.style.opacity = this._opacity);
          const n2 = -this._offset.y / s2.transform._pixelPerMeter, l2 = Math.sin(s2.getPitch() * Math.PI / 180) * n2, h2 = s2.terrain.depthAtPoint(new e.P(this._pos.x, this._pos.y - this._offset.y)), c2 = s2.transform.lngLatToCameraDepth(this._lngLat, r2 + l2) - h2 > 0.006;
          ((a2 = this._popup) === null || a2 === undefined ? undefined : a2.isOpen()) && c2 && this._popup.remove(), this._element.style.opacity = c2 ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t2) {
          return this._offset = e.P.convert(t2), this._update(), this;
        }
        addClassName(t2) {
          this._element.classList.add(t2);
        }
        removeClassName(t2) {
          this._element.classList.remove(t2);
        }
        toggleClassName(t2) {
          return this._element.classList.toggle(t2);
        }
        setDraggable(t2) {
          return this._draggable = !!t2, this._map && (t2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(t2) {
          return this._rotation = t2 || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(t2) {
          return this._rotationAlignment = t2 || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(t2) {
          return this._pitchAlignment = t2 && t2 !== "auto" ? t2 : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(t2, e2) {
          return t2 === undefined && e2 === undefined && (this._opacity = "1", this._opacityWhenCovered = "0.2"), t2 !== undefined && (this._opacity = t2), e2 !== undefined && (this._opacityWhenCovered = e2), this._map && this._updateOpacity(true), this;
        }
      }
      const Gs = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6000 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
      let Hs = 0, Ws = false;
      const $s = { maxWidth: 100, unit: "metric" };
      function Xs(t2, e2, i2) {
        const a2 = i2 && i2.maxWidth || 100, s2 = t2._container.clientHeight / 2, o2 = t2.unproject([0, s2]), r2 = t2.unproject([a2, s2]), n2 = o2.distanceTo(r2);
        if (i2 && i2.unit === "imperial") {
          const i3 = 3.2808 * n2;
          i3 > 5280 ? Ks(e2, a2, i3 / 5280, t2._getUIString("ScaleControl.Miles")) : Ks(e2, a2, i3, t2._getUIString("ScaleControl.Feet"));
        } else
          i2 && i2.unit === "nautical" ? Ks(e2, a2, n2 / 1852, t2._getUIString("ScaleControl.NauticalMiles")) : n2 >= 1000 ? Ks(e2, a2, n2 / 1000, t2._getUIString("ScaleControl.Kilometers")) : Ks(e2, a2, n2, t2._getUIString("ScaleControl.Meters"));
      }
      function Ks(t2, e2, i2, a2) {
        const s2 = function(t3) {
          const e3 = Math.pow(10, `${Math.floor(t3)}`.length - 1);
          let i3 = t3 / e3;
          return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(t4) {
            const e4 = Math.pow(10, Math.ceil(-Math.log(t4) / Math.LN10));
            return Math.round(t4 * e4) / e4;
          }(i3), e3 * i3;
        }(i2);
        t2.style.width = e2 * (s2 / i2) + "px", t2.innerHTML = `${s2}&nbsp;${a2}`;
      }
      const Js = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", subpixelPositioning: false }, Ys = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function Qs(t2) {
        if (t2) {
          if (typeof t2 == "number") {
            const i2 = Math.round(Math.abs(t2) / Math.SQRT2);
            return { center: new e.P(0, 0), top: new e.P(0, t2), "top-left": new e.P(i2, i2), "top-right": new e.P(-i2, i2), bottom: new e.P(0, -t2), "bottom-left": new e.P(i2, -i2), "bottom-right": new e.P(-i2, -i2), left: new e.P(t2, 0), right: new e.P(-t2, 0) };
          }
          if (t2 instanceof e.P || Array.isArray(t2)) {
            const i2 = e.P.convert(t2);
            return { center: i2, top: i2, "top-left": i2, "top-right": i2, bottom: i2, "bottom-left": i2, "bottom-right": i2, left: i2, right: i2 };
          }
          return { center: e.P.convert(t2.center || [0, 0]), top: e.P.convert(t2.top || [0, 0]), "top-left": e.P.convert(t2["top-left"] || [0, 0]), "top-right": e.P.convert(t2["top-right"] || [0, 0]), bottom: e.P.convert(t2.bottom || [0, 0]), "bottom-left": e.P.convert(t2["bottom-left"] || [0, 0]), "bottom-right": e.P.convert(t2["bottom-right"] || [0, 0]), left: e.P.convert(t2.left || [0, 0]), right: e.P.convert(t2.right || [0, 0]) };
        }
        return Qs(new e.P(0, 0));
      }
      const to = i;
      t.AJAXError = e.bh, t.Evented = e.E, t.LngLat = e.N, t.MercatorCoordinate = e.Z, t.Point = e.P, t.addProtocol = e.bi, t.config = e.a, t.removeProtocol = e.bj, t.AttributionControl = Es, t.BoxZoomHandler = Ua, t.CanvasSource = et, t.CooperativeGesturesHandler = vs, t.DoubleClickZoomHandler = ds, t.DragPanHandler = ms, t.DragRotateHandler = fs, t.EdgeInsets = ba, t.FullscreenControl = class extends e.E {
        constructor(t2 = {}) {
          super(), this._onFullscreenChange = () => {
            var t3;
            let e2 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (;(t3 = e2 == null ? undefined : e2.shadowRoot) === null || t3 === undefined ? undefined : t3.fullscreenElement; )
              e2 = e2.shadowRoot.fullscreenElement;
            e2 === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = false, t2 && t2.container && (t2.container instanceof HTMLElement ? this._container = t2.container : e.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : ("onmozfullscreenchange" in document) ? this._fullscreenchange = "mozfullscreenchange" : ("onwebkitfullscreenchange" in document) ? this._fullscreenchange = "webkitfullscreenchange" : ("onmsfullscreenchange" in document) && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(t2) {
          return this._map = t2, this._container || (this._container = this._map.getContainer()), this._controlContainer = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          r.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const t2 = this._fullscreenButton = r.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          r.create("span", "maplibregl-ctrl-icon", t2).setAttribute("aria-hidden", "true"), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const t2 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", t2), this._fullscreenButton.title = t2;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new e.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new e.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, t.GeoJSONSource = J, t.GeolocateControl = class extends e.E {
        constructor(t2) {
          super(), this._onSuccess = (t3) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(t3))
                return this._setErrorState(), this.fire(new e.k("outofmaxbounds", t3)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation)
                switch (this._lastKnownPosition = t3, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t3), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(t3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new e.k("geolocate", t3)), this._finish();
            }
          }, this._updateCamera = (t3) => {
            const i2 = new e.N(t3.coords.longitude, t3.coords.latitude), a2 = t3.coords.accuracy, s2 = this._map.getBearing(), o2 = e.e({ bearing: s2 }, this.options.fitBoundsOptions), r2 = H.fromLngLat(i2, a2);
            this._map.fitBounds(r2, o2, { geolocateSource: true });
          }, this._updateMarker = (t3) => {
            if (t3) {
              const i2 = new e.N(t3.coords.longitude, t3.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else
              this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (t3) => {
            if (this._map) {
              if (this.options.trackUserLocation)
                if (t3.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4), this._geolocationWatchID !== undefined && this._clearWatch();
                } else {
                  if (t3.code === 3 && Ws)
                    return;
                  this._setErrorState();
                }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new e.k("error", t3)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = undefined;
          }, this._setupUI = () => {
            this._map && (this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this._geolocateButton = r.create("button", "maplibregl-ctrl-geolocate", this._container), r.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
          }, this._finishSetupUI = (t3) => {
            if (this._map) {
              if (t3 === false) {
                e.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4);
              } else {
                const t4 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.disabled = false, this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = r.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Vs({ element: this._dotElement }), this._circleElement = r.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Vs({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t4) => {
                t4.geolocateSource || this._watchState !== "ACTIVE_LOCK" || t4.originalEvent && t4.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new e.k("trackuserlocationend")), this.fire(new e.k("userlocationlostfocus")));
              });
            }
          }, this.options = e.e({}, Gs, t2);
        }
        onAdd(t2) {
          return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
            return e._(this, arguments, undefined, function* (t3 = false) {
              if (Us !== undefined && !t3)
                return Us;
              if (window.navigator.permissions === undefined)
                return Us = !!window.navigator.geolocation, Us;
              try {
                const t4 = yield window.navigator.permissions.query({ name: "geolocation" });
                Us = t4.state !== "denied";
              } catch (t4) {
                Us = !!window.navigator.geolocation;
              }
              return Us;
            });
          }().then((t3) => this._finishSetupUI(t3)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== undefined && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = undefined), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), r.remove(this._container), this._map.off("zoom", this._onZoom), this._map = undefined, Hs = 0, Ws = false;
        }
        _isOutOfMapMaxBounds(t2) {
          const e2 = this._map.getMaxBounds(), i2 = t2.coords;
          return e2 && (i2.longitude < e2.getWest() || i2.longitude > e2.getEast() || i2.latitude < e2.getSouth() || i2.latitude > e2.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const t2 = this._map.getBounds(), e2 = t2.getSouthEast(), i2 = t2.getNorthEast(), a2 = e2.distanceTo(i2), s2 = Math.ceil(this._accuracy / (a2 / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${s2}px`, this._circleElement.style.height = `${s2}px`;
        }
        trigger() {
          if (!this._setup)
            return e.w("Geolocate control triggered before added to a map"), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new e.k("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                Hs--, Ws = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new e.k("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.k("trackuserlocationstart")), this.fire(new e.k("userlocationfocus"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== undefined)
              this._clearWatch();
            else if (this._geolocationWatchID === undefined) {
              let t2;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Hs++, Hs > 1 ? (t2 = { maximumAge: 600000, timeout: 0 }, Ws = true) : (t2 = this.options.positionOptions, Ws = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t2);
            }
          } else
            window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return true;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = undefined, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, t.Hash = Ea, t.ImageSource = Q, t.KeyboardHandler = ls, t.LngLatBounds = H, t.LogoControl = Ps, t.Map = class extends Ts {
        constructor(t2) {
          e.bf.mark(e.bg.create);
          const i2 = Object.assign(Object.assign({}, Fs), t2);
          if (i2.minZoom != null && i2.maxZoom != null && i2.minZoom > i2.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (i2.minPitch != null && i2.maxPitch != null && i2.minPitch > i2.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (i2.minPitch != null && i2.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (i2.maxPitch != null && i2.maxPitch > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (super(new Ta(i2.minZoom, i2.maxZoom, i2.minPitch, i2.maxPitch, i2.renderWorldCopies), { bearingSnap: i2.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new Cs, this._controls = [], this._mapId = e.a4(), this._contextLost = (t3) => {
            t3.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new e.k("webglcontextlost", { originalEvent: t3 }));
          }, this._contextRestored = (t3) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new e.k("webglcontextrestored", { originalEvent: t3 }));
          }, this._onMapScroll = (t3) => {
            if (t3.target === this._container)
              return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = i2.interactive, this._maxTileCacheSize = i2.maxTileCacheSize, this._maxTileCacheZoomLevels = i2.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = i2.failIfMajorPerformanceCaveat === true, this._preserveDrawingBuffer = i2.preserveDrawingBuffer === true, this._antialias = i2.antialias === true, this._trackResize = i2.trackResize === true, this._bearingSnap = i2.bearingSnap, this._refreshExpiredTiles = i2.refreshExpiredTiles === true, this._fadeDuration = i2.fadeDuration, this._crossSourceCollisions = i2.crossSourceCollisions === true, this._collectResourceTiming = i2.collectResourceTiming === true, this._locale = Object.assign(Object.assign({}, ks), i2.locale), this._clickTolerance = i2.clickTolerance, this._overridePixelRatio = i2.pixelRatio, this._maxCanvasSize = i2.maxCanvasSize, this.transformCameraUpdate = i2.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = i2.cancelPendingTileRequestsWhileZooming === true, this._imageQueueHandle = _.addThrottleControl(() => this.isMoving()), this._requestManager = new p(i2.transformRequest), typeof i2.container == "string") {
            if (this._container = document.getElementById(i2.container), !this._container)
              throw new Error(`Container '${i2.container}' not found.`);
          } else {
            if (!(i2.container instanceof HTMLElement))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = i2.container;
          }
          if (i2.maxBounds && this.setMaxBounds(i2.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)).on("moveend", () => this._update(false)).on("zoom", () => this._update(true)).on("terrain", () => {
            this.painter.terrainFacilitator.dirty = true, this._update(true);
          }).once("idle", () => {
            this._idleTriggered = true;
          }), typeof window != "undefined") {
            addEventListener("online", this._onWindowOnline, false);
            let t3 = false;
            const e2 = Ia((t4) => {
              this._trackResize && !this._removed && (this.resize(t4), this.redraw());
            }, 50);
            this._resizeObserver = new ResizeObserver((i3) => {
              t3 ? e2(i3) : t3 = true;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new ws(this, i2), this._hash = i2.hash && new Ea(typeof i2.hash == "string" && i2.hash || undefined).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: i2.center, zoom: i2.zoom, bearing: i2.bearing, pitch: i2.pitch }), i2.bounds && (this.resize(), this.fitBounds(i2.bounds, e.e({}, i2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = i2.localIdeographFontFamily, this._validateStyle = i2.validateStyle, i2.style && this.setStyle(i2.style, { localIdeographFontFamily: i2.localIdeographFontFamily }), i2.attributionControl && this.addControl(new Es(typeof i2.attributionControl == "boolean" ? undefined : i2.attributionControl)), i2.maplibreLogo && this.addControl(new Ps, i2.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (t3) => {
            this._update(t3.dataType === "style"), this.fire(new e.k(`${t3.dataType}data`, t3));
          }), this.on("dataloading", (t3) => {
            this.fire(new e.k(`${t3.dataType}dataloading`, t3));
          }), this.on("dataabort", (t3) => {
            this.fire(new e.k("sourcedataabort", t3));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(t2, i2) {
          if (i2 === undefined && (i2 = t2.getDefaultPosition ? t2.getDefaultPosition() : "top-right"), !t2 || !t2.onAdd)
            return this.fire(new e.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const a2 = t2.onAdd(this);
          this._controls.push(t2);
          const s2 = this._controlPositions[i2];
          return i2.indexOf("bottom") !== -1 ? s2.insertBefore(a2, s2.firstChild) : s2.appendChild(a2), this;
        }
        removeControl(t2) {
          if (!t2 || !t2.onRemove)
            return this.fire(new e.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const i2 = this._controls.indexOf(t2);
          return i2 > -1 && this._controls.splice(i2, 1), t2.onRemove(this), this;
        }
        hasControl(t2) {
          return this._controls.indexOf(t2) > -1;
        }
        calculateCameraOptionsFromTo(t2, e2, i2, a2) {
          return a2 == null && this.terrain && (a2 = this.terrain.getElevationForLngLatZoom(i2, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(t2, e2, i2, a2);
        }
        resize(t2) {
          var i2;
          const a2 = this._containerDimensions(), s2 = a2[0], o2 = a2[1], r2 = this._getClampedPixelRatio(s2, o2);
          if (this._resizeCanvas(s2, o2, r2), this.painter.resize(s2, o2, r2), this.painter.overLimit()) {
            const t3 = this.painter.context.gl;
            this._maxCanvasSize = [t3.drawingBufferWidth, t3.drawingBufferHeight];
            const e2 = this._getClampedPixelRatio(s2, o2);
            this._resizeCanvas(s2, o2, e2), this.painter.resize(s2, o2, e2);
          }
          this.transform.resize(s2, o2), (i2 = this._requestedCameraState) === null || i2 === undefined || i2.resize(s2, o2);
          const n2 = !this._moving;
          return n2 && (this.stop(), this.fire(new e.k("movestart", t2)).fire(new e.k("move", t2))), this.fire(new e.k("resize", t2)), n2 && this.fire(new e.k("moveend", t2)), this;
        }
        _getClampedPixelRatio(t2, e2) {
          const { 0: i2, 1: a2 } = this._maxCanvasSize, s2 = this.getPixelRatio(), o2 = t2 * s2, r2 = e2 * s2;
          return Math.min(o2 > i2 ? i2 / o2 : 1, r2 > a2 ? a2 / r2 : 1) * s2;
        }
        getPixelRatio() {
          var t2;
          return (t2 = this._overridePixelRatio) !== null && t2 !== undefined ? t2 : devicePixelRatio;
        }
        setPixelRatio(t2) {
          this._overridePixelRatio = t2, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(t2) {
          return this.transform.setMaxBounds(H.convert(t2)), this._update();
        }
        setMinZoom(t2) {
          if ((t2 = t2 == null ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
            return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 && this.setZoom(t2), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(t2) {
          if ((t2 = t2 == null ? 22 : t2) >= this.transform.minZoom)
            return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 && this.setZoom(t2), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(t2) {
          if ((t2 = t2 == null ? 0 : t2) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (t2 >= 0 && t2 <= this.transform.maxPitch)
            return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 && this.setPitch(t2), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(t2) {
          if ((t2 = t2 == null ? 60 : t2) > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (t2 >= this.transform.minPitch)
            return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 && this.setPitch(t2), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(t2) {
          return this.transform.renderWorldCopies = t2, this._update();
        }
        project(t2) {
          return this.transform.locationPoint(e.N.convert(t2), this.style && this.terrain);
        }
        unproject(t2) {
          return this.transform.pointLocation(e.P.convert(t2), this.terrain);
        }
        isMoving() {
          var t2;
          return this._moving || ((t2 = this.handlers) === null || t2 === undefined ? undefined : t2.isMoving());
        }
        isZooming() {
          var t2;
          return this._zooming || ((t2 = this.handlers) === null || t2 === undefined ? undefined : t2.isZooming());
        }
        isRotating() {
          var t2;
          return this._rotating || ((t2 = this.handlers) === null || t2 === undefined ? undefined : t2.isRotating());
        }
        _createDelegatedListener(t2, e2, i2) {
          if (t2 === "mouseenter" || t2 === "mouseover") {
            let a2 = false;
            const s2 = (s3) => {
              const o2 = e2.filter((t3) => this.getLayer(t3)), r2 = o2.length !== 0 ? this.queryRenderedFeatures(s3.point, { layers: o2 }) : [];
              r2.length ? a2 || (a2 = true, i2.call(this, new ka(t2, this, s3.originalEvent, { features: r2 }))) : a2 = false;
            };
            return { layers: e2, listener: i2, delegates: { mousemove: s2, mouseout: () => {
              a2 = false;
            } } };
          }
          if (t2 === "mouseleave" || t2 === "mouseout") {
            let a2 = false;
            const s2 = (s3) => {
              const o3 = e2.filter((t3) => this.getLayer(t3));
              (o3.length !== 0 ? this.queryRenderedFeatures(s3.point, { layers: o3 }) : []).length ? a2 = true : a2 && (a2 = false, i2.call(this, new ka(t2, this, s3.originalEvent)));
            }, o2 = (e3) => {
              a2 && (a2 = false, i2.call(this, new ka(t2, this, e3.originalEvent)));
            };
            return { layers: e2, listener: i2, delegates: { mousemove: s2, mouseout: o2 } };
          }
          {
            const a2 = (t3) => {
              const a3 = e2.filter((t4) => this.getLayer(t4)), s2 = a3.length !== 0 ? this.queryRenderedFeatures(t3.point, { layers: a3 }) : [];
              s2.length && (t3.features = s2, i2.call(this, t3), delete t3.features);
            };
            return { layers: e2, listener: i2, delegates: { [t2]: a2 } };
          }
        }
        _saveDelegatedListener(t2, e2) {
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t2] = this._delegatedListeners[t2] || [], this._delegatedListeners[t2].push(e2);
        }
        _removeDelegatedListener(t2, e2, i2) {
          if (!this._delegatedListeners || !this._delegatedListeners[t2])
            return;
          const a2 = this._delegatedListeners[t2];
          for (let t3 = 0;t3 < a2.length; t3++) {
            const s2 = a2[t3];
            if (s2.listener === i2 && s2.layers.length === e2.length && s2.layers.every((t4) => e2.includes(t4))) {
              for (const t4 in s2.delegates)
                this.off(t4, s2.delegates[t4]);
              return void a2.splice(t3, 1);
            }
          }
        }
        on(t2, e2, i2) {
          if (i2 === undefined)
            return super.on(t2, e2);
          const a2 = this._createDelegatedListener(t2, typeof e2 == "string" ? [e2] : e2, i2);
          this._saveDelegatedListener(t2, a2);
          for (const t3 in a2.delegates)
            this.on(t3, a2.delegates[t3]);
          return this;
        }
        once(t2, e2, i2) {
          if (i2 === undefined)
            return super.once(t2, e2);
          const a2 = typeof e2 == "string" ? [e2] : e2, s2 = this._createDelegatedListener(t2, a2, i2);
          for (const e3 in s2.delegates) {
            const o2 = s2.delegates[e3];
            s2.delegates[e3] = (...e4) => {
              this._removeDelegatedListener(t2, a2, i2), o2(...e4);
            };
          }
          this._saveDelegatedListener(t2, s2);
          for (const t3 in s2.delegates)
            this.once(t3, s2.delegates[t3]);
          return this;
        }
        off(t2, e2, i2) {
          return i2 === undefined ? super.off(t2, e2) : (this._removeDelegatedListener(t2, typeof e2 == "string" ? [e2] : e2, i2), this);
        }
        queryRenderedFeatures(t2, i2) {
          if (!this.style)
            return [];
          let a2;
          const s2 = t2 instanceof e.P || Array.isArray(t2), o2 = s2 ? t2 : [[0, 0], [this.transform.width, this.transform.height]];
          if (i2 = i2 || (s2 ? {} : t2) || {}, o2 instanceof e.P || typeof o2[0] == "number")
            a2 = [e.P.convert(o2)];
          else {
            const t3 = e.P.convert(o2[0]), i3 = e.P.convert(o2[1]);
            a2 = [t3, new e.P(i3.x, t3.y), i3, new e.P(t3.x, i3.y), t3];
          }
          return this.style.queryRenderedFeatures(a2, i2, this.transform);
        }
        querySourceFeatures(t2, e2) {
          return this.style.querySourceFeatures(t2, e2);
        }
        setStyle(t2, i2) {
          return (i2 = e.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i2)).diff !== false && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && t2 ? (this._diffStyle(t2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(t2, i2));
        }
        setTransformRequest(t2) {
          return this._requestManager.setTransformRequest(t2), this;
        }
        _getUIString(t2) {
          const e2 = this._locale[t2];
          if (e2 == null)
            throw new Error(`Missing UI string '${t2}'`);
          return e2;
        }
        _updateStyle(t2, e2) {
          if (e2.transformStyle && this.style && !this.style._loaded)
            return void this.style.once("style.load", () => this._updateStyle(t2, e2));
          const i2 = this.style && e2.transformStyle ? this.style.serialize() : undefined;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!t2)), t2 ? (this.style = new de2(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), typeof t2 == "string" ? this.style.loadURL(t2, e2, i2) : this.style.loadJSON(t2, e2, i2), this) : (delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new de2(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(t2, i2) {
          if (typeof t2 == "string") {
            const a2 = this._requestManager.transformRequest(t2, "Style");
            e.h(a2, new AbortController).then((t3) => {
              this._updateDiff(t3.data, i2);
            }).catch((t3) => {
              t3 && this.fire(new e.j(t3));
            });
          } else
            typeof t2 == "object" && this._updateDiff(t2, i2);
        }
        _updateDiff(t2, i2) {
          try {
            this.style.setState(t2, i2) && this._update(true);
          } catch (a2) {
            e.w(`Unable to perform style diff: ${a2.message || a2.error || a2}.  Rebuilding the style from scratch.`), this._updateStyle(t2, i2);
          }
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : e.w("There is no style added to the map.");
        }
        addSource(t2, e2) {
          return this._lazyInitEmptyStyle(), this.style.addSource(t2, e2), this._update(true);
        }
        isSourceLoaded(t2) {
          const i2 = this.style && this.style.sourceCaches[t2];
          if (i2 !== undefined)
            return i2.loaded();
          this.fire(new e.j(new Error(`There is no source with ID '${t2}'`)));
        }
        setTerrain(t2) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), t2) {
            const i2 = this.style.sourceCaches[t2.source];
            if (!i2)
              throw new Error(`cannot load terrain, because there exists no source with ID: ${t2.source}`);
            this.terrain === null && i2.reload();
            for (const i3 in this.style._layers) {
              const a2 = this.style._layers[i3];
              a2.type === "hillshade" && a2.source === t2.source && e.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new Ds(this.painter, i2, t2), this.painter.renderToTexture = new Rs(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (e2) => {
              e2.dataType === "style" ? this.terrain.sourceCache.freeRtt() : e2.dataType === "source" && e2.tile && (e2.sourceId !== t2.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(e2.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else
            this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
          return this.fire(new e.k("terrain", { terrain: t2 })), this;
        }
        getTerrain() {
          var t2, e2;
          return (e2 = (t2 = this.terrain) === null || t2 === undefined ? undefined : t2.options) !== null && e2 !== undefined ? e2 : null;
        }
        areTilesLoaded() {
          const t2 = this.style && this.style.sourceCaches;
          for (const e2 in t2) {
            const i2 = t2[e2]._tiles;
            for (const t3 in i2) {
              const e3 = i2[t3];
              if (e3.state !== "loaded" && e3.state !== "errored")
                return false;
            }
          }
          return true;
        }
        removeSource(t2) {
          return this.style.removeSource(t2), this._update(true);
        }
        getSource(t2) {
          return this.style.getSource(t2);
        }
        addImage(t2, i2, a2 = {}) {
          const { pixelRatio: s2 = 1, sdf: r2 = false, stretchX: n2, stretchY: l2, content: h2, textFitWidth: c2, textFitHeight: u5 } = a2;
          if (this._lazyInitEmptyStyle(), !(i2 instanceof HTMLImageElement || e.b(i2))) {
            if (i2.width === undefined || i2.height === undefined)
              return this.fire(new e.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: a3, height: o2, data: d2 } = i2, _2 = i2;
              return this.style.addImage(t2, { data: new e.R({ width: a3, height: o2 }, new Uint8Array(d2)), pixelRatio: s2, stretchX: n2, stretchY: l2, content: h2, textFitWidth: c2, textFitHeight: u5, sdf: r2, version: 0, userImage: _2 }), _2.onAdd && _2.onAdd(this, t2), this;
            }
          }
          {
            const { width: a3, height: d2, data: _2 } = o.getImageData(i2);
            this.style.addImage(t2, { data: new e.R({ width: a3, height: d2 }, _2), pixelRatio: s2, stretchX: n2, stretchY: l2, content: h2, textFitWidth: c2, textFitHeight: u5, sdf: r2, version: 0 });
          }
        }
        updateImage(t2, i2) {
          const a2 = this.style.getImage(t2);
          if (!a2)
            return this.fire(new e.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const s2 = i2 instanceof HTMLImageElement || e.b(i2) ? o.getImageData(i2) : i2, { width: r2, height: n2, data: l2 } = s2;
          if (r2 === undefined || n2 === undefined)
            return this.fire(new e.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (r2 !== a2.data.width || n2 !== a2.data.height)
            return this.fire(new e.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const h2 = !(i2 instanceof HTMLImageElement || e.b(i2));
          return a2.data.replace(l2, h2), this.style.updateImage(t2, a2), this;
        }
        getImage(t2) {
          return this.style.getImage(t2);
        }
        hasImage(t2) {
          return t2 ? !!this.style.getImage(t2) : (this.fire(new e.j(new Error("Missing required image id"))), false);
        }
        removeImage(t2) {
          this.style.removeImage(t2);
        }
        loadImage(t2) {
          return _.getImage(this._requestManager.transformRequest(t2, "Image"), new AbortController);
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(t2, e2) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(t2, e2), this._update(true);
        }
        moveLayer(t2, e2) {
          return this.style.moveLayer(t2, e2), this._update(true);
        }
        removeLayer(t2) {
          return this.style.removeLayer(t2), this._update(true);
        }
        getLayer(t2) {
          return this.style.getLayer(t2);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(t2, e2, i2) {
          return this.style.setLayerZoomRange(t2, e2, i2), this._update(true);
        }
        setFilter(t2, e2, i2 = {}) {
          return this.style.setFilter(t2, e2, i2), this._update(true);
        }
        getFilter(t2) {
          return this.style.getFilter(t2);
        }
        setPaintProperty(t2, e2, i2, a2 = {}) {
          return this.style.setPaintProperty(t2, e2, i2, a2), this._update(true);
        }
        getPaintProperty(t2, e2) {
          return this.style.getPaintProperty(t2, e2);
        }
        setLayoutProperty(t2, e2, i2, a2 = {}) {
          return this.style.setLayoutProperty(t2, e2, i2, a2), this._update(true);
        }
        getLayoutProperty(t2, e2) {
          return this.style.getLayoutProperty(t2, e2);
        }
        setGlyphs(t2, e2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(t2, e2), this._update(true);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(t2, e2, i2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.addSprite(t2, e2, i2, (t3) => {
            t3 || this._update(true);
          }), this;
        }
        removeSprite(t2) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(t2), this._update(true);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(t2, e2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSprite(t2, e2, (t3) => {
            t3 || this._update(true);
          }), this;
        }
        setLight(t2, e2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(t2, e2), this._update(true);
        }
        getLight() {
          return this.style.getLight();
        }
        setSky(t2) {
          return this._lazyInitEmptyStyle(), this.style.setSky(t2), this._update(true);
        }
        getSky() {
          return this.style.getSky();
        }
        setFeatureState(t2, e2) {
          return this.style.setFeatureState(t2, e2), this._update();
        }
        removeFeatureState(t2, e2) {
          return this.style.removeFeatureState(t2, e2), this._update();
        }
        getFeatureState(t2) {
          return this.style.getFeatureState(t2);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let t2 = 0, e2 = 0;
          return this._container && (t2 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t2, e2];
        }
        _setupContainer() {
          const t2 = this._container;
          t2.classList.add("maplibregl-map");
          const e2 = this._canvasContainer = r.create("div", "maplibregl-canvas-container", t2);
          this._interactive && e2.classList.add("maplibregl-interactive"), this._canvas = r.create("canvas", "maplibregl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
          const i2 = this._containerDimensions(), a2 = this._getClampedPixelRatio(i2[0], i2[1]);
          this._resizeCanvas(i2[0], i2[1], a2);
          const s2 = this._controlContainer = r.create("div", "maplibregl-control-container", t2), o2 = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t3) => {
            o2[t3] = r.create("div", `maplibregl-ctrl-${t3} `, s2);
          }), this._container.addEventListener("scroll", this._onMapScroll, false);
        }
        _resizeCanvas(t2, e2, i2) {
          this._canvas.width = Math.floor(i2 * t2), this._canvas.height = Math.floor(i2 * e2), this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${e2}px`;
        }
        _setupPainter() {
          const t2 = { alpha: true, stencil: true, depth: true, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false };
          let e2 = null;
          this._canvas.addEventListener("webglcontextcreationerror", (i3) => {
            e2 = { requestedAttributes: t2 }, i3 && (e2.statusMessage = i3.statusMessage, e2.type = i3.type);
          }, { once: true });
          const i2 = this._canvas.getContext("webgl2", t2) || this._canvas.getContext("webgl", t2);
          if (!i2) {
            const t3 = "Failed to initialize WebGL";
            throw e2 ? (e2.message = t3, new Error(JSON.stringify(e2))) : new Error(t3);
          }
          this.painter = new va(i2, this.transform), n.testSupport(i2);
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(t2) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || t2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(t2) {
          return this._update(), this._renderTaskQueue.add(t2);
        }
        _cancelRenderFrame(t2) {
          this._renderTaskQueue.remove(t2);
        }
        _render(t2) {
          const i2 = this._idleTriggered ? this._fadeDuration : 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t2), this._removed)
            return;
          let a2 = false;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            const t3 = this.transform.zoom, s3 = o.now();
            this.style.zoomHistory.update(t3, s3);
            const r2 = new e.z(t3, { now: s3, fadeDuration: i2, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), n2 = r2.crossFadingFactor();
            n2 === 1 && n2 === this._crossFadingFactor || (a2 = true, this._crossFadingFactor = n2), this.style.update(r2);
          }
          this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, i2, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: i2, showPadding: this.showPadding }), this.fire(new e.k("render")), this.loaded() && !this._loaded && (this._loaded = true, e.bf.mark(e.bg.load), this.fire(new e.k("load"))), this.style && (this.style.hasTransitions() || a2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const s2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return s2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new e.k("idle")), !this._loaded || this._fullyLoaded || s2 || (this._fullyLoaded = true, e.bf.mark(e.bg.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
        }
        remove() {
          var t2;
          this._hash && this._hash.remove();
          for (const t3 of this._controls)
            t3.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window != "undefined" && removeEventListener("online", this._onWindowOnline, false), _.removeThrottleControl(this._imageQueueHandle), (t2 = this._resizeObserver) === null || t2 === undefined || t2.disconnect();
          const i2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
          (i2 == null ? undefined : i2.loseContext) && i2.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), r.remove(this._canvasContainer), r.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), e.bf.clearMetrics(), this._removed = true, this.fire(new e.k("remove"));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController, o.frameAsync(this._frameRequest).then((t2) => {
            e.bf.frame(t2), this._frameRequest = null, this._render(t2);
          }).catch(() => {
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(t2) {
          this._showTileBoundaries !== t2 && (this._showTileBoundaries = t2, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(t2) {
          this._showPadding !== t2 && (this._showPadding = t2, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(t2) {
          this._showCollisionBoxes !== t2 && (this._showCollisionBoxes = t2, t2 ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(t2) {
          this._showOverdrawInspector !== t2 && (this._showOverdrawInspector = t2, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(t2) {
          this._repaint !== t2 && (this._repaint = t2, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(t2) {
          this._vertices = t2, this._update();
        }
        get version() {
          return Ls;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
      }, t.MapMouseEvent = ka, t.MapTouchEvent = La, t.MapWheelEvent = Fa, t.Marker = Vs, t.NavigationControl = class {
        constructor(t2) {
          this._updateZoomButtons = () => {
            const t3 = this._map.getZoom(), e2 = t3 === this._map.getMaxZoom(), i2 = t3 === this._map.getMinZoom();
            this._zoomInButton.disabled = e2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", e2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
          }, this._rotateCompassArrow = () => {
            const t3 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = t3;
          }, this._setButtonTitle = (t3, e2) => {
            const i2 = this._map._getUIString(`NavigationControl.${e2}`);
            t3.title = i2, t3.setAttribute("aria-label", i2);
          }, this.options = e.e({}, Os, t2), this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t3) => this._map.zoomIn({}, { originalEvent: t3 })), r.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t3) => this._map.zoomOut({}, { originalEvent: t3 })), r.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t3) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t3 }) : this._map.resetNorth({}, { originalEvent: t3 });
          }), this._compassIcon = r.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(t2) {
          return this._map = t2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ns(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          r.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(t2, e2) {
          const i2 = r.create("button", t2, this._container);
          return i2.type = "button", i2.addEventListener("click", e2), i2;
        }
      }, t.Popup = class extends e.E {
        constructor(t2) {
          super(), this.remove = () => (this._content && r.remove(this._content), this._container && (r.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new e.k("close"))), this), this._onMouseUp = (t3) => {
            this._update(t3.point);
          }, this._onMouseMove = (t3) => {
            this._update(t3.point);
          }, this._onDrag = (t3) => {
            this._update(t3.point);
          }, this._update = (t3) => {
            var e2;
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
              return;
            if (!this._container) {
              if (this._container = r.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = r.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                for (const t4 of this.options.className.split(" "))
                  this._container.classList.add(t4);
              this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? js(this._lngLat, this._flatPos, this._map.transform) : (e2 = this._lngLat) === null || e2 === undefined ? undefined : e2.wrap(), this._trackPointer && !t3)
              return;
            const i2 = this._flatPos = this._pos = this._trackPointer && t3 ? t3 : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && t3 ? t3 : this._map.transform.locationPoint(this._lngLat));
            let a2 = this.options.anchor;
            const s2 = Qs(this.options.offset);
            if (!a2) {
              const t4 = this._container.offsetWidth, e3 = this._container.offsetHeight;
              let o3;
              o3 = i2.y + s2.bottom.y < e3 ? ["top"] : i2.y > this._map.transform.height - e3 ? ["bottom"] : [], i2.x < t4 / 2 ? o3.push("left") : i2.x > this._map.transform.width - t4 / 2 && o3.push("right"), a2 = o3.length === 0 ? "bottom" : o3.join("-");
            }
            let o2 = i2.add(s2[a2]);
            this.options.subpixelPositioning || (o2 = o2.round()), r.setTransform(this._container, `${Zs[a2]} translate(${o2.x}px,${o2.y}px)`), qs(this._container, a2, "popup");
          }, this._onClose = () => {
            this.remove();
          }, this.options = e.e(Object.create(Js), t2);
        }
        addTo(t2) {
          return this._map && this.remove(), this._map = t2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new e.k("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t2) {
          return this._lngLat = e.N.convert(t2), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(t2) {
          return this.setDOMContent(document.createTextNode(t2));
        }
        setHTML(t2) {
          const e2 = document.createDocumentFragment(), i2 = document.createElement("body");
          let a2;
          for (i2.innerHTML = t2;a2 = i2.firstChild, a2; )
            e2.appendChild(a2);
          return this.setDOMContent(e2);
        }
        getMaxWidth() {
          var t2;
          return (t2 = this._container) === null || t2 === undefined ? undefined : t2.style.maxWidth;
        }
        setMaxWidth(t2) {
          return this.options.maxWidth = t2, this._update(), this;
        }
        setDOMContent(t2) {
          if (this._content)
            for (;this._content.hasChildNodes(); )
              this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else
            this._content = r.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(t2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(t2) {
          return this._container && this._container.classList.add(t2), this;
        }
        removeClassName(t2) {
          return this._container && this._container.classList.remove(t2), this;
        }
        setOffset(t2) {
          return this.options.offset = t2, this._update(), this;
        }
        toggleClassName(t2) {
          if (this._container)
            return this._container.classList.toggle(t2);
        }
        setSubpixelPositioning(t2) {
          this.options.subpixelPositioning = t2;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = r.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const t2 = this._container.querySelector(Ys);
          t2 && t2.focus();
        }
      }, t.RasterDEMTileSource = K, t.RasterTileSource = X, t.ScaleControl = class {
        constructor(t2) {
          this._onMove = () => {
            Xs(this._map, this._container, this.options);
          }, this.setUnit = (t3) => {
            this.options.unit = t3, Xs(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, $s), t2);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(t2) {
          return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", t2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          r.remove(this._container), this._map.off("move", this._onMove), this._map = undefined;
        }
      }, t.ScrollZoomHandler = us, t.Style = de2, t.TerrainControl = class {
        constructor(t2) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
          }, this.options = t2;
        }
        onAdd(t2) {
          return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = r.create("button", "maplibregl-ctrl-terrain", this._container), r.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          r.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = undefined;
        }
      }, t.TwoFingersTouchPitchHandler = rs, t.TwoFingersTouchRotateHandler = ss, t.TwoFingersTouchZoomHandler = is, t.TwoFingersTouchZoomRotateHandler = gs, t.VectorTileSource = $, t.VideoSource = tt, t.addSourceType = (t2, i2) => e._(undefined, undefined, undefined, function* () {
        if (at(t2))
          throw new Error(`A source type called "${t2}" already exists.`);
        ((t3, e2) => {
          it[t3] = e2;
        })(t2, i2);
      }), t.clearPrewarmedResources = function() {
        const t2 = B2;
        t2 && (t2.isPreloaded() && t2.numActive() === 1 ? (t2.release(k), B2 = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, t.getMaxParallelImageRequests = function() {
        return e.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, t.getRTLTextPluginStatus = function() {
        return nt().getRTLTextPluginStatus();
      }, t.getVersion = function() {
        return to;
      }, t.getWorkerCount = function() {
        return L.workerCount;
      }, t.getWorkerUrl = function() {
        return e.a.WORKER_URL;
      }, t.importScriptInWorkers = function(t2) {
        return j().broadcast("IS", t2);
      }, t.prewarm = function() {
        N().acquire(k);
      }, t.setMaxParallelImageRequests = function(t2) {
        e.a.MAX_PARALLEL_IMAGE_REQUESTS = t2;
      }, t.setRTLTextPlugin = function(t2, e2) {
        return nt().setRTLTextPlugin(t2, e2);
      }, t.setWorkerCount = function(t2) {
        L.workerCount = t2;
      }, t.setWorkerUrl = function(t2) {
        e.a.WORKER_URL = t2;
      };
    });
    var maplibregl$1 = maplibregl;
    return maplibregl$1;
  });
});

// node_modules/@turf/helpers/dist/esm/index.js
var earthRadius = 6371008.8;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: 360 / (2 * Math.PI),
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1000,
  kilometres: earthRadius / 1000,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1000,
  millimetres: earthRadius * 1000,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
function feature(geom, properties, options = {}) {
  const feat = { type: "Feature" };
  if (options.id === 0 || options.id) {
    feat.id = options.id;
  }
  if (options.bbox) {
    feat.bbox = options.bbox;
  }
  feat.properties = properties || {};
  feat.geometry = geom;
  return feat;
}
function point(coordinates, properties, options = {}) {
  if (!coordinates) {
    throw new Error("coordinates is required");
  }
  if (!Array.isArray(coordinates)) {
    throw new Error("coordinates must be an Array");
  }
  if (coordinates.length < 2) {
    throw new Error("coordinates must be at least 2 numbers long");
  }
  if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
    throw new Error("coordinates must contain numbers");
  }
  const geom = {
    type: "Point",
    coordinates
  };
  return feature(geom, properties, options);
}
function polygon(coordinates, properties, options = {}) {
  for (const ring of coordinates) {
    if (ring.length < 4) {
      throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
    }
    if (ring[ring.length - 1].length !== ring[0].length) {
      throw new Error("First and last Position are not equivalent.");
    }
    for (let j = 0;j < ring[ring.length - 1].length; j++) {
      if (ring[ring.length - 1][j] !== ring[0][j]) {
        throw new Error("First and last Position are not equivalent.");
      }
    }
  }
  const geom = {
    type: "Polygon",
    coordinates
  };
  return feature(geom, properties, options);
}
function isNumber(num) {
  return !isNaN(num) && num !== null && !Array.isArray(num);
}

// node_modules/@turf/bbox-polygon/dist/esm/index.js
function bboxPolygon(bbox, options = {}) {
  const west = Number(bbox[0]);
  const south = Number(bbox[1]);
  const east = Number(bbox[2]);
  const north = Number(bbox[3]);
  if (bbox.length === 6) {
    throw new Error("@turf/bbox-polygon does not support BBox with 6 positions");
  }
  const lowLeft = [west, south];
  const topLeft = [west, north];
  const topRight = [east, north];
  const lowRight = [east, south];
  return polygon([[lowLeft, lowRight, topRight, topLeft, lowLeft]], options.properties, { bbox, id: options.id });
}

// node_modules/robust-predicates/esm/util.js
var epsilon = 0.00000000000000011102230246251565;
var splitter = 134217729;
var resulterrbound = (3 + 8 * epsilon) * epsilon;
function sum(elen, e, flen, f, h) {
  let Q, Qnew, hh, bvirt;
  let enow = e[0];
  let fnow = f[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e[++eindex];
  } else {
    Q = fnow;
    fnow = f[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e) {
  let Q = e[0];
  for (let i = 1;i < elen; i++)
    Q += e[i];
  return Q;
}
function vec(n) {
  return new Float64Array(n);
}

// node_modules/robust-predicates/esm/orient2d.js
var ccwerrboundA = (3 + 16 * epsilon) * epsilon;
var ccwerrboundB = (2 + 12 * epsilon) * epsilon;
var ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
var B = vec(4);
var C1 = vec(8);
var C2 = vec(12);
var D = vec(16);
var u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcx;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  B[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  B[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  B[2] = _j - (u3 - bvirt) + (_i - bvirt);
  B[3] = u3;
  let det = estimate(4, B);
  let errbound = ccwerrboundB * detsum;
  if (det >= errbound || -det >= errbound) {
    return det;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
  det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det >= errbound || -det >= errbound)
    return det;
  s1 = acxtail * bcy;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcy;
  bhi = c - (c - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcx;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcx;
  bhi = c - (c - bcx);
  blo = bcx - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u[3] = u3;
  const C1len = sum(4, B, 4, u, C1);
  s1 = acx * bcytail;
  c = splitter * acx;
  ahi = c - (c - acx);
  alo = acx - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acy * bcxtail;
  c = splitter * acy;
  ahi = c - (c - acy);
  alo = acy - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u[3] = u3;
  const C2len = sum(C1len, C1, 4, u, C2);
  s1 = acxtail * bcytail;
  c = splitter * acxtail;
  ahi = c - (c - acxtail);
  alo = acxtail - ahi;
  c = splitter * bcytail;
  bhi = c - (c - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t1 = acytail * bcxtail;
  c = splitter * acytail;
  ahi = c - (c - acytail);
  alo = acytail - ahi;
  c = splitter * bcxtail;
  bhi = c - (c - bcxtail);
  blo = bcxtail - bhi;
  t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t0;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t0);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t1;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t1);
  u3 = _j + _i;
  bvirt = u3 - _j;
  u[2] = _j - (u3 - bvirt) + (_i - bvirt);
  u[3] = u3;
  const Dlen = sum(C2len, C2, 4, u, D);
  return D[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det) >= ccwerrboundA * detsum)
    return det;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}
// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA = (7 + 56 * epsilon) * epsilon;
var o3derrboundB = (3 + 28 * epsilon) * epsilon;
var o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u2 = vec(4);
var _8 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _12 = vec(12);
var fin = vec(192);
var fin2 = vec(192);
// node_modules/robust-predicates/esm/incircle.js
var iccerrboundA = (10 + 96 * epsilon) * epsilon;
var iccerrboundB = (4 + 48 * epsilon) * epsilon;
var iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u3 = vec(4);
var v = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _82 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);
// node_modules/robust-predicates/esm/insphere.js
var isperrboundA = (16 + 224 * epsilon) * epsilon;
var isperrboundB = (5 + 72 * epsilon) * epsilon;
var isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de = vec(4);
var ea = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _83 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin5 = vec(1152);
// node_modules/point-in-polygon-hao/dist/esm/index.js
function pointInPolygon(p, polygon2) {
  var i;
  var ii;
  var k = 0;
  var f;
  var u1;
  var v1;
  var u22;
  var v2;
  var currentP;
  var nextP;
  var x = p[0];
  var y = p[1];
  var numContours = polygon2.length;
  for (i = 0;i < numContours; i++) {
    ii = 0;
    var contour = polygon2[i];
    var contourLen = contour.length - 1;
    currentP = contour[0];
    if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {
      throw new Error("First and last coordinates in a ring must be the same");
    }
    u1 = currentP[0] - x;
    v1 = currentP[1] - y;
    for (ii;ii < contourLen; ii++) {
      nextP = contour[ii + 1];
      u22 = nextP[0] - x;
      v2 = nextP[1] - y;
      if (v1 === 0 && v2 === 0) {
        if (u22 <= 0 && u1 >= 0 || u1 <= 0 && u22 >= 0) {
          return 0;
        }
      } else if (v2 >= 0 && v1 < 0 || v2 < 0 && v1 >= 0) {
        f = orient2d(u1, u22, v1, v2, 0, 0);
        if (f === 0) {
          return 0;
        }
        if (f > 0 && v2 > 0 && v1 <= 0 || f < 0 && v2 <= 0 && v1 > 0) {
          k++;
        }
      }
      currentP = nextP;
      v1 = v2;
      u1 = u22;
    }
  }
  if (k % 2 === 0) {
    return false;
  }
  return true;
}

// node_modules/@turf/invariant/dist/esm/index.js
function getCoord(coord) {
  if (!coord) {
    throw new Error("coord is required");
  }
  if (!Array.isArray(coord)) {
    if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
      return [...coord.geometry.coordinates];
    }
    if (coord.type === "Point") {
      return [...coord.coordinates];
    }
  }
  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
    return [...coord];
  }
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getGeom(geojson) {
  if (geojson.type === "Feature") {
    return geojson.geometry;
  }
  return geojson;
}

// node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js
function booleanPointInPolygon(point2, polygon2, options = {}) {
  if (!point2) {
    throw new Error("point is required");
  }
  if (!polygon2) {
    throw new Error("polygon is required");
  }
  const pt = getCoord(point2);
  const geom = getGeom(polygon2);
  const type = geom.type;
  const bbox = polygon2.bbox;
  let polys = geom.coordinates;
  if (bbox && inBBox(pt, bbox) === false) {
    return false;
  }
  if (type === "Polygon") {
    polys = [polys];
  }
  let result = false;
  for (var i = 0;i < polys.length; ++i) {
    const polyResult = pointInPolygon(pt, polys[i]);
    if (polyResult === 0)
      return options.ignoreBoundary ? false : true;
    else if (polyResult)
      result = true;
  }
  return result;
}
function inBBox(pt, bbox) {
  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];
}

// src/client/GeoSpatial.ts
var LAT_CONVERSION = 111.32;
function distanceKm(p1, p2) {
  const lat1 = p1[1];
  const lat2 = p2[1];
  const lon1 = p1[0];
  const lon2 = p2[0];
  const dLat = (lat2 - lat1) * LAT_CONVERSION;
  const dLon = (lon2 - lon1) * LAT_CONVERSION * Math.cos((lat1 + lat2) * Math.PI / 360);
  return Math.sqrt(dLat * dLat + dLon * dLon);
}
function exceedDistance(p1, p2, threshHoldInMeters) {
  return distanceKm(p1, p2) * 1000 >= threshHoldInMeters;
}
function pointInPolygon2(point2, polygon2) {
  let intersection_count = 0;
  for (let i = 0, j = polygon2.length - 1;i < polygon2.length; j = i++) {
    let [lng1, lat1] = polygon2[i];
    let [lng2, lat2] = polygon2[j];
    let [lng, lat] = point2;
    let intersect = lat1 > lat !== lat2 > lat && lng < (lng2 - lng1) * (lat - lat1) / (lat2 - lat1) + lng1;
    if (intersect) {
      intersection_count += 1;
    }
  }
  return intersection_count % 2 === 1;
}
function getSquareCorners(center, distanceKm2) {
  const centerLon = center[0];
  const centerLat = center[1];
  const deltaLat = distanceKm2 / LAT_CONVERSION;
  const deltaLon = distanceKm2 / (LAT_CONVERSION * Math.cos(centerLat * Math.PI / 180));
  const topLeft = [centerLon - deltaLon, centerLat + deltaLat];
  const topRight = [centerLon + deltaLon, centerLat + deltaLat];
  const bottomLeft = [centerLon - deltaLon, centerLat - deltaLat];
  const bottomRight = [centerLon + deltaLon, centerLat - deltaLat];
  return [
    topLeft,
    topRight,
    bottomRight,
    bottomLeft
  ];
}

// src/client/client.ts
var import_maplibre_gl = __toESM(require_maplibre_gl(), 1);

// src/client/tidstangsel_constants.ts
var perim_center = [23.798001194926712, 65.94792047215071];
var update_dist = 10;
var map_bounds_turf = [65.8, 22.8, 66.4, 24.195];
var map_bounds = [[22.8, 65.8], [24.195, 66.4]];
var map_default_center = [23.61, 65.98];
var perim_coords = [
  [23.525427575932326, 66.0903488585733],
  [23.42668791159693, 66.06844236664259],
  [23.47140021242788, 66.00450362832879],
  [23.432276949200798, 65.95824681364806],
  [23.468605693625392, 65.83842512404459],
  [23.66422200976305, 65.83232398441024],
  [23.887783513920027, 65.79912368543009],
  [24.08619434886012, 65.8044691547079],
  [24.19704359467036, 65.82545847133909],
  [24.190523050799385, 65.8868015859372],
  [24.03030397282032, 66.06239587288295],
  [23.852386275762512, 66.04538240012698],
  [23.593427533447, 66.05256725398294],
  [23.525467719592257, 66.09034391453025],
  [23.525427575932326, 66.0903488585733]
];
var perim_coords_turf = [
  [66.0903488585733, 23.525427575932326],
  [66.06844236664259, 23.42668791159693],
  [66.00450362832879, 23.47140021242788],
  [65.95824681364806, 23.432276949200798],
  [65.83842512404459, 23.468605693625392],
  [65.83232398441024, 23.66422200976305],
  [65.79912368543009, 23.887783513920027],
  [65.8044691547079, 24.08619434886012],
  [65.82545847133909, 24.19704359467036],
  [65.8868015859372, 24.190523050799385],
  [66.06239587288295, 24.03030397282032],
  [66.04538240012698, 23.85238627576251],
  [66.05256725398294, 23.593427533447],
  [66.09034391453025, 23.525467719592257],
  [66.0903488585733, 23.525427575932326]
];
var mock_center = [18.030308, 59.256915];
var mock_perim_coords = perim_coords.map(([lon, lat]) => {
  let [clon, clat] = map_default_center;
  let [mlon, mlat] = mock_center;
  let dlon = clon - lon;
  let dlat = clat - lat;
  return [mlon + dlon, mlat + dlat];
});
var map_description = {
  container: "map",
  bounds: map_bounds,
  maxBounds: map_bounds,
  center: map_default_center,
  minZoom: 9,
  maxZoom: 16,
  zoom: 9,
  dragPan: true,
  dragRotate: false,
  pitchWithRotate: false,
  touchZoomRotate: false,
  touchPitch: false,
  keyboard: false,
  style: {
    version: 8,
    sources: {
      osm: {
        type: "raster",
        tiles: ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
        tileSize: 128,
        attribution: "&copy; OpenStreetMap Contributors",
        maxzoom: 16
      },
      perim_src: {
        type: "geojson",
        data: {
          type: "Feature",
          properties: {},
          geometry: {
            type: "LineString",
            coordinates: perim_coords
          }
        }
      },
      perim_pgon: {
        type: "geojson",
        data: {
          type: "Feature",
          properties: {},
          geometry: {
            type: "Polygon",
            coordinates: [perim_coords]
          }
        }
      },
      verner: {
        type: "image",
        url: "/assets/verner_bostrom_sprite.png",
        coordinates: getSquareCorners(perim_center, 10)
      }
    },
    layers: [
      {
        id: "osm",
        type: "raster",
        source: "osm"
      },
      {
        id: "perim_fill",
        source: "perim_pgon",
        type: "fill",
        paint: {
          "fill-color": "blue",
          "fill-opacity": 0.2
        }
      },
      {
        id: "verner_layer",
        type: "raster",
        source: "verner",
        paint: {
          "raster-opacity": 0.3
        }
      }
    ]
  }
};
var mock_map_description = {
  container: "map",
  bounds: map_bounds,
  maxBounds: map_bounds,
  center: map_default_center,
  minZoom: 9,
  maxZoom: 16,
  zoom: 9,
  dragPan: true,
  dragRotate: false,
  pitchWithRotate: false,
  touchZoomRotate: false,
  touchPitch: false,
  keyboard: false,
  style: {
    version: 8,
    sources: {
      osm: {
        type: "raster",
        tiles: ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
        tileSize: 128,
        attribution: "&copy; OpenStreetMap Contributors",
        maxzoom: 16
      },
      perim_src: {
        type: "geojson",
        data: {
          type: "Feature",
          properties: {},
          geometry: {
            type: "LineString",
            coordinates: mock_perim_coords
          }
        }
      },
      perim_pgon: {
        type: "geojson",
        data: {
          type: "Feature",
          properties: {},
          geometry: {
            type: "Polygon",
            coordinates: [mock_perim_coords]
          }
        }
      },
      verner: {
        type: "image",
        url: "/assets/verner_bostrom_sprite.png",
        coordinates: getSquareCorners(mock_center, 10)
      }
    },
    layers: [
      {
        id: "osm",
        type: "raster",
        source: "osm"
      },
      {
        id: "perim_fill",
        source: "perim_pgon",
        type: "fill",
        paint: {
          "fill-color": "blue",
          "fill-opacity": 0.2
        }
      },
      {
        id: "verner_layer",
        type: "raster",
        source: "verner",
        paint: {
          "raster-opacity": 0.3
        }
      }
    ]
  }
};
var eventmap = new Map([
  ["geomap", new Set(["ready", "removed"])],
  ["simmap", new Set(["ready", "removed"])],
  ["geopos", new Set(["outofbounds", "perim_enter", "perim_exit", "update", "error", "focus", "lostfocus", "init_success", "init_denied"])],
  ["simpos", new Set(["outofbounds", "perim_enter", "perim_exit", "update"])],
  ["stream", new Set(["fatal_error", "media_error", "network_error", "cannot_load", "autoplay_failed", "stream_closed", "stream_killed"])],
  ["app", new Set(["unsupported", "session_activated", "ready"])]
]);
var get_event_name = (emitter, name) => {
  if (eventmap.get(emitter)?.has(name)) {
    return emitter + "_" + name;
  } else {
    throw "incorrect setting of event name " + emitter + " " + name;
  }
};
function getNonce() {
  return document.getElementById("tidstangsel_script").getAttribute("data-nonce");
}

// node_modules/hls.js/dist/hls.mjs
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var urlToolkit = { exports: {} };
(function(module, exports) {
  (function(root) {
    var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
    var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
    var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
    var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
    var URLToolkit = {
      buildAbsoluteURL: function(baseURL, relativeURL, opts) {
        opts = opts || {};
        baseURL = baseURL.trim();
        relativeURL = relativeURL.trim();
        if (!relativeURL) {
          if (!opts.alwaysNormalize) {
            return baseURL;
          }
          var basePartsForNormalise = URLToolkit.parseURL(baseURL);
          if (!basePartsForNormalise) {
            throw new Error("Error trying to parse base URL.");
          }
          basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
          return URLToolkit.buildURLFromParts(basePartsForNormalise);
        }
        var relativeParts = URLToolkit.parseURL(relativeURL);
        if (!relativeParts) {
          throw new Error("Error trying to parse relative URL.");
        }
        if (relativeParts.scheme) {
          if (!opts.alwaysNormalize) {
            return relativeURL;
          }
          relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
          return URLToolkit.buildURLFromParts(relativeParts);
        }
        var baseParts = URLToolkit.parseURL(baseURL);
        if (!baseParts) {
          throw new Error("Error trying to parse base URL.");
        }
        if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
          var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
          baseParts.netLoc = pathParts[1];
          baseParts.path = pathParts[2];
        }
        if (baseParts.netLoc && !baseParts.path) {
          baseParts.path = "/";
        }
        var builtParts = {
          scheme: baseParts.scheme,
          netLoc: relativeParts.netLoc,
          path: null,
          params: relativeParts.params,
          query: relativeParts.query,
          fragment: relativeParts.fragment
        };
        if (!relativeParts.netLoc) {
          builtParts.netLoc = baseParts.netLoc;
          if (relativeParts.path[0] !== "/") {
            if (!relativeParts.path) {
              builtParts.path = baseParts.path;
              if (!relativeParts.params) {
                builtParts.params = baseParts.params;
                if (!relativeParts.query) {
                  builtParts.query = baseParts.query;
                }
              }
            } else {
              var baseURLPath = baseParts.path;
              var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
              builtParts.path = URLToolkit.normalizePath(newPath);
            }
          }
        }
        if (builtParts.path === null) {
          builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
        }
        return URLToolkit.buildURLFromParts(builtParts);
      },
      parseURL: function(url) {
        var parts = URL_REGEX.exec(url);
        if (!parts) {
          return null;
        }
        return {
          scheme: parts[1] || "",
          netLoc: parts[2] || "",
          path: parts[3] || "",
          params: parts[4] || "",
          query: parts[5] || "",
          fragment: parts[6] || ""
        };
      },
      normalizePath: function(path) {
        path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
        while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
        }
        return path.split("").reverse().join("");
      },
      buildURLFromParts: function(parts) {
        return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
      }
    };
    module.exports = URLToolkit;
  })();
})(urlToolkit);
var urlToolkitExports = urlToolkit.exports;
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1;r < arguments.length; r++) {
    var t = arguments[r] != null ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _toPrimitive(t, r) {
  if (typeof t != "object" || !t)
    return t;
  var e = t[Symbol.toPrimitive];
  if (e !== undefined) {
    var i = e.call(t, r || "default");
    if (typeof i != "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r === "string" ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return typeof i == "symbol" ? i : String(i);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var isFiniteNumber = Number.isFinite || function(value) {
  return typeof value === "number" && isFinite(value);
};
var isSafeInteger = Number.isSafeInteger || function(value) {
  return typeof value === "number" && Math.abs(value) <= MAX_SAFE_INTEGER;
};
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
var Events = /* @__PURE__ */ function(Events2) {
  Events2["MEDIA_ATTACHING"] = "hlsMediaAttaching";
  Events2["MEDIA_ATTACHED"] = "hlsMediaAttached";
  Events2["MEDIA_DETACHING"] = "hlsMediaDetaching";
  Events2["MEDIA_DETACHED"] = "hlsMediaDetached";
  Events2["BUFFER_RESET"] = "hlsBufferReset";
  Events2["BUFFER_CODECS"] = "hlsBufferCodecs";
  Events2["BUFFER_CREATED"] = "hlsBufferCreated";
  Events2["BUFFER_APPENDING"] = "hlsBufferAppending";
  Events2["BUFFER_APPENDED"] = "hlsBufferAppended";
  Events2["BUFFER_EOS"] = "hlsBufferEos";
  Events2["BUFFER_FLUSHING"] = "hlsBufferFlushing";
  Events2["BUFFER_FLUSHED"] = "hlsBufferFlushed";
  Events2["MANIFEST_LOADING"] = "hlsManifestLoading";
  Events2["MANIFEST_LOADED"] = "hlsManifestLoaded";
  Events2["MANIFEST_PARSED"] = "hlsManifestParsed";
  Events2["LEVEL_SWITCHING"] = "hlsLevelSwitching";
  Events2["LEVEL_SWITCHED"] = "hlsLevelSwitched";
  Events2["LEVEL_LOADING"] = "hlsLevelLoading";
  Events2["LEVEL_LOADED"] = "hlsLevelLoaded";
  Events2["LEVEL_UPDATED"] = "hlsLevelUpdated";
  Events2["LEVEL_PTS_UPDATED"] = "hlsLevelPtsUpdated";
  Events2["LEVELS_UPDATED"] = "hlsLevelsUpdated";
  Events2["AUDIO_TRACKS_UPDATED"] = "hlsAudioTracksUpdated";
  Events2["AUDIO_TRACK_SWITCHING"] = "hlsAudioTrackSwitching";
  Events2["AUDIO_TRACK_SWITCHED"] = "hlsAudioTrackSwitched";
  Events2["AUDIO_TRACK_LOADING"] = "hlsAudioTrackLoading";
  Events2["AUDIO_TRACK_LOADED"] = "hlsAudioTrackLoaded";
  Events2["SUBTITLE_TRACKS_UPDATED"] = "hlsSubtitleTracksUpdated";
  Events2["SUBTITLE_TRACKS_CLEARED"] = "hlsSubtitleTracksCleared";
  Events2["SUBTITLE_TRACK_SWITCH"] = "hlsSubtitleTrackSwitch";
  Events2["SUBTITLE_TRACK_LOADING"] = "hlsSubtitleTrackLoading";
  Events2["SUBTITLE_TRACK_LOADED"] = "hlsSubtitleTrackLoaded";
  Events2["SUBTITLE_FRAG_PROCESSED"] = "hlsSubtitleFragProcessed";
  Events2["CUES_PARSED"] = "hlsCuesParsed";
  Events2["NON_NATIVE_TEXT_TRACKS_FOUND"] = "hlsNonNativeTextTracksFound";
  Events2["INIT_PTS_FOUND"] = "hlsInitPtsFound";
  Events2["FRAG_LOADING"] = "hlsFragLoading";
  Events2["FRAG_LOAD_EMERGENCY_ABORTED"] = "hlsFragLoadEmergencyAborted";
  Events2["FRAG_LOADED"] = "hlsFragLoaded";
  Events2["FRAG_DECRYPTED"] = "hlsFragDecrypted";
  Events2["FRAG_PARSING_INIT_SEGMENT"] = "hlsFragParsingInitSegment";
  Events2["FRAG_PARSING_USERDATA"] = "hlsFragParsingUserdata";
  Events2["FRAG_PARSING_METADATA"] = "hlsFragParsingMetadata";
  Events2["FRAG_PARSED"] = "hlsFragParsed";
  Events2["FRAG_BUFFERED"] = "hlsFragBuffered";
  Events2["FRAG_CHANGED"] = "hlsFragChanged";
  Events2["FPS_DROP"] = "hlsFpsDrop";
  Events2["FPS_DROP_LEVEL_CAPPING"] = "hlsFpsDropLevelCapping";
  Events2["MAX_AUTO_LEVEL_UPDATED"] = "hlsMaxAutoLevelUpdated";
  Events2["ERROR"] = "hlsError";
  Events2["DESTROYING"] = "hlsDestroying";
  Events2["KEY_LOADING"] = "hlsKeyLoading";
  Events2["KEY_LOADED"] = "hlsKeyLoaded";
  Events2["LIVE_BACK_BUFFER_REACHED"] = "hlsLiveBackBufferReached";
  Events2["BACK_BUFFER_REACHED"] = "hlsBackBufferReached";
  Events2["STEERING_MANIFEST_LOADED"] = "hlsSteeringManifestLoaded";
  return Events2;
}({});
var ErrorTypes = /* @__PURE__ */ function(ErrorTypes2) {
  ErrorTypes2["NETWORK_ERROR"] = "networkError";
  ErrorTypes2["MEDIA_ERROR"] = "mediaError";
  ErrorTypes2["KEY_SYSTEM_ERROR"] = "keySystemError";
  ErrorTypes2["MUX_ERROR"] = "muxError";
  ErrorTypes2["OTHER_ERROR"] = "otherError";
  return ErrorTypes2;
}({});
var ErrorDetails = /* @__PURE__ */ function(ErrorDetails2) {
  ErrorDetails2["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
  ErrorDetails2["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
  ErrorDetails2["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
  ErrorDetails2["KEY_SYSTEM_NO_CONFIGURED_LICENSE"] = "keySystemNoConfiguredLicense";
  ErrorDetails2["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
  ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED"] = "keySystemServerCertificateRequestFailed";
  ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED"] = "keySystemServerCertificateUpdateFailed";
  ErrorDetails2["KEY_SYSTEM_SESSION_UPDATE_FAILED"] = "keySystemSessionUpdateFailed";
  ErrorDetails2["KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED"] = "keySystemStatusOutputRestricted";
  ErrorDetails2["KEY_SYSTEM_STATUS_INTERNAL_ERROR"] = "keySystemStatusInternalError";
  ErrorDetails2["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
  ErrorDetails2["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
  ErrorDetails2["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
  ErrorDetails2["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
  ErrorDetails2["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
  ErrorDetails2["LEVEL_LOAD_ERROR"] = "levelLoadError";
  ErrorDetails2["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
  ErrorDetails2["LEVEL_PARSING_ERROR"] = "levelParsingError";
  ErrorDetails2["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
  ErrorDetails2["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
  ErrorDetails2["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
  ErrorDetails2["SUBTITLE_LOAD_ERROR"] = "subtitleTrackLoadError";
  ErrorDetails2["SUBTITLE_TRACK_LOAD_TIMEOUT"] = "subtitleTrackLoadTimeOut";
  ErrorDetails2["FRAG_LOAD_ERROR"] = "fragLoadError";
  ErrorDetails2["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
  ErrorDetails2["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
  ErrorDetails2["FRAG_PARSING_ERROR"] = "fragParsingError";
  ErrorDetails2["FRAG_GAP"] = "fragGap";
  ErrorDetails2["REMUX_ALLOC_ERROR"] = "remuxAllocError";
  ErrorDetails2["KEY_LOAD_ERROR"] = "keyLoadError";
  ErrorDetails2["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
  ErrorDetails2["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
  ErrorDetails2["BUFFER_INCOMPATIBLE_CODECS_ERROR"] = "bufferIncompatibleCodecsError";
  ErrorDetails2["BUFFER_APPEND_ERROR"] = "bufferAppendError";
  ErrorDetails2["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
  ErrorDetails2["BUFFER_STALLED_ERROR"] = "bufferStalledError";
  ErrorDetails2["BUFFER_FULL_ERROR"] = "bufferFullError";
  ErrorDetails2["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
  ErrorDetails2["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
  ErrorDetails2["INTERNAL_EXCEPTION"] = "internalException";
  ErrorDetails2["INTERNAL_ABORTED"] = "aborted";
  ErrorDetails2["UNKNOWN"] = "unknown";
  return ErrorDetails2;
}({});
var noop = function noop2() {
};
var fakeLogger = {
  trace: noop,
  debug: noop,
  log: noop,
  warn: noop,
  info: noop,
  error: noop
};
var exportedLogger = fakeLogger;
function consolePrintFn(type) {
  const func = self.console[type];
  if (func) {
    return func.bind(self.console, `[${type}] >`);
  }
  return noop;
}
function exportLoggerFunctions(debugConfig, ...functions) {
  functions.forEach(function(type) {
    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
  });
}
function enableLogs(debugConfig, id) {
  if (typeof console === "object" && debugConfig === true || typeof debugConfig === "object") {
    exportLoggerFunctions(debugConfig, "debug", "log", "info", "warn", "error");
    try {
      exportedLogger.log(`Debug logs enabled for "${id}" in hls.js version ${"1.5.17"}`);
    } catch (e) {
      exportedLogger = fakeLogger;
    }
  } else {
    exportedLogger = fakeLogger;
  }
}
var logger = exportedLogger;
var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
var ATTR_LIST_REGEX = /(.+?)=(".*?"|.*?)(?:,|$)/g;

class AttrList {
  constructor(attrs) {
    if (typeof attrs === "string") {
      attrs = AttrList.parseAttrList(attrs);
    }
    _extends(this, attrs);
  }
  get clientAttrs() {
    return Object.keys(this).filter((attr) => attr.substring(0, 2) === "X-");
  }
  decimalInteger(attrName) {
    const intValue = parseInt(this[attrName], 10);
    if (intValue > Number.MAX_SAFE_INTEGER) {
      return Infinity;
    }
    return intValue;
  }
  hexadecimalInteger(attrName) {
    if (this[attrName]) {
      let stringValue = (this[attrName] || "0x").slice(2);
      stringValue = (stringValue.length & 1 ? "0" : "") + stringValue;
      const value = new Uint8Array(stringValue.length / 2);
      for (let i = 0;i < stringValue.length / 2; i++) {
        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
      }
      return value;
    } else {
      return null;
    }
  }
  hexadecimalIntegerAsNumber(attrName) {
    const intValue = parseInt(this[attrName], 16);
    if (intValue > Number.MAX_SAFE_INTEGER) {
      return Infinity;
    }
    return intValue;
  }
  decimalFloatingPoint(attrName) {
    return parseFloat(this[attrName]);
  }
  optionalFloat(attrName, defaultValue) {
    const value = this[attrName];
    return value ? parseFloat(value) : defaultValue;
  }
  enumeratedString(attrName) {
    return this[attrName];
  }
  bool(attrName) {
    return this[attrName] === "YES";
  }
  decimalResolution(attrName) {
    const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
    if (res === null) {
      return;
    }
    return {
      width: parseInt(res[1], 10),
      height: parseInt(res[2], 10)
    };
  }
  static parseAttrList(input) {
    let match;
    const attrs = {};
    const quote = '"';
    ATTR_LIST_REGEX.lastIndex = 0;
    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
      let value = match[2];
      if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
        value = value.slice(1, -1);
      }
      const name = match[1].trim();
      attrs[name] = value;
    }
    return attrs;
  }
}
function isDateRangeCueAttribute(attrName) {
  return attrName !== "ID" && attrName !== "CLASS" && attrName !== "START-DATE" && attrName !== "DURATION" && attrName !== "END-DATE" && attrName !== "END-ON-NEXT";
}
function isSCTE35Attribute(attrName) {
  return attrName === "SCTE35-OUT" || attrName === "SCTE35-IN";
}

class DateRange {
  constructor(dateRangeAttr, dateRangeWithSameId) {
    this.attr = undefined;
    this._startDate = undefined;
    this._endDate = undefined;
    this._badValueForSameId = undefined;
    if (dateRangeWithSameId) {
      const previousAttr = dateRangeWithSameId.attr;
      for (const key in previousAttr) {
        if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {
          logger.warn(`DATERANGE tag attribute: "${key}" does not match for tags with ID: "${dateRangeAttr.ID}"`);
          this._badValueForSameId = key;
          break;
        }
      }
      dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);
    }
    this.attr = dateRangeAttr;
    this._startDate = new Date(dateRangeAttr["START-DATE"]);
    if ("END-DATE" in this.attr) {
      const endDate = new Date(this.attr["END-DATE"]);
      if (isFiniteNumber(endDate.getTime())) {
        this._endDate = endDate;
      }
    }
  }
  get id() {
    return this.attr.ID;
  }
  get class() {
    return this.attr.CLASS;
  }
  get startDate() {
    return this._startDate;
  }
  get endDate() {
    if (this._endDate) {
      return this._endDate;
    }
    const duration = this.duration;
    if (duration !== null) {
      return new Date(this._startDate.getTime() + duration * 1000);
    }
    return null;
  }
  get duration() {
    if ("DURATION" in this.attr) {
      const duration = this.attr.decimalFloatingPoint("DURATION");
      if (isFiniteNumber(duration)) {
        return duration;
      }
    } else if (this._endDate) {
      return (this._endDate.getTime() - this._startDate.getTime()) / 1000;
    }
    return null;
  }
  get plannedDuration() {
    if ("PLANNED-DURATION" in this.attr) {
      return this.attr.decimalFloatingPoint("PLANNED-DURATION");
    }
    return null;
  }
  get endOnNext() {
    return this.attr.bool("END-ON-NEXT");
  }
  get isValid() {
    return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);
  }
}

class LoadStats {
  constructor() {
    this.aborted = false;
    this.loaded = 0;
    this.retry = 0;
    this.total = 0;
    this.chunkCount = 0;
    this.bwEstimate = 0;
    this.loading = {
      start: 0,
      first: 0,
      end: 0
    };
    this.parsing = {
      start: 0,
      end: 0
    };
    this.buffering = {
      start: 0,
      first: 0,
      end: 0
    };
  }
}
var ElementaryStreamTypes = {
  AUDIO: "audio",
  VIDEO: "video",
  AUDIOVIDEO: "audiovideo"
};

class BaseSegment {
  constructor(baseurl) {
    this._byteRange = null;
    this._url = null;
    this.baseurl = undefined;
    this.relurl = undefined;
    this.elementaryStreams = {
      [ElementaryStreamTypes.AUDIO]: null,
      [ElementaryStreamTypes.VIDEO]: null,
      [ElementaryStreamTypes.AUDIOVIDEO]: null
    };
    this.baseurl = baseurl;
  }
  setByteRange(value, previous) {
    const params = value.split("@", 2);
    let start;
    if (params.length === 1) {
      start = (previous == null ? undefined : previous.byteRangeEndOffset) || 0;
    } else {
      start = parseInt(params[1]);
    }
    this._byteRange = [start, parseInt(params[0]) + start];
  }
  get byteRange() {
    if (!this._byteRange) {
      return [];
    }
    return this._byteRange;
  }
  get byteRangeStartOffset() {
    return this.byteRange[0];
  }
  get byteRangeEndOffset() {
    return this.byteRange[1];
  }
  get url() {
    if (!this._url && this.baseurl && this.relurl) {
      this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {
        alwaysNormalize: true
      });
    }
    return this._url || "";
  }
  set url(value) {
    this._url = value;
  }
}

class Fragment extends BaseSegment {
  constructor(type, baseurl) {
    super(baseurl);
    this._decryptdata = null;
    this.rawProgramDateTime = null;
    this.programDateTime = null;
    this.tagList = [];
    this.duration = 0;
    this.sn = 0;
    this.levelkeys = undefined;
    this.type = undefined;
    this.loader = null;
    this.keyLoader = null;
    this.level = -1;
    this.cc = 0;
    this.startPTS = undefined;
    this.endPTS = undefined;
    this.startDTS = undefined;
    this.endDTS = undefined;
    this.start = 0;
    this.deltaPTS = undefined;
    this.maxStartPTS = undefined;
    this.minEndPTS = undefined;
    this.stats = new LoadStats;
    this.data = undefined;
    this.bitrateTest = false;
    this.title = null;
    this.initSegment = null;
    this.endList = undefined;
    this.gap = undefined;
    this.urlId = 0;
    this.type = type;
  }
  get decryptdata() {
    const {
      levelkeys
    } = this;
    if (!levelkeys && !this._decryptdata) {
      return null;
    }
    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
      const key = this.levelkeys.identity;
      if (key) {
        this._decryptdata = key.getDecryptData(this.sn);
      } else {
        const keyFormats = Object.keys(this.levelkeys);
        if (keyFormats.length === 1) {
          return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);
        }
      }
    }
    return this._decryptdata;
  }
  get end() {
    return this.start + this.duration;
  }
  get endProgramDateTime() {
    if (this.programDateTime === null) {
      return null;
    }
    if (!isFiniteNumber(this.programDateTime)) {
      return null;
    }
    const duration = !isFiniteNumber(this.duration) ? 0 : this.duration;
    return this.programDateTime + duration * 1000;
  }
  get encrypted() {
    var _this$_decryptdata;
    if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {
      return true;
    } else if (this.levelkeys) {
      const keyFormats = Object.keys(this.levelkeys);
      const len = keyFormats.length;
      if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {
        return true;
      }
    }
    return false;
  }
  setKeyFormat(keyFormat) {
    if (this.levelkeys) {
      const key = this.levelkeys[keyFormat];
      if (key && !this._decryptdata) {
        this._decryptdata = key.getDecryptData(this.sn);
      }
    }
  }
  abortRequests() {
    var _this$loader, _this$keyLoader;
    (_this$loader = this.loader) == null || _this$loader.abort();
    (_this$keyLoader = this.keyLoader) == null || _this$keyLoader.abort();
  }
  setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial = false) {
    const {
      elementaryStreams
    } = this;
    const info = elementaryStreams[type];
    if (!info) {
      elementaryStreams[type] = {
        startPTS,
        endPTS,
        startDTS,
        endDTS,
        partial
      };
      return;
    }
    info.startPTS = Math.min(info.startPTS, startPTS);
    info.endPTS = Math.max(info.endPTS, endPTS);
    info.startDTS = Math.min(info.startDTS, startDTS);
    info.endDTS = Math.max(info.endDTS, endDTS);
  }
  clearElementaryStreamInfo() {
    const {
      elementaryStreams
    } = this;
    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;
    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;
    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;
  }
}

class Part extends BaseSegment {
  constructor(partAttrs, frag, baseurl, index, previous) {
    super(baseurl);
    this.fragOffset = 0;
    this.duration = 0;
    this.gap = false;
    this.independent = false;
    this.relurl = undefined;
    this.fragment = undefined;
    this.index = undefined;
    this.stats = new LoadStats;
    this.duration = partAttrs.decimalFloatingPoint("DURATION");
    this.gap = partAttrs.bool("GAP");
    this.independent = partAttrs.bool("INDEPENDENT");
    this.relurl = partAttrs.enumeratedString("URI");
    this.fragment = frag;
    this.index = index;
    const byteRange = partAttrs.enumeratedString("BYTERANGE");
    if (byteRange) {
      this.setByteRange(byteRange, previous);
    }
    if (previous) {
      this.fragOffset = previous.fragOffset + previous.duration;
    }
  }
  get start() {
    return this.fragment.start + this.fragOffset;
  }
  get end() {
    return this.start + this.duration;
  }
  get loaded() {
    const {
      elementaryStreams
    } = this;
    return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);
  }
}
var DEFAULT_TARGET_DURATION = 10;

class LevelDetails {
  constructor(baseUrl) {
    this.PTSKnown = false;
    this.alignedSliding = false;
    this.averagetargetduration = undefined;
    this.endCC = 0;
    this.endSN = 0;
    this.fragments = undefined;
    this.fragmentHint = undefined;
    this.partList = null;
    this.dateRanges = undefined;
    this.live = true;
    this.ageHeader = 0;
    this.advancedDateTime = undefined;
    this.updated = true;
    this.advanced = true;
    this.availabilityDelay = undefined;
    this.misses = 0;
    this.startCC = 0;
    this.startSN = 0;
    this.startTimeOffset = null;
    this.targetduration = 0;
    this.totalduration = 0;
    this.type = null;
    this.url = undefined;
    this.m3u8 = "";
    this.version = null;
    this.canBlockReload = false;
    this.canSkipUntil = 0;
    this.canSkipDateRanges = false;
    this.skippedSegments = 0;
    this.recentlyRemovedDateranges = undefined;
    this.partHoldBack = 0;
    this.holdBack = 0;
    this.partTarget = 0;
    this.preloadHint = undefined;
    this.renditionReports = undefined;
    this.tuneInGoal = 0;
    this.deltaUpdateFailed = undefined;
    this.driftStartTime = 0;
    this.driftEndTime = 0;
    this.driftStart = 0;
    this.driftEnd = 0;
    this.encryptedFragments = undefined;
    this.playlistParsingError = null;
    this.variableList = null;
    this.hasVariableRefs = false;
    this.fragments = [];
    this.encryptedFragments = [];
    this.dateRanges = {};
    this.url = baseUrl;
  }
  reloaded(previous) {
    if (!previous) {
      this.advanced = true;
      this.updated = true;
      return;
    }
    const partSnDiff = this.lastPartSn - previous.lastPartSn;
    const partIndexDiff = this.lastPartIndex - previous.lastPartIndex;
    this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;
    this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;
    if (this.updated || this.advanced) {
      this.misses = Math.floor(previous.misses * 0.6);
    } else {
      this.misses = previous.misses + 1;
    }
    this.availabilityDelay = previous.availabilityDelay;
  }
  get hasProgramDateTime() {
    if (this.fragments.length) {
      return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);
    }
    return false;
  }
  get levelTargetDuration() {
    return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;
  }
  get drift() {
    const runTime = this.driftEndTime - this.driftStartTime;
    if (runTime > 0) {
      const runDuration = this.driftEnd - this.driftStart;
      return runDuration * 1000 / runTime;
    }
    return 1;
  }
  get edge() {
    return this.partEnd || this.fragmentEnd;
  }
  get partEnd() {
    var _this$partList;
    if ((_this$partList = this.partList) != null && _this$partList.length) {
      return this.partList[this.partList.length - 1].end;
    }
    return this.fragmentEnd;
  }
  get fragmentEnd() {
    var _this$fragments;
    if ((_this$fragments = this.fragments) != null && _this$fragments.length) {
      return this.fragments[this.fragments.length - 1].end;
    }
    return 0;
  }
  get age() {
    if (this.advancedDateTime) {
      return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;
    }
    return 0;
  }
  get lastPartIndex() {
    var _this$partList2;
    if ((_this$partList2 = this.partList) != null && _this$partList2.length) {
      return this.partList[this.partList.length - 1].index;
    }
    return -1;
  }
  get lastPartSn() {
    var _this$partList3;
    if ((_this$partList3 = this.partList) != null && _this$partList3.length) {
      return this.partList[this.partList.length - 1].fragment.sn;
    }
    return this.endSN;
  }
}
function base64Decode(base64encodedStr) {
  return Uint8Array.from(atob(base64encodedStr), (c) => c.charCodeAt(0));
}
function getKeyIdBytes(str) {
  const keyIdbytes = strToUtf8array(str).subarray(0, 16);
  const paddedkeyIdbytes = new Uint8Array(16);
  paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);
  return paddedkeyIdbytes;
}
function changeEndianness(keyId) {
  const swap = function swap(array, from, to) {
    const cur = array[from];
    array[from] = array[to];
    array[to] = cur;
  };
  swap(keyId, 0, 3);
  swap(keyId, 1, 2);
  swap(keyId, 4, 5);
  swap(keyId, 6, 7);
}
function convertDataUriToArrayBytes(uri) {
  const colonsplit = uri.split(":");
  let keydata = null;
  if (colonsplit[0] === "data" && colonsplit.length === 2) {
    const semicolonsplit = colonsplit[1].split(";");
    const commasplit = semicolonsplit[semicolonsplit.length - 1].split(",");
    if (commasplit.length === 2) {
      const isbase64 = commasplit[0] === "base64";
      const data = commasplit[1];
      if (isbase64) {
        semicolonsplit.splice(-1, 1);
        keydata = base64Decode(data);
      } else {
        keydata = getKeyIdBytes(data);
      }
    }
  }
  return keydata;
}
function strToUtf8array(str) {
  return Uint8Array.from(unescape(encodeURIComponent(str)), (c) => c.charCodeAt(0));
}
var optionalSelf = typeof self !== "undefined" ? self : undefined;
var KeySystems = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.fps",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "com.widevine.alpha"
};
var KeySystemFormats = {
  CLEARKEY: "org.w3.clearkey",
  FAIRPLAY: "com.apple.streamingkeydelivery",
  PLAYREADY: "com.microsoft.playready",
  WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
};
function keySystemFormatToKeySystemDomain(format) {
  switch (format) {
    case KeySystemFormats.FAIRPLAY:
      return KeySystems.FAIRPLAY;
    case KeySystemFormats.PLAYREADY:
      return KeySystems.PLAYREADY;
    case KeySystemFormats.WIDEVINE:
      return KeySystems.WIDEVINE;
    case KeySystemFormats.CLEARKEY:
      return KeySystems.CLEARKEY;
  }
}
var KeySystemIds = {
  CENC: "1077efecc0b24d02ace33c1e52e2fb4b",
  CLEARKEY: "e2719d58a985b3c9781ab030af78d30e",
  FAIRPLAY: "94ce86fb07ff4f43adb893d2fa968ca2",
  PLAYREADY: "9a04f07998404286ab92e65be0885f95",
  WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed"
};
function keySystemIdToKeySystemDomain(systemId) {
  if (systemId === KeySystemIds.WIDEVINE) {
    return KeySystems.WIDEVINE;
  } else if (systemId === KeySystemIds.PLAYREADY) {
    return KeySystems.PLAYREADY;
  } else if (systemId === KeySystemIds.CENC || systemId === KeySystemIds.CLEARKEY) {
    return KeySystems.CLEARKEY;
  }
}
function keySystemDomainToKeySystemFormat(keySystem) {
  switch (keySystem) {
    case KeySystems.FAIRPLAY:
      return KeySystemFormats.FAIRPLAY;
    case KeySystems.PLAYREADY:
      return KeySystemFormats.PLAYREADY;
    case KeySystems.WIDEVINE:
      return KeySystemFormats.WIDEVINE;
    case KeySystems.CLEARKEY:
      return KeySystemFormats.CLEARKEY;
  }
}
function getKeySystemsForConfig(config) {
  const {
    drmSystems,
    widevineLicenseUrl
  } = config;
  const keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter((keySystem) => !!drmSystems[keySystem]) : [];
  if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {
    keySystemsToAttempt.push(KeySystems.WIDEVINE);
  }
  return keySystemsToAttempt;
}
var requestMediaKeySystemAccess = function(_optionalSelf$navigat) {
  if (optionalSelf != null && (_optionalSelf$navigat = optionalSelf.navigator) != null && _optionalSelf$navigat.requestMediaKeySystemAccess) {
    return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);
  } else {
    return null;
  }
}();
function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {
  let initDataTypes;
  switch (keySystem) {
    case KeySystems.FAIRPLAY:
      initDataTypes = ["cenc", "sinf"];
      break;
    case KeySystems.WIDEVINE:
    case KeySystems.PLAYREADY:
      initDataTypes = ["cenc"];
      break;
    case KeySystems.CLEARKEY:
      initDataTypes = ["cenc", "keyids"];
      break;
    default:
      throw new Error(`Unknown key-system: ${keySystem}`);
  }
  return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);
}
function createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {
  const baseConfig = {
    initDataTypes,
    persistentState: drmSystemOptions.persistentState || "optional",
    distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || "optional",
    sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || "temporary"],
    audioCapabilities: audioCodecs.map((codec) => ({
      contentType: `audio/mp4; codecs="${codec}"`,
      robustness: drmSystemOptions.audioRobustness || "",
      encryptionScheme: drmSystemOptions.audioEncryptionScheme || null
    })),
    videoCapabilities: videoCodecs.map((codec) => ({
      contentType: `video/mp4; codecs="${codec}"`,
      robustness: drmSystemOptions.videoRobustness || "",
      encryptionScheme: drmSystemOptions.videoEncryptionScheme || null
    }))
  };
  return [baseConfig];
}
function sliceUint8(array, start, end) {
  return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));
}
var isHeader$2 = (data, offset) => {
  if (offset + 10 <= data.length) {
    if (data[offset] === 73 && data[offset + 1] === 68 && data[offset + 2] === 51) {
      if (data[offset + 3] < 255 && data[offset + 4] < 255) {
        if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
          return true;
        }
      }
    }
  }
  return false;
};
var isFooter = (data, offset) => {
  if (offset + 10 <= data.length) {
    if (data[offset] === 51 && data[offset + 1] === 68 && data[offset + 2] === 73) {
      if (data[offset + 3] < 255 && data[offset + 4] < 255) {
        if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
          return true;
        }
      }
    }
  }
  return false;
};
var getID3Data = (data, offset) => {
  const front = offset;
  let length = 0;
  while (isHeader$2(data, offset)) {
    length += 10;
    const size = readSize(data, offset + 6);
    length += size;
    if (isFooter(data, offset + 10)) {
      length += 10;
    }
    offset += length;
  }
  if (length > 0) {
    return data.subarray(front, front + length);
  }
  return;
};
var readSize = (data, offset) => {
  let size = 0;
  size = (data[offset] & 127) << 21;
  size |= (data[offset + 1] & 127) << 14;
  size |= (data[offset + 2] & 127) << 7;
  size |= data[offset + 3] & 127;
  return size;
};
var canParse$2 = (data, offset) => {
  return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;
};
var getTimeStamp = (data) => {
  const frames = getID3Frames(data);
  for (let i = 0;i < frames.length; i++) {
    const frame = frames[i];
    if (isTimeStampFrame(frame)) {
      return readTimeStamp(frame);
    }
  }
  return;
};
var isTimeStampFrame = (frame) => {
  return frame && frame.key === "PRIV" && frame.info === "com.apple.streaming.transportStreamTimestamp";
};
var getFrameData = (data) => {
  const type = String.fromCharCode(data[0], data[1], data[2], data[3]);
  const size = readSize(data, 4);
  const offset = 10;
  return {
    type,
    size,
    data: data.subarray(offset, offset + size)
  };
};
var getID3Frames = (id3Data) => {
  let offset = 0;
  const frames = [];
  while (isHeader$2(id3Data, offset)) {
    const size = readSize(id3Data, offset + 6);
    offset += 10;
    const end = offset + size;
    while (offset + 8 < end) {
      const frameData = getFrameData(id3Data.subarray(offset));
      const frame = decodeFrame(frameData);
      if (frame) {
        frames.push(frame);
      }
      offset += frameData.size + 10;
    }
    if (isFooter(id3Data, offset)) {
      offset += 10;
    }
  }
  return frames;
};
var decodeFrame = (frame) => {
  if (frame.type === "PRIV") {
    return decodePrivFrame(frame);
  } else if (frame.type[0] === "W") {
    return decodeURLFrame(frame);
  }
  return decodeTextFrame(frame);
};
var decodePrivFrame = (frame) => {
  if (frame.size < 2) {
    return;
  }
  const owner = utf8ArrayToStr(frame.data, true);
  const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
  return {
    key: frame.type,
    info: owner,
    data: privateData.buffer
  };
};
var decodeTextFrame = (frame) => {
  if (frame.size < 2) {
    return;
  }
  if (frame.type === "TXXX") {
    let index = 1;
    const description = utf8ArrayToStr(frame.data.subarray(index), true);
    index += description.length + 1;
    const value = utf8ArrayToStr(frame.data.subarray(index));
    return {
      key: frame.type,
      info: description,
      data: value
    };
  }
  const text = utf8ArrayToStr(frame.data.subarray(1));
  return {
    key: frame.type,
    data: text
  };
};
var decodeURLFrame = (frame) => {
  if (frame.type === "WXXX") {
    if (frame.size < 2) {
      return;
    }
    let index = 1;
    const description = utf8ArrayToStr(frame.data.subarray(index), true);
    index += description.length + 1;
    const value = utf8ArrayToStr(frame.data.subarray(index));
    return {
      key: frame.type,
      info: description,
      data: value
    };
  }
  const url = utf8ArrayToStr(frame.data);
  return {
    key: frame.type,
    data: url
  };
};
var readTimeStamp = (timeStampFrame) => {
  if (timeStampFrame.data.byteLength === 8) {
    const data = new Uint8Array(timeStampFrame.data);
    const pts33Bit = data[3] & 1;
    let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
    timestamp /= 45;
    if (pts33Bit) {
      timestamp += 47721858.84;
    }
    return Math.round(timestamp);
  }
  return;
};
var utf8ArrayToStr = (array, exitOnNull = false) => {
  const decoder = getTextDecoder();
  if (decoder) {
    const decoded = decoder.decode(array);
    if (exitOnNull) {
      const idx = decoded.indexOf("\x00");
      return idx !== -1 ? decoded.substring(0, idx) : decoded;
    }
    return decoded.replace(/\0/g, "");
  }
  const len = array.length;
  let c;
  let char2;
  let char3;
  let out = "";
  let i = 0;
  while (i < len) {
    c = array[i++];
    if (c === 0 && exitOnNull) {
      return out;
    } else if (c === 0 || c === 3) {
      continue;
    }
    switch (c >> 4) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        out += String.fromCharCode(c);
        break;
      case 12:
      case 13:
        char2 = array[i++];
        out += String.fromCharCode((c & 31) << 6 | char2 & 63);
        break;
      case 14:
        char2 = array[i++];
        char3 = array[i++];
        out += String.fromCharCode((c & 15) << 12 | (char2 & 63) << 6 | (char3 & 63) << 0);
        break;
    }
  }
  return out;
};
var decoder;
function getTextDecoder() {
  if (navigator.userAgent.includes("PlayStation 4")) {
    return;
  }
  if (!decoder && typeof self.TextDecoder !== "undefined") {
    decoder = new self.TextDecoder("utf-8");
  }
  return decoder;
}
var Hex = {
  hexDump: function(array) {
    let str = "";
    for (let i = 0;i < array.length; i++) {
      let h = array[i].toString(16);
      if (h.length < 2) {
        h = "0" + h;
      }
      str += h;
    }
    return str;
  }
};
var UINT32_MAX$1 = Math.pow(2, 32) - 1;
var push = [].push;
var RemuxerTrackIdConfig = {
  video: 1,
  audio: 2,
  id3: 3,
  text: 4
};
function bin2str(data) {
  return String.fromCharCode.apply(null, data);
}
function readUint16(buffer, offset) {
  const val = buffer[offset] << 8 | buffer[offset + 1];
  return val < 0 ? 65536 + val : val;
}
function readUint32(buffer, offset) {
  const val = readSint32(buffer, offset);
  return val < 0 ? 4294967296 + val : val;
}
function readUint64(buffer, offset) {
  let result = readUint32(buffer, offset);
  result *= Math.pow(2, 32);
  result += readUint32(buffer, offset + 4);
  return result;
}
function readSint32(buffer, offset) {
  return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
}
function writeUint32(buffer, offset, value) {
  buffer[offset] = value >> 24;
  buffer[offset + 1] = value >> 16 & 255;
  buffer[offset + 2] = value >> 8 & 255;
  buffer[offset + 3] = value & 255;
}
function hasMoofData(data) {
  const end = data.byteLength;
  for (let i = 0;i < end; ) {
    const size = readUint32(data, i);
    if (size > 8 && data[i + 4] === 109 && data[i + 5] === 111 && data[i + 6] === 111 && data[i + 7] === 102) {
      return true;
    }
    i = size > 1 ? i + size : end;
  }
  return false;
}
function findBox(data, path) {
  const results = [];
  if (!path.length) {
    return results;
  }
  const end = data.byteLength;
  for (let i = 0;i < end; ) {
    const size = readUint32(data, i);
    const type = bin2str(data.subarray(i + 4, i + 8));
    const endbox = size > 1 ? i + size : end;
    if (type === path[0]) {
      if (path.length === 1) {
        results.push(data.subarray(i + 8, endbox));
      } else {
        const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));
        if (subresults.length) {
          push.apply(results, subresults);
        }
      }
    }
    i = endbox;
  }
  return results;
}
function parseSegmentIndex(sidx) {
  const references = [];
  const version = sidx[0];
  let index = 8;
  const timescale = readUint32(sidx, index);
  index += 4;
  let earliestPresentationTime = 0;
  let firstOffset = 0;
  if (version === 0) {
    earliestPresentationTime = readUint32(sidx, index);
    firstOffset = readUint32(sidx, index + 4);
    index += 8;
  } else {
    earliestPresentationTime = readUint64(sidx, index);
    firstOffset = readUint64(sidx, index + 8);
    index += 16;
  }
  index += 2;
  let startByte = sidx.length + firstOffset;
  const referencesCount = readUint16(sidx, index);
  index += 2;
  for (let i = 0;i < referencesCount; i++) {
    let referenceIndex = index;
    const referenceInfo = readUint32(sidx, referenceIndex);
    referenceIndex += 4;
    const referenceSize = referenceInfo & 2147483647;
    const referenceType = (referenceInfo & 2147483648) >>> 31;
    if (referenceType === 1) {
      logger.warn("SIDX has hierarchical references (not supported)");
      return null;
    }
    const subsegmentDuration = readUint32(sidx, referenceIndex);
    referenceIndex += 4;
    references.push({
      referenceSize,
      subsegmentDuration,
      info: {
        duration: subsegmentDuration / timescale,
        start: startByte,
        end: startByte + referenceSize - 1
      }
    });
    startByte += referenceSize;
    referenceIndex += 4;
    index = referenceIndex;
  }
  return {
    earliestPresentationTime,
    timescale,
    version,
    referencesCount,
    references
  };
}
function parseInitSegment(initSegment) {
  const result = [];
  const traks = findBox(initSegment, ["moov", "trak"]);
  for (let i = 0;i < traks.length; i++) {
    const trak = traks[i];
    const tkhd = findBox(trak, ["tkhd"])[0];
    if (tkhd) {
      let version = tkhd[0];
      const trackId = readUint32(tkhd, version === 0 ? 12 : 20);
      const mdhd = findBox(trak, ["mdia", "mdhd"])[0];
      if (mdhd) {
        version = mdhd[0];
        const timescale = readUint32(mdhd, version === 0 ? 12 : 20);
        const hdlr = findBox(trak, ["mdia", "hdlr"])[0];
        if (hdlr) {
          const hdlrType = bin2str(hdlr.subarray(8, 12));
          const type = {
            soun: ElementaryStreamTypes.AUDIO,
            vide: ElementaryStreamTypes.VIDEO
          }[hdlrType];
          if (type) {
            const stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
            const stsdData = parseStsd(stsd);
            result[trackId] = {
              timescale,
              type
            };
            result[type] = _objectSpread2({
              timescale,
              id: trackId
            }, stsdData);
          }
        }
      }
    }
  }
  const trex = findBox(initSegment, ["moov", "mvex", "trex"]);
  trex.forEach((trex2) => {
    const trackId = readUint32(trex2, 4);
    const track = result[trackId];
    if (track) {
      track.default = {
        duration: readUint32(trex2, 12),
        flags: readUint32(trex2, 20)
      };
    }
  });
  return result;
}
function parseStsd(stsd) {
  const sampleEntries = stsd.subarray(8);
  const sampleEntriesEnd = sampleEntries.subarray(8 + 78);
  const fourCC = bin2str(sampleEntries.subarray(4, 8));
  let codec = fourCC;
  const encrypted = fourCC === "enca" || fourCC === "encv";
  if (encrypted) {
    const encBox = findBox(sampleEntries, [fourCC])[0];
    const encBoxChildren = encBox.subarray(fourCC === "enca" ? 28 : 78);
    const sinfs = findBox(encBoxChildren, ["sinf"]);
    sinfs.forEach((sinf) => {
      const schm = findBox(sinf, ["schm"])[0];
      if (schm) {
        const scheme = bin2str(schm.subarray(4, 8));
        if (scheme === "cbcs" || scheme === "cenc") {
          const frma = findBox(sinf, ["frma"])[0];
          if (frma) {
            codec = bin2str(frma);
          }
        }
      }
    });
  }
  switch (codec) {
    case "avc1":
    case "avc2":
    case "avc3":
    case "avc4": {
      const avcCBox = findBox(sampleEntriesEnd, ["avcC"])[0];
      codec += "." + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);
      break;
    }
    case "mp4a": {
      const codecBox = findBox(sampleEntries, [fourCC])[0];
      const esdsBox = findBox(codecBox.subarray(28), ["esds"])[0];
      if (esdsBox && esdsBox.length > 12) {
        let i = 4;
        if (esdsBox[i++] !== 3) {
          break;
        }
        i = skipBERInteger(esdsBox, i);
        i += 2;
        const flags = esdsBox[i++];
        if (flags & 128) {
          i += 2;
        }
        if (flags & 64) {
          i += esdsBox[i++];
        }
        if (esdsBox[i++] !== 4) {
          break;
        }
        i = skipBERInteger(esdsBox, i);
        const objectType = esdsBox[i++];
        if (objectType === 64) {
          codec += "." + toHex(objectType);
        } else {
          break;
        }
        i += 12;
        if (esdsBox[i++] !== 5) {
          break;
        }
        i = skipBERInteger(esdsBox, i);
        const firstByte = esdsBox[i++];
        let audioObjectType = (firstByte & 248) >> 3;
        if (audioObjectType === 31) {
          audioObjectType += 1 + ((firstByte & 7) << 3) + ((esdsBox[i] & 224) >> 5);
        }
        codec += "." + audioObjectType;
      }
      break;
    }
    case "hvc1":
    case "hev1": {
      const hvcCBox = findBox(sampleEntriesEnd, ["hvcC"])[0];
      const profileByte = hvcCBox[1];
      const profileSpace = ["", "A", "B", "C"][profileByte >> 6];
      const generalProfileIdc = profileByte & 31;
      const profileCompat = readUint32(hvcCBox, 2);
      const tierFlag = (profileByte & 32) >> 5 ? "H" : "L";
      const levelIDC = hvcCBox[12];
      const constraintIndicator = hvcCBox.subarray(6, 12);
      codec += "." + profileSpace + generalProfileIdc;
      codec += "." + profileCompat.toString(16).toUpperCase();
      codec += "." + tierFlag + levelIDC;
      let constraintString = "";
      for (let i = constraintIndicator.length;i--; ) {
        const byte = constraintIndicator[i];
        if (byte || constraintString) {
          const encodedByte = byte.toString(16).toUpperCase();
          constraintString = "." + encodedByte + constraintString;
        }
      }
      codec += constraintString;
      break;
    }
    case "dvh1":
    case "dvhe": {
      const dvcCBox = findBox(sampleEntriesEnd, ["dvcC"])[0];
      const profile = dvcCBox[2] >> 1 & 127;
      const level = dvcCBox[2] << 5 & 32 | dvcCBox[3] >> 3 & 31;
      codec += "." + addLeadingZero(profile) + "." + addLeadingZero(level);
      break;
    }
    case "vp09": {
      const vpcCBox = findBox(sampleEntriesEnd, ["vpcC"])[0];
      const profile = vpcCBox[4];
      const level = vpcCBox[5];
      const bitDepth = vpcCBox[6] >> 4 & 15;
      codec += "." + addLeadingZero(profile) + "." + addLeadingZero(level) + "." + addLeadingZero(bitDepth);
      break;
    }
    case "av01": {
      const av1CBox = findBox(sampleEntriesEnd, ["av1C"])[0];
      const profile = av1CBox[1] >>> 5;
      const level = av1CBox[1] & 31;
      const tierFlag = av1CBox[2] >>> 7 ? "H" : "M";
      const highBitDepth = (av1CBox[2] & 64) >> 6;
      const twelveBit = (av1CBox[2] & 32) >> 5;
      const bitDepth = profile === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;
      const monochrome = (av1CBox[2] & 16) >> 4;
      const chromaSubsamplingX = (av1CBox[2] & 8) >> 3;
      const chromaSubsamplingY = (av1CBox[2] & 4) >> 2;
      const chromaSamplePosition = av1CBox[2] & 3;
      const colorPrimaries = 1;
      const transferCharacteristics = 1;
      const matrixCoefficients = 1;
      const videoFullRangeFlag = 0;
      codec += "." + profile + "." + addLeadingZero(level) + tierFlag + "." + addLeadingZero(bitDepth) + "." + monochrome + "." + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + "." + addLeadingZero(colorPrimaries) + "." + addLeadingZero(transferCharacteristics) + "." + addLeadingZero(matrixCoefficients) + "." + videoFullRangeFlag;
      break;
    }
  }
  return {
    codec,
    encrypted
  };
}
function skipBERInteger(bytes, i) {
  const limit = i + 5;
  while (bytes[i++] & 128 && i < limit) {
  }
  return i;
}
function toHex(x) {
  return ("0" + x.toString(16).toUpperCase()).slice(-2);
}
function addLeadingZero(num) {
  return (num < 10 ? "0" : "") + num;
}
function patchEncyptionData(initSegment, decryptdata) {
  if (!initSegment || !decryptdata) {
    return initSegment;
  }
  const keyId = decryptdata.keyId;
  if (keyId && decryptdata.isCommonEncryption) {
    const traks = findBox(initSegment, ["moov", "trak"]);
    traks.forEach((trak) => {
      const stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
      const sampleEntries = stsd.subarray(8);
      let encBoxes = findBox(sampleEntries, ["enca"]);
      const isAudio = encBoxes.length > 0;
      if (!isAudio) {
        encBoxes = findBox(sampleEntries, ["encv"]);
      }
      encBoxes.forEach((enc) => {
        const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);
        const sinfBoxes = findBox(encBoxChildren, ["sinf"]);
        sinfBoxes.forEach((sinf) => {
          const tenc = parseSinf(sinf);
          if (tenc) {
            const tencKeyId = tenc.subarray(8, 24);
            if (!tencKeyId.some((b) => b !== 0)) {
              logger.log(`[eme] Patching keyId in 'enc${isAudio ? "a" : "v"}>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(keyId)}`);
              tenc.set(keyId, 8);
            }
          }
        });
      });
    });
  }
  return initSegment;
}
function parseSinf(sinf) {
  const schm = findBox(sinf, ["schm"])[0];
  if (schm) {
    const scheme = bin2str(schm.subarray(4, 8));
    if (scheme === "cbcs" || scheme === "cenc") {
      return findBox(sinf, ["schi", "tenc"])[0];
    }
  }
  return null;
}
function getStartDTS(initData, fmp4) {
  return findBox(fmp4, ["moof", "traf"]).reduce((result, traf) => {
    const tfdt = findBox(traf, ["tfdt"])[0];
    const version = tfdt[0];
    const start = findBox(traf, ["tfhd"]).reduce((result2, tfhd) => {
      const id = readUint32(tfhd, 4);
      const track = initData[id];
      if (track) {
        let baseTime = readUint32(tfdt, 4);
        if (version === 1) {
          if (baseTime === UINT32_MAX$1) {
            logger.warn(`[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`);
            return result2;
          }
          baseTime *= UINT32_MAX$1 + 1;
          baseTime += readUint32(tfdt, 8);
        }
        const scale2 = track.timescale || 90000;
        const startTime = baseTime / scale2;
        if (isFiniteNumber(startTime) && (result2 === null || startTime < result2)) {
          return startTime;
        }
      }
      return result2;
    }, null);
    if (start !== null && isFiniteNumber(start) && (result === null || start < result)) {
      return start;
    }
    return result;
  }, null);
}
function getDuration(data, initData) {
  let rawDuration = 0;
  let videoDuration = 0;
  let audioDuration = 0;
  const trafs = findBox(data, ["moof", "traf"]);
  for (let i = 0;i < trafs.length; i++) {
    const traf = trafs[i];
    const tfhd = findBox(traf, ["tfhd"])[0];
    const id = readUint32(tfhd, 4);
    const track = initData[id];
    if (!track) {
      continue;
    }
    const trackDefault = track.default;
    const tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? undefined : trackDefault.flags);
    let sampleDuration = trackDefault == null ? undefined : trackDefault.duration;
    if (tfhdFlags & 8) {
      if (tfhdFlags & 2) {
        sampleDuration = readUint32(tfhd, 12);
      } else {
        sampleDuration = readUint32(tfhd, 8);
      }
    }
    const timescale = track.timescale || 90000;
    const truns = findBox(traf, ["trun"]);
    for (let j = 0;j < truns.length; j++) {
      rawDuration = computeRawDurationFromSamples(truns[j]);
      if (!rawDuration && sampleDuration) {
        const sampleCount = readUint32(truns[j], 4);
        rawDuration = sampleDuration * sampleCount;
      }
      if (track.type === ElementaryStreamTypes.VIDEO) {
        videoDuration += rawDuration / timescale;
      } else if (track.type === ElementaryStreamTypes.AUDIO) {
        audioDuration += rawDuration / timescale;
      }
    }
  }
  if (videoDuration === 0 && audioDuration === 0) {
    let sidxMinStart = Infinity;
    let sidxMaxEnd = 0;
    let sidxDuration = 0;
    const sidxs = findBox(data, ["sidx"]);
    for (let i = 0;i < sidxs.length; i++) {
      const sidx = parseSegmentIndex(sidxs[i]);
      if (sidx != null && sidx.references) {
        sidxMinStart = Math.min(sidxMinStart, sidx.earliestPresentationTime / sidx.timescale);
        const subSegmentDuration = sidx.references.reduce((dur, ref) => dur + ref.info.duration || 0, 0);
        sidxMaxEnd = Math.max(sidxMaxEnd, subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale);
        sidxDuration = sidxMaxEnd - sidxMinStart;
      }
    }
    if (sidxDuration && isFiniteNumber(sidxDuration)) {
      return sidxDuration;
    }
  }
  if (videoDuration) {
    return videoDuration;
  }
  return audioDuration;
}
function computeRawDurationFromSamples(trun) {
  const flags = readUint32(trun, 0);
  let offset = 8;
  if (flags & 1) {
    offset += 4;
  }
  if (flags & 4) {
    offset += 4;
  }
  let duration = 0;
  const sampleCount = readUint32(trun, 4);
  for (let i = 0;i < sampleCount; i++) {
    if (flags & 256) {
      const sampleDuration = readUint32(trun, offset);
      duration += sampleDuration;
      offset += 4;
    }
    if (flags & 512) {
      offset += 4;
    }
    if (flags & 1024) {
      offset += 4;
    }
    if (flags & 2048) {
      offset += 4;
    }
  }
  return duration;
}
function offsetStartDTS(initData, fmp4, timeOffset) {
  findBox(fmp4, ["moof", "traf"]).forEach((traf) => {
    findBox(traf, ["tfhd"]).forEach((tfhd) => {
      const id = readUint32(tfhd, 4);
      const track = initData[id];
      if (!track) {
        return;
      }
      const timescale = track.timescale || 90000;
      findBox(traf, ["tfdt"]).forEach((tfdt) => {
        const version = tfdt[0];
        const offset = timeOffset * timescale;
        if (offset) {
          let baseMediaDecodeTime = readUint32(tfdt, 4);
          if (version === 0) {
            baseMediaDecodeTime -= offset;
            baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
            writeUint32(tfdt, 4, baseMediaDecodeTime);
          } else {
            baseMediaDecodeTime *= Math.pow(2, 32);
            baseMediaDecodeTime += readUint32(tfdt, 8);
            baseMediaDecodeTime -= offset;
            baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
            const upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));
            const lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));
            writeUint32(tfdt, 4, upper);
            writeUint32(tfdt, 8, lower);
          }
        }
      });
    });
  });
}
function segmentValidRange(data) {
  const segmentedRange = {
    valid: null,
    remainder: null
  };
  const moofs = findBox(data, ["moof"]);
  if (moofs.length < 2) {
    segmentedRange.remainder = data;
    return segmentedRange;
  }
  const last = moofs[moofs.length - 1];
  segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);
  segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);
  return segmentedRange;
}
function appendUint8Array(data1, data2) {
  const temp = new Uint8Array(data1.length + data2.length);
  temp.set(data1);
  temp.set(data2, data1.length);
  return temp;
}
function parseSamples(timeOffset, track) {
  const seiSamples = [];
  const videoData = track.samples;
  const timescale = track.timescale;
  const trackId = track.id;
  let isHEVCFlavor = false;
  const moofs = findBox(videoData, ["moof"]);
  moofs.map((moof) => {
    const moofOffset = moof.byteOffset - 8;
    const trafs = findBox(moof, ["traf"]);
    trafs.map((traf) => {
      const baseTime = findBox(traf, ["tfdt"]).map((tfdt) => {
        const version = tfdt[0];
        let result = readUint32(tfdt, 4);
        if (version === 1) {
          result *= Math.pow(2, 32);
          result += readUint32(tfdt, 8);
        }
        return result / timescale;
      })[0];
      if (baseTime !== undefined) {
        timeOffset = baseTime;
      }
      return findBox(traf, ["tfhd"]).map((tfhd) => {
        const id = readUint32(tfhd, 4);
        const tfhdFlags = readUint32(tfhd, 0) & 16777215;
        const baseDataOffsetPresent = (tfhdFlags & 1) !== 0;
        const sampleDescriptionIndexPresent = (tfhdFlags & 2) !== 0;
        const defaultSampleDurationPresent = (tfhdFlags & 8) !== 0;
        let defaultSampleDuration = 0;
        const defaultSampleSizePresent = (tfhdFlags & 16) !== 0;
        let defaultSampleSize = 0;
        const defaultSampleFlagsPresent = (tfhdFlags & 32) !== 0;
        let tfhdOffset = 8;
        if (id === trackId) {
          if (baseDataOffsetPresent) {
            tfhdOffset += 8;
          }
          if (sampleDescriptionIndexPresent) {
            tfhdOffset += 4;
          }
          if (defaultSampleDurationPresent) {
            defaultSampleDuration = readUint32(tfhd, tfhdOffset);
            tfhdOffset += 4;
          }
          if (defaultSampleSizePresent) {
            defaultSampleSize = readUint32(tfhd, tfhdOffset);
            tfhdOffset += 4;
          }
          if (defaultSampleFlagsPresent) {
            tfhdOffset += 4;
          }
          if (track.type === "video") {
            isHEVCFlavor = isHEVC(track.codec);
          }
          findBox(traf, ["trun"]).map((trun) => {
            const version = trun[0];
            const flags = readUint32(trun, 0) & 16777215;
            const dataOffsetPresent = (flags & 1) !== 0;
            let dataOffset = 0;
            const firstSampleFlagsPresent = (flags & 4) !== 0;
            const sampleDurationPresent = (flags & 256) !== 0;
            let sampleDuration = 0;
            const sampleSizePresent = (flags & 512) !== 0;
            let sampleSize = 0;
            const sampleFlagsPresent = (flags & 1024) !== 0;
            const sampleCompositionOffsetsPresent = (flags & 2048) !== 0;
            let compositionOffset = 0;
            const sampleCount = readUint32(trun, 4);
            let trunOffset = 8;
            if (dataOffsetPresent) {
              dataOffset = readUint32(trun, trunOffset);
              trunOffset += 4;
            }
            if (firstSampleFlagsPresent) {
              trunOffset += 4;
            }
            let sampleOffset = dataOffset + moofOffset;
            for (let ix = 0;ix < sampleCount; ix++) {
              if (sampleDurationPresent) {
                sampleDuration = readUint32(trun, trunOffset);
                trunOffset += 4;
              } else {
                sampleDuration = defaultSampleDuration;
              }
              if (sampleSizePresent) {
                sampleSize = readUint32(trun, trunOffset);
                trunOffset += 4;
              } else {
                sampleSize = defaultSampleSize;
              }
              if (sampleFlagsPresent) {
                trunOffset += 4;
              }
              if (sampleCompositionOffsetsPresent) {
                if (version === 0) {
                  compositionOffset = readUint32(trun, trunOffset);
                } else {
                  compositionOffset = readSint32(trun, trunOffset);
                }
                trunOffset += 4;
              }
              if (track.type === ElementaryStreamTypes.VIDEO) {
                let naluTotalSize = 0;
                while (naluTotalSize < sampleSize) {
                  const naluSize = readUint32(videoData, sampleOffset);
                  sampleOffset += 4;
                  if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {
                    const data = videoData.subarray(sampleOffset, sampleOffset + naluSize);
                    parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);
                  }
                  sampleOffset += naluSize;
                  naluTotalSize += naluSize + 4;
                }
              }
              timeOffset += sampleDuration / timescale;
            }
          });
        }
      });
    });
  });
  return seiSamples;
}
function isHEVC(codec) {
  if (!codec) {
    return false;
  }
  const delimit = codec.indexOf(".");
  const baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);
  return baseCodec === "hvc1" || baseCodec === "hev1" || baseCodec === "dvh1" || baseCodec === "dvhe";
}
function isSEIMessage(isHEVCFlavor, naluHeader) {
  if (isHEVCFlavor) {
    const naluType = naluHeader >> 1 & 63;
    return naluType === 39 || naluType === 40;
  } else {
    const naluType = naluHeader & 31;
    return naluType === 6;
  }
}
function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {
  const data = discardEPB(unescapedData);
  let seiPtr = 0;
  seiPtr += headerSize;
  let payloadType = 0;
  let payloadSize = 0;
  let b = 0;
  while (seiPtr < data.length) {
    payloadType = 0;
    do {
      if (seiPtr >= data.length) {
        break;
      }
      b = data[seiPtr++];
      payloadType += b;
    } while (b === 255);
    payloadSize = 0;
    do {
      if (seiPtr >= data.length) {
        break;
      }
      b = data[seiPtr++];
      payloadSize += b;
    } while (b === 255);
    const leftOver = data.length - seiPtr;
    let payPtr = seiPtr;
    if (payloadSize < leftOver) {
      seiPtr += payloadSize;
    } else if (payloadSize > leftOver) {
      logger.error(`Malformed SEI payload. ${payloadSize} is too small, only ${leftOver} bytes left to parse.`);
      break;
    }
    if (payloadType === 4) {
      const countryCode = data[payPtr++];
      if (countryCode === 181) {
        const providerCode = readUint16(data, payPtr);
        payPtr += 2;
        if (providerCode === 49) {
          const userStructure = readUint32(data, payPtr);
          payPtr += 4;
          if (userStructure === 1195456820) {
            const userDataType = data[payPtr++];
            if (userDataType === 3) {
              const firstByte = data[payPtr++];
              const totalCCs = 31 & firstByte;
              const enabled = 64 & firstByte;
              const totalBytes = enabled ? 2 + totalCCs * 3 : 0;
              const byteArray = new Uint8Array(totalBytes);
              if (enabled) {
                byteArray[0] = firstByte;
                for (let i = 1;i < totalBytes; i++) {
                  byteArray[i] = data[payPtr++];
                }
              }
              samples.push({
                type: userDataType,
                payloadType,
                pts,
                bytes: byteArray
              });
            }
          }
        }
      }
    } else if (payloadType === 5) {
      if (payloadSize > 16) {
        const uuidStrArray = [];
        for (let i = 0;i < 16; i++) {
          const _b = data[payPtr++].toString(16);
          uuidStrArray.push(_b.length == 1 ? "0" + _b : _b);
          if (i === 3 || i === 5 || i === 7 || i === 9) {
            uuidStrArray.push("-");
          }
        }
        const length = payloadSize - 16;
        const userDataBytes = new Uint8Array(length);
        for (let i = 0;i < length; i++) {
          userDataBytes[i] = data[payPtr++];
        }
        samples.push({
          payloadType,
          pts,
          uuid: uuidStrArray.join(""),
          userData: utf8ArrayToStr(userDataBytes),
          userDataBytes
        });
      }
    }
  }
}
function discardEPB(data) {
  const length = data.byteLength;
  const EPBPositions = [];
  let i = 1;
  while (i < length - 2) {
    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
      EPBPositions.push(i + 2);
      i += 2;
    } else {
      i++;
    }
  }
  if (EPBPositions.length === 0) {
    return data;
  }
  const newLength = length - EPBPositions.length;
  const newData = new Uint8Array(newLength);
  let sourceIndex = 0;
  for (i = 0;i < newLength; sourceIndex++, i++) {
    if (sourceIndex === EPBPositions[0]) {
      sourceIndex++;
      EPBPositions.shift();
    }
    newData[i] = data[sourceIndex];
  }
  return newData;
}
function parseEmsg(data) {
  const version = data[0];
  let schemeIdUri = "";
  let value = "";
  let timeScale = 0;
  let presentationTimeDelta = 0;
  let presentationTime = 0;
  let eventDuration = 0;
  let id = 0;
  let offset = 0;
  if (version === 0) {
    while (bin2str(data.subarray(offset, offset + 1)) !== "\x00") {
      schemeIdUri += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
    }
    schemeIdUri += bin2str(data.subarray(offset, offset + 1));
    offset += 1;
    while (bin2str(data.subarray(offset, offset + 1)) !== "\x00") {
      value += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
    }
    value += bin2str(data.subarray(offset, offset + 1));
    offset += 1;
    timeScale = readUint32(data, 12);
    presentationTimeDelta = readUint32(data, 16);
    eventDuration = readUint32(data, 20);
    id = readUint32(data, 24);
    offset = 28;
  } else if (version === 1) {
    offset += 4;
    timeScale = readUint32(data, offset);
    offset += 4;
    const leftPresentationTime = readUint32(data, offset);
    offset += 4;
    const rightPresentationTime = readUint32(data, offset);
    offset += 4;
    presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;
    if (!isSafeInteger(presentationTime)) {
      presentationTime = Number.MAX_SAFE_INTEGER;
      logger.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box");
    }
    eventDuration = readUint32(data, offset);
    offset += 4;
    id = readUint32(data, offset);
    offset += 4;
    while (bin2str(data.subarray(offset, offset + 1)) !== "\x00") {
      schemeIdUri += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
    }
    schemeIdUri += bin2str(data.subarray(offset, offset + 1));
    offset += 1;
    while (bin2str(data.subarray(offset, offset + 1)) !== "\x00") {
      value += bin2str(data.subarray(offset, offset + 1));
      offset += 1;
    }
    value += bin2str(data.subarray(offset, offset + 1));
    offset += 1;
  }
  const payload = data.subarray(offset, data.byteLength);
  return {
    schemeIdUri,
    value,
    timeScale,
    presentationTime,
    presentationTimeDelta,
    eventDuration,
    id,
    payload
  };
}
function mp4Box(type, ...payload) {
  const len = payload.length;
  let size = 8;
  let i = len;
  while (i--) {
    size += payload[i].byteLength;
  }
  const result = new Uint8Array(size);
  result[0] = size >> 24 & 255;
  result[1] = size >> 16 & 255;
  result[2] = size >> 8 & 255;
  result[3] = size & 255;
  result.set(type, 4);
  for (i = 0, size = 8;i < len; i++) {
    result.set(payload[i], size);
    size += payload[i].byteLength;
  }
  return result;
}
function mp4pssh(systemId, keyids, data) {
  if (systemId.byteLength !== 16) {
    throw new RangeError("Invalid system id");
  }
  let version;
  let kids;
  if (keyids) {
    version = 1;
    kids = new Uint8Array(keyids.length * 16);
    for (let ix = 0;ix < keyids.length; ix++) {
      const k = keyids[ix];
      if (k.byteLength !== 16) {
        throw new RangeError("Invalid key");
      }
      kids.set(k, ix * 16);
    }
  } else {
    version = 0;
    kids = new Uint8Array;
  }
  let kidCount;
  if (version > 0) {
    kidCount = new Uint8Array(4);
    if (keyids.length > 0) {
      new DataView(kidCount.buffer).setUint32(0, keyids.length, false);
    }
  } else {
    kidCount = new Uint8Array;
  }
  const dataSize = new Uint8Array(4);
  if (data && data.byteLength > 0) {
    new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);
  }
  return mp4Box([112, 115, 115, 104], new Uint8Array([
    version,
    0,
    0,
    0
  ]), systemId, kidCount, kids, dataSize, data || new Uint8Array);
}
function parseMultiPssh(initData) {
  const results = [];
  if (initData instanceof ArrayBuffer) {
    const length = initData.byteLength;
    let offset = 0;
    while (offset + 32 < length) {
      const view = new DataView(initData, offset);
      const pssh = parsePssh(view);
      results.push(pssh);
      offset += pssh.size;
    }
  }
  return results;
}
function parsePssh(view) {
  const size = view.getUint32(0);
  const offset = view.byteOffset;
  const length = view.byteLength;
  if (length < size) {
    return {
      offset,
      size: length
    };
  }
  const type = view.getUint32(4);
  if (type !== 1886614376) {
    return {
      offset,
      size
    };
  }
  const version = view.getUint32(8) >>> 24;
  if (version !== 0 && version !== 1) {
    return {
      offset,
      size
    };
  }
  const buffer = view.buffer;
  const systemId = Hex.hexDump(new Uint8Array(buffer, offset + 12, 16));
  const dataSizeOrKidCount = view.getUint32(28);
  let kids = null;
  let data = null;
  if (version === 0) {
    if (size - 32 < dataSizeOrKidCount || dataSizeOrKidCount < 22) {
      return {
        offset,
        size
      };
    }
    data = new Uint8Array(buffer, offset + 32, dataSizeOrKidCount);
  } else if (version === 1) {
    if (!dataSizeOrKidCount || length < offset + 32 + dataSizeOrKidCount * 16 + 16) {
      return {
        offset,
        size
      };
    }
    kids = [];
    for (let i = 0;i < dataSizeOrKidCount; i++) {
      kids.push(new Uint8Array(buffer, offset + 32 + i * 16, 16));
    }
  }
  return {
    version,
    systemId,
    kids,
    data,
    offset,
    size
  };
}
var keyUriToKeyIdMap = {};

class LevelKey {
  static clearKeyUriToKeyIdMap() {
    keyUriToKeyIdMap = {};
  }
  constructor(method, uri, format, formatversions = [1], iv = null) {
    this.uri = undefined;
    this.method = undefined;
    this.keyFormat = undefined;
    this.keyFormatVersions = undefined;
    this.encrypted = undefined;
    this.isCommonEncryption = undefined;
    this.iv = null;
    this.key = null;
    this.keyId = null;
    this.pssh = null;
    this.method = method;
    this.uri = uri;
    this.keyFormat = format;
    this.keyFormatVersions = formatversions;
    this.iv = iv;
    this.encrypted = method ? method !== "NONE" : false;
    this.isCommonEncryption = this.encrypted && method !== "AES-128";
  }
  isSupported() {
    if (this.method) {
      if (this.method === "AES-128" || this.method === "NONE") {
        return true;
      }
      if (this.keyFormat === "identity") {
        return this.method === "SAMPLE-AES";
      } else {
        switch (this.keyFormat) {
          case KeySystemFormats.FAIRPLAY:
          case KeySystemFormats.WIDEVINE:
          case KeySystemFormats.PLAYREADY:
          case KeySystemFormats.CLEARKEY:
            return ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1;
        }
      }
    }
    return false;
  }
  getDecryptData(sn) {
    if (!this.encrypted || !this.uri) {
      return null;
    }
    if (this.method === "AES-128" && this.uri && !this.iv) {
      if (typeof sn !== "number") {
        if (this.method === "AES-128" && !this.iv) {
          logger.warn(`missing IV for initialization segment with method="${this.method}" - compliance issue`);
        }
        sn = 0;
      }
      const iv = createInitializationVector(sn);
      const decryptdata = new LevelKey(this.method, this.uri, "identity", this.keyFormatVersions, iv);
      return decryptdata;
    }
    const keyBytes = convertDataUriToArrayBytes(this.uri);
    if (keyBytes) {
      switch (this.keyFormat) {
        case KeySystemFormats.WIDEVINE:
          this.pssh = keyBytes;
          if (keyBytes.length >= 22) {
            this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);
          }
          break;
        case KeySystemFormats.PLAYREADY: {
          const PlayReadyKeySystemUUID = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
          this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);
          const keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);
          const keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));
          const xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf("<"), keyByteStr.length);
          const parser = new DOMParser;
          const xmlDoc = parser.parseFromString(xmlKeyBytes, "text/xml");
          const keyData = xmlDoc.getElementsByTagName("KID")[0];
          if (keyData) {
            const keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute("VALUE");
            if (keyId) {
              const keyIdArray = base64Decode(keyId).subarray(0, 16);
              changeEndianness(keyIdArray);
              this.keyId = keyIdArray;
            }
          }
          break;
        }
        default: {
          let keydata = keyBytes.subarray(0, 16);
          if (keydata.length !== 16) {
            const padded = new Uint8Array(16);
            padded.set(keydata, 16 - keydata.length);
            keydata = padded;
          }
          this.keyId = keydata;
          break;
        }
      }
    }
    if (!this.keyId || this.keyId.byteLength !== 16) {
      let keyId = keyUriToKeyIdMap[this.uri];
      if (!keyId) {
        const val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;
        keyId = new Uint8Array(16);
        const dv = new DataView(keyId.buffer, 12, 4);
        dv.setUint32(0, val);
        keyUriToKeyIdMap[this.uri] = keyId;
      }
      this.keyId = keyId;
    }
    return this;
  }
}
function createInitializationVector(segmentNumber) {
  const uint8View = new Uint8Array(16);
  for (let i = 12;i < 16; i++) {
    uint8View[i] = segmentNumber >> 8 * (15 - i) & 255;
  }
  return uint8View;
}
var VARIABLE_REPLACEMENT_REGEX = /\{\$([a-zA-Z0-9-_]+)\}/g;
function hasVariableReferences(str) {
  return VARIABLE_REPLACEMENT_REGEX.test(str);
}
function substituteVariablesInAttributes(parsed, attr, attributeNames) {
  if (parsed.variableList !== null || parsed.hasVariableRefs) {
    for (let i = attributeNames.length;i--; ) {
      const name = attributeNames[i];
      const value = attr[name];
      if (value) {
        attr[name] = substituteVariables(parsed, value);
      }
    }
  }
}
function substituteVariables(parsed, value) {
  if (parsed.variableList !== null || parsed.hasVariableRefs) {
    const variableList = parsed.variableList;
    return value.replace(VARIABLE_REPLACEMENT_REGEX, (variableReference) => {
      const variableName = variableReference.substring(2, variableReference.length - 1);
      const variableValue = variableList == null ? undefined : variableList[variableName];
      if (variableValue === undefined) {
        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: "${variableName}"`));
        return variableReference;
      }
      return variableValue;
    });
  }
  return value;
}
function addVariableDefinition(parsed, attr, parentUrl) {
  let variableList = parsed.variableList;
  if (!variableList) {
    parsed.variableList = variableList = {};
  }
  let NAME;
  let VALUE;
  if ("QUERYPARAM" in attr) {
    NAME = attr.QUERYPARAM;
    try {
      const searchParams = new self.URL(parentUrl).searchParams;
      if (searchParams.has(NAME)) {
        VALUE = searchParams.get(NAME);
      } else {
        throw new Error(`"${NAME}" does not match any query parameter in URI: "${parentUrl}"`);
      }
    } catch (error) {
      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${error.message}`));
    }
  } else {
    NAME = attr.NAME;
    VALUE = attr.VALUE;
  }
  if (NAME in variableList) {
    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: "${NAME}"`));
  } else {
    variableList[NAME] = VALUE || "";
  }
}
function importVariableDefinition(parsed, attr, sourceVariableList) {
  const IMPORT = attr.IMPORT;
  if (sourceVariableList && IMPORT in sourceVariableList) {
    let variableList = parsed.variableList;
    if (!variableList) {
      parsed.variableList = variableList = {};
    }
    variableList[IMPORT] = sourceVariableList[IMPORT];
  } else {
    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "${IMPORT}"`));
  }
}
function getMediaSource(preferManagedMediaSource = true) {
  if (typeof self === "undefined")
    return;
  const mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;
  return mms || self.MediaSource || self.WebKitMediaSource;
}
function isManagedMediaSource(source) {
  return typeof self !== "undefined" && source === self.ManagedMediaSource;
}
var sampleEntryCodesISO = {
  audio: {
    a3ds: 1,
    "ac-3": 0.95,
    "ac-4": 1,
    alac: 0.9,
    alaw: 1,
    dra1: 1,
    "dts+": 1,
    "dts-": 1,
    dtsc: 1,
    dtse: 1,
    dtsh: 1,
    "ec-3": 0.9,
    enca: 1,
    fLaC: 0.9,
    flac: 0.9,
    FLAC: 0.9,
    g719: 1,
    g726: 1,
    m4ae: 1,
    mha1: 1,
    mha2: 1,
    mhm1: 1,
    mhm2: 1,
    mlpa: 1,
    mp4a: 1,
    "raw ": 1,
    Opus: 1,
    opus: 1,
    samr: 1,
    sawb: 1,
    sawp: 1,
    sevc: 1,
    sqcp: 1,
    ssmv: 1,
    twos: 1,
    ulaw: 1
  },
  video: {
    avc1: 1,
    avc2: 1,
    avc3: 1,
    avc4: 1,
    avcp: 1,
    av01: 0.8,
    drac: 1,
    dva1: 1,
    dvav: 1,
    dvh1: 0.7,
    dvhe: 0.7,
    encv: 1,
    hev1: 0.75,
    hvc1: 0.75,
    mjp2: 1,
    mp4v: 1,
    mvc1: 1,
    mvc2: 1,
    mvc3: 1,
    mvc4: 1,
    resv: 1,
    rv60: 1,
    s263: 1,
    svc1: 1,
    svc2: 1,
    "vc-1": 1,
    vp08: 1,
    vp09: 0.9
  },
  text: {
    stpp: 1,
    wvtt: 1
  }
};
function isCodecType(codec, type) {
  const typeCodes = sampleEntryCodesISO[type];
  return !!typeCodes && !!typeCodes[codec.slice(0, 4)];
}
function areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource = true) {
  return !codecs.split(",").some((codec) => !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource));
}
function isCodecMediaSourceSupported(codec, type, preferManagedMediaSource = true) {
  var _MediaSource$isTypeSu;
  const MediaSource = getMediaSource(preferManagedMediaSource);
  return (_MediaSource$isTypeSu = MediaSource == null ? undefined : MediaSource.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;
}
function mimeTypeForCodec(codec, type) {
  return `${type}/mp4;codecs="${codec}"`;
}
function videoCodecPreferenceValue(videoCodec) {
  if (videoCodec) {
    const fourCC = videoCodec.substring(0, 4);
    return sampleEntryCodesISO.video[fourCC];
  }
  return 2;
}
function codecsSetSelectionPreferenceValue(codecSet) {
  return codecSet.split(",").reduce((num, fourCC) => {
    const preferenceValue = sampleEntryCodesISO.video[fourCC];
    if (preferenceValue) {
      return (preferenceValue * 2 + num) / (num ? 3 : 2);
    }
    return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);
  }, 0);
}
var CODEC_COMPATIBLE_NAMES = {};
function getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource = true) {
  if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {
    return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];
  }
  const codecsToCheck = {
    flac: ["flac", "fLaC", "FLAC"],
    opus: ["opus", "Opus"]
  }[lowerCaseCodec];
  for (let i = 0;i < codecsToCheck.length; i++) {
    if (isCodecMediaSourceSupported(codecsToCheck[i], "audio", preferManagedMediaSource)) {
      CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];
      return codecsToCheck[i];
    }
  }
  return lowerCaseCodec;
}
var AUDIO_CODEC_REGEXP = /flac|opus/i;
function getCodecCompatibleName(codec, preferManagedMediaSource = true) {
  return codec.replace(AUDIO_CODEC_REGEXP, (m) => getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource));
}
function pickMostCompleteCodecName(parsedCodec, levelCodec) {
  if (parsedCodec && parsedCodec !== "mp4a") {
    return parsedCodec;
  }
  return levelCodec ? levelCodec.split(",")[0] : levelCodec;
}
function convertAVC1ToAVCOTI(codec) {
  const codecs = codec.split(",");
  for (let i = 0;i < codecs.length; i++) {
    const avcdata = codecs[i].split(".");
    if (avcdata.length > 2) {
      let result = avcdata.shift() + ".";
      result += parseInt(avcdata.shift()).toString(16);
      result += ("000" + parseInt(avcdata.shift()).toString(16)).slice(-4);
      codecs[i] = result;
    }
  }
  return codecs.join(",");
}
var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g;
var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
var IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m;
var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([
  /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
  /(?!#) *(\S[^\r\n]*)/.source,
  /#EXT-X-BYTERANGE:*(.+)/.source,
  /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
  /#.*/.source
].join("|"), "g");
var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));

class M3U8Parser {
  static findGroup(groups, mediaGroupId) {
    for (let i = 0;i < groups.length; i++) {
      const group = groups[i];
      if (group.id === mediaGroupId) {
        return group;
      }
    }
  }
  static resolve(url, baseUrl) {
    return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {
      alwaysNormalize: true
    });
  }
  static isMediaPlaylist(str) {
    return IS_MEDIA_PLAYLIST.test(str);
  }
  static parseMasterPlaylist(string, baseurl) {
    const hasVariableRefs = hasVariableReferences(string);
    const parsed = {
      contentSteering: null,
      levels: [],
      playlistParsingError: null,
      sessionData: null,
      sessionKeys: null,
      startTimeOffset: null,
      variableList: null,
      hasVariableRefs
    };
    const levelsWithKnownCodecs = [];
    MASTER_PLAYLIST_REGEX.lastIndex = 0;
    let result;
    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
      if (result[1]) {
        var _level$unknownCodecs;
        const attrs = new AttrList(result[1]);
        {
          substituteVariablesInAttributes(parsed, attrs, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]);
        }
        const uri = substituteVariables(parsed, result[2]);
        const level = {
          attrs,
          bitrate: attrs.decimalInteger("BANDWIDTH") || attrs.decimalInteger("AVERAGE-BANDWIDTH"),
          name: attrs.NAME,
          url: M3U8Parser.resolve(uri, baseurl)
        };
        const resolution = attrs.decimalResolution("RESOLUTION");
        if (resolution) {
          level.width = resolution.width;
          level.height = resolution.height;
        }
        setCodecs(attrs.CODECS, level);
        if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {
          levelsWithKnownCodecs.push(level);
        }
        parsed.levels.push(level);
      } else if (result[3]) {
        const tag = result[3];
        const attributes = result[4];
        switch (tag) {
          case "SESSION-DATA": {
            const sessionAttrs = new AttrList(attributes);
            {
              substituteVariablesInAttributes(parsed, sessionAttrs, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]);
            }
            const dataId = sessionAttrs["DATA-ID"];
            if (dataId) {
              if (parsed.sessionData === null) {
                parsed.sessionData = {};
              }
              parsed.sessionData[dataId] = sessionAttrs;
            }
            break;
          }
          case "SESSION-KEY": {
            const sessionKey = parseKey(attributes, baseurl, parsed);
            if (sessionKey.encrypted && sessionKey.isSupported()) {
              if (parsed.sessionKeys === null) {
                parsed.sessionKeys = [];
              }
              parsed.sessionKeys.push(sessionKey);
            } else {
              logger.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "${attributes}"`);
            }
            break;
          }
          case "DEFINE": {
            {
              const variableAttributes = new AttrList(attributes);
              substituteVariablesInAttributes(parsed, variableAttributes, ["NAME", "VALUE", "QUERYPARAM"]);
              addVariableDefinition(parsed, variableAttributes, baseurl);
            }
            break;
          }
          case "CONTENT-STEERING": {
            const contentSteeringAttributes = new AttrList(attributes);
            {
              substituteVariablesInAttributes(parsed, contentSteeringAttributes, ["SERVER-URI", "PATHWAY-ID"]);
            }
            parsed.contentSteering = {
              uri: M3U8Parser.resolve(contentSteeringAttributes["SERVER-URI"], baseurl),
              pathwayId: contentSteeringAttributes["PATHWAY-ID"] || "."
            };
            break;
          }
          case "START": {
            parsed.startTimeOffset = parseStartTimeOffset(attributes);
            break;
          }
        }
      }
    }
    const stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;
    parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;
    if (parsed.levels.length === 0) {
      parsed.playlistParsingError = new Error("no levels found in manifest");
    }
    return parsed;
  }
  static parseMasterPlaylistMedia(string, baseurl, parsed) {
    let result;
    const results = {};
    const levels = parsed.levels;
    const groupsByType = {
      AUDIO: levels.map((level) => ({
        id: level.attrs.AUDIO,
        audioCodec: level.audioCodec
      })),
      SUBTITLES: levels.map((level) => ({
        id: level.attrs.SUBTITLES,
        textCodec: level.textCodec
      })),
      "CLOSED-CAPTIONS": []
    };
    let id = 0;
    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
      const attrs = new AttrList(result[1]);
      const type = attrs.TYPE;
      if (type) {
        const groups = groupsByType[type];
        const medias = results[type] || [];
        results[type] = medias;
        {
          substituteVariablesInAttributes(parsed, attrs, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]);
        }
        const lang = attrs.LANGUAGE;
        const assocLang = attrs["ASSOC-LANGUAGE"];
        const channels = attrs.CHANNELS;
        const characteristics = attrs.CHARACTERISTICS;
        const instreamId = attrs["INSTREAM-ID"];
        const media = {
          attrs,
          bitrate: 0,
          id: id++,
          groupId: attrs["GROUP-ID"] || "",
          name: attrs.NAME || lang || "",
          type,
          default: attrs.bool("DEFAULT"),
          autoselect: attrs.bool("AUTOSELECT"),
          forced: attrs.bool("FORCED"),
          lang,
          url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ""
        };
        if (assocLang) {
          media.assocLang = assocLang;
        }
        if (channels) {
          media.channels = channels;
        }
        if (characteristics) {
          media.characteristics = characteristics;
        }
        if (instreamId) {
          media.instreamId = instreamId;
        }
        if (groups != null && groups.length) {
          const groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];
          assignCodec(media, groupCodec, "audioCodec");
          assignCodec(media, groupCodec, "textCodec");
        }
        medias.push(media);
      }
    }
    return results;
  }
  static parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {
    const level = new LevelDetails(baseurl);
    const fragments = level.fragments;
    let currentInitSegment = null;
    let currentSN = 0;
    let currentPart = 0;
    let totalduration = 0;
    let discontinuityCounter = 0;
    let prevFrag = null;
    let frag = new Fragment(type, baseurl);
    let result;
    let i;
    let levelkeys;
    let firstPdtIndex = -1;
    let createNextFrag = false;
    let nextByteRange = null;
    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
    level.m3u8 = string;
    level.hasVariableRefs = hasVariableReferences(string);
    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
      if (createNextFrag) {
        createNextFrag = false;
        frag = new Fragment(type, baseurl);
        frag.start = totalduration;
        frag.sn = currentSN;
        frag.cc = discontinuityCounter;
        frag.level = id;
        if (currentInitSegment) {
          frag.initSegment = currentInitSegment;
          frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
          currentInitSegment.rawProgramDateTime = null;
          if (nextByteRange) {
            frag.setByteRange(nextByteRange);
            nextByteRange = null;
          }
        }
      }
      const duration = result[1];
      if (duration) {
        frag.duration = parseFloat(duration);
        const title = (" " + result[2]).slice(1);
        frag.title = title || null;
        frag.tagList.push(title ? ["INF", duration, title] : ["INF", duration]);
      } else if (result[3]) {
        if (isFiniteNumber(frag.duration)) {
          frag.start = totalduration;
          if (levelkeys) {
            setFragLevelKeys(frag, levelkeys, level);
          }
          frag.sn = currentSN;
          frag.level = id;
          frag.cc = discontinuityCounter;
          fragments.push(frag);
          const uri = (" " + result[3]).slice(1);
          frag.relurl = substituteVariables(level, uri);
          assignProgramDateTime(frag, prevFrag);
          prevFrag = frag;
          totalduration += frag.duration;
          currentSN++;
          currentPart = 0;
          createNextFrag = true;
        }
      } else if (result[4]) {
        const data = (" " + result[4]).slice(1);
        if (prevFrag) {
          frag.setByteRange(data, prevFrag);
        } else {
          frag.setByteRange(data);
        }
      } else if (result[5]) {
        frag.rawProgramDateTime = (" " + result[5]).slice(1);
        frag.tagList.push(["PROGRAM-DATE-TIME", frag.rawProgramDateTime]);
        if (firstPdtIndex === -1) {
          firstPdtIndex = fragments.length;
        }
      } else {
        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
        if (!result) {
          logger.warn("No matches on slow regex match for level playlist!");
          continue;
        }
        for (i = 1;i < result.length; i++) {
          if (typeof result[i] !== "undefined") {
            break;
          }
        }
        const tag = (" " + result[i]).slice(1);
        const value1 = (" " + result[i + 1]).slice(1);
        const value2 = result[i + 2] ? (" " + result[i + 2]).slice(1) : "";
        switch (tag) {
          case "PLAYLIST-TYPE":
            level.type = value1.toUpperCase();
            break;
          case "MEDIA-SEQUENCE":
            currentSN = level.startSN = parseInt(value1);
            break;
          case "SKIP": {
            const skipAttrs = new AttrList(value1);
            {
              substituteVariablesInAttributes(level, skipAttrs, ["RECENTLY-REMOVED-DATERANGES"]);
            }
            const skippedSegments = skipAttrs.decimalInteger("SKIPPED-SEGMENTS");
            if (isFiniteNumber(skippedSegments)) {
              level.skippedSegments = skippedSegments;
              for (let _i = skippedSegments;_i--; ) {
                fragments.unshift(null);
              }
              currentSN += skippedSegments;
            }
            const recentlyRemovedDateranges = skipAttrs.enumeratedString("RECENTLY-REMOVED-DATERANGES");
            if (recentlyRemovedDateranges) {
              level.recentlyRemovedDateranges = recentlyRemovedDateranges.split("\t");
            }
            break;
          }
          case "TARGETDURATION":
            level.targetduration = Math.max(parseInt(value1), 1);
            break;
          case "VERSION":
            level.version = parseInt(value1);
            break;
          case "INDEPENDENT-SEGMENTS":
          case "EXTM3U":
            break;
          case "ENDLIST":
            level.live = false;
            break;
          case "#":
            if (value1 || value2) {
              frag.tagList.push(value2 ? [value1, value2] : [value1]);
            }
            break;
          case "DISCONTINUITY":
            discontinuityCounter++;
            frag.tagList.push(["DIS"]);
            break;
          case "GAP":
            frag.gap = true;
            frag.tagList.push([tag]);
            break;
          case "BITRATE":
            frag.tagList.push([tag, value1]);
            break;
          case "DATERANGE": {
            const dateRangeAttr = new AttrList(value1);
            {
              substituteVariablesInAttributes(level, dateRangeAttr, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]);
              substituteVariablesInAttributes(level, dateRangeAttr, dateRangeAttr.clientAttrs);
            }
            const dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);
            if (dateRange.isValid || level.skippedSegments) {
              level.dateRanges[dateRange.id] = dateRange;
            } else {
              logger.warn(`Ignoring invalid DATERANGE tag: "${value1}"`);
            }
            frag.tagList.push(["EXT-X-DATERANGE", value1]);
            break;
          }
          case "DEFINE": {
            {
              const variableAttributes = new AttrList(value1);
              substituteVariablesInAttributes(level, variableAttributes, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]);
              if ("IMPORT" in variableAttributes) {
                importVariableDefinition(level, variableAttributes, multivariantVariableList);
              } else {
                addVariableDefinition(level, variableAttributes, baseurl);
              }
            }
            break;
          }
          case "DISCONTINUITY-SEQUENCE":
            discontinuityCounter = parseInt(value1);
            break;
          case "KEY": {
            const levelKey = parseKey(value1, baseurl, level);
            if (levelKey.isSupported()) {
              if (levelKey.method === "NONE") {
                levelkeys = undefined;
                break;
              }
              if (!levelkeys) {
                levelkeys = {};
              }
              if (levelkeys[levelKey.keyFormat]) {
                levelkeys = _extends({}, levelkeys);
              }
              levelkeys[levelKey.keyFormat] = levelKey;
            } else {
              logger.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: "${value1}"`);
            }
            break;
          }
          case "START":
            level.startTimeOffset = parseStartTimeOffset(value1);
            break;
          case "MAP": {
            const mapAttrs = new AttrList(value1);
            {
              substituteVariablesInAttributes(level, mapAttrs, ["BYTERANGE", "URI"]);
            }
            if (frag.duration) {
              const init = new Fragment(type, baseurl);
              setInitSegment(init, mapAttrs, id, levelkeys);
              currentInitSegment = init;
              frag.initSegment = currentInitSegment;
              if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {
                frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
              }
            } else {
              const end = frag.byteRangeEndOffset;
              if (end) {
                const start = frag.byteRangeStartOffset;
                nextByteRange = `${end - start}@${start}`;
              } else {
                nextByteRange = null;
              }
              setInitSegment(frag, mapAttrs, id, levelkeys);
              currentInitSegment = frag;
              createNextFrag = true;
            }
            break;
          }
          case "SERVER-CONTROL": {
            const serverControlAttrs = new AttrList(value1);
            level.canBlockReload = serverControlAttrs.bool("CAN-BLOCK-RELOAD");
            level.canSkipUntil = serverControlAttrs.optionalFloat("CAN-SKIP-UNTIL", 0);
            level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool("CAN-SKIP-DATERANGES");
            level.partHoldBack = serverControlAttrs.optionalFloat("PART-HOLD-BACK", 0);
            level.holdBack = serverControlAttrs.optionalFloat("HOLD-BACK", 0);
            break;
          }
          case "PART-INF": {
            const partInfAttrs = new AttrList(value1);
            level.partTarget = partInfAttrs.decimalFloatingPoint("PART-TARGET");
            break;
          }
          case "PART": {
            let partList = level.partList;
            if (!partList) {
              partList = level.partList = [];
            }
            const previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;
            const index = currentPart++;
            const partAttrs = new AttrList(value1);
            {
              substituteVariablesInAttributes(level, partAttrs, ["BYTERANGE", "URI"]);
            }
            const part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);
            partList.push(part);
            frag.duration += part.duration;
            break;
          }
          case "PRELOAD-HINT": {
            const preloadHintAttrs = new AttrList(value1);
            {
              substituteVariablesInAttributes(level, preloadHintAttrs, ["URI"]);
            }
            level.preloadHint = preloadHintAttrs;
            break;
          }
          case "RENDITION-REPORT": {
            const renditionReportAttrs = new AttrList(value1);
            {
              substituteVariablesInAttributes(level, renditionReportAttrs, ["URI"]);
            }
            level.renditionReports = level.renditionReports || [];
            level.renditionReports.push(renditionReportAttrs);
            break;
          }
          default:
            logger.warn(`line parsed but not handled: ${result}`);
            break;
        }
      }
    }
    if (prevFrag && !prevFrag.relurl) {
      fragments.pop();
      totalduration -= prevFrag.duration;
      if (level.partList) {
        level.fragmentHint = prevFrag;
      }
    } else if (level.partList) {
      assignProgramDateTime(frag, prevFrag);
      frag.cc = discontinuityCounter;
      level.fragmentHint = frag;
      if (levelkeys) {
        setFragLevelKeys(frag, levelkeys, level);
      }
    }
    const fragmentLength = fragments.length;
    const firstFragment = fragments[0];
    const lastFragment = fragments[fragmentLength - 1];
    totalduration += level.skippedSegments * level.targetduration;
    if (totalduration > 0 && fragmentLength && lastFragment) {
      level.averagetargetduration = totalduration / fragmentLength;
      const lastSn = lastFragment.sn;
      level.endSN = lastSn !== "initSegment" ? lastSn : 0;
      if (!level.live) {
        lastFragment.endList = true;
      }
      if (firstFragment) {
        level.startCC = firstFragment.cc;
      }
    } else {
      level.endSN = 0;
      level.startCC = 0;
    }
    if (level.fragmentHint) {
      totalduration += level.fragmentHint.duration;
    }
    level.totalduration = totalduration;
    level.endCC = discontinuityCounter;
    if (firstPdtIndex > 0) {
      backfillProgramDateTimes(fragments, firstPdtIndex);
    }
    return level;
  }
}
function parseKey(keyTagAttributes, baseurl, parsed) {
  var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;
  const keyAttrs = new AttrList(keyTagAttributes);
  {
    substituteVariablesInAttributes(parsed, keyAttrs, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]);
  }
  const decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : "";
  const decrypturi = keyAttrs.URI;
  const decryptiv = keyAttrs.hexadecimalInteger("IV");
  const decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;
  const decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : "identity";
  if (decrypturi && keyAttrs.IV && !decryptiv) {
    logger.error(`Invalid IV: ${keyAttrs.IV}`);
  }
  const resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : "";
  const keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : "1").split("/").map(Number).filter(Number.isFinite);
  return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);
}
function parseStartTimeOffset(startAttributes) {
  const startAttrs = new AttrList(startAttributes);
  const startTimeOffset = startAttrs.decimalFloatingPoint("TIME-OFFSET");
  if (isFiniteNumber(startTimeOffset)) {
    return startTimeOffset;
  }
  return null;
}
function setCodecs(codecsAttributeValue, level) {
  let codecs = (codecsAttributeValue || "").split(/[ ,]+/).filter((c) => c);
  ["video", "audio", "text"].forEach((type) => {
    const filtered = codecs.filter((codec) => isCodecType(codec, type));
    if (filtered.length) {
      level[`${type}Codec`] = filtered.join(",");
      codecs = codecs.filter((codec) => filtered.indexOf(codec) === -1);
    }
  });
  level.unknownCodecs = codecs;
}
function assignCodec(media, groupItem, codecProperty) {
  const codecValue = groupItem[codecProperty];
  if (codecValue) {
    media[codecProperty] = codecValue;
  }
}
function backfillProgramDateTimes(fragments, firstPdtIndex) {
  let fragPrev = fragments[firstPdtIndex];
  for (let i = firstPdtIndex;i--; ) {
    const frag = fragments[i];
    if (!frag) {
      return;
    }
    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;
    fragPrev = frag;
  }
}
function assignProgramDateTime(frag, prevFrag) {
  if (frag.rawProgramDateTime) {
    frag.programDateTime = Date.parse(frag.rawProgramDateTime);
  } else if (prevFrag != null && prevFrag.programDateTime) {
    frag.programDateTime = prevFrag.endProgramDateTime;
  }
  if (!isFiniteNumber(frag.programDateTime)) {
    frag.programDateTime = null;
    frag.rawProgramDateTime = null;
  }
}
function setInitSegment(frag, mapAttrs, id, levelkeys) {
  frag.relurl = mapAttrs.URI;
  if (mapAttrs.BYTERANGE) {
    frag.setByteRange(mapAttrs.BYTERANGE);
  }
  frag.level = id;
  frag.sn = "initSegment";
  if (levelkeys) {
    frag.levelkeys = levelkeys;
  }
  frag.initSegment = null;
}
function setFragLevelKeys(frag, levelkeys, level) {
  frag.levelkeys = levelkeys;
  const {
    encryptedFragments
  } = level;
  if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some((format) => levelkeys[format].isCommonEncryption)) {
    encryptedFragments.push(frag);
  }
}
var PlaylistContextType = {
  MANIFEST: "manifest",
  LEVEL: "level",
  AUDIO_TRACK: "audioTrack",
  SUBTITLE_TRACK: "subtitleTrack"
};
var PlaylistLevelType = {
  MAIN: "main",
  AUDIO: "audio",
  SUBTITLE: "subtitle"
};
function mapContextToLevelType(context) {
  const {
    type
  } = context;
  switch (type) {
    case PlaylistContextType.AUDIO_TRACK:
      return PlaylistLevelType.AUDIO;
    case PlaylistContextType.SUBTITLE_TRACK:
      return PlaylistLevelType.SUBTITLE;
    default:
      return PlaylistLevelType.MAIN;
  }
}
function getResponseUrl(response, context) {
  let url = response.url;
  if (url === undefined || url.indexOf("data:") === 0) {
    url = context.url;
  }
  return url;
}

class PlaylistLoader {
  constructor(hls) {
    this.hls = undefined;
    this.loaders = Object.create(null);
    this.variableList = null;
    this.hls = hls;
    this.registerListeners();
  }
  startLoad(startPosition) {
  }
  stopLoad() {
    this.destroyInternalLoaders();
  }
  registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
    hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
  }
  unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
    hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
  }
  createInternalLoader(context) {
    const config = this.hls.config;
    const PLoader = config.pLoader;
    const Loader = config.loader;
    const InternalLoader = PLoader || Loader;
    const loader = new InternalLoader(config);
    this.loaders[context.type] = loader;
    return loader;
  }
  getInternalLoader(context) {
    return this.loaders[context.type];
  }
  resetInternalLoader(contextType) {
    if (this.loaders[contextType]) {
      delete this.loaders[contextType];
    }
  }
  destroyInternalLoaders() {
    for (const contextType in this.loaders) {
      const loader = this.loaders[contextType];
      if (loader) {
        loader.destroy();
      }
      this.resetInternalLoader(contextType);
    }
  }
  destroy() {
    this.variableList = null;
    this.unregisterListeners();
    this.destroyInternalLoaders();
  }
  onManifestLoading(event, data) {
    const {
      url
    } = data;
    this.variableList = null;
    this.load({
      id: null,
      level: 0,
      responseType: "text",
      type: PlaylistContextType.MANIFEST,
      url,
      deliveryDirectives: null
    });
  }
  onLevelLoading(event, data) {
    const {
      id,
      level,
      pathwayId,
      url,
      deliveryDirectives
    } = data;
    this.load({
      id,
      level,
      pathwayId,
      responseType: "text",
      type: PlaylistContextType.LEVEL,
      url,
      deliveryDirectives
    });
  }
  onAudioTrackLoading(event, data) {
    const {
      id,
      groupId,
      url,
      deliveryDirectives
    } = data;
    this.load({
      id,
      groupId,
      level: null,
      responseType: "text",
      type: PlaylistContextType.AUDIO_TRACK,
      url,
      deliveryDirectives
    });
  }
  onSubtitleTrackLoading(event, data) {
    const {
      id,
      groupId,
      url,
      deliveryDirectives
    } = data;
    this.load({
      id,
      groupId,
      level: null,
      responseType: "text",
      type: PlaylistContextType.SUBTITLE_TRACK,
      url,
      deliveryDirectives
    });
  }
  load(context) {
    var _context$deliveryDire;
    const config = this.hls.config;
    let loader = this.getInternalLoader(context);
    if (loader) {
      const loaderContext = loader.context;
      if (loaderContext && loaderContext.url === context.url && loaderContext.level === context.level) {
        logger.trace("[playlist-loader]: playlist request ongoing");
        return;
      }
      logger.log(`[playlist-loader]: aborting previous loader for type: ${context.type}`);
      loader.abort();
    }
    let loadPolicy;
    if (context.type === PlaylistContextType.MANIFEST) {
      loadPolicy = config.manifestLoadPolicy.default;
    } else {
      loadPolicy = _extends({}, config.playlistLoadPolicy.default, {
        timeoutRetry: null,
        errorRetry: null
      });
    }
    loader = this.createInternalLoader(context);
    if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? undefined : _context$deliveryDire.part)) {
      let levelDetails;
      if (context.type === PlaylistContextType.LEVEL && context.level !== null) {
        levelDetails = this.hls.levels[context.level].details;
      } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {
        levelDetails = this.hls.audioTracks[context.id].details;
      } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {
        levelDetails = this.hls.subtitleTracks[context.id].details;
      }
      if (levelDetails) {
        const partTarget = levelDetails.partTarget;
        const targetDuration = levelDetails.targetduration;
        if (partTarget && targetDuration) {
          const maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;
          loadPolicy = _extends({}, loadPolicy, {
            maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),
            maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)
          });
        }
      }
    }
    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
    const loaderConfig = {
      loadPolicy,
      timeout: loadPolicy.maxLoadTimeMs,
      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
    };
    const loaderCallbacks = {
      onSuccess: (response, stats, context2, networkDetails) => {
        const loader2 = this.getInternalLoader(context2);
        this.resetInternalLoader(context2.type);
        const string = response.data;
        if (string.indexOf("#EXTM3U") !== 0) {
          this.handleManifestParsingError(response, context2, new Error("no EXTM3U delimiter"), networkDetails || null, stats);
          return;
        }
        stats.parsing.start = performance.now();
        if (M3U8Parser.isMediaPlaylist(string)) {
          this.handleTrackOrLevelPlaylist(response, stats, context2, networkDetails || null, loader2);
        } else {
          this.handleMasterPlaylist(response, stats, context2, networkDetails);
        }
      },
      onError: (response, context2, networkDetails, stats) => {
        this.handleNetworkError(context2, networkDetails, false, response, stats);
      },
      onTimeout: (stats, context2, networkDetails) => {
        this.handleNetworkError(context2, networkDetails, true, undefined, stats);
      }
    };
    loader.load(context, loaderConfig, loaderCallbacks);
  }
  handleMasterPlaylist(response, stats, context, networkDetails) {
    const hls = this.hls;
    const string = response.data;
    const url = getResponseUrl(response, context);
    const parsedResult = M3U8Parser.parseMasterPlaylist(string, url);
    if (parsedResult.playlistParsingError) {
      this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);
      return;
    }
    const {
      contentSteering,
      levels,
      sessionData,
      sessionKeys,
      startTimeOffset,
      variableList
    } = parsedResult;
    this.variableList = variableList;
    const {
      AUDIO: audioTracks = [],
      SUBTITLES: subtitles,
      "CLOSED-CAPTIONS": captions
    } = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult);
    if (audioTracks.length) {
      const embeddedAudioFound = audioTracks.some((audioTrack) => !audioTrack.url);
      if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
        logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one");
        audioTracks.unshift({
          type: "main",
          name: "main",
          groupId: "main",
          default: false,
          autoselect: false,
          forced: false,
          id: -1,
          attrs: new AttrList({}),
          bitrate: 0,
          url: ""
        });
      }
    }
    hls.trigger(Events.MANIFEST_LOADED, {
      levels,
      audioTracks,
      subtitles,
      captions,
      contentSteering,
      url,
      stats,
      networkDetails,
      sessionData,
      sessionKeys,
      startTimeOffset,
      variableList
    });
  }
  handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {
    const hls = this.hls;
    const {
      id,
      level,
      type
    } = context;
    const url = getResponseUrl(response, context);
    const levelUrlId = 0;
    const levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;
    const levelType = mapContextToLevelType(context);
    const levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);
    if (type === PlaylistContextType.MANIFEST) {
      const singleLevel = {
        attrs: new AttrList({}),
        bitrate: 0,
        details: levelDetails,
        name: "",
        url
      };
      hls.trigger(Events.MANIFEST_LOADED, {
        levels: [singleLevel],
        audioTracks: [],
        url,
        stats,
        networkDetails,
        sessionData: null,
        sessionKeys: null,
        contentSteering: null,
        startTimeOffset: null,
        variableList: null
      });
    }
    stats.parsing.end = performance.now();
    context.levelDetails = levelDetails;
    this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);
  }
  handleManifestParsingError(response, context, error, networkDetails, stats) {
    this.hls.trigger(Events.ERROR, {
      type: ErrorTypes.NETWORK_ERROR,
      details: ErrorDetails.MANIFEST_PARSING_ERROR,
      fatal: context.type === PlaylistContextType.MANIFEST,
      url: response.url,
      err: error,
      error,
      reason: error.message,
      response,
      context,
      networkDetails,
      stats
    });
  }
  handleNetworkError(context, networkDetails, timeout = false, response, stats) {
    let message = `A network ${timeout ? "timeout" : "error" + (response ? " (status " + response.code + ")" : "")} occurred while loading ${context.type}`;
    if (context.type === PlaylistContextType.LEVEL) {
      message += `: ${context.level} id: ${context.id}`;
    } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {
      message += ` id: ${context.id} group-id: "${context.groupId}"`;
    }
    const error = new Error(message);
    logger.warn(`[playlist-loader]: ${message}`);
    let details = ErrorDetails.UNKNOWN;
    let fatal = false;
    const loader = this.getInternalLoader(context);
    switch (context.type) {
      case PlaylistContextType.MANIFEST:
        details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;
        fatal = true;
        break;
      case PlaylistContextType.LEVEL:
        details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;
        fatal = false;
        break;
      case PlaylistContextType.AUDIO_TRACK:
        details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
        fatal = false;
        break;
      case PlaylistContextType.SUBTITLE_TRACK:
        details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;
        fatal = false;
        break;
    }
    if (loader) {
      this.resetInternalLoader(context.type);
    }
    const errorData = {
      type: ErrorTypes.NETWORK_ERROR,
      details,
      fatal,
      url: context.url,
      loader,
      context,
      error,
      networkDetails,
      stats
    };
    if (response) {
      const url = (networkDetails == null ? undefined : networkDetails.url) || context.url;
      errorData.response = _objectSpread2({
        url,
        data: undefined
      }, response);
    }
    this.hls.trigger(Events.ERROR, errorData);
  }
  handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {
    const hls = this.hls;
    const {
      type,
      level,
      id,
      groupId,
      deliveryDirectives
    } = context;
    const url = getResponseUrl(response, context);
    const parent = mapContextToLevelType(context);
    const levelIndex = typeof context.level === "number" && parent === PlaylistLevelType.MAIN ? level : undefined;
    if (!levelDetails.fragments.length) {
      const _error = new Error("No Segments found in Playlist");
      hls.trigger(Events.ERROR, {
        type: ErrorTypes.NETWORK_ERROR,
        details: ErrorDetails.LEVEL_EMPTY_ERROR,
        fatal: false,
        url,
        error: _error,
        reason: _error.message,
        response,
        context,
        level: levelIndex,
        parent,
        networkDetails,
        stats
      });
      return;
    }
    if (!levelDetails.targetduration) {
      levelDetails.playlistParsingError = new Error("Missing Target Duration");
    }
    const error = levelDetails.playlistParsingError;
    if (error) {
      hls.trigger(Events.ERROR, {
        type: ErrorTypes.NETWORK_ERROR,
        details: ErrorDetails.LEVEL_PARSING_ERROR,
        fatal: false,
        url,
        error,
        reason: error.message,
        response,
        context,
        level: levelIndex,
        parent,
        networkDetails,
        stats
      });
      return;
    }
    if (levelDetails.live && loader) {
      if (loader.getCacheAge) {
        levelDetails.ageHeader = loader.getCacheAge() || 0;
      }
      if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {
        levelDetails.ageHeader = 0;
      }
    }
    switch (type) {
      case PlaylistContextType.MANIFEST:
      case PlaylistContextType.LEVEL:
        hls.trigger(Events.LEVEL_LOADED, {
          details: levelDetails,
          level: levelIndex || 0,
          id: id || 0,
          stats,
          networkDetails,
          deliveryDirectives
        });
        break;
      case PlaylistContextType.AUDIO_TRACK:
        hls.trigger(Events.AUDIO_TRACK_LOADED, {
          details: levelDetails,
          id: id || 0,
          groupId: groupId || "",
          stats,
          networkDetails,
          deliveryDirectives
        });
        break;
      case PlaylistContextType.SUBTITLE_TRACK:
        hls.trigger(Events.SUBTITLE_TRACK_LOADED, {
          details: levelDetails,
          id: id || 0,
          groupId: groupId || "",
          stats,
          networkDetails,
          deliveryDirectives
        });
        break;
    }
  }
}
function sendAddTrackEvent(track, videoEl) {
  let event;
  try {
    event = new Event("addtrack");
  } catch (err) {
    event = document.createEvent("Event");
    event.initEvent("addtrack", false, false);
  }
  event.track = track;
  videoEl.dispatchEvent(event);
}
function addCueToTrack(track, cue) {
  const mode = track.mode;
  if (mode === "disabled") {
    track.mode = "hidden";
  }
  if (track.cues && !track.cues.getCueById(cue.id)) {
    try {
      track.addCue(cue);
      if (!track.cues.getCueById(cue.id)) {
        throw new Error(`addCue is failed for: ${cue}`);
      }
    } catch (err) {
      logger.debug(`[texttrack-utils]: ${err}`);
      try {
        const textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);
        textTrackCue.id = cue.id;
        track.addCue(textTrackCue);
      } catch (err2) {
        logger.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${err2}`);
      }
    }
  }
  if (mode === "disabled") {
    track.mode = mode;
  }
}
function clearCurrentCues(track) {
  const mode = track.mode;
  if (mode === "disabled") {
    track.mode = "hidden";
  }
  if (track.cues) {
    for (let i = track.cues.length;i--; ) {
      track.removeCue(track.cues[i]);
    }
  }
  if (mode === "disabled") {
    track.mode = mode;
  }
}
function removeCuesInRange(track, start, end, predicate) {
  const mode = track.mode;
  if (mode === "disabled") {
    track.mode = "hidden";
  }
  if (track.cues && track.cues.length > 0) {
    const cues = getCuesInRange(track.cues, start, end);
    for (let i = 0;i < cues.length; i++) {
      if (!predicate || predicate(cues[i])) {
        track.removeCue(cues[i]);
      }
    }
  }
  if (mode === "disabled") {
    track.mode = mode;
  }
}
function getFirstCueIndexAfterTime(cues, time) {
  if (time < cues[0].startTime) {
    return 0;
  }
  const len = cues.length - 1;
  if (time > cues[len].endTime) {
    return -1;
  }
  let left = 0;
  let right = len;
  while (left <= right) {
    const mid = Math.floor((right + left) / 2);
    if (time < cues[mid].startTime) {
      right = mid - 1;
    } else if (time > cues[mid].startTime && left < len) {
      left = mid + 1;
    } else {
      return mid;
    }
  }
  return cues[left].startTime - time < time - cues[right].startTime ? left : right;
}
function getCuesInRange(cues, start, end) {
  const cuesFound = [];
  const firstCueInRange = getFirstCueIndexAfterTime(cues, start);
  if (firstCueInRange > -1) {
    for (let i = firstCueInRange, len = cues.length;i < len; i++) {
      const cue = cues[i];
      if (cue.startTime >= start && cue.endTime <= end) {
        cuesFound.push(cue);
      } else if (cue.startTime > end) {
        return cuesFound;
      }
    }
  }
  return cuesFound;
}
function filterSubtitleTracks(textTrackList) {
  const tracks = [];
  for (let i = 0;i < textTrackList.length; i++) {
    const track = textTrackList[i];
    if ((track.kind === "subtitles" || track.kind === "captions") && track.label) {
      tracks.push(textTrackList[i]);
    }
  }
  return tracks;
}
var MetadataSchema = {
  audioId3: "org.id3",
  dateRange: "com.apple.quicktime.HLS",
  emsg: "https://aomedia.org/emsg/ID3"
};
var MIN_CUE_DURATION = 0.25;
function getCueClass() {
  if (typeof self === "undefined")
    return;
  return self.VTTCue || self.TextTrackCue;
}
function createCueWithDataFields(Cue, startTime, endTime, data, type) {
  let cue = new Cue(startTime, endTime, "");
  try {
    cue.value = data;
    if (type) {
      cue.type = type;
    }
  } catch (e) {
    cue = new Cue(startTime, endTime, JSON.stringify(type ? _objectSpread2({
      type
    }, data) : data));
  }
  return cue;
}
var MAX_CUE_ENDTIME = (() => {
  const Cue = getCueClass();
  try {
    Cue && new Cue(0, Number.POSITIVE_INFINITY, "");
  } catch (e) {
    return Number.MAX_VALUE;
  }
  return Number.POSITIVE_INFINITY;
})();
function dateRangeDateToTimelineSeconds(date, offset) {
  return date.getTime() / 1000 - offset;
}
function hexToArrayBuffer(str) {
  return Uint8Array.from(str.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
}

class ID3TrackController {
  constructor(hls) {
    this.hls = undefined;
    this.id3Track = null;
    this.media = null;
    this.dateRangeCuesAppended = {};
    this.hls = hls;
    this._registerListeners();
  }
  destroy() {
    this._unregisterListeners();
    this.id3Track = null;
    this.media = null;
    this.dateRangeCuesAppended = {};
    this.hls = null;
  }
  _registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  _unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  onMediaAttached(event, data) {
    this.media = data.media;
  }
  onMediaDetaching() {
    if (!this.id3Track) {
      return;
    }
    clearCurrentCues(this.id3Track);
    this.id3Track = null;
    this.media = null;
    this.dateRangeCuesAppended = {};
  }
  onManifestLoading() {
    this.dateRangeCuesAppended = {};
  }
  createTrack(media) {
    const track = this.getID3Track(media.textTracks);
    track.mode = "hidden";
    return track;
  }
  getID3Track(textTracks) {
    if (!this.media) {
      return;
    }
    for (let i = 0;i < textTracks.length; i++) {
      const textTrack = textTracks[i];
      if (textTrack.kind === "metadata" && textTrack.label === "id3") {
        sendAddTrackEvent(textTrack, this.media);
        return textTrack;
      }
    }
    return this.media.addTextTrack("metadata", "id3");
  }
  onFragParsingMetadata(event, data) {
    if (!this.media) {
      return;
    }
    const {
      hls: {
        config: {
          enableEmsgMetadataCues,
          enableID3MetadataCues
        }
      }
    } = this;
    if (!enableEmsgMetadataCues && !enableID3MetadataCues) {
      return;
    }
    const {
      samples
    } = data;
    if (!this.id3Track) {
      this.id3Track = this.createTrack(this.media);
    }
    const Cue = getCueClass();
    if (!Cue) {
      return;
    }
    for (let i = 0;i < samples.length; i++) {
      const type = samples[i].type;
      if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {
        continue;
      }
      const frames = getID3Frames(samples[i].data);
      if (frames) {
        const startTime = samples[i].pts;
        let endTime = startTime + samples[i].duration;
        if (endTime > MAX_CUE_ENDTIME) {
          endTime = MAX_CUE_ENDTIME;
        }
        const timeDiff = endTime - startTime;
        if (timeDiff <= 0) {
          endTime = startTime + MIN_CUE_DURATION;
        }
        for (let j = 0;j < frames.length; j++) {
          const frame = frames[j];
          if (!isTimeStampFrame(frame)) {
            this.updateId3CueEnds(startTime, type);
            const cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);
            if (cue) {
              this.id3Track.addCue(cue);
            }
          }
        }
      }
    }
  }
  updateId3CueEnds(startTime, type) {
    var _this$id3Track;
    const cues = (_this$id3Track = this.id3Track) == null ? undefined : _this$id3Track.cues;
    if (cues) {
      for (let i = cues.length;i--; ) {
        const cue = cues[i];
        if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {
          cue.endTime = startTime;
        }
      }
    }
  }
  onBufferFlushing(event, {
    startOffset,
    endOffset,
    type
  }) {
    const {
      id3Track,
      hls
    } = this;
    if (!hls) {
      return;
    }
    const {
      config: {
        enableEmsgMetadataCues,
        enableID3MetadataCues
      }
    } = hls;
    if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {
      let predicate;
      if (type === "audio") {
        predicate = (cue) => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;
      } else if (type === "video") {
        predicate = (cue) => cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
      } else {
        predicate = (cue) => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
      }
      removeCuesInRange(id3Track, startOffset, endOffset, predicate);
    }
  }
  onLevelUpdated(event, {
    details
  }) {
    if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {
      return;
    }
    const {
      dateRangeCuesAppended,
      id3Track
    } = this;
    const {
      dateRanges
    } = details;
    const ids = Object.keys(dateRanges);
    if (id3Track) {
      const idsToRemove = Object.keys(dateRangeCuesAppended).filter((id) => !ids.includes(id));
      for (let i = idsToRemove.length;i--; ) {
        const id = idsToRemove[i];
        Object.keys(dateRangeCuesAppended[id].cues).forEach((key) => {
          id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);
        });
        delete dateRangeCuesAppended[id];
      }
    }
    const lastFragment = details.fragments[details.fragments.length - 1];
    if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? undefined : lastFragment.programDateTime)) {
      return;
    }
    if (!this.id3Track) {
      this.id3Track = this.createTrack(this.media);
    }
    const dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;
    const Cue = getCueClass();
    for (let i = 0;i < ids.length; i++) {
      const id = ids[i];
      const dateRange = dateRanges[id];
      const startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);
      const appendedDateRangeCues = dateRangeCuesAppended[id];
      const cues = (appendedDateRangeCues == null ? undefined : appendedDateRangeCues.cues) || {};
      let durationKnown = (appendedDateRangeCues == null ? undefined : appendedDateRangeCues.durationKnown) || false;
      let endTime = MAX_CUE_ENDTIME;
      const endDate = dateRange.endDate;
      if (endDate) {
        endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);
        durationKnown = true;
      } else if (dateRange.endOnNext && !durationKnown) {
        const nextDateRangeWithSameClass = ids.reduce((candidateDateRange, id2) => {
          if (id2 !== dateRange.id) {
            const otherDateRange = dateRanges[id2];
            if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {
              return otherDateRange;
            }
          }
          return candidateDateRange;
        }, null);
        if (nextDateRangeWithSameClass) {
          endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);
          durationKnown = true;
        }
      }
      const attributes = Object.keys(dateRange.attr);
      for (let j = 0;j < attributes.length; j++) {
        const key = attributes[j];
        if (!isDateRangeCueAttribute(key)) {
          continue;
        }
        const cue = cues[key];
        if (cue) {
          if (durationKnown && !appendedDateRangeCues.durationKnown) {
            cue.endTime = endTime;
          }
        } else if (Cue) {
          let data = dateRange.attr[key];
          if (isSCTE35Attribute(key)) {
            data = hexToArrayBuffer(data);
          }
          const _cue = createCueWithDataFields(Cue, startTime, endTime, {
            key,
            data
          }, MetadataSchema.dateRange);
          if (_cue) {
            _cue.id = id;
            this.id3Track.addCue(_cue);
            cues[key] = _cue;
          }
        }
      }
      dateRangeCuesAppended[id] = {
        cues,
        dateRange,
        durationKnown
      };
    }
  }
}

class LatencyController {
  constructor(hls) {
    this.hls = undefined;
    this.config = undefined;
    this.media = null;
    this.levelDetails = null;
    this.currentTime = 0;
    this.stallCount = 0;
    this._latency = null;
    this.timeupdateHandler = () => this.timeupdate();
    this.hls = hls;
    this.config = hls.config;
    this.registerListeners();
  }
  get latency() {
    return this._latency || 0;
  }
  get maxLatency() {
    const {
      config,
      levelDetails
    } = this;
    if (config.liveMaxLatencyDuration !== undefined) {
      return config.liveMaxLatencyDuration;
    }
    return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;
  }
  get targetLatency() {
    const {
      levelDetails
    } = this;
    if (levelDetails === null) {
      return null;
    }
    const {
      holdBack,
      partHoldBack,
      targetduration
    } = levelDetails;
    const {
      liveSyncDuration,
      liveSyncDurationCount,
      lowLatencyMode
    } = this.config;
    const userConfig = this.hls.userConfig;
    let targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;
    if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {
      targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;
    }
    const maxLiveSyncOnStallIncrease = targetduration;
    const liveSyncOnStallIncrease = 1;
    return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);
  }
  get liveSyncPosition() {
    const liveEdge = this.estimateLiveEdge();
    const targetLatency = this.targetLatency;
    const levelDetails = this.levelDetails;
    if (liveEdge === null || targetLatency === null || levelDetails === null) {
      return null;
    }
    const edge = levelDetails.edge;
    const syncPosition = liveEdge - targetLatency - this.edgeStalled;
    const min = edge - levelDetails.totalduration;
    const max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);
    return Math.min(Math.max(min, syncPosition), max);
  }
  get drift() {
    const {
      levelDetails
    } = this;
    if (levelDetails === null) {
      return 1;
    }
    return levelDetails.drift;
  }
  get edgeStalled() {
    const {
      levelDetails
    } = this;
    if (levelDetails === null) {
      return 0;
    }
    const maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;
    return Math.max(levelDetails.age - maxLevelUpdateAge, 0);
  }
  get forwardBufferLength() {
    const {
      media,
      levelDetails
    } = this;
    if (!media || !levelDetails) {
      return 0;
    }
    const bufferedRanges = media.buffered.length;
    return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;
  }
  destroy() {
    this.unregisterListeners();
    this.onMediaDetaching();
    this.levelDetails = null;
    this.hls = this.timeupdateHandler = null;
  }
  registerListeners() {
    this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    this.hls.on(Events.ERROR, this.onError, this);
  }
  unregisterListeners() {
    this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    this.hls.off(Events.ERROR, this.onError, this);
  }
  onMediaAttached(event, data) {
    this.media = data.media;
    this.media.addEventListener("timeupdate", this.timeupdateHandler);
  }
  onMediaDetaching() {
    if (this.media) {
      this.media.removeEventListener("timeupdate", this.timeupdateHandler);
      this.media = null;
    }
  }
  onManifestLoading() {
    this.levelDetails = null;
    this._latency = null;
    this.stallCount = 0;
  }
  onLevelUpdated(event, {
    details
  }) {
    this.levelDetails = details;
    if (details.advanced) {
      this.timeupdate();
    }
    if (!details.live && this.media) {
      this.media.removeEventListener("timeupdate", this.timeupdateHandler);
    }
  }
  onError(event, data) {
    var _this$levelDetails;
    if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {
      return;
    }
    this.stallCount++;
    if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {
      logger.warn("[playback-rate-controller]: Stall detected, adjusting target latency");
    }
  }
  timeupdate() {
    const {
      media,
      levelDetails
    } = this;
    if (!media || !levelDetails) {
      return;
    }
    this.currentTime = media.currentTime;
    const latency = this.computeLatency();
    if (latency === null) {
      return;
    }
    this._latency = latency;
    const {
      lowLatencyMode,
      maxLiveSyncPlaybackRate
    } = this.config;
    if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {
      return;
    }
    const targetLatency = this.targetLatency;
    if (targetLatency === null) {
      return;
    }
    const distanceFromTarget = latency - targetLatency;
    const liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);
    const inLiveRange = distanceFromTarget < liveMinLatencyDuration;
    if (inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {
      const max = Math.min(2, Math.max(1, maxLiveSyncPlaybackRate));
      const rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;
      media.playbackRate = Math.min(max, Math.max(1, rate));
    } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {
      media.playbackRate = 1;
    }
  }
  estimateLiveEdge() {
    const {
      levelDetails
    } = this;
    if (levelDetails === null) {
      return null;
    }
    return levelDetails.edge + levelDetails.age;
  }
  computeLatency() {
    const liveEdge = this.estimateLiveEdge();
    if (liveEdge === null) {
      return null;
    }
    return liveEdge - this.currentTime;
  }
}
var HdcpLevels = ["NONE", "TYPE-0", "TYPE-1", null];
function isHdcpLevel(value) {
  return HdcpLevels.indexOf(value) > -1;
}
var VideoRangeValues = ["SDR", "PQ", "HLG"];
function isVideoRange(value) {
  return !!value && VideoRangeValues.indexOf(value) > -1;
}
var HlsSkip = {
  No: "",
  Yes: "YES",
  v2: "v2"
};
function getSkipValue(details) {
  const {
    canSkipUntil,
    canSkipDateRanges,
    age
  } = details;
  const playlistRecentEnough = age < canSkipUntil / 2;
  if (canSkipUntil && playlistRecentEnough) {
    if (canSkipDateRanges) {
      return HlsSkip.v2;
    }
    return HlsSkip.Yes;
  }
  return HlsSkip.No;
}

class HlsUrlParameters {
  constructor(msn, part, skip) {
    this.msn = undefined;
    this.part = undefined;
    this.skip = undefined;
    this.msn = msn;
    this.part = part;
    this.skip = skip;
  }
  addDirectives(uri) {
    const url = new self.URL(uri);
    if (this.msn !== undefined) {
      url.searchParams.set("_HLS_msn", this.msn.toString());
    }
    if (this.part !== undefined) {
      url.searchParams.set("_HLS_part", this.part.toString());
    }
    if (this.skip) {
      url.searchParams.set("_HLS_skip", this.skip);
    }
    return url.href;
  }
}

class Level {
  constructor(data) {
    this._attrs = undefined;
    this.audioCodec = undefined;
    this.bitrate = undefined;
    this.codecSet = undefined;
    this.url = undefined;
    this.frameRate = undefined;
    this.height = undefined;
    this.id = undefined;
    this.name = undefined;
    this.videoCodec = undefined;
    this.width = undefined;
    this.details = undefined;
    this.fragmentError = 0;
    this.loadError = 0;
    this.loaded = undefined;
    this.realBitrate = 0;
    this.supportedPromise = undefined;
    this.supportedResult = undefined;
    this._avgBitrate = 0;
    this._audioGroups = undefined;
    this._subtitleGroups = undefined;
    this._urlId = 0;
    this.url = [data.url];
    this._attrs = [data.attrs];
    this.bitrate = data.bitrate;
    if (data.details) {
      this.details = data.details;
    }
    this.id = data.id || 0;
    this.name = data.name;
    this.width = data.width || 0;
    this.height = data.height || 0;
    this.frameRate = data.attrs.optionalFloat("FRAME-RATE", 0);
    this._avgBitrate = data.attrs.decimalInteger("AVERAGE-BANDWIDTH");
    this.audioCodec = data.audioCodec;
    this.videoCodec = data.videoCodec;
    this.codecSet = [data.videoCodec, data.audioCodec].filter((c) => !!c).map((s) => s.substring(0, 4)).join(",");
    this.addGroupId("audio", data.attrs.AUDIO);
    this.addGroupId("text", data.attrs.SUBTITLES);
  }
  get maxBitrate() {
    return Math.max(this.realBitrate, this.bitrate);
  }
  get averageBitrate() {
    return this._avgBitrate || this.realBitrate || this.bitrate;
  }
  get attrs() {
    return this._attrs[0];
  }
  get codecs() {
    return this.attrs.CODECS || "";
  }
  get pathwayId() {
    return this.attrs["PATHWAY-ID"] || ".";
  }
  get videoRange() {
    return this.attrs["VIDEO-RANGE"] || "SDR";
  }
  get score() {
    return this.attrs.optionalFloat("SCORE", 0);
  }
  get uri() {
    return this.url[0] || "";
  }
  hasAudioGroup(groupId) {
    return hasGroup(this._audioGroups, groupId);
  }
  hasSubtitleGroup(groupId) {
    return hasGroup(this._subtitleGroups, groupId);
  }
  get audioGroups() {
    return this._audioGroups;
  }
  get subtitleGroups() {
    return this._subtitleGroups;
  }
  addGroupId(type, groupId) {
    if (!groupId) {
      return;
    }
    if (type === "audio") {
      let audioGroups = this._audioGroups;
      if (!audioGroups) {
        audioGroups = this._audioGroups = [];
      }
      if (audioGroups.indexOf(groupId) === -1) {
        audioGroups.push(groupId);
      }
    } else if (type === "text") {
      let subtitleGroups = this._subtitleGroups;
      if (!subtitleGroups) {
        subtitleGroups = this._subtitleGroups = [];
      }
      if (subtitleGroups.indexOf(groupId) === -1) {
        subtitleGroups.push(groupId);
      }
    }
  }
  get urlId() {
    return 0;
  }
  set urlId(value) {
  }
  get audioGroupIds() {
    return this.audioGroups ? [this.audioGroupId] : undefined;
  }
  get textGroupIds() {
    return this.subtitleGroups ? [this.textGroupId] : undefined;
  }
  get audioGroupId() {
    var _this$audioGroups;
    return (_this$audioGroups = this.audioGroups) == null ? undefined : _this$audioGroups[0];
  }
  get textGroupId() {
    var _this$subtitleGroups;
    return (_this$subtitleGroups = this.subtitleGroups) == null ? undefined : _this$subtitleGroups[0];
  }
  addFallback() {
  }
}
function hasGroup(groups, groupId) {
  if (!groupId || !groups) {
    return false;
  }
  return groups.indexOf(groupId) !== -1;
}
function updateFromToPTS(fragFrom, fragTo) {
  const fragToPTS = fragTo.startPTS;
  if (isFiniteNumber(fragToPTS)) {
    let duration = 0;
    let frag;
    if (fragTo.sn > fragFrom.sn) {
      duration = fragToPTS - fragFrom.start;
      frag = fragFrom;
    } else {
      duration = fragFrom.start - fragToPTS;
      frag = fragTo;
    }
    if (frag.duration !== duration) {
      frag.duration = duration;
    }
  } else if (fragTo.sn > fragFrom.sn) {
    const contiguous = fragFrom.cc === fragTo.cc;
    if (contiguous && fragFrom.minEndPTS) {
      fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);
    } else {
      fragTo.start = fragFrom.start + fragFrom.duration;
    }
  } else {
    fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
  }
}
function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
  const parsedMediaDuration = endPTS - startPTS;
  if (parsedMediaDuration <= 0) {
    logger.warn("Fragment should have a positive duration", frag);
    endPTS = startPTS + frag.duration;
    endDTS = startDTS + frag.duration;
  }
  let maxStartPTS = startPTS;
  let minEndPTS = endPTS;
  const fragStartPts = frag.startPTS;
  const fragEndPts = frag.endPTS;
  if (isFiniteNumber(fragStartPts)) {
    const deltaPTS = Math.abs(fragStartPts - startPTS);
    if (!isFiniteNumber(frag.deltaPTS)) {
      frag.deltaPTS = deltaPTS;
    } else {
      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
    }
    maxStartPTS = Math.max(startPTS, fragStartPts);
    startPTS = Math.min(startPTS, fragStartPts);
    startDTS = Math.min(startDTS, frag.startDTS);
    minEndPTS = Math.min(endPTS, fragEndPts);
    endPTS = Math.max(endPTS, fragEndPts);
    endDTS = Math.max(endDTS, frag.endDTS);
  }
  const drift = startPTS - frag.start;
  if (frag.start !== 0) {
    frag.start = startPTS;
  }
  frag.duration = endPTS - frag.start;
  frag.startPTS = startPTS;
  frag.maxStartPTS = maxStartPTS;
  frag.startDTS = startDTS;
  frag.endPTS = endPTS;
  frag.minEndPTS = minEndPTS;
  frag.endDTS = endDTS;
  const sn = frag.sn;
  if (!details || sn < details.startSN || sn > details.endSN) {
    return 0;
  }
  let i;
  const fragIdx = sn - details.startSN;
  const fragments = details.fragments;
  fragments[fragIdx] = frag;
  for (i = fragIdx;i > 0; i--) {
    updateFromToPTS(fragments[i], fragments[i - 1]);
  }
  for (i = fragIdx;i < fragments.length - 1; i++) {
    updateFromToPTS(fragments[i], fragments[i + 1]);
  }
  if (details.fragmentHint) {
    updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);
  }
  details.PTSKnown = details.alignedSliding = true;
  return drift;
}
function mergeDetails(oldDetails, newDetails) {
  let currentInitSegment = null;
  const oldFragments = oldDetails.fragments;
  for (let i = oldFragments.length - 1;i >= 0; i--) {
    const oldInit = oldFragments[i].initSegment;
    if (oldInit) {
      currentInitSegment = oldInit;
      break;
    }
  }
  if (oldDetails.fragmentHint) {
    delete oldDetails.fragmentHint.endPTS;
  }
  let ccOffset = 0;
  let PTSFrag;
  mapFragmentIntersection(oldDetails, newDetails, (oldFrag, newFrag) => {
    if (oldFrag.relurl) {
      ccOffset = oldFrag.cc - newFrag.cc;
    }
    if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {
      newFrag.start = newFrag.startPTS = oldFrag.startPTS;
      newFrag.startDTS = oldFrag.startDTS;
      newFrag.maxStartPTS = oldFrag.maxStartPTS;
      newFrag.endPTS = oldFrag.endPTS;
      newFrag.endDTS = oldFrag.endDTS;
      newFrag.minEndPTS = oldFrag.minEndPTS;
      newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;
      if (newFrag.duration) {
        PTSFrag = newFrag;
      }
      newDetails.PTSKnown = newDetails.alignedSliding = true;
    }
    newFrag.elementaryStreams = oldFrag.elementaryStreams;
    newFrag.loader = oldFrag.loader;
    newFrag.stats = oldFrag.stats;
    if (oldFrag.initSegment) {
      newFrag.initSegment = oldFrag.initSegment;
      currentInitSegment = oldFrag.initSegment;
    }
  });
  if (currentInitSegment) {
    const fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
    fragmentsToCheck.forEach((frag) => {
      var _currentInitSegment;
      if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? undefined : _currentInitSegment.relurl))) {
        frag.initSegment = currentInitSegment;
      }
    });
  }
  if (newDetails.skippedSegments) {
    newDetails.deltaUpdateFailed = newDetails.fragments.some((frag) => !frag);
    if (newDetails.deltaUpdateFailed) {
      logger.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
      for (let i = newDetails.skippedSegments;i--; ) {
        newDetails.fragments.shift();
      }
      newDetails.startSN = newDetails.fragments[0].sn;
      newDetails.startCC = newDetails.fragments[0].cc;
    } else if (newDetails.canSkipDateRanges) {
      newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);
    }
  }
  const newFragments = newDetails.fragments;
  if (ccOffset) {
    logger.warn("discontinuity sliding from playlist, take drift into account");
    for (let i = 0;i < newFragments.length; i++) {
      newFragments[i].cc += ccOffset;
    }
  }
  if (newDetails.skippedSegments) {
    newDetails.startCC = newDetails.fragments[0].cc;
  }
  mapPartIntersection(oldDetails.partList, newDetails.partList, (oldPart, newPart) => {
    newPart.elementaryStreams = oldPart.elementaryStreams;
    newPart.stats = oldPart.stats;
  });
  if (PTSFrag) {
    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
  } else {
    adjustSliding(oldDetails, newDetails);
  }
  if (newFragments.length) {
    newDetails.totalduration = newDetails.edge - newFragments[0].start;
  }
  newDetails.driftStartTime = oldDetails.driftStartTime;
  newDetails.driftStart = oldDetails.driftStart;
  const advancedDateTime = newDetails.advancedDateTime;
  if (newDetails.advanced && advancedDateTime) {
    const edge = newDetails.edge;
    if (!newDetails.driftStart) {
      newDetails.driftStartTime = advancedDateTime;
      newDetails.driftStart = edge;
    }
    newDetails.driftEndTime = advancedDateTime;
    newDetails.driftEnd = edge;
  } else {
    newDetails.driftEndTime = oldDetails.driftEndTime;
    newDetails.driftEnd = oldDetails.driftEnd;
    newDetails.advancedDateTime = oldDetails.advancedDateTime;
  }
}
function mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {
  const dateRanges = _extends({}, oldDateRanges);
  if (recentlyRemovedDateranges) {
    recentlyRemovedDateranges.forEach((id) => {
      delete dateRanges[id];
    });
  }
  Object.keys(deltaDateRanges).forEach((id) => {
    const dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);
    if (dateRange.isValid) {
      dateRanges[id] = dateRange;
    } else {
      logger.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: "${JSON.stringify(deltaDateRanges[id].attr)}"`);
    }
  });
  return dateRanges;
}
function mapPartIntersection(oldParts, newParts, intersectionFn) {
  if (oldParts && newParts) {
    let delta = 0;
    for (let i = 0, len = oldParts.length;i <= len; i++) {
      const oldPart = oldParts[i];
      const newPart = newParts[i + delta];
      if (oldPart && newPart && oldPart.index === newPart.index && oldPart.fragment.sn === newPart.fragment.sn) {
        intersectionFn(oldPart, newPart);
      } else {
        delta--;
      }
    }
  }
}
function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {
  const skippedSegments = newDetails.skippedSegments;
  const start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;
  const end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;
  const delta = newDetails.startSN - oldDetails.startSN;
  const newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
  const oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;
  for (let i = start;i <= end; i++) {
    const oldFrag = oldFrags[delta + i];
    let newFrag = newFrags[i];
    if (skippedSegments && !newFrag && i < skippedSegments) {
      newFrag = newDetails.fragments[i] = oldFrag;
    }
    if (oldFrag && newFrag) {
      intersectionFn(oldFrag, newFrag);
    }
  }
}
function adjustSliding(oldDetails, newDetails) {
  const delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;
  const oldFragments = oldDetails.fragments;
  if (delta < 0 || delta >= oldFragments.length) {
    return;
  }
  addSliding(newDetails, oldFragments[delta].start);
}
function addSliding(details, start) {
  if (start) {
    const fragments = details.fragments;
    for (let i = details.skippedSegments;i < fragments.length; i++) {
      fragments[i].start += start;
    }
    if (details.fragmentHint) {
      details.fragmentHint.start += start;
    }
  }
}
function computeReloadInterval(newDetails, distanceToLiveEdgeMs = Infinity) {
  let reloadInterval = 1000 * newDetails.targetduration;
  if (newDetails.updated) {
    const fragments = newDetails.fragments;
    const liveEdgeMaxTargetDurations = 4;
    if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {
      const lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;
      if (lastSegmentDuration < reloadInterval) {
        reloadInterval = lastSegmentDuration;
      }
    }
  } else {
    reloadInterval /= 2;
  }
  return Math.round(reloadInterval);
}
function getFragmentWithSN(level, sn, fragCurrent) {
  if (!(level != null && level.details)) {
    return null;
  }
  const levelDetails = level.details;
  let fragment = levelDetails.fragments[sn - levelDetails.startSN];
  if (fragment) {
    return fragment;
  }
  fragment = levelDetails.fragmentHint;
  if (fragment && fragment.sn === sn) {
    return fragment;
  }
  if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {
    return fragCurrent;
  }
  return null;
}
function getPartWith(level, sn, partIndex) {
  var _level$details;
  if (!(level != null && level.details)) {
    return null;
  }
  return findPart((_level$details = level.details) == null ? undefined : _level$details.partList, sn, partIndex);
}
function findPart(partList, sn, partIndex) {
  if (partList) {
    for (let i = partList.length;i--; ) {
      const part = partList[i];
      if (part.index === partIndex && part.fragment.sn === sn) {
        return part;
      }
    }
  }
  return null;
}
function reassignFragmentLevelIndexes(levels) {
  levels.forEach((level, index) => {
    const {
      details
    } = level;
    if (details != null && details.fragments) {
      details.fragments.forEach((fragment) => {
        fragment.level = index;
      });
    }
  });
}
function isTimeoutError(error) {
  switch (error.details) {
    case ErrorDetails.FRAG_LOAD_TIMEOUT:
    case ErrorDetails.KEY_LOAD_TIMEOUT:
    case ErrorDetails.LEVEL_LOAD_TIMEOUT:
    case ErrorDetails.MANIFEST_LOAD_TIMEOUT:
      return true;
  }
  return false;
}
function getRetryConfig(loadPolicy, error) {
  const isTimeout = isTimeoutError(error);
  return loadPolicy.default[`${isTimeout ? "timeout" : "error"}Retry`];
}
function getRetryDelay(retryConfig, retryCount) {
  const backoffFactor = retryConfig.backoff === "linear" ? 1 : Math.pow(2, retryCount);
  return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);
}
function getLoaderConfigWithoutReties(loderConfig) {
  return _objectSpread2(_objectSpread2({}, loderConfig), {
    errorRetry: null,
    timeoutRetry: null
  });
}
function shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {
  if (!retryConfig) {
    return false;
  }
  const httpStatus = loaderResponse == null ? undefined : loaderResponse.code;
  const retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);
  return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;
}
function retryForHttpStatus(httpStatus) {
  return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);
}
var BinarySearch = {
  search: function(list, comparisonFn) {
    let minIndex = 0;
    let maxIndex = list.length - 1;
    let currentIndex = null;
    let currentElement = null;
    while (minIndex <= maxIndex) {
      currentIndex = (minIndex + maxIndex) / 2 | 0;
      currentElement = list[currentIndex];
      const comparisonResult = comparisonFn(currentElement);
      if (comparisonResult > 0) {
        minIndex = currentIndex + 1;
      } else if (comparisonResult < 0) {
        maxIndex = currentIndex - 1;
      } else {
        return currentElement;
      }
    }
    return null;
  }
};
function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
  if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {
    return null;
  }
  const startPDT = fragments[0].programDateTime;
  if (PDTValue < (startPDT || 0)) {
    return null;
  }
  const endPDT = fragments[fragments.length - 1].endProgramDateTime;
  if (PDTValue >= (endPDT || 0)) {
    return null;
  }
  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
  for (let seg = 0;seg < fragments.length; ++seg) {
    const frag = fragments[seg];
    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
      return frag;
    }
  }
  return null;
}
function findFragmentByPTS(fragPrevious, fragments, bufferEnd = 0, maxFragLookUpTolerance = 0, nextFragLookupTolerance = 0.005) {
  let fragNext = null;
  if (fragPrevious) {
    fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;
    const bufferEdgeError = fragPrevious.endDTS - bufferEnd;
    if (bufferEdgeError > 0 && bufferEdgeError < 0.0000015) {
      bufferEnd += 0.0000015;
    }
  } else if (bufferEnd === 0 && fragments[0].start === 0) {
    fragNext = fragments[0];
  }
  if (fragNext && ((!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0 || fragmentWithinFastStartSwitch(fragNext, fragPrevious, Math.min(nextFragLookupTolerance, maxFragLookUpTolerance)))) {
    return fragNext;
  }
  const foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
  if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {
    return foundFragment;
  }
  return fragNext;
}
function fragmentWithinFastStartSwitch(fragNext, fragPrevious, nextFragLookupTolerance) {
  if (fragPrevious && fragPrevious.start === 0 && fragPrevious.level < fragNext.level && (fragPrevious.endPTS || 0) > 0) {
    const firstDuration = fragPrevious.tagList.reduce((duration, tag) => {
      if (tag[0] === "INF") {
        duration += parseFloat(tag[1]);
      }
      return duration;
    }, nextFragLookupTolerance);
    return fragNext.start <= firstDuration;
  }
  return false;
}
function fragmentWithinToleranceTest(bufferEnd = 0, maxFragLookUpTolerance = 0, candidate) {
  if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {
    return 0;
  }
  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
    return 1;
  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
    return -1;
  }
  return 0;
}
function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;
  const endProgramDateTime = candidate.endProgramDateTime || 0;
  return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
}
function findFragWithCC(fragments, cc2) {
  return BinarySearch.search(fragments, (candidate) => {
    if (candidate.cc < cc2) {
      return 1;
    } else if (candidate.cc > cc2) {
      return -1;
    } else {
      return 0;
    }
  });
}
var NetworkErrorAction = {
  DoNothing: 0,
  SendEndCallback: 1,
  SendAlternateToPenaltyBox: 2,
  RemoveAlternatePermanently: 3,
  InsertDiscontinuity: 4,
  RetryRequest: 5
};
var ErrorActionFlags = {
  None: 0,
  MoveAllAlternatesMatchingHost: 1,
  MoveAllAlternatesMatchingHDCP: 2,
  SwitchToSDR: 4
};

class ErrorController {
  constructor(hls) {
    this.hls = undefined;
    this.playlistError = 0;
    this.penalizedRenditions = {};
    this.log = undefined;
    this.warn = undefined;
    this.error = undefined;
    this.hls = hls;
    this.log = logger.log.bind(logger, `[info]:`);
    this.warn = logger.warn.bind(logger, `[warning]:`);
    this.error = logger.error.bind(logger, `[error]:`);
    this.registerListeners();
  }
  registerListeners() {
    const hls = this.hls;
    hls.on(Events.ERROR, this.onError, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  unregisterListeners() {
    const hls = this.hls;
    if (!hls) {
      return;
    }
    hls.off(Events.ERROR, this.onError, this);
    hls.off(Events.ERROR, this.onErrorOut, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
  }
  destroy() {
    this.unregisterListeners();
    this.hls = null;
    this.penalizedRenditions = {};
  }
  startLoad(startPosition) {
  }
  stopLoad() {
    this.playlistError = 0;
  }
  getVariantLevelIndex(frag) {
    return (frag == null ? undefined : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;
  }
  onManifestLoading() {
    this.playlistError = 0;
    this.penalizedRenditions = {};
  }
  onLevelUpdated() {
    this.playlistError = 0;
  }
  onError(event, data) {
    var _data$frag, _data$level;
    if (data.fatal) {
      return;
    }
    const hls = this.hls;
    const context = data.context;
    switch (data.details) {
      case ErrorDetails.FRAG_LOAD_ERROR:
      case ErrorDetails.FRAG_LOAD_TIMEOUT:
      case ErrorDetails.KEY_LOAD_ERROR:
      case ErrorDetails.KEY_LOAD_TIMEOUT:
        data.errorAction = this.getFragRetryOrSwitchAction(data);
        return;
      case ErrorDetails.FRAG_PARSING_ERROR:
        if ((_data$frag = data.frag) != null && _data$frag.gap) {
          data.errorAction = {
            action: NetworkErrorAction.DoNothing,
            flags: ErrorActionFlags.None
          };
          return;
        }
      case ErrorDetails.FRAG_GAP:
      case ErrorDetails.FRAG_DECRYPT_ERROR: {
        data.errorAction = this.getFragRetryOrSwitchAction(data);
        data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
        return;
      }
      case ErrorDetails.LEVEL_EMPTY_ERROR:
      case ErrorDetails.LEVEL_PARSING_ERROR:
        {
          var _data$context, _data$context$levelDe;
          const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;
          if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {
            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);
          } else {
            data.levelRetry = false;
            data.errorAction = this.getLevelSwitchAction(data, levelIndex);
          }
        }
        return;
      case ErrorDetails.LEVEL_LOAD_ERROR:
      case ErrorDetails.LEVEL_LOAD_TIMEOUT:
        if (typeof (context == null ? undefined : context.level) === "number") {
          data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);
        }
        return;
      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
      case ErrorDetails.SUBTITLE_LOAD_ERROR:
      case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:
        if (context) {
          const level = hls.levels[hls.loadLevel];
          if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {
            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);
            data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
            data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;
            return;
          }
        }
        return;
      case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
        {
          const level = hls.levels[hls.loadLevel];
          const restrictedHdcpLevel = level == null ? undefined : level.attrs["HDCP-LEVEL"];
          if (restrictedHdcpLevel) {
            data.errorAction = {
              action: NetworkErrorAction.SendAlternateToPenaltyBox,
              flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,
              hdcpLevel: restrictedHdcpLevel
            };
          } else {
            this.keySystemError(data);
          }
        }
        return;
      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
      case ErrorDetails.REMUX_ALLOC_ERROR:
      case ErrorDetails.BUFFER_APPEND_ERROR:
        data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);
        return;
      case ErrorDetails.INTERNAL_EXCEPTION:
      case ErrorDetails.BUFFER_APPENDING_ERROR:
      case ErrorDetails.BUFFER_FULL_ERROR:
      case ErrorDetails.LEVEL_SWITCH_ERROR:
      case ErrorDetails.BUFFER_STALLED_ERROR:
      case ErrorDetails.BUFFER_SEEK_OVER_HOLE:
      case ErrorDetails.BUFFER_NUDGE_ON_STALL:
        data.errorAction = {
          action: NetworkErrorAction.DoNothing,
          flags: ErrorActionFlags.None
        };
        return;
    }
    if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {
      this.keySystemError(data);
    }
  }
  keySystemError(data) {
    const levelIndex = this.getVariantLevelIndex(data.frag);
    data.levelRetry = false;
    data.errorAction = this.getLevelSwitchAction(data, levelIndex);
  }
  getPlaylistRetryOrSwitchAction(data, levelIndex) {
    const hls = this.hls;
    const retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);
    const retryCount = this.playlistError++;
    const retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);
    if (retry) {
      return {
        action: NetworkErrorAction.RetryRequest,
        flags: ErrorActionFlags.None,
        retryConfig,
        retryCount
      };
    }
    const errorAction = this.getLevelSwitchAction(data, levelIndex);
    if (retryConfig) {
      errorAction.retryConfig = retryConfig;
      errorAction.retryCount = retryCount;
    }
    return errorAction;
  }
  getFragRetryOrSwitchAction(data) {
    const hls = this.hls;
    const variantLevelIndex = this.getVariantLevelIndex(data.frag);
    const level = hls.levels[variantLevelIndex];
    const {
      fragLoadPolicy,
      keyLoadPolicy
    } = hls.config;
    const retryConfig = getRetryConfig(data.details.startsWith("key") ? keyLoadPolicy : fragLoadPolicy, data);
    const fragmentErrors = hls.levels.reduce((acc, level2) => acc + level2.fragmentError, 0);
    if (level) {
      if (data.details !== ErrorDetails.FRAG_GAP) {
        level.fragmentError++;
      }
      const retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);
      if (retry) {
        return {
          action: NetworkErrorAction.RetryRequest,
          flags: ErrorActionFlags.None,
          retryConfig,
          retryCount: fragmentErrors
        };
      }
    }
    const errorAction = this.getLevelSwitchAction(data, variantLevelIndex);
    if (retryConfig) {
      errorAction.retryConfig = retryConfig;
      errorAction.retryCount = fragmentErrors;
    }
    return errorAction;
  }
  getLevelSwitchAction(data, levelIndex) {
    const hls = this.hls;
    if (levelIndex === null || levelIndex === undefined) {
      levelIndex = hls.loadLevel;
    }
    const level = this.hls.levels[levelIndex];
    if (level) {
      var _data$frag2, _data$context2;
      const errorDetails = data.details;
      level.loadError++;
      if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {
        level.fragmentError++;
      }
      let nextLevel = -1;
      const {
        levels,
        loadLevel,
        minAutoLevel,
        maxAutoLevel
      } = hls;
      if (!hls.autoLevelEnabled) {
        hls.loadLevel = -1;
      }
      const fragErrorType = (_data$frag2 = data.frag) == null ? undefined : _data$frag2.type;
      const isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === "audio" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
      const findAudioCodecAlternate = isAudioCodecError && levels.some(({
        audioCodec
      }) => level.audioCodec !== audioCodec);
      const isVideoCodecError = data.sourceBufferName === "video" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
      const findVideoCodecAlternate = isVideoCodecError && levels.some(({
        codecSet,
        audioCodec
      }) => level.codecSet !== codecSet && level.audioCodec === audioCodec);
      const {
        type: playlistErrorType,
        groupId: playlistErrorGroupId
      } = (_data$context2 = data.context) != null ? _data$context2 : {};
      for (let i = levels.length;i--; ) {
        const candidate = (i + loadLevel) % levels.length;
        if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {
          var _level$audioGroups, _level$subtitleGroups;
          const levelCandidate = levels[candidate];
          if (errorDetails === ErrorDetails.FRAG_GAP && fragErrorType === PlaylistLevelType.MAIN && data.frag) {
            const levelDetails = levels[candidate].details;
            if (levelDetails) {
              const fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);
              if (fragCandidate != null && fragCandidate.gap) {
                continue;
              }
            }
          } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {
            continue;
          } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some((groupId) => levelCandidate.hasAudioGroup(groupId)) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some((groupId) => levelCandidate.hasSubtitleGroup(groupId)) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || !findAudioCodecAlternate && level.audioCodec !== levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet) {
            continue;
          }
          nextLevel = candidate;
          break;
        }
      }
      if (nextLevel > -1 && hls.loadLevel !== nextLevel) {
        data.levelRetry = true;
        this.playlistError = 0;
        return {
          action: NetworkErrorAction.SendAlternateToPenaltyBox,
          flags: ErrorActionFlags.None,
          nextAutoLevel: nextLevel
        };
      }
    }
    return {
      action: NetworkErrorAction.SendAlternateToPenaltyBox,
      flags: ErrorActionFlags.MoveAllAlternatesMatchingHost
    };
  }
  onErrorOut(event, data) {
    var _data$errorAction;
    switch ((_data$errorAction = data.errorAction) == null ? undefined : _data$errorAction.action) {
      case NetworkErrorAction.DoNothing:
        break;
      case NetworkErrorAction.SendAlternateToPenaltyBox:
        this.sendAlternateToPenaltyBox(data);
        if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {
          data.fatal = true;
        } else if (/MediaSource readyState: ended/.test(data.error.message)) {
          this.warn(`MediaSource ended after "${data.sourceBufferName}" sourceBuffer append error. Attempting to recover from media error.`);
          this.hls.recoverMediaError();
        }
        break;
      case NetworkErrorAction.RetryRequest:
        break;
    }
    if (data.fatal) {
      this.hls.stopLoad();
      return;
    }
  }
  sendAlternateToPenaltyBox(data) {
    const hls = this.hls;
    const errorAction = data.errorAction;
    if (!errorAction) {
      return;
    }
    const {
      flags,
      hdcpLevel,
      nextAutoLevel
    } = errorAction;
    switch (flags) {
      case ErrorActionFlags.None:
        this.switchLevel(data, nextAutoLevel);
        break;
      case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:
        if (hdcpLevel) {
          hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];
          errorAction.resolved = true;
        }
        this.warn(`Restricting playback to HDCP-LEVEL of "${hls.maxHdcpLevel}" or lower`);
        break;
    }
    if (!errorAction.resolved) {
      this.switchLevel(data, nextAutoLevel);
    }
  }
  switchLevel(data, levelIndex) {
    if (levelIndex !== undefined && data.errorAction) {
      this.warn(`switching to level ${levelIndex} after ${data.details}`);
      this.hls.nextAutoLevel = levelIndex;
      data.errorAction.resolved = true;
      this.hls.nextLoadLevel = this.hls.nextAutoLevel;
    }
  }
}

class BasePlaylistController {
  constructor(hls, logPrefix) {
    this.hls = undefined;
    this.timer = -1;
    this.requestScheduled = -1;
    this.canLoad = false;
    this.log = undefined;
    this.warn = undefined;
    this.log = logger.log.bind(logger, `${logPrefix}:`);
    this.warn = logger.warn.bind(logger, `${logPrefix}:`);
    this.hls = hls;
  }
  destroy() {
    this.clearTimer();
    this.hls = this.log = this.warn = null;
  }
  clearTimer() {
    if (this.timer !== -1) {
      self.clearTimeout(this.timer);
      this.timer = -1;
    }
  }
  startLoad() {
    this.canLoad = true;
    this.requestScheduled = -1;
    this.loadPlaylist();
  }
  stopLoad() {
    this.canLoad = false;
    this.clearTimer();
  }
  switchParams(playlistUri, previous, current) {
    const renditionReports = previous == null ? undefined : previous.renditionReports;
    if (renditionReports) {
      let foundIndex = -1;
      for (let i = 0;i < renditionReports.length; i++) {
        const attr = renditionReports[i];
        let uri;
        try {
          uri = new self.URL(attr.URI, previous.url).href;
        } catch (error) {
          logger.warn(`Could not construct new URL for Rendition Report: ${error}`);
          uri = attr.URI || "";
        }
        if (uri === playlistUri) {
          foundIndex = i;
          break;
        } else if (uri === playlistUri.substring(0, uri.length)) {
          foundIndex = i;
        }
      }
      if (foundIndex !== -1) {
        const attr = renditionReports[foundIndex];
        const msn = parseInt(attr["LAST-MSN"]) || (previous == null ? undefined : previous.lastPartSn);
        let part = parseInt(attr["LAST-PART"]) || (previous == null ? undefined : previous.lastPartIndex);
        if (this.hls.config.lowLatencyMode) {
          const currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);
          if (part >= 0 && currentGoal > previous.partTarget) {
            part += 1;
          }
        }
        const skip = current && getSkipValue(current);
        return new HlsUrlParameters(msn, part >= 0 ? part : undefined, skip);
      }
    }
  }
  loadPlaylist(hlsUrlParameters) {
    if (this.requestScheduled === -1) {
      this.requestScheduled = self.performance.now();
    }
  }
  shouldLoadPlaylist(playlist) {
    return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);
  }
  shouldReloadPlaylist(playlist) {
    return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);
  }
  playlistLoaded(index, data, previousDetails) {
    const {
      details,
      stats
    } = data;
    const now = self.performance.now();
    const elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;
    details.advancedDateTime = Date.now() - elapsed;
    if (details.live || previousDetails != null && previousDetails.live) {
      details.reloaded(previousDetails);
      if (previousDetails) {
        this.log(`live playlist ${index} ${details.advanced ? "REFRESHED " + details.lastPartSn + "-" + details.lastPartIndex : details.updated ? "UPDATED" : "MISSED"}`);
      }
      if (previousDetails && details.fragments.length > 0) {
        mergeDetails(previousDetails, details);
      }
      if (!this.canLoad || !details.live) {
        return;
      }
      let deliveryDirectives;
      let msn = undefined;
      let part = undefined;
      if (details.canBlockReload && details.endSN && details.advanced) {
        const lowLatencyMode = this.hls.config.lowLatencyMode;
        const lastPartSn = details.lastPartSn;
        const endSn = details.endSN;
        const lastPartIndex = details.lastPartIndex;
        const hasParts = lastPartIndex !== -1;
        const lastPart = lastPartSn === endSn;
        const nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;
        if (hasParts) {
          msn = lastPart ? endSn + 1 : lastPartSn;
          part = lastPart ? nextSnStartIndex : lastPartIndex + 1;
        } else {
          msn = endSn + 1;
        }
        const lastAdvanced = details.age;
        const cdnAge = lastAdvanced + details.ageHeader;
        let currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);
        if (currentGoal > 0) {
          if (previousDetails && currentGoal > previousDetails.tuneInGoal) {
            this.warn(`CDN Tune-in goal increased from: ${previousDetails.tuneInGoal} to: ${currentGoal} with playlist age: ${details.age}`);
            currentGoal = 0;
          } else {
            const segments = Math.floor(currentGoal / details.targetduration);
            msn += segments;
            if (part !== undefined) {
              const parts = Math.round(currentGoal % details.targetduration / details.partTarget);
              part += parts;
            }
            this.log(`CDN Tune-in age: ${details.ageHeader}s last advanced ${lastAdvanced.toFixed(2)}s goal: ${currentGoal} skip sn ${segments} to part ${part}`);
          }
          details.tuneInGoal = currentGoal;
        }
        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
        if (lowLatencyMode || !lastPart) {
          this.loadPlaylist(deliveryDirectives);
          return;
        }
      } else if (details.canBlockReload || details.canSkipUntil) {
        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
      }
      const bufferInfo = this.hls.mainForwardBufferInfo;
      const position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;
      const distanceToLiveEdgeMs = (details.edge - position) * 1000;
      const reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);
      if (details.updated && now > this.requestScheduled + reloadInterval) {
        this.requestScheduled = stats.loading.start;
      }
      if (msn !== undefined && details.canBlockReload) {
        this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);
      } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now) {
        this.requestScheduled = now;
      } else if (this.requestScheduled - now <= 0) {
        this.requestScheduled += reloadInterval;
      }
      let estimatedTimeUntilUpdate = this.requestScheduled - now;
      estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);
      this.log(`reload live playlist ${index} in ${Math.round(estimatedTimeUntilUpdate)} ms`);
      this.timer = self.setTimeout(() => this.loadPlaylist(deliveryDirectives), estimatedTimeUntilUpdate);
    } else {
      this.clearTimer();
    }
  }
  getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {
    let skip = getSkipValue(details);
    if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {
      msn = previousDeliveryDirectives.msn;
      part = previousDeliveryDirectives.part;
      skip = HlsSkip.No;
    }
    return new HlsUrlParameters(msn, part, skip);
  }
  checkRetry(errorEvent) {
    const errorDetails = errorEvent.details;
    const isTimeout = isTimeoutError(errorEvent);
    const errorAction = errorEvent.errorAction;
    const {
      action,
      retryCount = 0,
      retryConfig
    } = errorAction || {};
    const retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);
    if (retry) {
      var _errorEvent$context;
      this.requestScheduled = -1;
      if (retryCount >= retryConfig.maxNumRetry) {
        return false;
      }
      if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {
        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after "${errorDetails}" without delivery-directives`);
        this.loadPlaylist();
      } else {
        const delay = getRetryDelay(retryConfig, retryCount);
        this.timer = self.setTimeout(() => this.loadPlaylist(), delay);
        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after "${errorDetails}" in ${delay}ms`);
      }
      errorEvent.levelRetry = true;
      errorAction.resolved = true;
    }
    return retry;
  }
}

class EWMA {
  constructor(halfLife, estimate2 = 0, weight = 0) {
    this.halfLife = undefined;
    this.alpha_ = undefined;
    this.estimate_ = undefined;
    this.totalWeight_ = undefined;
    this.halfLife = halfLife;
    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
    this.estimate_ = estimate2;
    this.totalWeight_ = weight;
  }
  sample(weight, value) {
    const adjAlpha = Math.pow(this.alpha_, weight);
    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
    this.totalWeight_ += weight;
  }
  getTotalWeight() {
    return this.totalWeight_;
  }
  getEstimate() {
    if (this.alpha_) {
      const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
      if (zeroFactor) {
        return this.estimate_ / zeroFactor;
      }
    }
    return this.estimate_;
  }
}

class EwmaBandWidthEstimator {
  constructor(slow, fast, defaultEstimate, defaultTTFB = 100) {
    this.defaultEstimate_ = undefined;
    this.minWeight_ = undefined;
    this.minDelayMs_ = undefined;
    this.slow_ = undefined;
    this.fast_ = undefined;
    this.defaultTTFB_ = undefined;
    this.ttfb_ = undefined;
    this.defaultEstimate_ = defaultEstimate;
    this.minWeight_ = 0.001;
    this.minDelayMs_ = 50;
    this.slow_ = new EWMA(slow);
    this.fast_ = new EWMA(fast);
    this.defaultTTFB_ = defaultTTFB;
    this.ttfb_ = new EWMA(slow);
  }
  update(slow, fast) {
    const {
      slow_,
      fast_,
      ttfb_
    } = this;
    if (slow_.halfLife !== slow) {
      this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());
    }
    if (fast_.halfLife !== fast) {
      this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());
    }
    if (ttfb_.halfLife !== slow) {
      this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());
    }
  }
  sample(durationMs, numBytes) {
    durationMs = Math.max(durationMs, this.minDelayMs_);
    const numBits = 8 * numBytes;
    const durationS = durationMs / 1000;
    const bandwidthInBps = numBits / durationS;
    this.fast_.sample(durationS, bandwidthInBps);
    this.slow_.sample(durationS, bandwidthInBps);
  }
  sampleTTFB(ttfb) {
    const seconds = ttfb / 1000;
    const weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);
    this.ttfb_.sample(weight, Math.max(ttfb, 5));
  }
  canEstimate() {
    return this.fast_.getTotalWeight() >= this.minWeight_;
  }
  getEstimate() {
    if (this.canEstimate()) {
      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
    } else {
      return this.defaultEstimate_;
    }
  }
  getEstimateTTFB() {
    if (this.ttfb_.getTotalWeight() >= this.minWeight_) {
      return this.ttfb_.getEstimate();
    } else {
      return this.defaultTTFB_;
    }
  }
  destroy() {
  }
}
var SUPPORTED_INFO_DEFAULT = {
  supported: true,
  configurations: [],
  decodingInfoResults: [{
    supported: true,
    powerEfficient: true,
    smooth: true
  }]
};
var SUPPORTED_INFO_CACHE = {};
function requiresMediaCapabilitiesDecodingInfo(level, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference) {
  const audioGroups = level.audioCodec ? level.audioGroups : null;
  const audioCodecPreference = audioPreference == null ? undefined : audioPreference.audioCodec;
  const channelsPreference = audioPreference == null ? undefined : audioPreference.channels;
  const maxChannels = channelsPreference ? parseInt(channelsPreference) : audioCodecPreference ? Infinity : 2;
  let audioChannels = null;
  if (audioGroups != null && audioGroups.length) {
    try {
      if (audioGroups.length === 1 && audioGroups[0]) {
        audioChannels = audioTracksByGroup.groups[audioGroups[0]].channels;
      } else {
        audioChannels = audioGroups.reduce((acc, groupId) => {
          if (groupId) {
            const audioTrackGroup = audioTracksByGroup.groups[groupId];
            if (!audioTrackGroup) {
              throw new Error(`Audio track group ${groupId} not found`);
            }
            Object.keys(audioTrackGroup.channels).forEach((key) => {
              acc[key] = (acc[key] || 0) + audioTrackGroup.channels[key];
            });
          }
          return acc;
        }, {
          2: 0
        });
      }
    } catch (error) {
      return true;
    }
  }
  return level.videoCodec !== undefined && (level.width > 1920 && level.height > 1088 || level.height > 1920 && level.width > 1088 || level.frameRate > Math.max(currentFrameRate, 30) || level.videoRange !== "SDR" && level.videoRange !== currentVideoRange || level.bitrate > Math.max(currentBw, 8000000)) || !!audioChannels && isFiniteNumber(maxChannels) && Object.keys(audioChannels).some((channels) => parseInt(channels) > maxChannels);
}
function getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities) {
  const videoCodecs = level.videoCodec;
  const audioCodecs = level.audioCodec;
  if (!videoCodecs || !audioCodecs || !mediaCapabilities) {
    return Promise.resolve(SUPPORTED_INFO_DEFAULT);
  }
  const baseVideoConfiguration = {
    width: level.width,
    height: level.height,
    bitrate: Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate)),
    framerate: level.frameRate || 30
  };
  const videoRange = level.videoRange;
  if (videoRange !== "SDR") {
    baseVideoConfiguration.transferFunction = videoRange.toLowerCase();
  }
  const configurations = videoCodecs.split(",").map((videoCodec) => ({
    type: "media-source",
    video: _objectSpread2(_objectSpread2({}, baseVideoConfiguration), {}, {
      contentType: mimeTypeForCodec(videoCodec, "video")
    })
  }));
  if (audioCodecs && level.audioGroups) {
    level.audioGroups.forEach((audioGroupId) => {
      var _audioTracksByGroup$g;
      if (!audioGroupId) {
        return;
      }
      (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null || _audioTracksByGroup$g.tracks.forEach((audioTrack) => {
        if (audioTrack.groupId === audioGroupId) {
          const channels = audioTrack.channels || "";
          const channelsNumber = parseFloat(channels);
          if (isFiniteNumber(channelsNumber) && channelsNumber > 2) {
            configurations.push.apply(configurations, audioCodecs.split(",").map((audioCodec) => ({
              type: "media-source",
              audio: {
                contentType: mimeTypeForCodec(audioCodec, "audio"),
                channels: "" + channelsNumber
              }
            })));
          }
        }
      });
    });
  }
  return Promise.all(configurations.map((configuration) => {
    const decodingInfoKey = getMediaDecodingInfoKey(configuration);
    return SUPPORTED_INFO_CACHE[decodingInfoKey] || (SUPPORTED_INFO_CACHE[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));
  })).then((decodingInfoResults) => ({
    supported: !decodingInfoResults.some((info) => !info.supported),
    configurations,
    decodingInfoResults
  })).catch((error) => ({
    supported: false,
    configurations,
    decodingInfoResults: [],
    error
  }));
}
function getMediaDecodingInfoKey(config) {
  const {
    audio,
    video
  } = config;
  const mediaConfig = video || audio;
  if (mediaConfig) {
    const codec = mediaConfig.contentType.split('"')[1];
    if (video) {
      return `r${video.height}x${video.width}f${Math.ceil(video.framerate)}${video.transferFunction || "sd"}_${codec}_${Math.ceil(video.bitrate / 1e5)}`;
    }
    if (audio) {
      return `c${audio.channels}${audio.spatialRendering ? "s" : "n"}_${codec}`;
    }
  }
  return "";
}
function isHdrSupported() {
  if (typeof matchMedia === "function") {
    const mediaQueryList = matchMedia("(dynamic-range: high)");
    const badQuery = matchMedia("bad query");
    if (mediaQueryList.media !== badQuery.media) {
      return mediaQueryList.matches === true;
    }
  }
  return false;
}
function getVideoSelectionOptions(currentVideoRange, videoPreference) {
  let preferHDR = false;
  let allowedVideoRanges = [];
  if (currentVideoRange) {
    preferHDR = currentVideoRange !== "SDR";
    allowedVideoRanges = [currentVideoRange];
  }
  if (videoPreference) {
    allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);
    preferHDR = videoPreference.preferHDR !== undefined ? videoPreference.preferHDR : isHdrSupported();
    if (preferHDR) {
      allowedVideoRanges = allowedVideoRanges.filter((range) => range !== "SDR");
    } else {
      allowedVideoRanges = ["SDR"];
    }
  }
  return {
    preferHDR,
    allowedVideoRanges
  };
}
function getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {
  const codecSets = Object.keys(codecTiers);
  const channelsPreference = audioPreference == null ? undefined : audioPreference.channels;
  const audioCodecPreference = audioPreference == null ? undefined : audioPreference.audioCodec;
  const preferStereo = channelsPreference && parseInt(channelsPreference) === 2;
  let hasStereo = true;
  let hasCurrentVideoRange = false;
  let minHeight = Infinity;
  let minFramerate = Infinity;
  let minBitrate = Infinity;
  let selectedScore = 0;
  let videoRanges = [];
  const {
    preferHDR,
    allowedVideoRanges
  } = getVideoSelectionOptions(currentVideoRange, videoPreference);
  for (let i = codecSets.length;i--; ) {
    const tier = codecTiers[codecSets[i]];
    hasStereo = tier.channels[2] > 0;
    minHeight = Math.min(minHeight, tier.minHeight);
    minFramerate = Math.min(minFramerate, tier.minFramerate);
    minBitrate = Math.min(minBitrate, tier.minBitrate);
    const matchingVideoRanges = allowedVideoRanges.filter((range) => tier.videoRanges[range] > 0);
    if (matchingVideoRanges.length > 0) {
      hasCurrentVideoRange = true;
      videoRanges = matchingVideoRanges;
    }
  }
  minHeight = isFiniteNumber(minHeight) ? minHeight : 0;
  minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;
  const maxHeight = Math.max(1080, minHeight);
  const maxFramerate = Math.max(30, minFramerate);
  minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;
  currentBw = Math.max(minBitrate, currentBw);
  if (!hasCurrentVideoRange) {
    currentVideoRange = undefined;
    videoRanges = [];
  }
  const codecSet = codecSets.reduce((selected, candidate) => {
    const candidateTier = codecTiers[candidate];
    if (candidate === selected) {
      return selected;
    }
    if (candidateTier.minBitrate > currentBw) {
      logStartCodecCandidateIgnored(candidate, `min bitrate of ${candidateTier.minBitrate} > current estimate of ${currentBw}`);
      return selected;
    }
    if (!candidateTier.hasDefaultAudio) {
      logStartCodecCandidateIgnored(candidate, `no renditions with default or auto-select sound found`);
      return selected;
    }
    if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {
      logStartCodecCandidateIgnored(candidate, `audio codec preference "${audioCodecPreference}" not found`);
      return selected;
    }
    if (channelsPreference && !preferStereo) {
      if (!candidateTier.channels[channelsPreference]) {
        logStartCodecCandidateIgnored(candidate, `no renditions with ${channelsPreference} channel sound found (channels options: ${Object.keys(candidateTier.channels)})`);
        return selected;
      }
    } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels["2"] === 0) {
      logStartCodecCandidateIgnored(candidate, `no renditions with stereo sound found`);
      return selected;
    }
    if (candidateTier.minHeight > maxHeight) {
      logStartCodecCandidateIgnored(candidate, `min resolution of ${candidateTier.minHeight} > maximum of ${maxHeight}`);
      return selected;
    }
    if (candidateTier.minFramerate > maxFramerate) {
      logStartCodecCandidateIgnored(candidate, `min framerate of ${candidateTier.minFramerate} > maximum of ${maxFramerate}`);
      return selected;
    }
    if (!videoRanges.some((range) => candidateTier.videoRanges[range] > 0)) {
      logStartCodecCandidateIgnored(candidate, `no variants with VIDEO-RANGE of ${JSON.stringify(videoRanges)} found`);
      return selected;
    }
    if (candidateTier.maxScore < selectedScore) {
      logStartCodecCandidateIgnored(candidate, `max score of ${candidateTier.maxScore} < selected max of ${selectedScore}`);
      return selected;
    }
    if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {
      return selected;
    }
    selectedScore = candidateTier.maxScore;
    return candidate;
  }, undefined);
  return {
    codecSet,
    videoRanges,
    preferHDR,
    minFramerate,
    minBitrate
  };
}
function logStartCodecCandidateIgnored(codeSet, reason) {
  logger.log(`[abr] start candidates with "${codeSet}" ignored because ${reason}`);
}
function getAudioTracksByGroup(allAudioTracks) {
  return allAudioTracks.reduce((audioTracksByGroup, track) => {
    let trackGroup = audioTracksByGroup.groups[track.groupId];
    if (!trackGroup) {
      trackGroup = audioTracksByGroup.groups[track.groupId] = {
        tracks: [],
        channels: {
          2: 0
        },
        hasDefault: false,
        hasAutoSelect: false
      };
    }
    trackGroup.tracks.push(track);
    const channelsKey = track.channels || "2";
    trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;
    trackGroup.hasDefault = trackGroup.hasDefault || track.default;
    trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;
    if (trackGroup.hasDefault) {
      audioTracksByGroup.hasDefaultAudio = true;
    }
    if (trackGroup.hasAutoSelect) {
      audioTracksByGroup.hasAutoSelectAudio = true;
    }
    return audioTracksByGroup;
  }, {
    hasDefaultAudio: false,
    hasAutoSelectAudio: false,
    groups: {}
  });
}
function getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {
  return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce((tiers, level) => {
    if (!level.codecSet) {
      return tiers;
    }
    const audioGroups = level.audioGroups;
    let tier = tiers[level.codecSet];
    if (!tier) {
      tiers[level.codecSet] = tier = {
        minBitrate: Infinity,
        minHeight: Infinity,
        minFramerate: Infinity,
        maxScore: 0,
        videoRanges: {
          SDR: 0
        },
        channels: {
          "2": 0
        },
        hasDefaultAudio: !audioGroups,
        fragmentError: 0
      };
    }
    tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);
    const lesserWidthOrHeight = Math.min(level.height, level.width);
    tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);
    tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);
    tier.maxScore = Math.max(tier.maxScore, level.score);
    tier.fragmentError += level.fragmentError;
    tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;
    if (audioGroups) {
      audioGroups.forEach((audioGroupId) => {
        if (!audioGroupId) {
          return;
        }
        const audioGroup = audioTracksByGroup.groups[audioGroupId];
        if (!audioGroup) {
          return;
        }
        tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;
        Object.keys(audioGroup.channels).forEach((channels) => {
          tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];
        });
      });
    }
    return tiers;
  }, {});
}
function findMatchingOption(option, tracks, matchPredicate) {
  if ("attrs" in option) {
    const index = tracks.indexOf(option);
    if (index !== -1) {
      return index;
    }
  }
  for (let i = 0;i < tracks.length; i++) {
    const track = tracks[i];
    if (matchesOption(option, track, matchPredicate)) {
      return i;
    }
  }
  return -1;
}
function matchesOption(option, track, matchPredicate) {
  const {
    groupId,
    name,
    lang,
    assocLang,
    characteristics,
    default: isDefault
  } = option;
  const forced = option.forced;
  return (groupId === undefined || track.groupId === groupId) && (name === undefined || track.name === name) && (lang === undefined || track.lang === lang) && (lang === undefined || track.assocLang === assocLang) && (isDefault === undefined || track.default === isDefault) && (forced === undefined || track.forced === forced) && (characteristics === undefined || characteristicsMatch(characteristics, track.characteristics)) && (matchPredicate === undefined || matchPredicate(option, track));
}
function characteristicsMatch(characteristicsA, characteristicsB = "") {
  const arrA = characteristicsA.split(",");
  const arrB = characteristicsB.split(",");
  return arrA.length === arrB.length && !arrA.some((el) => arrB.indexOf(el) === -1);
}
function audioMatchPredicate(option, track) {
  const {
    audioCodec,
    channels
  } = option;
  return (audioCodec === undefined || (track.audioCodec || "").substring(0, 4) === audioCodec.substring(0, 4)) && (channels === undefined || channels === (track.channels || "2"));
}
function findClosestLevelWithAudioGroup(option, levels, allAudioTracks, searchIndex, matchPredicate) {
  const currentLevel = levels[searchIndex];
  const variants = levels.reduce((variantMap, level, index) => {
    const uri = level.uri;
    const renditions2 = variantMap[uri] || (variantMap[uri] = []);
    renditions2.push(index);
    return variantMap;
  }, {});
  const renditions = variants[currentLevel.uri];
  if (renditions.length > 1) {
    searchIndex = Math.max.apply(Math, renditions);
  }
  const currentVideoRange = currentLevel.videoRange;
  const currentFrameRate = currentLevel.frameRate;
  const currentVideoCodec = currentLevel.codecSet.substring(0, 4);
  const matchingVideo = searchDownAndUpList(levels, searchIndex, (level) => {
    if (level.videoRange !== currentVideoRange || level.frameRate !== currentFrameRate || level.codecSet.substring(0, 4) !== currentVideoCodec) {
      return false;
    }
    const audioGroups = level.audioGroups;
    const tracks = allAudioTracks.filter((track) => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);
    return findMatchingOption(option, tracks, matchPredicate) > -1;
  });
  if (matchingVideo > -1) {
    return matchingVideo;
  }
  return searchDownAndUpList(levels, searchIndex, (level) => {
    const audioGroups = level.audioGroups;
    const tracks = allAudioTracks.filter((track) => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);
    return findMatchingOption(option, tracks, matchPredicate) > -1;
  });
}
function searchDownAndUpList(arr, searchIndex, predicate) {
  for (let i = searchIndex;i > -1; i--) {
    if (predicate(arr[i])) {
      return i;
    }
  }
  for (let i = searchIndex + 1;i < arr.length; i++) {
    if (predicate(arr[i])) {
      return i;
    }
  }
  return -1;
}

class AbrController {
  constructor(_hls) {
    this.hls = undefined;
    this.lastLevelLoadSec = 0;
    this.lastLoadedFragLevel = -1;
    this.firstSelection = -1;
    this._nextAutoLevel = -1;
    this.nextAutoLevelKey = "";
    this.audioTracksByGroup = null;
    this.codecTiers = null;
    this.timer = -1;
    this.fragCurrent = null;
    this.partCurrent = null;
    this.bitrateTestDelay = 0;
    this.bwEstimator = undefined;
    this._abandonRulesCheck = () => {
      const {
        fragCurrent: frag,
        partCurrent: part,
        hls
      } = this;
      const {
        autoLevelEnabled,
        media
      } = hls;
      if (!frag || !media) {
        return;
      }
      const now = performance.now();
      const stats = part ? part.stats : frag.stats;
      const duration = part ? part.duration : frag.duration;
      const timeLoading = now - stats.loading.start;
      const minAutoLevel = hls.minAutoLevel;
      if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level <= minAutoLevel) {
        this.clearTimer();
        this._nextAutoLevel = -1;
        return;
      }
      if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {
        return;
      }
      const bufferInfo = hls.mainForwardBufferInfo;
      if (bufferInfo === null) {
        return;
      }
      const ttfbEstimate = this.bwEstimator.getEstimateTTFB();
      const playbackRate = Math.abs(media.playbackRate);
      if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {
        return;
      }
      const bufferStarvationDelay = bufferInfo.len / playbackRate;
      const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
      const loadedFirstByte = stats.loaded && ttfb > -1;
      const bwEstimate = this.getBwEstimate();
      const levels = hls.levels;
      const level = levels[frag.level];
      const expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.averageBitrate / 8));
      let timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;
      if (timeStreaming < 1 && loadedFirstByte) {
        timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);
      }
      const loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;
      const fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1000;
      if (fragLoadedDelay <= bufferStarvationDelay) {
        return;
      }
      const bwe = loadRate ? loadRate * 8 : bwEstimate;
      let fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;
      let nextLoadLevel;
      for (nextLoadLevel = frag.level - 1;nextLoadLevel > minAutoLevel; nextLoadLevel--) {
        const levelNextBitrate = levels[nextLoadLevel].maxBitrate;
        fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbEstimate / 1000, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);
        if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
          break;
        }
      }
      if (fragLevelNextLoadedDelay >= fragLoadedDelay) {
        return;
      }
      if (fragLevelNextLoadedDelay > duration * 10) {
        return;
      }
      hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;
      if (loadedFirstByte) {
        this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
      } else {
        this.bwEstimator.sampleTTFB(timeLoading);
      }
      const nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;
      if (this.getBwEstimate() * this.hls.config.abrBandWidthUpFactor > nextLoadLevelBitrate) {
        this.resetEstimator(nextLoadLevelBitrate);
      }
      this.clearTimer();
      logger.warn(`[abr] Fragment ${frag.sn}${part ? " part " + part.index : ""} of level ${frag.level} is loading too slowly;
      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s
      Estimated load time for current fragment: ${fragLoadedDelay.toFixed(3)} s
      Estimated load time for down switch fragment: ${fragLevelNextLoadedDelay.toFixed(3)} s
      TTFB estimate: ${ttfb | 0} ms
      Current BW estimate: ${isFiniteNumber(bwEstimate) ? bwEstimate | 0 : "Unknown"} bps
      New BW estimate: ${this.getBwEstimate() | 0} bps
      Switching to level ${nextLoadLevel} @ ${nextLoadLevelBitrate | 0} bps`);
      hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {
        frag,
        part,
        stats
      });
    };
    this.hls = _hls;
    this.bwEstimator = this.initEstimator();
    this.registerListeners();
  }
  resetEstimator(abrEwmaDefaultEstimate) {
    if (abrEwmaDefaultEstimate) {
      logger.log(`setting initial bwe to ${abrEwmaDefaultEstimate}`);
      this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;
    }
    this.firstSelection = -1;
    this.bwEstimator = this.initEstimator();
  }
  initEstimator() {
    const config = this.hls.config;
    return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);
  }
  registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
    hls.on(Events.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls
    } = this;
    if (!hls) {
      return;
    }
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
    hls.off(Events.ERROR, this.onError, this);
  }
  destroy() {
    this.unregisterListeners();
    this.clearTimer();
    this.hls = this._abandonRulesCheck = null;
    this.fragCurrent = this.partCurrent = null;
  }
  onManifestLoading(event, data) {
    this.lastLoadedFragLevel = -1;
    this.firstSelection = -1;
    this.lastLevelLoadSec = 0;
    this.fragCurrent = this.partCurrent = null;
    this.onLevelsUpdated();
    this.clearTimer();
  }
  onLevelsUpdated() {
    if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {
      this.lastLoadedFragLevel = this.fragCurrent.level;
    }
    this._nextAutoLevel = -1;
    this.onMaxAutoLevelUpdated();
    this.codecTiers = null;
    this.audioTracksByGroup = null;
  }
  onMaxAutoLevelUpdated() {
    this.firstSelection = -1;
    this.nextAutoLevelKey = "";
  }
  onFragLoading(event, data) {
    const frag = data.frag;
    if (this.ignoreFragment(frag)) {
      return;
    }
    if (!frag.bitrateTest) {
      var _data$part;
      this.fragCurrent = frag;
      this.partCurrent = (_data$part = data.part) != null ? _data$part : null;
    }
    this.clearTimer();
    this.timer = self.setInterval(this._abandonRulesCheck, 100);
  }
  onLevelSwitching(event, data) {
    this.clearTimer();
  }
  onError(event, data) {
    if (data.fatal) {
      return;
    }
    switch (data.details) {
      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
      case ErrorDetails.BUFFER_APPEND_ERROR:
        this.lastLoadedFragLevel = -1;
        this.firstSelection = -1;
        break;
      case ErrorDetails.FRAG_LOAD_TIMEOUT: {
        const frag = data.frag;
        const {
          fragCurrent,
          partCurrent: part
        } = this;
        if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {
          const now = performance.now();
          const stats = part ? part.stats : frag.stats;
          const timeLoading = now - stats.loading.start;
          const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
          const loadedFirstByte = stats.loaded && ttfb > -1;
          if (loadedFirstByte) {
            const ttfbEstimate = this.bwEstimator.getEstimateTTFB();
            this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
          } else {
            this.bwEstimator.sampleTTFB(timeLoading);
          }
        }
        break;
      }
    }
  }
  getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {
    const fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;
    const playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;
    return fragLoadSec + playlistLoadSec;
  }
  onLevelLoaded(event, data) {
    const config = this.hls.config;
    const {
      loading
    } = data.stats;
    const timeLoadingMs = loading.end - loading.start;
    if (isFiniteNumber(timeLoadingMs)) {
      this.lastLevelLoadSec = timeLoadingMs / 1000;
    }
    if (data.details.live) {
      this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);
    } else {
      this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);
    }
  }
  onFragLoaded(event, {
    frag,
    part
  }) {
    const stats = part ? part.stats : frag.stats;
    if (frag.type === PlaylistLevelType.MAIN) {
      this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);
    }
    if (this.ignoreFragment(frag)) {
      return;
    }
    this.clearTimer();
    if (frag.level === this._nextAutoLevel) {
      this._nextAutoLevel = -1;
    }
    this.firstSelection = -1;
    if (this.hls.config.abrMaxWithRealBitrate) {
      const duration = part ? part.duration : frag.duration;
      const level = this.hls.levels[frag.level];
      const loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;
      const loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;
      level.loaded = {
        bytes: loadedBytes,
        duration: loadedDuration
      };
      level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
    }
    if (frag.bitrateTest) {
      const fragBufferedData = {
        stats,
        frag,
        part,
        id: frag.type
      };
      this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);
      frag.bitrateTest = false;
    } else {
      this.lastLoadedFragLevel = frag.level;
    }
  }
  onFragBuffered(event, data) {
    const {
      frag,
      part
    } = data;
    const stats = part != null && part.stats.loaded ? part.stats : frag.stats;
    if (stats.aborted) {
      return;
    }
    if (this.ignoreFragment(frag)) {
      return;
    }
    const processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());
    this.bwEstimator.sample(processingMs, stats.loaded);
    stats.bwEstimate = this.getBwEstimate();
    if (frag.bitrateTest) {
      this.bitrateTestDelay = processingMs / 1000;
    } else {
      this.bitrateTestDelay = 0;
    }
  }
  ignoreFragment(frag) {
    return frag.type !== PlaylistLevelType.MAIN || frag.sn === "initSegment";
  }
  clearTimer() {
    if (this.timer > -1) {
      self.clearInterval(this.timer);
      this.timer = -1;
    }
  }
  get firstAutoLevel() {
    const {
      maxAutoLevel,
      minAutoLevel
    } = this.hls;
    const bwEstimate = this.getBwEstimate();
    const maxStartDelay = this.hls.config.maxStarvationDelay;
    const abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);
    if (abrAutoLevel > -1) {
      return abrAutoLevel;
    }
    const firstLevel = this.hls.firstLevel;
    const clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);
    logger.warn(`[abr] Could not find best starting auto level. Defaulting to first in playlist ${firstLevel} clamped to ${clamped}`);
    return clamped;
  }
  get forcedAutoLevel() {
    if (this.nextAutoLevelKey) {
      return -1;
    }
    return this._nextAutoLevel;
  }
  get nextAutoLevel() {
    const forcedAutoLevel = this.forcedAutoLevel;
    const bwEstimator = this.bwEstimator;
    const useEstimate = bwEstimator.canEstimate();
    const loadedFirstFrag = this.lastLoadedFragLevel > -1;
    if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {
      return forcedAutoLevel;
    }
    const nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;
    if (forcedAutoLevel !== -1) {
      const levels = this.hls.levels;
      if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {
        return forcedAutoLevel;
      }
    }
    this._nextAutoLevel = nextABRAutoLevel;
    this.nextAutoLevelKey = this.getAutoLevelKey();
    return nextABRAutoLevel;
  }
  getAutoLevelKey() {
    return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;
  }
  getNextABRAutoLevel() {
    const {
      fragCurrent,
      partCurrent,
      hls
    } = this;
    const {
      maxAutoLevel,
      config,
      minAutoLevel
    } = hls;
    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
    const avgbw = this.getBwEstimate();
    const bufferStarvationDelay = this.getStarvationDelay();
    let bwFactor = config.abrBandWidthFactor;
    let bwUpFactor = config.abrBandWidthUpFactor;
    if (bufferStarvationDelay) {
      const _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);
      if (_bestLevel >= 0) {
        return _bestLevel;
      }
    }
    let maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;
    if (!bufferStarvationDelay) {
      const bitrateTestDelay = this.bitrateTestDelay;
      if (bitrateTestDelay) {
        const maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
        logger.info(`[abr] bitrate test took ${Math.round(1000 * bitrateTestDelay)}ms, set first fragment max fetchDuration to ${Math.round(1000 * maxStarvationDelay)} ms`);
        bwFactor = bwUpFactor = 1;
      }
    }
    const bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);
    logger.info(`[abr] ${bufferStarvationDelay ? "rebuffering expected" : "buffer is empty"}, optimal quality level ${bestLevel}`);
    if (bestLevel > -1) {
      return bestLevel;
    }
    const minLevel = hls.levels[minAutoLevel];
    const autoLevel = hls.levels[hls.loadLevel];
    if ((minLevel == null ? undefined : minLevel.bitrate) < (autoLevel == null ? undefined : autoLevel.bitrate)) {
      return minAutoLevel;
    }
    return hls.loadLevel;
  }
  getStarvationDelay() {
    const hls = this.hls;
    const media = hls.media;
    if (!media) {
      return Infinity;
    }
    const playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1;
    const bufferInfo = hls.mainForwardBufferInfo;
    return (bufferInfo ? bufferInfo.len : 0) / playbackRate;
  }
  getBwEstimate() {
    return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;
  }
  findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {
    var _level$details;
    const maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;
    const lastLoadedFragLevel = this.lastLoadedFragLevel;
    const selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;
    const {
      fragCurrent,
      partCurrent
    } = this;
    const {
      levels,
      allAudioTracks,
      loadLevel,
      config
    } = this.hls;
    if (levels.length === 1) {
      return 0;
    }
    const level = levels[selectionBaseLevel];
    const live = !!(level != null && (_level$details = level.details) != null && _level$details.live);
    const firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;
    let currentCodecSet;
    let currentVideoRange = "SDR";
    let currentFrameRate = (level == null ? undefined : level.frameRate) || 0;
    const {
      audioPreference,
      videoPreference
    } = config;
    const audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));
    if (firstSelection) {
      if (this.firstSelection !== -1) {
        return this.firstSelection;
      }
      const codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));
      const startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);
      const {
        codecSet,
        videoRanges,
        minFramerate,
        minBitrate,
        preferHDR
      } = startTier;
      currentCodecSet = codecSet;
      currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];
      currentFrameRate = minFramerate;
      currentBw = Math.max(currentBw, minBitrate);
      logger.log(`[abr] picked start tier ${JSON.stringify(startTier)}`);
    } else {
      currentCodecSet = level == null ? undefined : level.codecSet;
      currentVideoRange = level == null ? undefined : level.videoRange;
    }
    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
    const ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;
    const levelsSkipped = [];
    for (let i = maxAutoLevel;i >= minAutoLevel; i--) {
      var _levelInfo$supportedR;
      const levelInfo = levels[i];
      const upSwitch = i > selectionBaseLevel;
      if (!levelInfo) {
        continue;
      }
      if (config.useMediaCapabilities && !levelInfo.supportedResult && !levelInfo.supportedPromise) {
        const mediaCapabilities = navigator.mediaCapabilities;
        if (typeof (mediaCapabilities == null ? undefined : mediaCapabilities.decodingInfo) === "function" && requiresMediaCapabilitiesDecodingInfo(levelInfo, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference)) {
          levelInfo.supportedPromise = getMediaDecodingInfoPromise(levelInfo, audioTracksByGroup, mediaCapabilities);
          levelInfo.supportedPromise.then((decodingInfo) => {
            if (!this.hls) {
              return;
            }
            levelInfo.supportedResult = decodingInfo;
            const levels2 = this.hls.levels;
            const index = levels2.indexOf(levelInfo);
            if (decodingInfo.error) {
              logger.warn(`[abr] MediaCapabilities decodingInfo error: "${decodingInfo.error}" for level ${index} ${JSON.stringify(decodingInfo)}`);
            } else if (!decodingInfo.supported) {
              logger.warn(`[abr] Unsupported MediaCapabilities decodingInfo result for level ${index} ${JSON.stringify(decodingInfo)}`);
              if (index > -1 && levels2.length > 1) {
                logger.log(`[abr] Removing unsupported level ${index}`);
                this.hls.removeLevel(index);
              }
            }
          });
        } else {
          levelInfo.supportedResult = SUPPORTED_INFO_DEFAULT;
        }
      }
      if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || levelInfo.supportedResult && !((_levelInfo$supportedR = levelInfo.supportedResult.decodingInfoResults) != null && _levelInfo$supportedR[0].smooth)) {
        levelsSkipped.push(i);
        continue;
      }
      const levelDetails = levelInfo.details;
      const avgDuration = (partCurrent ? levelDetails == null ? undefined : levelDetails.partTarget : levelDetails == null ? undefined : levelDetails.averagetargetduration) || currentFragDuration;
      let adjustedbw;
      if (!upSwitch) {
        adjustedbw = bwFactor * currentBw;
      } else {
        adjustedbw = bwUpFactor * currentBw;
      }
      const bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levels[i].averageBitrate : levels[i].maxBitrate;
      const fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);
      const canSwitchWithinTolerance = adjustedbw >= bitrate && (i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && (fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration);
      if (canSwitchWithinTolerance) {
        const forcedAutoLevel = this.forcedAutoLevel;
        if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {
          if (levelsSkipped.length) {
            logger.trace(`[abr] Skipped level(s) ${levelsSkipped.join(",")} of ${maxAutoLevel} max with CODECS and VIDEO-RANGE:"${levels[levelsSkipped[0]].codecs}" ${levels[levelsSkipped[0]].videoRange}; not compatible with "${level.codecs}" ${currentVideoRange}`);
          }
          logger.info(`[abr] switch candidate:${selectionBaseLevel}->${i} adjustedbw(${Math.round(adjustedbw)})-bitrate=${Math.round(adjustedbw - bitrate)} ttfb:${ttfbEstimateSec.toFixed(1)} avgDuration:${avgDuration.toFixed(1)} maxFetchDuration:${maxFetchDuration.toFixed(1)} fetchDuration:${fetchDuration.toFixed(1)} firstSelection:${firstSelection} codecSet:${currentCodecSet} videoRange:${currentVideoRange} hls.loadLevel:${loadLevel}`);
        }
        if (firstSelection) {
          this.firstSelection = i;
        }
        return i;
      }
    }
    return -1;
  }
  set nextAutoLevel(nextLevel) {
    const {
      maxAutoLevel,
      minAutoLevel
    } = this.hls;
    const value = Math.min(Math.max(nextLevel, minAutoLevel), maxAutoLevel);
    if (this._nextAutoLevel !== value) {
      this.nextAutoLevelKey = "";
      this._nextAutoLevel = value;
    }
  }
}

class TaskLoop {
  constructor() {
    this._boundTick = undefined;
    this._tickTimer = null;
    this._tickInterval = null;
    this._tickCallCount = 0;
    this._boundTick = this.tick.bind(this);
  }
  destroy() {
    this.onHandlerDestroying();
    this.onHandlerDestroyed();
  }
  onHandlerDestroying() {
    this.clearNextTick();
    this.clearInterval();
  }
  onHandlerDestroyed() {
  }
  hasInterval() {
    return !!this._tickInterval;
  }
  hasNextTick() {
    return !!this._tickTimer;
  }
  setInterval(millis) {
    if (!this._tickInterval) {
      this._tickCallCount = 0;
      this._tickInterval = self.setInterval(this._boundTick, millis);
      return true;
    }
    return false;
  }
  clearInterval() {
    if (this._tickInterval) {
      self.clearInterval(this._tickInterval);
      this._tickInterval = null;
      return true;
    }
    return false;
  }
  clearNextTick() {
    if (this._tickTimer) {
      self.clearTimeout(this._tickTimer);
      this._tickTimer = null;
      return true;
    }
    return false;
  }
  tick() {
    this._tickCallCount++;
    if (this._tickCallCount === 1) {
      this.doTick();
      if (this._tickCallCount > 1) {
        this.tickImmediate();
      }
      this._tickCallCount = 0;
    }
  }
  tickImmediate() {
    this.clearNextTick();
    this._tickTimer = self.setTimeout(this._boundTick, 0);
  }
  doTick() {
  }
}
var FragmentState = {
  NOT_LOADED: "NOT_LOADED",
  APPENDING: "APPENDING",
  PARTIAL: "PARTIAL",
  OK: "OK"
};

class FragmentTracker {
  constructor(hls) {
    this.activePartLists = Object.create(null);
    this.endListFragments = Object.create(null);
    this.fragments = Object.create(null);
    this.timeRanges = Object.create(null);
    this.bufferPadding = 0.2;
    this.hls = undefined;
    this.hasGaps = false;
    this.hls = hls;
    this._registerListeners();
  }
  _registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);
    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
  }
  _unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);
    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
  }
  destroy() {
    this._unregisterListeners();
    this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null;
  }
  getAppendedFrag(position, levelType) {
    const activeParts = this.activePartLists[levelType];
    if (activeParts) {
      for (let i = activeParts.length;i--; ) {
        const activePart = activeParts[i];
        if (!activePart) {
          break;
        }
        const appendedPTS = activePart.end;
        if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {
          return activePart;
        }
      }
    }
    return this.getBufferedFrag(position, levelType);
  }
  getBufferedFrag(position, levelType) {
    const {
      fragments
    } = this;
    const keys = Object.keys(fragments);
    for (let i = keys.length;i--; ) {
      const fragmentEntity = fragments[keys[i]];
      if ((fragmentEntity == null ? undefined : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {
        const frag = fragmentEntity.body;
        if (frag.start <= position && position <= frag.end) {
          return frag;
        }
      }
    }
    return null;
  }
  detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {
    if (this.timeRanges) {
      this.timeRanges[elementaryStream] = timeRange;
    }
    const appendedPartSn = (appendedPart == null ? undefined : appendedPart.fragment.sn) || -1;
    Object.keys(this.fragments).forEach((key) => {
      const fragmentEntity = this.fragments[key];
      if (!fragmentEntity) {
        return;
      }
      if (appendedPartSn >= fragmentEntity.body.sn) {
        return;
      }
      if (!fragmentEntity.buffered && !fragmentEntity.loaded) {
        if (fragmentEntity.body.type === playlistType) {
          this.removeFragment(fragmentEntity.body);
        }
        return;
      }
      const esData = fragmentEntity.range[elementaryStream];
      if (!esData) {
        return;
      }
      esData.time.some((time) => {
        const isNotBuffered = !this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);
        if (isNotBuffered) {
          this.removeFragment(fragmentEntity.body);
        }
        return isNotBuffered;
      });
    });
  }
  detectPartialFragments(data) {
    const timeRanges = this.timeRanges;
    const {
      frag,
      part
    } = data;
    if (!timeRanges || frag.sn === "initSegment") {
      return;
    }
    const fragKey = getFragmentKey(frag);
    const fragmentEntity = this.fragments[fragKey];
    if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {
      return;
    }
    const isFragHint = !frag.relurl;
    Object.keys(timeRanges).forEach((elementaryStream) => {
      const streamInfo = frag.elementaryStreams[elementaryStream];
      if (!streamInfo) {
        return;
      }
      const timeRange = timeRanges[elementaryStream];
      const partial = isFragHint || streamInfo.partial === true;
      fragmentEntity.range[elementaryStream] = this.getBufferedTimes(frag, part, partial, timeRange);
    });
    fragmentEntity.loaded = null;
    if (Object.keys(fragmentEntity.range).length) {
      fragmentEntity.buffered = true;
      const endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;
      if (endList) {
        this.endListFragments[fragmentEntity.body.type] = fragmentEntity;
      }
      if (!isPartial(fragmentEntity)) {
        this.removeParts(frag.sn - 1, frag.type);
      }
    } else {
      this.removeFragment(fragmentEntity.body);
    }
  }
  removeParts(snToKeep, levelType) {
    const activeParts = this.activePartLists[levelType];
    if (!activeParts) {
      return;
    }
    this.activePartLists[levelType] = activeParts.filter((part) => part.fragment.sn >= snToKeep);
  }
  fragBuffered(frag, force) {
    const fragKey = getFragmentKey(frag);
    let fragmentEntity = this.fragments[fragKey];
    if (!fragmentEntity && force) {
      fragmentEntity = this.fragments[fragKey] = {
        body: frag,
        appendedPTS: null,
        loaded: null,
        buffered: false,
        range: Object.create(null)
      };
      if (frag.gap) {
        this.hasGaps = true;
      }
    }
    if (fragmentEntity) {
      fragmentEntity.loaded = null;
      fragmentEntity.buffered = true;
    }
  }
  getBufferedTimes(fragment, part, partial, timeRange) {
    const buffered = {
      time: [],
      partial
    };
    const startPTS = fragment.start;
    const endPTS = fragment.end;
    const minEndPTS = fragment.minEndPTS || endPTS;
    const maxStartPTS = fragment.maxStartPTS || startPTS;
    for (let i = 0;i < timeRange.length; i++) {
      const startTime = timeRange.start(i) - this.bufferPadding;
      const endTime = timeRange.end(i) + this.bufferPadding;
      if (maxStartPTS >= startTime && minEndPTS <= endTime) {
        buffered.time.push({
          startPTS: Math.max(startPTS, timeRange.start(i)),
          endPTS: Math.min(endPTS, timeRange.end(i))
        });
        break;
      } else if (startPTS < endTime && endPTS > startTime) {
        const start = Math.max(startPTS, timeRange.start(i));
        const end = Math.min(endPTS, timeRange.end(i));
        if (end > start) {
          buffered.partial = true;
          buffered.time.push({
            startPTS: start,
            endPTS: end
          });
        }
      } else if (endPTS <= startTime) {
        break;
      }
    }
    return buffered;
  }
  getPartialFragment(time) {
    let bestFragment = null;
    let timePadding;
    let startTime;
    let endTime;
    let bestOverlap = 0;
    const {
      bufferPadding,
      fragments
    } = this;
    Object.keys(fragments).forEach((key) => {
      const fragmentEntity = fragments[key];
      if (!fragmentEntity) {
        return;
      }
      if (isPartial(fragmentEntity)) {
        startTime = fragmentEntity.body.start - bufferPadding;
        endTime = fragmentEntity.body.end + bufferPadding;
        if (time >= startTime && time <= endTime) {
          timePadding = Math.min(time - startTime, endTime - time);
          if (bestOverlap <= timePadding) {
            bestFragment = fragmentEntity.body;
            bestOverlap = timePadding;
          }
        }
      }
    });
    return bestFragment;
  }
  isEndListAppended(type) {
    const lastFragmentEntity = this.endListFragments[type];
    return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));
  }
  getState(fragment) {
    const fragKey = getFragmentKey(fragment);
    const fragmentEntity = this.fragments[fragKey];
    if (fragmentEntity) {
      if (!fragmentEntity.buffered) {
        return FragmentState.APPENDING;
      } else if (isPartial(fragmentEntity)) {
        return FragmentState.PARTIAL;
      } else {
        return FragmentState.OK;
      }
    }
    return FragmentState.NOT_LOADED;
  }
  isTimeBuffered(startPTS, endPTS, timeRange) {
    let startTime;
    let endTime;
    for (let i = 0;i < timeRange.length; i++) {
      startTime = timeRange.start(i) - this.bufferPadding;
      endTime = timeRange.end(i) + this.bufferPadding;
      if (startPTS >= startTime && endPTS <= endTime) {
        return true;
      }
      if (endPTS <= startTime) {
        return false;
      }
    }
    return false;
  }
  onFragLoaded(event, data) {
    const {
      frag,
      part
    } = data;
    if (frag.sn === "initSegment" || frag.bitrateTest) {
      return;
    }
    const loaded = part ? null : data;
    const fragKey = getFragmentKey(frag);
    this.fragments[fragKey] = {
      body: frag,
      appendedPTS: null,
      loaded,
      buffered: false,
      range: Object.create(null)
    };
  }
  onBufferAppended(event, data) {
    const {
      frag,
      part,
      timeRanges
    } = data;
    if (frag.sn === "initSegment") {
      return;
    }
    const playlistType = frag.type;
    if (part) {
      let activeParts = this.activePartLists[playlistType];
      if (!activeParts) {
        this.activePartLists[playlistType] = activeParts = [];
      }
      activeParts.push(part);
    }
    this.timeRanges = timeRanges;
    Object.keys(timeRanges).forEach((elementaryStream) => {
      const timeRange = timeRanges[elementaryStream];
      this.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);
    });
  }
  onFragBuffered(event, data) {
    this.detectPartialFragments(data);
  }
  hasFragment(fragment) {
    const fragKey = getFragmentKey(fragment);
    return !!this.fragments[fragKey];
  }
  hasParts(type) {
    var _this$activePartLists;
    return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);
  }
  removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {
    if (withGapOnly && !this.hasGaps) {
      return;
    }
    Object.keys(this.fragments).forEach((key) => {
      const fragmentEntity = this.fragments[key];
      if (!fragmentEntity) {
        return;
      }
      const frag = fragmentEntity.body;
      if (frag.type !== playlistType || withGapOnly && !frag.gap) {
        return;
      }
      if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {
        this.removeFragment(frag);
      }
    });
  }
  removeFragment(fragment) {
    const fragKey = getFragmentKey(fragment);
    fragment.stats.loaded = 0;
    fragment.clearElementaryStreamInfo();
    const activeParts = this.activePartLists[fragment.type];
    if (activeParts) {
      const snToRemove = fragment.sn;
      this.activePartLists[fragment.type] = activeParts.filter((part) => part.fragment.sn !== snToRemove);
    }
    delete this.fragments[fragKey];
    if (fragment.endList) {
      delete this.endListFragments[fragment.type];
    }
  }
  removeAllFragments() {
    this.fragments = Object.create(null);
    this.endListFragments = Object.create(null);
    this.activePartLists = Object.create(null);
    this.hasGaps = false;
  }
}
function isPartial(fragmentEntity) {
  var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;
  return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? undefined : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? undefined : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? undefined : _fragmentEntity$range3.partial));
}
function getFragmentKey(fragment) {
  return `${fragment.type}_${fragment.level}_${fragment.sn}`;
}
var noopBuffered = {
  length: 0,
  start: () => 0,
  end: () => 0
};

class BufferHelper {
  static isBuffered(media, position) {
    try {
      if (media) {
        const buffered = BufferHelper.getBuffered(media);
        for (let i = 0;i < buffered.length; i++) {
          if (position >= buffered.start(i) && position <= buffered.end(i)) {
            return true;
          }
        }
      }
    } catch (error) {
    }
    return false;
  }
  static bufferInfo(media, pos, maxHoleDuration) {
    try {
      if (media) {
        const vbuffered = BufferHelper.getBuffered(media);
        const buffered = [];
        let i;
        for (i = 0;i < vbuffered.length; i++) {
          buffered.push({
            start: vbuffered.start(i),
            end: vbuffered.end(i)
          });
        }
        return this.bufferedInfo(buffered, pos, maxHoleDuration);
      }
    } catch (error) {
    }
    return {
      len: 0,
      start: pos,
      end: pos,
      nextStart: undefined
    };
  }
  static bufferedInfo(buffered, pos, maxHoleDuration) {
    pos = Math.max(0, pos);
    buffered.sort(function(a, b) {
      const diff = a.start - b.start;
      if (diff) {
        return diff;
      } else {
        return b.end - a.end;
      }
    });
    let buffered2 = [];
    if (maxHoleDuration) {
      for (let i = 0;i < buffered.length; i++) {
        const buf2len = buffered2.length;
        if (buf2len) {
          const buf2end = buffered2[buf2len - 1].end;
          if (buffered[i].start - buf2end < maxHoleDuration) {
            if (buffered[i].end > buf2end) {
              buffered2[buf2len - 1].end = buffered[i].end;
            }
          } else {
            buffered2.push(buffered[i]);
          }
        } else {
          buffered2.push(buffered[i]);
        }
      }
    } else {
      buffered2 = buffered;
    }
    let bufferLen = 0;
    let bufferStartNext;
    let bufferStart = pos;
    let bufferEnd = pos;
    for (let i = 0;i < buffered2.length; i++) {
      const start = buffered2[i].start;
      const end = buffered2[i].end;
      if (pos + maxHoleDuration >= start && pos < end) {
        bufferStart = start;
        bufferEnd = end;
        bufferLen = bufferEnd - pos;
      } else if (pos + maxHoleDuration < start) {
        bufferStartNext = start;
        break;
      }
    }
    return {
      len: bufferLen,
      start: bufferStart || 0,
      end: bufferEnd || 0,
      nextStart: bufferStartNext
    };
  }
  static getBuffered(media) {
    try {
      return media.buffered;
    } catch (e) {
      logger.log("failed to get media.buffered", e);
      return noopBuffered;
    }
  }
}

class ChunkMetadata {
  constructor(level, sn, id, size = 0, part = -1, partial = false) {
    this.level = undefined;
    this.sn = undefined;
    this.part = undefined;
    this.id = undefined;
    this.size = undefined;
    this.partial = undefined;
    this.transmuxing = getNewPerformanceTiming();
    this.buffering = {
      audio: getNewPerformanceTiming(),
      video: getNewPerformanceTiming(),
      audiovideo: getNewPerformanceTiming()
    };
    this.level = level;
    this.sn = sn;
    this.id = id;
    this.size = size;
    this.part = part;
    this.partial = partial;
  }
}
function getNewPerformanceTiming() {
  return {
    start: 0,
    executeStart: 0,
    executeEnd: 0,
    end: 0
  };
}
function findFirstFragWithCC(fragments, cc2) {
  for (let i = 0, len = fragments.length;i < len; i++) {
    var _fragments$i;
    if (((_fragments$i = fragments[i]) == null ? undefined : _fragments$i.cc) === cc2) {
      return fragments[i];
    }
  }
  return null;
}
function shouldAlignOnDiscontinuities(lastFrag, switchDetails, details) {
  if (switchDetails) {
    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
      return true;
    }
  }
  return false;
}
function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
  const prevFrags = prevDetails.fragments;
  const curFrags = curDetails.fragments;
  if (!curFrags.length || !prevFrags.length) {
    logger.log("No fragments to align");
    return;
  }
  const prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);
  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
    logger.log("No frag in previous level to align on");
    return;
  }
  return prevStartFrag;
}
function adjustFragmentStart(frag, sliding) {
  if (frag) {
    const start = frag.start + sliding;
    frag.start = frag.startPTS = start;
    frag.endPTS = start + frag.duration;
  }
}
function adjustSlidingStart(sliding, details) {
  const fragments = details.fragments;
  for (let i = 0, len = fragments.length;i < len; i++) {
    adjustFragmentStart(fragments[i], sliding);
  }
  if (details.fragmentHint) {
    adjustFragmentStart(details.fragmentHint, sliding);
  }
  details.alignedSliding = true;
}
function alignStream(lastFrag, switchDetails, details) {
  if (!switchDetails) {
    return;
  }
  alignDiscontinuities(lastFrag, details, switchDetails);
  if (!details.alignedSliding && switchDetails) {
    alignMediaPlaylistByPDT(details, switchDetails);
  }
  if (!details.alignedSliding && switchDetails && !details.skippedSegments) {
    adjustSliding(switchDetails, details);
  }
}
function alignDiscontinuities(lastFrag, details, switchDetails) {
  if (shouldAlignOnDiscontinuities(lastFrag, switchDetails, details)) {
    const referenceFrag = findDiscontinuousReferenceFrag(switchDetails, details);
    if (referenceFrag && isFiniteNumber(referenceFrag.start)) {
      logger.log(`Adjusting PTS using last level due to CC increase within current level ${details.url}`);
      adjustSlidingStart(referenceFrag.start, details);
    }
  }
}
function alignMediaPlaylistByPDT(details, refDetails) {
  if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {
    return;
  }
  const fragments = details.fragments;
  const refFragments = refDetails.fragments;
  if (!fragments.length || !refFragments.length) {
    return;
  }
  let refFrag;
  let frag;
  const targetCC = Math.min(refDetails.endCC, details.endCC);
  if (refDetails.startCC < targetCC && details.startCC < targetCC) {
    refFrag = findFirstFragWithCC(refFragments, targetCC);
    frag = findFirstFragWithCC(fragments, targetCC);
  }
  if (!refFrag || !frag) {
    refFrag = refFragments[Math.floor(refFragments.length / 2)];
    frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];
  }
  const refPDT = refFrag.programDateTime;
  const targetPDT = frag.programDateTime;
  if (!refPDT || !targetPDT) {
    return;
  }
  const delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);
  adjustSlidingStart(delta, details);
}
var MIN_CHUNK_SIZE = Math.pow(2, 17);

class FragmentLoader {
  constructor(config) {
    this.config = undefined;
    this.loader = null;
    this.partLoadTimeout = -1;
    this.config = config;
  }
  destroy() {
    if (this.loader) {
      this.loader.destroy();
      this.loader = null;
    }
  }
  abort() {
    if (this.loader) {
      this.loader.abort();
    }
  }
  load(frag, onProgress) {
    const url = frag.url;
    if (!url) {
      return Promise.reject(new LoadError({
        type: ErrorTypes.NETWORK_ERROR,
        details: ErrorDetails.FRAG_LOAD_ERROR,
        fatal: false,
        frag,
        error: new Error(`Fragment does not have a ${url ? "part list" : "url"}`),
        networkDetails: null
      }));
    }
    this.abort();
    const config = this.config;
    const FragmentILoader = config.fLoader;
    const DefaultILoader = config.loader;
    return new Promise((resolve, reject) => {
      if (this.loader) {
        this.loader.destroy();
      }
      if (frag.gap) {
        if (frag.tagList.some((tags) => tags[0] === "GAP")) {
          reject(createGapLoadError(frag));
          return;
        } else {
          frag.gap = false;
        }
      }
      const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
      const loaderContext = createLoaderContext(frag);
      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: frag.sn === "initSegment" ? Infinity : MIN_CHUNK_SIZE
      };
      frag.stats = loader.stats;
      loader.load(loaderContext, loaderConfig, {
        onSuccess: (response, stats, context, networkDetails) => {
          this.resetLoader(frag, loader);
          let payload = response.data;
          if (context.resetIV && frag.decryptdata) {
            frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));
            payload = payload.slice(16);
          }
          resolve({
            frag,
            part: null,
            payload,
            networkDetails
          });
        },
        onError: (response, context, networkDetails, stats) => {
          this.resetLoader(frag, loader);
          reject(new LoadError({
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.FRAG_LOAD_ERROR,
            fatal: false,
            frag,
            response: _objectSpread2({
              url,
              data: undefined
            }, response),
            error: new Error(`HTTP Error ${response.code} ${response.text}`),
            networkDetails,
            stats
          }));
        },
        onAbort: (stats, context, networkDetails) => {
          this.resetLoader(frag, loader);
          reject(new LoadError({
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.INTERNAL_ABORTED,
            fatal: false,
            frag,
            error: new Error("Aborted"),
            networkDetails,
            stats
          }));
        },
        onTimeout: (stats, context, networkDetails) => {
          this.resetLoader(frag, loader);
          reject(new LoadError({
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.FRAG_LOAD_TIMEOUT,
            fatal: false,
            frag,
            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),
            networkDetails,
            stats
          }));
        },
        onProgress: (stats, context, data, networkDetails) => {
          if (onProgress) {
            onProgress({
              frag,
              part: null,
              payload: data,
              networkDetails
            });
          }
        }
      });
    });
  }
  loadPart(frag, part, onProgress) {
    this.abort();
    const config = this.config;
    const FragmentILoader = config.fLoader;
    const DefaultILoader = config.loader;
    return new Promise((resolve, reject) => {
      if (this.loader) {
        this.loader.destroy();
      }
      if (frag.gap || part.gap) {
        reject(createGapLoadError(frag, part));
        return;
      }
      const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
      const loaderContext = createLoaderContext(frag, part);
      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0,
        highWaterMark: MIN_CHUNK_SIZE
      };
      part.stats = loader.stats;
      loader.load(loaderContext, loaderConfig, {
        onSuccess: (response, stats, context, networkDetails) => {
          this.resetLoader(frag, loader);
          this.updateStatsFromPart(frag, part);
          const partLoadedData = {
            frag,
            part,
            payload: response.data,
            networkDetails
          };
          onProgress(partLoadedData);
          resolve(partLoadedData);
        },
        onError: (response, context, networkDetails, stats) => {
          this.resetLoader(frag, loader);
          reject(new LoadError({
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.FRAG_LOAD_ERROR,
            fatal: false,
            frag,
            part,
            response: _objectSpread2({
              url: loaderContext.url,
              data: undefined
            }, response),
            error: new Error(`HTTP Error ${response.code} ${response.text}`),
            networkDetails,
            stats
          }));
        },
        onAbort: (stats, context, networkDetails) => {
          frag.stats.aborted = part.stats.aborted;
          this.resetLoader(frag, loader);
          reject(new LoadError({
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.INTERNAL_ABORTED,
            fatal: false,
            frag,
            part,
            error: new Error("Aborted"),
            networkDetails,
            stats
          }));
        },
        onTimeout: (stats, context, networkDetails) => {
          this.resetLoader(frag, loader);
          reject(new LoadError({
            type: ErrorTypes.NETWORK_ERROR,
            details: ErrorDetails.FRAG_LOAD_TIMEOUT,
            fatal: false,
            frag,
            part,
            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),
            networkDetails,
            stats
          }));
        }
      });
    });
  }
  updateStatsFromPart(frag, part) {
    const fragStats = frag.stats;
    const partStats = part.stats;
    const partTotal = partStats.total;
    fragStats.loaded += partStats.loaded;
    if (partTotal) {
      const estTotalParts = Math.round(frag.duration / part.duration);
      const estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);
      const estRemainingParts = estTotalParts - estLoadedParts;
      const estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);
      fragStats.total = fragStats.loaded + estRemainingBytes;
    } else {
      fragStats.total = Math.max(fragStats.loaded, fragStats.total);
    }
    const fragLoading = fragStats.loading;
    const partLoading = partStats.loading;
    if (fragLoading.start) {
      fragLoading.first += partLoading.first - partLoading.start;
    } else {
      fragLoading.start = partLoading.start;
      fragLoading.first = partLoading.first;
    }
    fragLoading.end = partLoading.end;
  }
  resetLoader(frag, loader) {
    frag.loader = null;
    if (this.loader === loader) {
      self.clearTimeout(this.partLoadTimeout);
      this.loader = null;
    }
    loader.destroy();
  }
}
function createLoaderContext(frag, part = null) {
  const segment = part || frag;
  const loaderContext = {
    frag,
    part,
    responseType: "arraybuffer",
    url: segment.url,
    headers: {},
    rangeStart: 0,
    rangeEnd: 0
  };
  const start = segment.byteRangeStartOffset;
  const end = segment.byteRangeEndOffset;
  if (isFiniteNumber(start) && isFiniteNumber(end)) {
    var _frag$decryptdata;
    let byteRangeStart = start;
    let byteRangeEnd = end;
    if (frag.sn === "initSegment" && ((_frag$decryptdata = frag.decryptdata) == null ? undefined : _frag$decryptdata.method) === "AES-128") {
      const fragmentLen = end - start;
      if (fragmentLen % 16) {
        byteRangeEnd = end + (16 - fragmentLen % 16);
      }
      if (start !== 0) {
        loaderContext.resetIV = true;
        byteRangeStart = start - 16;
      }
    }
    loaderContext.rangeStart = byteRangeStart;
    loaderContext.rangeEnd = byteRangeEnd;
  }
  return loaderContext;
}
function createGapLoadError(frag, part) {
  const error = new Error(`GAP ${frag.gap ? "tag" : "attribute"} found`);
  const errorData = {
    type: ErrorTypes.MEDIA_ERROR,
    details: ErrorDetails.FRAG_GAP,
    fatal: false,
    frag,
    error,
    networkDetails: null
  };
  if (part) {
    errorData.part = part;
  }
  (part ? part : frag).stats.aborted = true;
  return new LoadError(errorData);
}

class LoadError extends Error {
  constructor(data) {
    super(data.error.message);
    this.data = undefined;
    this.data = data;
  }
}

class AESCrypto {
  constructor(subtle, iv) {
    this.subtle = undefined;
    this.aesIV = undefined;
    this.subtle = subtle;
    this.aesIV = iv;
  }
  decrypt(data, key) {
    return this.subtle.decrypt({
      name: "AES-CBC",
      iv: this.aesIV
    }, key, data);
  }
}

class FastAESKey {
  constructor(subtle, key) {
    this.subtle = undefined;
    this.key = undefined;
    this.subtle = subtle;
    this.key = key;
  }
  expandKey() {
    return this.subtle.importKey("raw", this.key, {
      name: "AES-CBC"
    }, false, ["encrypt", "decrypt"]);
  }
}
function removePadding(array) {
  const outputBytes = array.byteLength;
  const paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);
  if (paddingBytes) {
    return sliceUint8(array, 0, outputBytes - paddingBytes);
  }
  return array;
}

class AESDecryptor {
  constructor() {
    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
    this.sBox = new Uint32Array(256);
    this.invSBox = new Uint32Array(256);
    this.key = new Uint32Array(0);
    this.ksRows = 0;
    this.keySize = 0;
    this.keySchedule = undefined;
    this.invKeySchedule = undefined;
    this.initTable();
  }
  uint8ArrayToUint32Array_(arrayBuffer) {
    const view = new DataView(arrayBuffer);
    const newArray = new Uint32Array(4);
    for (let i = 0;i < 4; i++) {
      newArray[i] = view.getUint32(i * 4);
    }
    return newArray;
  }
  initTable() {
    const sBox = this.sBox;
    const invSBox = this.invSBox;
    const subMix = this.subMix;
    const subMix0 = subMix[0];
    const subMix1 = subMix[1];
    const subMix2 = subMix[2];
    const subMix3 = subMix[3];
    const invSubMix = this.invSubMix;
    const invSubMix0 = invSubMix[0];
    const invSubMix1 = invSubMix[1];
    const invSubMix2 = invSubMix[2];
    const invSubMix3 = invSubMix[3];
    const d = new Uint32Array(256);
    let x = 0;
    let xi = 0;
    let i = 0;
    for (i = 0;i < 256; i++) {
      if (i < 128) {
        d[i] = i << 1;
      } else {
        d[i] = i << 1 ^ 283;
      }
    }
    for (i = 0;i < 256; i++) {
      let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
      sx = sx >>> 8 ^ sx & 255 ^ 99;
      sBox[x] = sx;
      invSBox[sx] = x;
      const x2 = d[x];
      const x4 = d[x2];
      const x8 = d[x4];
      let t = d[sx] * 257 ^ sx * 16843008;
      subMix0[x] = t << 24 | t >>> 8;
      subMix1[x] = t << 16 | t >>> 16;
      subMix2[x] = t << 8 | t >>> 24;
      subMix3[x] = t;
      t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      invSubMix0[sx] = t << 24 | t >>> 8;
      invSubMix1[sx] = t << 16 | t >>> 16;
      invSubMix2[sx] = t << 8 | t >>> 24;
      invSubMix3[sx] = t;
      if (!x) {
        x = xi = 1;
      } else {
        x = x2 ^ d[d[d[x8 ^ x2]]];
        xi ^= d[d[xi]];
      }
    }
  }
  expandKey(keyBuffer) {
    const key = this.uint8ArrayToUint32Array_(keyBuffer);
    let sameKey = true;
    let offset = 0;
    while (offset < key.length && sameKey) {
      sameKey = key[offset] === this.key[offset];
      offset++;
    }
    if (sameKey) {
      return;
    }
    this.key = key;
    const keySize = this.keySize = key.length;
    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
      throw new Error("Invalid aes key size=" + keySize);
    }
    const ksRows = this.ksRows = (keySize + 6 + 1) * 4;
    let ksRow;
    let invKsRow;
    const keySchedule = this.keySchedule = new Uint32Array(ksRows);
    const invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
    const sbox = this.sBox;
    const rcon = this.rcon;
    const invSubMix = this.invSubMix;
    const invSubMix0 = invSubMix[0];
    const invSubMix1 = invSubMix[1];
    const invSubMix2 = invSubMix[2];
    const invSubMix3 = invSubMix[3];
    let prev;
    let t;
    for (ksRow = 0;ksRow < ksRows; ksRow++) {
      if (ksRow < keySize) {
        prev = keySchedule[ksRow] = key[ksRow];
        continue;
      }
      t = prev;
      if (ksRow % keySize === 0) {
        t = t << 8 | t >>> 24;
        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
        t ^= rcon[ksRow / keySize | 0] << 24;
      } else if (keySize > 6 && ksRow % keySize === 4) {
        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
      }
      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
    }
    for (invKsRow = 0;invKsRow < ksRows; invKsRow++) {
      ksRow = ksRows - invKsRow;
      if (invKsRow & 3) {
        t = keySchedule[ksRow];
      } else {
        t = keySchedule[ksRow - 4];
      }
      if (invKsRow < 4 || ksRow <= 4) {
        invKeySchedule[invKsRow] = t;
      } else {
        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 255]] ^ invSubMix2[sbox[t >>> 8 & 255]] ^ invSubMix3[sbox[t & 255]];
      }
      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
    }
  }
  networkToHostOrderSwap(word) {
    return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
  }
  decrypt(inputArrayBuffer, offset, aesIV) {
    const nRounds = this.keySize + 6;
    const invKeySchedule = this.invKeySchedule;
    const invSBOX = this.invSBox;
    const invSubMix = this.invSubMix;
    const invSubMix0 = invSubMix[0];
    const invSubMix1 = invSubMix[1];
    const invSubMix2 = invSubMix[2];
    const invSubMix3 = invSubMix[3];
    const initVector = this.uint8ArrayToUint32Array_(aesIV);
    let initVector0 = initVector[0];
    let initVector1 = initVector[1];
    let initVector2 = initVector[2];
    let initVector3 = initVector[3];
    const inputInt32 = new Int32Array(inputArrayBuffer);
    const outputInt32 = new Int32Array(inputInt32.length);
    let t0, t1, t2, t3;
    let s0, s1, s2, s3;
    let inputWords0, inputWords1, inputWords2, inputWords3;
    let ksRow, i;
    const swapWord = this.networkToHostOrderSwap;
    while (offset < inputInt32.length) {
      inputWords0 = swapWord(inputInt32[offset]);
      inputWords1 = swapWord(inputInt32[offset + 1]);
      inputWords2 = swapWord(inputInt32[offset + 2]);
      inputWords3 = swapWord(inputInt32[offset + 3]);
      s0 = inputWords0 ^ invKeySchedule[0];
      s1 = inputWords3 ^ invKeySchedule[1];
      s2 = inputWords2 ^ invKeySchedule[2];
      s3 = inputWords1 ^ invKeySchedule[3];
      ksRow = 4;
      for (i = 1;i < nRounds; i++) {
        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 255] ^ invSubMix2[s2 >> 8 & 255] ^ invSubMix3[s3 & 255] ^ invKeySchedule[ksRow];
        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 255] ^ invSubMix2[s3 >> 8 & 255] ^ invSubMix3[s0 & 255] ^ invKeySchedule[ksRow + 1];
        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 255] ^ invSubMix2[s0 >> 8 & 255] ^ invSubMix3[s1 & 255] ^ invKeySchedule[ksRow + 2];
        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 255] ^ invSubMix2[s1 >> 8 & 255] ^ invSubMix3[s2 & 255] ^ invKeySchedule[ksRow + 3];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
        ksRow = ksRow + 4;
      }
      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 255] << 16 ^ invSBOX[s2 >> 8 & 255] << 8 ^ invSBOX[s3 & 255] ^ invKeySchedule[ksRow];
      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 255] << 16 ^ invSBOX[s3 >> 8 & 255] << 8 ^ invSBOX[s0 & 255] ^ invKeySchedule[ksRow + 1];
      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 255] << 16 ^ invSBOX[s0 >> 8 & 255] << 8 ^ invSBOX[s1 & 255] ^ invKeySchedule[ksRow + 2];
      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 255] << 16 ^ invSBOX[s1 >> 8 & 255] << 8 ^ invSBOX[s2 & 255] ^ invKeySchedule[ksRow + 3];
      outputInt32[offset] = swapWord(t0 ^ initVector0);
      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);
      initVector0 = inputWords0;
      initVector1 = inputWords1;
      initVector2 = inputWords2;
      initVector3 = inputWords3;
      offset = offset + 4;
    }
    return outputInt32.buffer;
  }
}
var CHUNK_SIZE = 16;

class Decrypter {
  constructor(config, {
    removePKCS7Padding = true
  } = {}) {
    this.logEnabled = true;
    this.removePKCS7Padding = undefined;
    this.subtle = null;
    this.softwareDecrypter = null;
    this.key = null;
    this.fastAesKey = null;
    this.remainderData = null;
    this.currentIV = null;
    this.currentResult = null;
    this.useSoftware = undefined;
    this.useSoftware = config.enableSoftwareAES;
    this.removePKCS7Padding = removePKCS7Padding;
    if (removePKCS7Padding) {
      try {
        const browserCrypto = self.crypto;
        if (browserCrypto) {
          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
        }
      } catch (e) {
      }
    }
    this.useSoftware = !this.subtle;
  }
  destroy() {
    this.subtle = null;
    this.softwareDecrypter = null;
    this.key = null;
    this.fastAesKey = null;
    this.remainderData = null;
    this.currentIV = null;
    this.currentResult = null;
  }
  isSync() {
    return this.useSoftware;
  }
  flush() {
    const {
      currentResult,
      remainderData
    } = this;
    if (!currentResult || remainderData) {
      this.reset();
      return null;
    }
    const data = new Uint8Array(currentResult);
    this.reset();
    if (this.removePKCS7Padding) {
      return removePadding(data);
    }
    return data;
  }
  reset() {
    this.currentResult = null;
    this.currentIV = null;
    this.remainderData = null;
    if (this.softwareDecrypter) {
      this.softwareDecrypter = null;
    }
  }
  decrypt(data, key, iv) {
    if (this.useSoftware) {
      return new Promise((resolve, reject) => {
        this.softwareDecrypt(new Uint8Array(data), key, iv);
        const decryptResult = this.flush();
        if (decryptResult) {
          resolve(decryptResult.buffer);
        } else {
          reject(new Error("[softwareDecrypt] Failed to decrypt data"));
        }
      });
    }
    return this.webCryptoDecrypt(new Uint8Array(data), key, iv);
  }
  softwareDecrypt(data, key, iv) {
    const {
      currentIV,
      currentResult,
      remainderData
    } = this;
    this.logOnce("JS AES decrypt");
    if (remainderData) {
      data = appendUint8Array(remainderData, data);
      this.remainderData = null;
    }
    const currentChunk = this.getValidChunk(data);
    if (!currentChunk.length) {
      return null;
    }
    if (currentIV) {
      iv = currentIV;
    }
    let softwareDecrypter = this.softwareDecrypter;
    if (!softwareDecrypter) {
      softwareDecrypter = this.softwareDecrypter = new AESDecryptor;
    }
    softwareDecrypter.expandKey(key);
    const result = currentResult;
    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);
    this.currentIV = sliceUint8(currentChunk, -16).buffer;
    if (!result) {
      return null;
    }
    return result;
  }
  webCryptoDecrypt(data, key, iv) {
    if (this.key !== key || !this.fastAesKey) {
      if (!this.subtle) {
        return Promise.resolve(this.onWebCryptoError(data, key, iv));
      }
      this.key = key;
      this.fastAesKey = new FastAESKey(this.subtle, key);
    }
    return this.fastAesKey.expandKey().then((aesKey) => {
      if (!this.subtle) {
        return Promise.reject(new Error("web crypto not initialized"));
      }
      this.logOnce("WebCrypto AES decrypt");
      const crypto2 = new AESCrypto(this.subtle, new Uint8Array(iv));
      return crypto2.decrypt(data.buffer, aesKey);
    }).catch((err) => {
      logger.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`);
      return this.onWebCryptoError(data, key, iv);
    });
  }
  onWebCryptoError(data, key, iv) {
    this.useSoftware = true;
    this.logEnabled = true;
    this.softwareDecrypt(data, key, iv);
    const decryptResult = this.flush();
    if (decryptResult) {
      return decryptResult.buffer;
    }
    throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data");
  }
  getValidChunk(data) {
    let currentChunk = data;
    const splitPoint = data.length - data.length % CHUNK_SIZE;
    if (splitPoint !== data.length) {
      currentChunk = sliceUint8(data, 0, splitPoint);
      this.remainderData = sliceUint8(data, splitPoint);
    }
    return currentChunk;
  }
  logOnce(msg) {
    if (!this.logEnabled) {
      return;
    }
    logger.log(`[decrypter]: ${msg}`);
    this.logEnabled = false;
  }
}
var TimeRanges = {
  toString: function(r) {
    let log = "";
    const len = r.length;
    for (let i = 0;i < len; i++) {
      log += `[${r.start(i).toFixed(3)}-${r.end(i).toFixed(3)}]`;
    }
    return log;
  }
};
var State = {
  STOPPED: "STOPPED",
  IDLE: "IDLE",
  KEY_LOADING: "KEY_LOADING",
  FRAG_LOADING: "FRAG_LOADING",
  FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
  WAITING_TRACK: "WAITING_TRACK",
  PARSING: "PARSING",
  PARSED: "PARSED",
  ENDED: "ENDED",
  ERROR: "ERROR",
  WAITING_INIT_PTS: "WAITING_INIT_PTS",
  WAITING_LEVEL: "WAITING_LEVEL"
};

class BaseStreamController extends TaskLoop {
  constructor(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {
    super();
    this.hls = undefined;
    this.fragPrevious = null;
    this.fragCurrent = null;
    this.fragmentTracker = undefined;
    this.transmuxer = null;
    this._state = State.STOPPED;
    this.playlistType = undefined;
    this.media = null;
    this.mediaBuffer = null;
    this.config = undefined;
    this.bitrateTest = false;
    this.lastCurrentTime = 0;
    this.nextLoadPosition = 0;
    this.startPosition = 0;
    this.startTimeOffset = null;
    this.loadedmetadata = false;
    this.retryDate = 0;
    this.levels = null;
    this.fragmentLoader = undefined;
    this.keyLoader = undefined;
    this.levelLastLoaded = null;
    this.startFragRequested = false;
    this.decrypter = undefined;
    this.initPTS = [];
    this.onvseeking = null;
    this.onvended = null;
    this.logPrefix = "";
    this.log = undefined;
    this.warn = undefined;
    this.playlistType = playlistType;
    this.logPrefix = logPrefix;
    this.log = logger.log.bind(logger, `${logPrefix}:`);
    this.warn = logger.warn.bind(logger, `${logPrefix}:`);
    this.hls = hls;
    this.fragmentLoader = new FragmentLoader(hls.config);
    this.keyLoader = keyLoader;
    this.fragmentTracker = fragmentTracker;
    this.config = hls.config;
    this.decrypter = new Decrypter(hls.config);
    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
  }
  doTick() {
    this.onTickEnd();
  }
  onTickEnd() {
  }
  startLoad(startPosition) {
  }
  stopLoad() {
    this.fragmentLoader.abort();
    this.keyLoader.abort(this.playlistType);
    const frag = this.fragCurrent;
    if (frag != null && frag.loader) {
      frag.abortRequests();
      this.fragmentTracker.removeFragment(frag);
    }
    this.resetTransmuxer();
    this.fragCurrent = null;
    this.fragPrevious = null;
    this.clearInterval();
    this.clearNextTick();
    this.state = State.STOPPED;
  }
  _streamEnded(bufferInfo, levelDetails) {
    if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {
      return false;
    }
    const partList = levelDetails.partList;
    if (partList != null && partList.length) {
      const lastPart = partList[partList.length - 1];
      const lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);
      return lastPartBuffered;
    }
    const playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;
    return this.fragmentTracker.isEndListAppended(playlistType);
  }
  getLevelDetails() {
    if (this.levels && this.levelLastLoaded !== null) {
      var _this$levelLastLoaded;
      return (_this$levelLastLoaded = this.levelLastLoaded) == null ? undefined : _this$levelLastLoaded.details;
    }
  }
  onMediaAttached(event, data) {
    const media = this.media = this.mediaBuffer = data.media;
    this.onvseeking = this.onMediaSeeking.bind(this);
    this.onvended = this.onMediaEnded.bind(this);
    media.addEventListener("seeking", this.onvseeking);
    media.addEventListener("ended", this.onvended);
    const config = this.config;
    if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {
      this.startLoad(config.startPosition);
    }
  }
  onMediaDetaching() {
    const media = this.media;
    if (media != null && media.ended) {
      this.log("MSE detaching and video ended, reset startPosition");
      this.startPosition = this.lastCurrentTime = 0;
    }
    if (media && this.onvseeking && this.onvended) {
      media.removeEventListener("seeking", this.onvseeking);
      media.removeEventListener("ended", this.onvended);
      this.onvseeking = this.onvended = null;
    }
    if (this.keyLoader) {
      this.keyLoader.detach();
    }
    this.media = this.mediaBuffer = null;
    this.loadedmetadata = false;
    this.fragmentTracker.removeAllFragments();
    this.stopLoad();
  }
  onMediaSeeking() {
    const {
      config,
      fragCurrent,
      media,
      mediaBuffer,
      state
    } = this;
    const currentTime = media ? media.currentTime : 0;
    const bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);
    this.log(`media seeking to ${isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime}, state: ${state}`);
    if (this.state === State.ENDED) {
      this.resetLoadingState();
    } else if (fragCurrent) {
      const tolerance = config.maxFragLookUpTolerance;
      const fragStartOffset = fragCurrent.start - tolerance;
      const fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
      if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {
        const pastFragment = currentTime > fragEndOffset;
        if (currentTime < fragStartOffset || pastFragment) {
          if (pastFragment && fragCurrent.loader) {
            this.log("seeking outside of buffer while fragment load in progress, cancel fragment load");
            fragCurrent.abortRequests();
            this.resetLoadingState();
          }
          this.fragPrevious = null;
        }
      }
    }
    if (media) {
      this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);
      this.lastCurrentTime = currentTime;
    }
    if (!this.loadedmetadata && !bufferInfo.len) {
      this.nextLoadPosition = this.startPosition = currentTime;
    }
    this.tickImmediate();
  }
  onMediaEnded() {
    this.startPosition = this.lastCurrentTime = 0;
  }
  onManifestLoaded(event, data) {
    this.startTimeOffset = data.startTimeOffset;
    this.initPTS = [];
  }
  onHandlerDestroying() {
    this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    this.stopLoad();
    super.onHandlerDestroying();
    this.hls = null;
  }
  onHandlerDestroyed() {
    this.state = State.STOPPED;
    if (this.fragmentLoader) {
      this.fragmentLoader.destroy();
    }
    if (this.keyLoader) {
      this.keyLoader.destroy();
    }
    if (this.decrypter) {
      this.decrypter.destroy();
    }
    this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;
    super.onHandlerDestroyed();
  }
  loadFragment(frag, level, targetBufferTime) {
    this._loadFragForPlayback(frag, level, targetBufferTime);
  }
  _loadFragForPlayback(frag, level, targetBufferTime) {
    const progressCallback = (data) => {
      if (this.fragContextChanged(frag)) {
        this.warn(`Fragment ${frag.sn}${data.part ? " p: " + data.part.index : ""} of level ${frag.level} was dropped during download.`);
        this.fragmentTracker.removeFragment(frag);
        return;
      }
      frag.stats.chunkCount++;
      this._handleFragmentLoadProgress(data);
    };
    this._doFragLoad(frag, level, targetBufferTime, progressCallback).then((data) => {
      if (!data) {
        return;
      }
      const state = this.state;
      if (this.fragContextChanged(frag)) {
        if (state === State.FRAG_LOADING || !this.fragCurrent && state === State.PARSING) {
          this.fragmentTracker.removeFragment(frag);
          this.state = State.IDLE;
        }
        return;
      }
      if ("payload" in data) {
        this.log(`Loaded fragment ${frag.sn} of level ${frag.level}`);
        this.hls.trigger(Events.FRAG_LOADED, data);
      }
      this._handleFragmentLoadComplete(data);
    }).catch((reason) => {
      if (this.state === State.STOPPED || this.state === State.ERROR) {
        return;
      }
      this.warn(`Frag error: ${(reason == null ? undefined : reason.message) || reason}`);
      this.resetFragmentLoading(frag);
    });
  }
  clearTrackerIfNeeded(frag) {
    var _this$mediaBuffer;
    const {
      fragmentTracker
    } = this;
    const fragState = fragmentTracker.getState(frag);
    if (fragState === FragmentState.APPENDING) {
      const playlistType = frag.type;
      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
      const minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);
      const backtrackFragment = this.backtrackFragment;
      const backtracked = backtrackFragment ? frag.sn - backtrackFragment.sn : 0;
      if (backtracked === 1 || this.reduceMaxBufferLength(minForwardBufferLength, frag.duration)) {
        fragmentTracker.removeFragment(frag);
      }
    } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? undefined : _this$mediaBuffer.buffered.length) === 0) {
      fragmentTracker.removeAllFragments();
    } else if (fragmentTracker.hasParts(frag.type)) {
      fragmentTracker.detectPartialFragments({
        frag,
        part: null,
        stats: frag.stats,
        id: frag.type
      });
      if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {
        fragmentTracker.removeFragment(frag);
      }
    }
  }
  checkLiveUpdate(details) {
    if (details.updated && !details.live) {
      const lastFragment = details.fragments[details.fragments.length - 1];
      this.fragmentTracker.detectPartialFragments({
        frag: lastFragment,
        part: null,
        stats: lastFragment.stats,
        id: lastFragment.type
      });
    }
    if (!details.fragments[0]) {
      details.deltaUpdateFailed = true;
    }
  }
  flushMainBuffer(startOffset, endOffset, type = null) {
    if (!(startOffset - endOffset)) {
      return;
    }
    const flushScope = {
      startOffset,
      endOffset,
      type
    };
    this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);
  }
  _loadInitSegment(frag, level) {
    this._doFragLoad(frag, level).then((data) => {
      if (!data || this.fragContextChanged(frag) || !this.levels) {
        throw new Error("init load aborted");
      }
      return data;
    }).then((data) => {
      const {
        hls
      } = this;
      const {
        payload
      } = data;
      const decryptData = frag.decryptdata;
      if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
        const startTime = self.performance.now();
        return this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch((err) => {
          hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.FRAG_DECRYPT_ERROR,
            fatal: false,
            error: err,
            reason: err.message,
            frag
          });
          throw err;
        }).then((decryptedData) => {
          const endTime = self.performance.now();
          hls.trigger(Events.FRAG_DECRYPTED, {
            frag,
            payload: decryptedData,
            stats: {
              tstart: startTime,
              tdecrypt: endTime
            }
          });
          data.payload = decryptedData;
          return this.completeInitSegmentLoad(data);
        });
      }
      return this.completeInitSegmentLoad(data);
    }).catch((reason) => {
      if (this.state === State.STOPPED || this.state === State.ERROR) {
        return;
      }
      this.warn(reason);
      this.resetFragmentLoading(frag);
    });
  }
  completeInitSegmentLoad(data) {
    const {
      levels
    } = this;
    if (!levels) {
      throw new Error("init load aborted, missing levels");
    }
    const stats = data.frag.stats;
    this.state = State.IDLE;
    data.frag.data = new Uint8Array(data.payload);
    stats.parsing.start = stats.buffering.start = self.performance.now();
    stats.parsing.end = stats.buffering.end = self.performance.now();
    this.tick();
  }
  fragContextChanged(frag) {
    const {
      fragCurrent
    } = this;
    return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;
  }
  fragBufferedComplete(frag, part) {
    var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;
    const media = this.mediaBuffer ? this.mediaBuffer : this.media;
    this.log(`Buffered ${frag.type} sn: ${frag.sn}${part ? " part: " + part.index : ""} of ${this.playlistType === PlaylistLevelType.MAIN ? "level" : "track"} ${frag.level} (frag:[${((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3)}-${((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3)}] > buffer:${media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : "(detached)"})`);
    if (frag.sn !== "initSegment") {
      var _this$levels;
      if (frag.type !== PlaylistLevelType.SUBTITLE) {
        const el = frag.elementaryStreams;
        if (!Object.keys(el).some((type) => !!el[type])) {
          this.state = State.IDLE;
          return;
        }
      }
      const level = (_this$levels = this.levels) == null ? undefined : _this$levels[frag.level];
      if (level != null && level.fragmentError) {
        this.log(`Resetting level fragment error count of ${level.fragmentError} on frag buffered`);
        level.fragmentError = 0;
      }
    }
    this.state = State.IDLE;
    if (!media) {
      return;
    }
    if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? undefined : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? undefined : _this$fragPrevious.sn)) {
      this.loadedmetadata = true;
      this.seekToStartPos();
    }
    this.tick();
  }
  seekToStartPos() {
  }
  _handleFragmentLoadComplete(fragLoadedEndData) {
    const {
      transmuxer
    } = this;
    if (!transmuxer) {
      return;
    }
    const {
      frag,
      part,
      partsLoaded
    } = fragLoadedEndData;
    const complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some((fragLoaded) => !fragLoaded);
    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);
    transmuxer.flush(chunkMeta);
  }
  _handleFragmentLoadProgress(frag) {
  }
  _doFragLoad(frag, level, targetBufferTime = null, progressCallback) {
    var _frag$decryptdata;
    const details = level == null ? undefined : level.details;
    if (!this.levels || !details) {
      throw new Error(`frag load aborted, missing level${details ? "" : " detail"}s`);
    }
    let keyLoadingPromise = null;
    if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {
      this.log(`Loading key for ${frag.sn} of [${details.startSN}-${details.endSN}], ${this.logPrefix === "[stream-controller]" ? "level" : "track"} ${frag.level}`);
      this.state = State.KEY_LOADING;
      this.fragCurrent = frag;
      keyLoadingPromise = this.keyLoader.load(frag).then((keyLoadedData) => {
        if (!this.fragContextChanged(keyLoadedData.frag)) {
          this.hls.trigger(Events.KEY_LOADED, keyLoadedData);
          if (this.state === State.KEY_LOADING) {
            this.state = State.IDLE;
          }
          return keyLoadedData;
        }
      });
      this.hls.trigger(Events.KEY_LOADING, {
        frag
      });
      if (this.fragCurrent === null) {
        keyLoadingPromise = Promise.reject(new Error(`frag load aborted, context changed in KEY_LOADING`));
      }
    } else if (!frag.encrypted && details.encryptedFragments.length) {
      this.keyLoader.loadClear(frag, details.encryptedFragments);
    }
    targetBufferTime = Math.max(frag.start, targetBufferTime || 0);
    if (this.config.lowLatencyMode && frag.sn !== "initSegment") {
      const partList = details.partList;
      if (partList && progressCallback) {
        if (targetBufferTime > frag.end && details.fragmentHint) {
          frag = details.fragmentHint;
        }
        const partIndex = this.getNextPart(partList, frag, targetBufferTime);
        if (partIndex > -1) {
          const part = partList[partIndex];
          this.log(`Loading part sn: ${frag.sn} p: ${part.index} cc: ${frag.cc} of playlist [${details.startSN}-${details.endSN}] parts [0-${partIndex}-${partList.length - 1}] ${this.logPrefix === "[stream-controller]" ? "level" : "track"}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);
          this.nextLoadPosition = part.start + part.duration;
          this.state = State.FRAG_LOADING;
          let _result;
          if (keyLoadingPromise) {
            _result = keyLoadingPromise.then((keyLoadedData) => {
              if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {
                return null;
              }
              return this.doFragPartsLoad(frag, part, level, progressCallback);
            }).catch((error) => this.handleFragLoadError(error));
          } else {
            _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch((error) => this.handleFragLoadError(error));
          }
          this.hls.trigger(Events.FRAG_LOADING, {
            frag,
            part,
            targetBufferTime
          });
          if (this.fragCurrent === null) {
            return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING parts`));
          }
          return _result;
        } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {
          return Promise.resolve(null);
        }
      }
    }
    this.log(`Loading fragment ${frag.sn} cc: ${frag.cc} ${details ? "of [" + details.startSN + "-" + details.endSN + "] " : ""}${this.logPrefix === "[stream-controller]" ? "level" : "track"}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);
    if (isFiniteNumber(frag.sn) && !this.bitrateTest) {
      this.nextLoadPosition = frag.start + frag.duration;
    }
    this.state = State.FRAG_LOADING;
    const dataOnProgress = this.config.progressive;
    let result;
    if (dataOnProgress && keyLoadingPromise) {
      result = keyLoadingPromise.then((keyLoadedData) => {
        if (!keyLoadedData || this.fragContextChanged(keyLoadedData == null ? undefined : keyLoadedData.frag)) {
          return null;
        }
        return this.fragmentLoader.load(frag, progressCallback);
      }).catch((error) => this.handleFragLoadError(error));
    } else {
      result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(([fragLoadedData]) => {
        if (!dataOnProgress && fragLoadedData && progressCallback) {
          progressCallback(fragLoadedData);
        }
        return fragLoadedData;
      }).catch((error) => this.handleFragLoadError(error));
    }
    this.hls.trigger(Events.FRAG_LOADING, {
      frag,
      targetBufferTime
    });
    if (this.fragCurrent === null) {
      return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING`));
    }
    return result;
  }
  doFragPartsLoad(frag, fromPart, level, progressCallback) {
    return new Promise((resolve, reject) => {
      var _level$details;
      const partsLoaded = [];
      const initialPartList = (_level$details = level.details) == null ? undefined : _level$details.partList;
      const loadPart = (part) => {
        this.fragmentLoader.loadPart(frag, part, progressCallback).then((partLoadedData) => {
          partsLoaded[part.index] = partLoadedData;
          const loadedPart = partLoadedData.part;
          this.hls.trigger(Events.FRAG_LOADED, partLoadedData);
          const nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);
          if (nextPart) {
            loadPart(nextPart);
          } else {
            return resolve({
              frag,
              part: loadedPart,
              partsLoaded
            });
          }
        }).catch(reject);
      };
      loadPart(fromPart);
    });
  }
  handleFragLoadError(error) {
    if ("data" in error) {
      const data = error.data;
      if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {
        this.handleFragLoadAborted(data.frag, data.part);
      } else {
        this.hls.trigger(Events.ERROR, data);
      }
    } else {
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.OTHER_ERROR,
        details: ErrorDetails.INTERNAL_EXCEPTION,
        err: error,
        error,
        fatal: true
      });
    }
    return null;
  }
  _handleTransmuxerFlush(chunkMeta) {
    const context = this.getCurrentContext(chunkMeta);
    if (!context || this.state !== State.PARSING) {
      if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {
        this.state = State.IDLE;
      }
      return;
    }
    const {
      frag,
      part,
      level
    } = context;
    const now = self.performance.now();
    frag.stats.parsing.end = now;
    if (part) {
      part.stats.parsing.end = now;
    }
    this.updateLevelTiming(frag, part, level, chunkMeta.partial);
  }
  getCurrentContext(chunkMeta) {
    const {
      levels,
      fragCurrent
    } = this;
    const {
      level: levelIndex,
      sn,
      part: partIndex
    } = chunkMeta;
    if (!(levels != null && levels[levelIndex])) {
      this.warn(`Levels object was unset while buffering fragment ${sn} of level ${levelIndex}. The current chunk will not be buffered.`);
      return null;
    }
    const level = levels[levelIndex];
    const part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;
    const frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);
    if (!frag) {
      return null;
    }
    if (fragCurrent && fragCurrent !== frag) {
      frag.stats = fragCurrent.stats;
    }
    return {
      frag,
      part,
      level
    };
  }
  bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {
    var _buffer;
    if (!data || this.state !== State.PARSING) {
      return;
    }
    const {
      data1,
      data2
    } = data;
    let buffer = data1;
    if (data1 && data2) {
      buffer = appendUint8Array(data1, data2);
    }
    if (!((_buffer = buffer) != null && _buffer.length)) {
      return;
    }
    const segment = {
      type: data.type,
      frag,
      part,
      chunkMeta,
      parent: frag.type,
      data: buffer
    };
    this.hls.trigger(Events.BUFFER_APPENDING, segment);
    if (data.dropped && data.independent && !part) {
      if (noBacktracking) {
        return;
      }
      this.flushBufferGap(frag);
    }
  }
  flushBufferGap(frag) {
    const media = this.media;
    if (!media) {
      return;
    }
    if (!BufferHelper.isBuffered(media, media.currentTime)) {
      this.flushMainBuffer(0, frag.start);
      return;
    }
    const currentTime = media.currentTime;
    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
    const fragDuration = frag.duration;
    const segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);
    const start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);
    if (frag.start - start > segmentFraction) {
      this.flushMainBuffer(start, frag.start);
    }
  }
  getFwdBufferInfo(bufferable, type) {
    const pos = this.getLoadPosition();
    if (!isFiniteNumber(pos)) {
      return null;
    }
    return this.getFwdBufferInfoAtPos(bufferable, pos, type);
  }
  getFwdBufferInfoAtPos(bufferable, pos, type) {
    const {
      config: {
        maxBufferHole
      }
    } = this;
    const bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);
    if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {
      const bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);
      if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {
        return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));
      }
    }
    return bufferInfo;
  }
  getMaxBufferLength(levelBitrate) {
    const {
      config
    } = this;
    let maxBufLen;
    if (levelBitrate) {
      maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
    } else {
      maxBufLen = config.maxBufferLength;
    }
    return Math.min(maxBufLen, config.maxMaxBufferLength);
  }
  reduceMaxBufferLength(threshold, fragDuration) {
    const config = this.config;
    const minLength = Math.max(Math.min(threshold - fragDuration, config.maxBufferLength), fragDuration);
    const reducedLength = Math.max(threshold - fragDuration * 3, config.maxMaxBufferLength / 2, minLength);
    if (reducedLength >= minLength) {
      config.maxMaxBufferLength = reducedLength;
      this.warn(`Reduce max buffer length to ${reducedLength}s`);
      return true;
    }
    return false;
  }
  getAppendedFrag(position, playlistType = PlaylistLevelType.MAIN) {
    const fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);
    if (fragOrPart && "fragment" in fragOrPart) {
      return fragOrPart.fragment;
    }
    return fragOrPart;
  }
  getNextFragment(pos, levelDetails) {
    const fragments = levelDetails.fragments;
    const fragLen = fragments.length;
    if (!fragLen) {
      return null;
    }
    const {
      config
    } = this;
    const start = fragments[0].start;
    let frag;
    if (levelDetails.live) {
      const initialLiveManifestSize = config.initialLiveManifestSize;
      if (fragLen < initialLiveManifestSize) {
        this.warn(`Not enough fragments to start playback (have: ${fragLen}, need: ${initialLiveManifestSize})`);
        return null;
      }
      if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {
        frag = this.getInitialLiveFragment(levelDetails, fragments);
        this.startPosition = this.nextLoadPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;
      }
    } else if (pos <= start) {
      frag = fragments[0];
    }
    if (!frag) {
      const end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;
      frag = this.getFragmentAtPosition(pos, end, levelDetails);
    }
    return this.mapToInitFragWhenRequired(frag);
  }
  isLoopLoading(frag, targetBufferTime) {
    const trackerState = this.fragmentTracker.getState(frag);
    return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;
  }
  getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {
    const gapStart = frag.gap;
    const nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);
    if (nextFragment === null) {
      return nextFragment;
    }
    frag = nextFragment;
    if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {
      const nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);
      if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {
        this.log(`buffer full after gaps in "${playlistType}" playlist starting at sn: ${frag.sn}`);
        return null;
      }
    }
    return frag;
  }
  mapToInitFragWhenRequired(frag) {
    if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {
      return frag.initSegment;
    }
    return frag;
  }
  getNextPart(partList, frag, targetBufferTime) {
    let nextPart = -1;
    let contiguous = false;
    let independentAttrOmitted = true;
    for (let i = 0, len = partList.length;i < len; i++) {
      const part = partList[i];
      independentAttrOmitted = independentAttrOmitted && !part.independent;
      if (nextPart > -1 && targetBufferTime < part.start) {
        break;
      }
      const loaded = part.loaded;
      if (loaded) {
        nextPart = -1;
      } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {
        nextPart = i;
      }
      contiguous = loaded;
    }
    return nextPart;
  }
  loadedEndOfParts(partList, targetBufferTime) {
    const lastPart = partList[partList.length - 1];
    return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;
  }
  getInitialLiveFragment(levelDetails, fragments) {
    const fragPrevious = this.fragPrevious;
    let frag = null;
    if (fragPrevious) {
      if (levelDetails.hasProgramDateTime) {
        this.log(`Live playlist, switching playlist, load frag with same PDT: ${fragPrevious.programDateTime}`);
        frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);
      }
      if (!frag) {
        const targetSN = fragPrevious.sn + 1;
        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
          const fragNext = fragments[targetSN - levelDetails.startSN];
          if (fragPrevious.cc === fragNext.cc) {
            frag = fragNext;
            this.log(`Live playlist, switching playlist, load frag with next SN: ${frag.sn}`);
          }
        }
        if (!frag) {
          frag = findFragWithCC(fragments, fragPrevious.cc);
          if (frag) {
            this.log(`Live playlist, switching playlist, load frag with same CC: ${frag.sn}`);
          }
        }
      }
    } else {
      const liveStart = this.hls.liveSyncPosition;
      if (liveStart !== null) {
        frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);
      }
    }
    return frag;
  }
  getFragmentAtPosition(bufferEnd, end, levelDetails) {
    const {
      config
    } = this;
    let {
      fragPrevious
    } = this;
    let {
      fragments,
      endSN
    } = levelDetails;
    const {
      fragmentHint
    } = levelDetails;
    const {
      maxFragLookUpTolerance
    } = config;
    const partList = levelDetails.partList;
    const loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);
    if (loadingParts && fragmentHint && !this.bitrateTest) {
      fragments = fragments.concat(fragmentHint);
      endSN = fragmentHint.sn;
    }
    let frag;
    if (bufferEnd < end) {
      const lookupTolerance = bufferEnd > end - maxFragLookUpTolerance ? 0 : maxFragLookUpTolerance;
      frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);
    } else {
      frag = fragments[fragments.length - 1];
    }
    if (frag) {
      const curSNIdx = frag.sn - levelDetails.startSN;
      const fragState = this.fragmentTracker.getState(frag);
      if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {
        fragPrevious = frag;
      }
      if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {
        const sameLevel = fragPrevious && frag.level === fragPrevious.level;
        if (sameLevel) {
          const nextFrag = fragments[curSNIdx + 1];
          if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {
            frag = nextFrag;
          } else {
            frag = null;
          }
        }
      }
    }
    return frag;
  }
  synchronizeToLiveEdge(levelDetails) {
    const {
      config,
      media
    } = this;
    if (!media) {
      return;
    }
    const liveSyncPosition = this.hls.liveSyncPosition;
    const currentTime = media.currentTime;
    const start = levelDetails.fragments[0].start;
    const end = levelDetails.edge;
    const withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;
    if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {
      const maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;
      if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {
        if (!this.loadedmetadata) {
          this.nextLoadPosition = liveSyncPosition;
        }
        if (media.readyState) {
          this.warn(`Playback: ${currentTime.toFixed(3)} is located too far from the end of live sliding playlist: ${end}, reset currentTime to : ${liveSyncPosition.toFixed(3)}`);
          media.currentTime = liveSyncPosition;
        }
      }
    }
  }
  alignPlaylists(details, previousDetails, switchDetails) {
    const length = details.fragments.length;
    if (!length) {
      this.warn(`No fragments in live playlist`);
      return 0;
    }
    const slidingStart = details.fragments[0].start;
    const firstLevelLoad = !previousDetails;
    const aligned = details.alignedSliding && isFiniteNumber(slidingStart);
    if (firstLevelLoad || !aligned && !slidingStart) {
      const {
        fragPrevious
      } = this;
      alignStream(fragPrevious, switchDetails, details);
      const alignedSlidingStart = details.fragments[0].start;
      this.log(`Live playlist sliding: ${alignedSlidingStart.toFixed(2)} start-sn: ${previousDetails ? previousDetails.startSN : "na"}->${details.startSN} prev-sn: ${fragPrevious ? fragPrevious.sn : "na"} fragments: ${length}`);
      return alignedSlidingStart;
    }
    return slidingStart;
  }
  waitForCdnTuneIn(details) {
    const advancePartLimit = 3;
    return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);
  }
  setStartPosition(details, sliding) {
    let startPosition = this.startPosition;
    if (startPosition < sliding) {
      startPosition = -1;
    }
    if (startPosition === -1 || this.lastCurrentTime === -1) {
      const offsetInMultivariantPlaylist = this.startTimeOffset !== null;
      const startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;
      if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {
        startPosition = sliding + startTimeOffset;
        if (startTimeOffset < 0) {
          startPosition += details.totalduration;
        }
        startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);
        this.log(`Start time offset ${startTimeOffset} found in ${offsetInMultivariantPlaylist ? "multivariant" : "media"} playlist, adjust startPosition to ${startPosition}`);
        this.startPosition = startPosition;
      } else if (details.live) {
        startPosition = this.hls.liveSyncPosition || sliding;
      } else {
        this.startPosition = startPosition = 0;
      }
      this.lastCurrentTime = startPosition;
    }
    this.nextLoadPosition = startPosition;
  }
  getLoadPosition() {
    const {
      media
    } = this;
    let pos = 0;
    if (this.loadedmetadata && media) {
      pos = media.currentTime;
    } else if (this.nextLoadPosition) {
      pos = this.nextLoadPosition;
    }
    return pos;
  }
  handleFragLoadAborted(frag, part) {
    if (this.transmuxer && frag.sn !== "initSegment" && frag.stats.aborted) {
      this.warn(`Fragment ${frag.sn}${part ? " part " + part.index : ""} of level ${frag.level} was aborted`);
      this.resetFragmentLoading(frag);
    }
  }
  resetFragmentLoading(frag) {
    if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {
      this.state = State.IDLE;
    }
  }
  onFragmentOrKeyLoadError(filterType, data) {
    if (data.chunkMeta && !data.frag) {
      const context = this.getCurrentContext(data.chunkMeta);
      if (context) {
        data.frag = context.frag;
      }
    }
    const frag = data.frag;
    if (!frag || frag.type !== filterType || !this.levels) {
      return;
    }
    if (this.fragContextChanged(frag)) {
      var _this$fragCurrent2;
      this.warn(`Frag load error must match current frag to retry ${frag.url} > ${(_this$fragCurrent2 = this.fragCurrent) == null ? undefined : _this$fragCurrent2.url}`);
      return;
    }
    const gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;
    if (gapTagEncountered) {
      this.fragmentTracker.fragBuffered(frag, true);
    }
    const errorAction = data.errorAction;
    const {
      action,
      retryCount = 0,
      retryConfig
    } = errorAction || {};
    if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {
      this.resetStartWhenNotLoaded(this.levelLastLoaded);
      const delay = getRetryDelay(retryConfig, retryCount);
      this.warn(`Fragment ${frag.sn} of ${filterType} ${frag.level} errored with ${data.details}, retrying loading ${retryCount + 1}/${retryConfig.maxNumRetry} in ${delay}ms`);
      errorAction.resolved = true;
      this.retryDate = self.performance.now() + delay;
      this.state = State.FRAG_LOADING_WAITING_RETRY;
    } else if (retryConfig && errorAction) {
      this.resetFragmentErrors(filterType);
      if (retryCount < retryConfig.maxNumRetry) {
        if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {
          errorAction.resolved = true;
        }
      } else {
        logger.warn(`${data.details} reached or exceeded max retry (${retryCount})`);
        return;
      }
    } else if ((errorAction == null ? undefined : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox) {
      this.state = State.WAITING_LEVEL;
    } else {
      this.state = State.ERROR;
    }
    this.tickImmediate();
  }
  reduceLengthAndFlushBuffer(data) {
    if (this.state === State.PARSING || this.state === State.PARSED) {
      const frag = data.frag;
      const playlistType = data.parent;
      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
      const buffered = bufferedInfo && bufferedInfo.len > 0.5;
      if (buffered) {
        this.reduceMaxBufferLength(bufferedInfo.len, (frag == null ? undefined : frag.duration) || 10);
      }
      const flushBuffer = !buffered;
      if (flushBuffer) {
        this.warn(`Buffer full error while media.currentTime is not buffered, flush ${playlistType} buffer`);
      }
      if (frag) {
        this.fragmentTracker.removeFragment(frag);
        this.nextLoadPosition = frag.start;
      }
      this.resetLoadingState();
      return flushBuffer;
    }
    return false;
  }
  resetFragmentErrors(filterType) {
    if (filterType === PlaylistLevelType.AUDIO) {
      this.fragCurrent = null;
    }
    if (!this.loadedmetadata) {
      this.startFragRequested = false;
    }
    if (this.state !== State.STOPPED) {
      this.state = State.IDLE;
    }
  }
  afterBufferFlushed(media, bufferType, playlistType) {
    if (!media) {
      return;
    }
    const bufferedTimeRanges = BufferHelper.getBuffered(media);
    this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);
    if (this.state === State.ENDED) {
      this.resetLoadingState();
    }
  }
  resetLoadingState() {
    this.log("Reset loading state");
    this.fragCurrent = null;
    this.fragPrevious = null;
    this.state = State.IDLE;
  }
  resetStartWhenNotLoaded(level) {
    if (!this.loadedmetadata) {
      this.startFragRequested = false;
      const details = level ? level.details : null;
      if (details != null && details.live) {
        this.startPosition = -1;
        this.setStartPosition(details, 0);
        this.resetLoadingState();
      } else {
        this.nextLoadPosition = this.startPosition;
      }
    }
  }
  resetWhenMissingContext(chunkMeta) {
    this.warn(`The loading context changed while buffering fragment ${chunkMeta.sn} of level ${chunkMeta.level}. This chunk will not be buffered.`);
    this.removeUnbufferedFrags();
    this.resetStartWhenNotLoaded(this.levelLastLoaded);
    this.resetLoadingState();
  }
  removeUnbufferedFrags(start = 0) {
    this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);
  }
  updateLevelTiming(frag, part, level, partial) {
    var _this$transmuxer;
    const details = level.details;
    if (!details) {
      this.warn("level.details undefined");
      return;
    }
    const parsed = Object.keys(frag.elementaryStreams).reduce((result, type) => {
      const info = frag.elementaryStreams[type];
      if (info) {
        const parsedDuration = info.endPTS - info.startPTS;
        if (parsedDuration <= 0) {
          this.warn(`Could not parse fragment ${frag.sn} ${type} duration reliably (${parsedDuration})`);
          return result || false;
        }
        const drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);
        this.hls.trigger(Events.LEVEL_PTS_UPDATED, {
          details,
          level,
          drift,
          type,
          frag,
          start: info.startPTS,
          end: info.endPTS
        });
        return true;
      }
      return result;
    }, false);
    if (!parsed && ((_this$transmuxer = this.transmuxer) == null ? undefined : _this$transmuxer.error) === null) {
      const error = new Error(`Found no media in fragment ${frag.sn} of level ${frag.level} resetting transmuxer to fallback to playlist timing`);
      if (level.fragmentError === 0) {
        level.fragmentError++;
        frag.gap = true;
        this.fragmentTracker.removeFragment(frag);
        this.fragmentTracker.fragBuffered(frag, true);
      }
      this.warn(error.message);
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.FRAG_PARSING_ERROR,
        fatal: false,
        error,
        frag,
        reason: `Found no media in msn ${frag.sn} of level "${level.url}"`
      });
      if (!this.hls) {
        return;
      }
      this.resetTransmuxer();
    }
    this.state = State.PARSED;
    this.hls.trigger(Events.FRAG_PARSED, {
      frag,
      part
    });
  }
  resetTransmuxer() {
    if (this.transmuxer) {
      this.transmuxer.destroy();
      this.transmuxer = null;
    }
  }
  recoverWorkerError(data) {
    if (data.event === "demuxerWorker") {
      this.fragmentTracker.removeAllFragments();
      this.resetTransmuxer();
      this.resetStartWhenNotLoaded(this.levelLastLoaded);
      this.resetLoadingState();
    }
  }
  set state(nextState) {
    const previousState = this._state;
    if (previousState !== nextState) {
      this._state = nextState;
      this.log(`${previousState}->${nextState}`);
    }
  }
  get state() {
    return this._state;
  }
}

class ChunkCache {
  constructor() {
    this.chunks = [];
    this.dataLength = 0;
  }
  push(chunk) {
    this.chunks.push(chunk);
    this.dataLength += chunk.length;
  }
  flush() {
    const {
      chunks,
      dataLength
    } = this;
    let result;
    if (!chunks.length) {
      return new Uint8Array(0);
    } else if (chunks.length === 1) {
      result = chunks[0];
    } else {
      result = concatUint8Arrays(chunks, dataLength);
    }
    this.reset();
    return result;
  }
  reset() {
    this.chunks.length = 0;
    this.dataLength = 0;
  }
}
function concatUint8Arrays(chunks, dataLength) {
  const result = new Uint8Array(dataLength);
  let offset = 0;
  for (let i = 0;i < chunks.length; i++) {
    const chunk = chunks[i];
    result.set(chunk, offset);
    offset += chunk.length;
  }
  return result;
}
function hasUMDWorker() {
  return typeof __HLS_WORKER_BUNDLE__ === "function";
}
function injectWorker() {
  const blob = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {
    type: "text/javascript"
  });
  const objectURL = self.URL.createObjectURL(blob);
  const worker = new self.Worker(objectURL);
  return {
    worker,
    objectURL
  };
}
function loadWorker(path) {
  const scriptURL = new self.URL(path, self.location.href).href;
  const worker = new self.Worker(scriptURL);
  return {
    worker,
    scriptURL
  };
}
function dummyTrack(type = "", inputTimeScale = 90000) {
  return {
    type,
    id: -1,
    pid: -1,
    inputTimeScale,
    sequenceNumber: -1,
    samples: [],
    dropped: 0
  };
}

class BaseAudioDemuxer {
  constructor() {
    this._audioTrack = undefined;
    this._id3Track = undefined;
    this.frameIndex = 0;
    this.cachedData = null;
    this.basePTS = null;
    this.initPTS = null;
    this.lastPTS = null;
  }
  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
    this._id3Track = {
      type: "id3",
      id: 3,
      pid: -1,
      inputTimeScale: 90000,
      sequenceNumber: 0,
      samples: [],
      dropped: 0
    };
  }
  resetTimeStamp(deaultTimestamp) {
    this.initPTS = deaultTimestamp;
    this.resetContiguity();
  }
  resetContiguity() {
    this.basePTS = null;
    this.lastPTS = null;
    this.frameIndex = 0;
  }
  canParse(data, offset) {
    return false;
  }
  appendFrame(track, data, offset) {
  }
  demux(data, timeOffset) {
    if (this.cachedData) {
      data = appendUint8Array(this.cachedData, data);
      this.cachedData = null;
    }
    let id3Data = getID3Data(data, 0);
    let offset = id3Data ? id3Data.length : 0;
    let lastDataIndex;
    const track = this._audioTrack;
    const id3Track = this._id3Track;
    const timestamp = id3Data ? getTimeStamp(id3Data) : undefined;
    const length = data.length;
    if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {
      this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);
      this.lastPTS = this.basePTS;
    }
    if (this.lastPTS === null) {
      this.lastPTS = this.basePTS;
    }
    if (id3Data && id3Data.length > 0) {
      id3Track.samples.push({
        pts: this.lastPTS,
        dts: this.lastPTS,
        data: id3Data,
        type: MetadataSchema.audioId3,
        duration: Number.POSITIVE_INFINITY
      });
    }
    while (offset < length) {
      if (this.canParse(data, offset)) {
        const frame = this.appendFrame(track, data, offset);
        if (frame) {
          this.frameIndex++;
          this.lastPTS = frame.sample.pts;
          offset += frame.length;
          lastDataIndex = offset;
        } else {
          offset = length;
        }
      } else if (canParse$2(data, offset)) {
        id3Data = getID3Data(data, offset);
        id3Track.samples.push({
          pts: this.lastPTS,
          dts: this.lastPTS,
          data: id3Data,
          type: MetadataSchema.audioId3,
          duration: Number.POSITIVE_INFINITY
        });
        offset += id3Data.length;
        lastDataIndex = offset;
      } else {
        offset++;
      }
      if (offset === length && lastDataIndex !== length) {
        const partialData = sliceUint8(data, lastDataIndex);
        if (this.cachedData) {
          this.cachedData = appendUint8Array(this.cachedData, partialData);
        } else {
          this.cachedData = partialData;
        }
      }
    }
    return {
      audioTrack: track,
      videoTrack: dummyTrack(),
      id3Track,
      textTrack: dummyTrack()
    };
  }
  demuxSampleAes(data, keyData, timeOffset) {
    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));
  }
  flush(timeOffset) {
    const cachedData = this.cachedData;
    if (cachedData) {
      this.cachedData = null;
      this.demux(cachedData, 0);
    }
    return {
      audioTrack: this._audioTrack,
      videoTrack: dummyTrack(),
      id3Track: this._id3Track,
      textTrack: dummyTrack()
    };
  }
  destroy() {
  }
}
var initPTSFn = (timestamp, timeOffset, initPTS) => {
  if (isFiniteNumber(timestamp)) {
    return timestamp * 90;
  }
  const init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;
  return timeOffset * 90000 + init90kHz;
};
function getAudioConfig(observer, data, offset, audioCodec) {
  let adtsObjectType;
  let adtsExtensionSamplingIndex;
  let adtsChannelConfig;
  let config;
  const userAgent = navigator.userAgent.toLowerCase();
  const manifestCodec = audioCodec;
  const adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
  adtsObjectType = ((data[offset + 2] & 192) >>> 6) + 1;
  const adtsSamplingIndex = (data[offset + 2] & 60) >>> 2;
  if (adtsSamplingIndex > adtsSamplingRates.length - 1) {
    const error = new Error(`invalid ADTS sampling index:${adtsSamplingIndex}`);
    observer.emit(Events.ERROR, Events.ERROR, {
      type: ErrorTypes.MEDIA_ERROR,
      details: ErrorDetails.FRAG_PARSING_ERROR,
      fatal: true,
      error,
      reason: error.message
    });
    return;
  }
  adtsChannelConfig = (data[offset + 2] & 1) << 2;
  adtsChannelConfig |= (data[offset + 3] & 192) >>> 6;
  logger.log(`manifest codec:${audioCodec}, ADTS type:${adtsObjectType}, samplingIndex:${adtsSamplingIndex}`);
  if (/firefox/i.test(userAgent)) {
    if (adtsSamplingIndex >= 6) {
      adtsObjectType = 5;
      config = new Array(4);
      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
    } else {
      adtsObjectType = 2;
      config = new Array(2);
      adtsExtensionSamplingIndex = adtsSamplingIndex;
    }
  } else if (userAgent.indexOf("android") !== -1) {
    adtsObjectType = 2;
    config = new Array(2);
    adtsExtensionSamplingIndex = adtsSamplingIndex;
  } else {
    adtsObjectType = 5;
    config = new Array(4);
    if (audioCodec && (audioCodec.indexOf("mp4a.40.29") !== -1 || audioCodec.indexOf("mp4a.40.5") !== -1) || !audioCodec && adtsSamplingIndex >= 6) {
      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
    } else {
      if (audioCodec && audioCodec.indexOf("mp4a.40.2") !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {
        adtsObjectType = 2;
        config = new Array(2);
      }
      adtsExtensionSamplingIndex = adtsSamplingIndex;
    }
  }
  config[0] = adtsObjectType << 3;
  config[0] |= (adtsSamplingIndex & 14) >> 1;
  config[1] |= (adtsSamplingIndex & 1) << 7;
  config[1] |= adtsChannelConfig << 3;
  if (adtsObjectType === 5) {
    config[1] |= (adtsExtensionSamplingIndex & 14) >> 1;
    config[2] = (adtsExtensionSamplingIndex & 1) << 7;
    config[2] |= 2 << 2;
    config[3] = 0;
  }
  return {
    config,
    samplerate: adtsSamplingRates[adtsSamplingIndex],
    channelCount: adtsChannelConfig,
    codec: "mp4a.40." + adtsObjectType,
    manifestCodec
  };
}
function isHeaderPattern$1(data, offset) {
  return data[offset] === 255 && (data[offset + 1] & 246) === 240;
}
function getHeaderLength(data, offset) {
  return data[offset + 1] & 1 ? 7 : 9;
}
function getFullFrameLength(data, offset) {
  return (data[offset + 3] & 3) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 224) >>> 5;
}
function canGetFrameLength(data, offset) {
  return offset + 5 < data.length;
}
function isHeader$1(data, offset) {
  return offset + 1 < data.length && isHeaderPattern$1(data, offset);
}
function canParse$1(data, offset) {
  return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;
}
function probe$1(data, offset) {
  if (isHeader$1(data, offset)) {
    const headerLength = getHeaderLength(data, offset);
    if (offset + headerLength >= data.length) {
      return false;
    }
    const frameLength = getFullFrameLength(data, offset);
    if (frameLength <= headerLength) {
      return false;
    }
    const newOffset = offset + frameLength;
    return newOffset === data.length || isHeader$1(data, newOffset);
  }
  return false;
}
function initTrackConfig(track, observer, data, offset, audioCodec) {
  if (!track.samplerate) {
    const config = getAudioConfig(observer, data, offset, audioCodec);
    if (!config) {
      return;
    }
    track.config = config.config;
    track.samplerate = config.samplerate;
    track.channelCount = config.channelCount;
    track.codec = config.codec;
    track.manifestCodec = config.manifestCodec;
    logger.log(`parsed codec:${track.codec}, rate:${config.samplerate}, channels:${config.channelCount}`);
  }
}
function getFrameDuration(samplerate) {
  return 1024 * 90000 / samplerate;
}
function parseFrameHeader(data, offset) {
  const headerLength = getHeaderLength(data, offset);
  if (offset + headerLength <= data.length) {
    const frameLength = getFullFrameLength(data, offset) - headerLength;
    if (frameLength > 0) {
      return {
        headerLength,
        frameLength
      };
    }
  }
}
function appendFrame$2(track, data, offset, pts, frameIndex) {
  const frameDuration = getFrameDuration(track.samplerate);
  const stamp = pts + frameIndex * frameDuration;
  const header = parseFrameHeader(data, offset);
  let unit;
  if (header) {
    const {
      frameLength,
      headerLength
    } = header;
    const _length = headerLength + frameLength;
    const missing = Math.max(0, offset + _length - data.length);
    if (missing) {
      unit = new Uint8Array(_length - headerLength);
      unit.set(data.subarray(offset + headerLength, data.length), 0);
    } else {
      unit = data.subarray(offset + headerLength, offset + _length);
    }
    const _sample = {
      unit,
      pts: stamp
    };
    if (!missing) {
      track.samples.push(_sample);
    }
    return {
      sample: _sample,
      length: _length,
      missing
    };
  }
  const length = data.length - offset;
  unit = new Uint8Array(length);
  unit.set(data.subarray(offset, data.length), 0);
  const sample = {
    unit,
    pts: stamp
  };
  return {
    sample,
    length,
    missing: -1
  };
}
var chromeVersion$1 = null;
var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];
var SamplesCoefficients = [
  [
    0,
    72,
    144,
    12
  ],
  [
    0,
    0,
    0,
    0
  ],
  [
    0,
    72,
    144,
    12
  ],
  [
    0,
    144,
    144,
    12
  ]
];
var BytesInSlot = [
  0,
  1,
  1,
  4
];
function appendFrame$1(track, data, offset, pts, frameIndex) {
  if (offset + 24 > data.length) {
    return;
  }
  const header = parseHeader(data, offset);
  if (header && offset + header.frameLength <= data.length) {
    const frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;
    const stamp = pts + frameIndex * frameDuration;
    const sample = {
      unit: data.subarray(offset, offset + header.frameLength),
      pts: stamp,
      dts: stamp
    };
    track.config = [];
    track.channelCount = header.channelCount;
    track.samplerate = header.sampleRate;
    track.samples.push(sample);
    return {
      sample,
      length: header.frameLength,
      missing: 0
    };
  }
}
function parseHeader(data, offset) {
  const mpegVersion = data[offset + 1] >> 3 & 3;
  const mpegLayer = data[offset + 1] >> 1 & 3;
  const bitRateIndex = data[offset + 2] >> 4 & 15;
  const sampleRateIndex = data[offset + 2] >> 2 & 3;
  if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {
    const paddingBit = data[offset + 2] >> 1 & 1;
    const channelMode = data[offset + 3] >> 6;
    const columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;
    const bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;
    const columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;
    const sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];
    const channelCount = channelMode === 3 ? 1 : 2;
    const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];
    const bytesInSlot = BytesInSlot[mpegLayer];
    const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
    const frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;
    if (chromeVersion$1 === null) {
      const userAgent = navigator.userAgent || "";
      const result = userAgent.match(/Chrome\/(\d+)/i);
      chromeVersion$1 = result ? parseInt(result[1]) : 0;
    }
    const needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;
    if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {
      data[offset + 3] = data[offset + 3] | 128;
    }
    return {
      sampleRate,
      channelCount,
      frameLength,
      samplesPerFrame
    };
  }
}
function isHeaderPattern(data, offset) {
  return data[offset] === 255 && (data[offset + 1] & 224) === 224 && (data[offset + 1] & 6) !== 0;
}
function isHeader(data, offset) {
  return offset + 1 < data.length && isHeaderPattern(data, offset);
}
function canParse(data, offset) {
  const headerSize = 4;
  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;
}
function probe(data, offset) {
  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
    const headerLength = 4;
    const header = parseHeader(data, offset);
    let frameLength = headerLength;
    if (header != null && header.frameLength) {
      frameLength = header.frameLength;
    }
    const newOffset = offset + frameLength;
    return newOffset === data.length || isHeader(data, newOffset);
  }
  return false;
}

class AACDemuxer extends BaseAudioDemuxer {
  constructor(observer, config) {
    super();
    this.observer = undefined;
    this.config = undefined;
    this.observer = observer;
    this.config = config;
  }
  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);
    this._audioTrack = {
      container: "audio/adts",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "aac",
      samples: [],
      manifestCodec: audioCodec,
      duration: trackDuration,
      inputTimeScale: 90000,
      dropped: 0
    };
  }
  static probe(data) {
    if (!data) {
      return false;
    }
    const id3Data = getID3Data(data, 0);
    let offset = (id3Data == null ? undefined : id3Data.length) || 0;
    if (probe(data, offset)) {
      return false;
    }
    for (let length = data.length;offset < length; offset++) {
      if (probe$1(data, offset)) {
        logger.log("ADTS sync word found !");
        return true;
      }
    }
    return false;
  }
  canParse(data, offset) {
    return canParse$1(data, offset);
  }
  appendFrame(track, data, offset) {
    initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
    const frame = appendFrame$2(track, data, offset, this.basePTS, this.frameIndex);
    if (frame && frame.missing === 0) {
      return frame;
    }
  }
}
var emsgSchemePattern = /\/emsg[-/]ID3/i;

class MP4Demuxer {
  constructor(observer, config) {
    this.remainderData = null;
    this.timeOffset = 0;
    this.config = undefined;
    this.videoTrack = undefined;
    this.audioTrack = undefined;
    this.id3Track = undefined;
    this.txtTrack = undefined;
    this.config = config;
  }
  resetTimeStamp() {
  }
  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
    const videoTrack = this.videoTrack = dummyTrack("video", 1);
    const audioTrack = this.audioTrack = dummyTrack("audio", 1);
    const captionTrack = this.txtTrack = dummyTrack("text", 1);
    this.id3Track = dummyTrack("id3", 1);
    this.timeOffset = 0;
    if (!(initSegment != null && initSegment.byteLength)) {
      return;
    }
    const initData = parseInitSegment(initSegment);
    if (initData.video) {
      const {
        id,
        timescale,
        codec
      } = initData.video;
      videoTrack.id = id;
      videoTrack.timescale = captionTrack.timescale = timescale;
      videoTrack.codec = codec;
    }
    if (initData.audio) {
      const {
        id,
        timescale,
        codec
      } = initData.audio;
      audioTrack.id = id;
      audioTrack.timescale = timescale;
      audioTrack.codec = codec;
    }
    captionTrack.id = RemuxerTrackIdConfig.text;
    videoTrack.sampleDuration = 0;
    videoTrack.duration = audioTrack.duration = trackDuration;
  }
  resetContiguity() {
    this.remainderData = null;
  }
  static probe(data) {
    return hasMoofData(data);
  }
  demux(data, timeOffset) {
    this.timeOffset = timeOffset;
    let videoSamples = data;
    const videoTrack = this.videoTrack;
    const textTrack = this.txtTrack;
    if (this.config.progressive) {
      if (this.remainderData) {
        videoSamples = appendUint8Array(this.remainderData, data);
      }
      const segmentedData = segmentValidRange(videoSamples);
      this.remainderData = segmentedData.remainder;
      videoTrack.samples = segmentedData.valid || new Uint8Array;
    } else {
      videoTrack.samples = videoSamples;
    }
    const id3Track = this.extractID3Track(videoTrack, timeOffset);
    textTrack.samples = parseSamples(timeOffset, videoTrack);
    return {
      videoTrack,
      audioTrack: this.audioTrack,
      id3Track,
      textTrack: this.txtTrack
    };
  }
  flush() {
    const timeOffset = this.timeOffset;
    const videoTrack = this.videoTrack;
    const textTrack = this.txtTrack;
    videoTrack.samples = this.remainderData || new Uint8Array;
    this.remainderData = null;
    const id3Track = this.extractID3Track(videoTrack, this.timeOffset);
    textTrack.samples = parseSamples(timeOffset, videoTrack);
    return {
      videoTrack,
      audioTrack: dummyTrack(),
      id3Track,
      textTrack: dummyTrack()
    };
  }
  extractID3Track(videoTrack, timeOffset) {
    const id3Track = this.id3Track;
    if (videoTrack.samples.length) {
      const emsgs = findBox(videoTrack.samples, ["emsg"]);
      if (emsgs) {
        emsgs.forEach((data) => {
          const emsgInfo = parseEmsg(data);
          if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {
            const pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;
            let duration = emsgInfo.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;
            if (duration <= 0.001) {
              duration = Number.POSITIVE_INFINITY;
            }
            const payload = emsgInfo.payload;
            id3Track.samples.push({
              data: payload,
              len: payload.byteLength,
              dts: pts,
              pts,
              type: MetadataSchema.emsg,
              duration
            });
          }
        });
      }
    }
    return id3Track;
  }
  demuxSampleAes(data, keyData, timeOffset) {
    return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
  }
  destroy() {
  }
}
var getAudioBSID = (data, offset) => {
  let bsid = 0;
  let numBits = 5;
  offset += numBits;
  const temp = new Uint32Array(1);
  const mask = new Uint32Array(1);
  const byte = new Uint8Array(1);
  while (numBits > 0) {
    byte[0] = data[offset];
    const bits = Math.min(numBits, 8);
    const shift = 8 - bits;
    mask[0] = 4278190080 >>> 24 + shift << shift;
    temp[0] = (byte[0] & mask[0]) >> shift;
    bsid = !bsid ? temp[0] : bsid << bits | temp[0];
    offset += 1;
    numBits -= bits;
  }
  return bsid;
};

class AC3Demuxer extends BaseAudioDemuxer {
  constructor(observer) {
    super();
    this.observer = undefined;
    this.observer = observer;
  }
  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);
    this._audioTrack = {
      container: "audio/ac-3",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "ac3",
      samples: [],
      manifestCodec: audioCodec,
      duration: trackDuration,
      inputTimeScale: 90000,
      dropped: 0
    };
  }
  canParse(data, offset) {
    return offset + 64 < data.length;
  }
  appendFrame(track, data, offset) {
    const frameLength = appendFrame(track, data, offset, this.basePTS, this.frameIndex);
    if (frameLength !== -1) {
      const sample = track.samples[track.samples.length - 1];
      return {
        sample,
        length: frameLength,
        missing: 0
      };
    }
  }
  static probe(data) {
    if (!data) {
      return false;
    }
    const id3Data = getID3Data(data, 0);
    if (!id3Data) {
      return false;
    }
    const offset = id3Data.length;
    if (data[offset] === 11 && data[offset + 1] === 119 && getTimeStamp(id3Data) !== undefined && getAudioBSID(data, offset) < 16) {
      return true;
    }
    return false;
  }
}
function appendFrame(track, data, start, pts, frameIndex) {
  if (start + 8 > data.length) {
    return -1;
  }
  if (data[start] !== 11 || data[start + 1] !== 119) {
    return -1;
  }
  const samplingRateCode = data[start + 4] >> 6;
  if (samplingRateCode >= 3) {
    return -1;
  }
  const samplingRateMap = [48000, 44100, 32000];
  const sampleRate = samplingRateMap[samplingRateCode];
  const frameSizeCode = data[start + 4] & 63;
  const frameSizeMap = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920];
  const frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;
  if (start + frameLength > data.length) {
    return -1;
  }
  const channelMode = data[start + 6] >> 5;
  let skipCount = 0;
  if (channelMode === 2) {
    skipCount += 2;
  } else {
    if (channelMode & 1 && channelMode !== 1) {
      skipCount += 2;
    }
    if (channelMode & 4) {
      skipCount += 2;
    }
  }
  const lfeon = (data[start + 6] << 8 | data[start + 7]) >> 12 - skipCount & 1;
  const channelsMap = [2, 1, 2, 3, 3, 4, 4, 5];
  const channelCount = channelsMap[channelMode] + lfeon;
  const bsid = data[start + 5] >> 3;
  const bsmod = data[start + 5] & 7;
  const config = new Uint8Array([samplingRateCode << 6 | bsid << 1 | bsmod >> 2, (bsmod & 3) << 6 | channelMode << 3 | lfeon << 2 | frameSizeCode >> 4, frameSizeCode << 4 & 224]);
  const frameDuration = 1536 / sampleRate * 90000;
  const stamp = pts + frameIndex * frameDuration;
  const unit = data.subarray(start, start + frameLength);
  track.config = config;
  track.channelCount = channelCount;
  track.samplerate = sampleRate;
  track.samples.push({
    unit,
    pts: stamp
  });
  return frameLength;
}

class BaseVideoParser {
  constructor() {
    this.VideoSample = null;
  }
  createVideoSample(key, pts, dts, debug) {
    return {
      key,
      frame: false,
      pts,
      dts,
      units: [],
      debug,
      length: 0
    };
  }
  getLastNalUnit(samples) {
    var _VideoSample;
    let VideoSample = this.VideoSample;
    let lastUnit;
    if (!VideoSample || VideoSample.units.length === 0) {
      VideoSample = samples[samples.length - 1];
    }
    if ((_VideoSample = VideoSample) != null && _VideoSample.units) {
      const units = VideoSample.units;
      lastUnit = units[units.length - 1];
    }
    return lastUnit;
  }
  pushAccessUnit(VideoSample, videoTrack) {
    if (VideoSample.units.length && VideoSample.frame) {
      if (VideoSample.pts === undefined) {
        const samples = videoTrack.samples;
        const nbSamples = samples.length;
        if (nbSamples) {
          const lastSample = samples[nbSamples - 1];
          VideoSample.pts = lastSample.pts;
          VideoSample.dts = lastSample.dts;
        } else {
          videoTrack.dropped++;
          return;
        }
      }
      videoTrack.samples.push(VideoSample);
    }
    if (VideoSample.debug.length) {
      logger.log(VideoSample.pts + "/" + VideoSample.dts + ":" + VideoSample.debug);
    }
  }
}

class ExpGolomb {
  constructor(data) {
    this.data = undefined;
    this.bytesAvailable = undefined;
    this.word = undefined;
    this.bitsAvailable = undefined;
    this.data = data;
    this.bytesAvailable = data.byteLength;
    this.word = 0;
    this.bitsAvailable = 0;
  }
  loadWord() {
    const data = this.data;
    const bytesAvailable = this.bytesAvailable;
    const position = data.byteLength - bytesAvailable;
    const workingBytes = new Uint8Array(4);
    const availableBytes = Math.min(4, bytesAvailable);
    if (availableBytes === 0) {
      throw new Error("no bytes available");
    }
    workingBytes.set(data.subarray(position, position + availableBytes));
    this.word = new DataView(workingBytes.buffer).getUint32(0);
    this.bitsAvailable = availableBytes * 8;
    this.bytesAvailable -= availableBytes;
  }
  skipBits(count) {
    let skipBytes;
    count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);
    if (this.bitsAvailable > count) {
      this.word <<= count;
      this.bitsAvailable -= count;
    } else {
      count -= this.bitsAvailable;
      skipBytes = count >> 3;
      count -= skipBytes << 3;
      this.bytesAvailable -= skipBytes;
      this.loadWord();
      this.word <<= count;
      this.bitsAvailable -= count;
    }
  }
  readBits(size) {
    let bits = Math.min(this.bitsAvailable, size);
    const valu = this.word >>> 32 - bits;
    if (size > 32) {
      logger.error("Cannot read more than 32 bits at a time");
    }
    this.bitsAvailable -= bits;
    if (this.bitsAvailable > 0) {
      this.word <<= bits;
    } else if (this.bytesAvailable > 0) {
      this.loadWord();
    } else {
      throw new Error("no bits available");
    }
    bits = size - bits;
    if (bits > 0 && this.bitsAvailable) {
      return valu << bits | this.readBits(bits);
    } else {
      return valu;
    }
  }
  skipLZ() {
    let leadingZeroCount;
    for (leadingZeroCount = 0;leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
      if ((this.word & 2147483648 >>> leadingZeroCount) !== 0) {
        this.word <<= leadingZeroCount;
        this.bitsAvailable -= leadingZeroCount;
        return leadingZeroCount;
      }
    }
    this.loadWord();
    return leadingZeroCount + this.skipLZ();
  }
  skipUEG() {
    this.skipBits(1 + this.skipLZ());
  }
  skipEG() {
    this.skipBits(1 + this.skipLZ());
  }
  readUEG() {
    const clz = this.skipLZ();
    return this.readBits(clz + 1) - 1;
  }
  readEG() {
    const valu = this.readUEG();
    if (1 & valu) {
      return 1 + valu >>> 1;
    } else {
      return -1 * (valu >>> 1);
    }
  }
  readBoolean() {
    return this.readBits(1) === 1;
  }
  readUByte() {
    return this.readBits(8);
  }
  readUShort() {
    return this.readBits(16);
  }
  readUInt() {
    return this.readBits(32);
  }
  skipScalingList(count) {
    let lastScale = 8;
    let nextScale = 8;
    let deltaScale;
    for (let j = 0;j < count; j++) {
      if (nextScale !== 0) {
        deltaScale = this.readEG();
        nextScale = (lastScale + deltaScale + 256) % 256;
      }
      lastScale = nextScale === 0 ? lastScale : nextScale;
    }
  }
  readSPS() {
    let frameCropLeftOffset = 0;
    let frameCropRightOffset = 0;
    let frameCropTopOffset = 0;
    let frameCropBottomOffset = 0;
    let numRefFramesInPicOrderCntCycle;
    let scalingListCount;
    let i;
    const readUByte = this.readUByte.bind(this);
    const readBits = this.readBits.bind(this);
    const readUEG = this.readUEG.bind(this);
    const readBoolean = this.readBoolean.bind(this);
    const skipBits = this.skipBits.bind(this);
    const skipEG = this.skipEG.bind(this);
    const skipUEG = this.skipUEG.bind(this);
    const skipScalingList = this.skipScalingList.bind(this);
    readUByte();
    const profileIdc = readUByte();
    readBits(5);
    skipBits(3);
    readUByte();
    skipUEG();
    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
      const chromaFormatIdc = readUEG();
      if (chromaFormatIdc === 3) {
        skipBits(1);
      }
      skipUEG();
      skipUEG();
      skipBits(1);
      if (readBoolean()) {
        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
        for (i = 0;i < scalingListCount; i++) {
          if (readBoolean()) {
            if (i < 6) {
              skipScalingList(16);
            } else {
              skipScalingList(64);
            }
          }
        }
      }
    }
    skipUEG();
    const picOrderCntType = readUEG();
    if (picOrderCntType === 0) {
      readUEG();
    } else if (picOrderCntType === 1) {
      skipBits(1);
      skipEG();
      skipEG();
      numRefFramesInPicOrderCntCycle = readUEG();
      for (i = 0;i < numRefFramesInPicOrderCntCycle; i++) {
        skipEG();
      }
    }
    skipUEG();
    skipBits(1);
    const picWidthInMbsMinus1 = readUEG();
    const picHeightInMapUnitsMinus1 = readUEG();
    const frameMbsOnlyFlag = readBits(1);
    if (frameMbsOnlyFlag === 0) {
      skipBits(1);
    }
    skipBits(1);
    if (readBoolean()) {
      frameCropLeftOffset = readUEG();
      frameCropRightOffset = readUEG();
      frameCropTopOffset = readUEG();
      frameCropBottomOffset = readUEG();
    }
    let pixelRatio = [1, 1];
    if (readBoolean()) {
      if (readBoolean()) {
        const aspectRatioIdc = readUByte();
        switch (aspectRatioIdc) {
          case 1:
            pixelRatio = [1, 1];
            break;
          case 2:
            pixelRatio = [12, 11];
            break;
          case 3:
            pixelRatio = [10, 11];
            break;
          case 4:
            pixelRatio = [16, 11];
            break;
          case 5:
            pixelRatio = [40, 33];
            break;
          case 6:
            pixelRatio = [24, 11];
            break;
          case 7:
            pixelRatio = [20, 11];
            break;
          case 8:
            pixelRatio = [32, 11];
            break;
          case 9:
            pixelRatio = [80, 33];
            break;
          case 10:
            pixelRatio = [18, 11];
            break;
          case 11:
            pixelRatio = [15, 11];
            break;
          case 12:
            pixelRatio = [64, 33];
            break;
          case 13:
            pixelRatio = [160, 99];
            break;
          case 14:
            pixelRatio = [4, 3];
            break;
          case 15:
            pixelRatio = [3, 2];
            break;
          case 16:
            pixelRatio = [2, 1];
            break;
          case 255: {
            pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
            break;
          }
        }
      }
    }
    return {
      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
      pixelRatio
    };
  }
  readSliceType() {
    this.readUByte();
    this.readUEG();
    return this.readUEG();
  }
}

class AvcVideoParser extends BaseVideoParser {
  parseAVCPES(track, textTrack, pes, last, duration) {
    const units = this.parseAVCNALu(track, pes.data);
    let VideoSample = this.VideoSample;
    let push2;
    let spsfound = false;
    pes.data = null;
    if (VideoSample && units.length && !track.audFound) {
      this.pushAccessUnit(VideoSample, track);
      VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, "");
    }
    units.forEach((unit) => {
      var _VideoSample2;
      switch (unit.type) {
        case 1: {
          let iskey = false;
          push2 = true;
          const data = unit.data;
          if (spsfound && data.length > 4) {
            const sliceType = new ExpGolomb(data).readSliceType();
            if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
              iskey = true;
            }
          }
          if (iskey) {
            var _VideoSample;
            if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {
              this.pushAccessUnit(VideoSample, track);
              VideoSample = this.VideoSample = null;
            }
          }
          if (!VideoSample) {
            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts, "");
          }
          VideoSample.frame = true;
          VideoSample.key = iskey;
          break;
        }
        case 5:
          push2 = true;
          if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {
            this.pushAccessUnit(VideoSample, track);
            VideoSample = this.VideoSample = null;
          }
          if (!VideoSample) {
            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts, "");
          }
          VideoSample.key = true;
          VideoSample.frame = true;
          break;
        case 6: {
          push2 = true;
          parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);
          break;
        }
        case 7: {
          var _track$pixelRatio, _track$pixelRatio2;
          push2 = true;
          spsfound = true;
          const sps = unit.data;
          const expGolombDecoder = new ExpGolomb(sps);
          const config = expGolombDecoder.readSPS();
          if (!track.sps || track.width !== config.width || track.height !== config.height || ((_track$pixelRatio = track.pixelRatio) == null ? undefined : _track$pixelRatio[0]) !== config.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? undefined : _track$pixelRatio2[1]) !== config.pixelRatio[1]) {
            track.width = config.width;
            track.height = config.height;
            track.pixelRatio = config.pixelRatio;
            track.sps = [sps];
            track.duration = duration;
            const codecarray = sps.subarray(1, 4);
            let codecstring = "avc1.";
            for (let i = 0;i < 3; i++) {
              let h = codecarray[i].toString(16);
              if (h.length < 2) {
                h = "0" + h;
              }
              codecstring += h;
            }
            track.codec = codecstring;
          }
          break;
        }
        case 8:
          push2 = true;
          track.pps = [unit.data];
          break;
        case 9:
          push2 = true;
          track.audFound = true;
          if (VideoSample) {
            this.pushAccessUnit(VideoSample, track);
          }
          VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, "");
          break;
        case 12:
          push2 = true;
          break;
        default:
          push2 = false;
          if (VideoSample) {
            VideoSample.debug += "unknown NAL " + unit.type + " ";
          }
          break;
      }
      if (VideoSample && push2) {
        const units2 = VideoSample.units;
        units2.push(unit);
      }
    });
    if (last && VideoSample) {
      this.pushAccessUnit(VideoSample, track);
      this.VideoSample = null;
    }
  }
  parseAVCNALu(track, array) {
    const len = array.byteLength;
    let state = track.naluState || 0;
    const lastState = state;
    const units = [];
    let i = 0;
    let value;
    let overflow;
    let unitType;
    let lastUnitStart = -1;
    let lastUnitType = 0;
    if (state === -1) {
      lastUnitStart = 0;
      lastUnitType = array[0] & 31;
      state = 0;
      i = 1;
    }
    while (i < len) {
      value = array[i++];
      if (!state) {
        state = value ? 0 : 1;
        continue;
      }
      if (state === 1) {
        state = value ? 0 : 2;
        continue;
      }
      if (!value) {
        state = 3;
      } else if (value === 1) {
        overflow = i - state - 1;
        if (lastUnitStart >= 0) {
          const unit = {
            data: array.subarray(lastUnitStart, overflow),
            type: lastUnitType
          };
          units.push(unit);
        } else {
          const lastUnit = this.getLastNalUnit(track.samples);
          if (lastUnit) {
            if (lastState && i <= 4 - lastState) {
              if (lastUnit.state) {
                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
              }
            }
            if (overflow > 0) {
              lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));
              lastUnit.state = 0;
            }
          }
        }
        if (i < len) {
          unitType = array[i] & 31;
          lastUnitStart = i;
          lastUnitType = unitType;
          state = 0;
        } else {
          state = -1;
        }
      } else {
        state = 0;
      }
    }
    if (lastUnitStart >= 0 && state >= 0) {
      const unit = {
        data: array.subarray(lastUnitStart, len),
        type: lastUnitType,
        state
      };
      units.push(unit);
    }
    if (units.length === 0) {
      const lastUnit = this.getLastNalUnit(track.samples);
      if (lastUnit) {
        lastUnit.data = appendUint8Array(lastUnit.data, array);
      }
    }
    track.naluState = state;
    return units;
  }
}

class SampleAesDecrypter {
  constructor(observer, config, keyData) {
    this.keyData = undefined;
    this.decrypter = undefined;
    this.keyData = keyData;
    this.decrypter = new Decrypter(config, {
      removePKCS7Padding: false
    });
  }
  decryptBuffer(encryptedData) {
    return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);
  }
  decryptAacSample(samples, sampleIndex, callback) {
    const curUnit = samples[sampleIndex].unit;
    if (curUnit.length <= 16) {
      return;
    }
    const encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
    const encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
    this.decryptBuffer(encryptedBuffer).then((decryptedBuffer) => {
      const decryptedData = new Uint8Array(decryptedBuffer);
      curUnit.set(decryptedData, 16);
      if (!this.decrypter.isSync()) {
        this.decryptAacSamples(samples, sampleIndex + 1, callback);
      }
    });
  }
  decryptAacSamples(samples, sampleIndex, callback) {
    for (;; sampleIndex++) {
      if (sampleIndex >= samples.length) {
        callback();
        return;
      }
      if (samples[sampleIndex].unit.length < 32) {
        continue;
      }
      this.decryptAacSample(samples, sampleIndex, callback);
      if (!this.decrypter.isSync()) {
        return;
      }
    }
  }
  getAvcEncryptedData(decodedData) {
    const encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
    const encryptedData = new Int8Array(encryptedDataLen);
    let outputPos = 0;
    for (let inputPos = 32;inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {
      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
    }
    return encryptedData;
  }
  getAvcDecryptedUnit(decodedData, decryptedData) {
    const uint8DecryptedData = new Uint8Array(decryptedData);
    let inputPos = 0;
    for (let outputPos = 32;outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {
      decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);
    }
    return decodedData;
  }
  decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {
    const decodedData = discardEPB(curUnit.data);
    const encryptedData = this.getAvcEncryptedData(decodedData);
    this.decryptBuffer(encryptedData.buffer).then((decryptedBuffer) => {
      curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);
      if (!this.decrypter.isSync()) {
        this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
      }
    });
  }
  decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
    if (samples instanceof Uint8Array) {
      throw new Error("Cannot decrypt samples of type Uint8Array");
    }
    for (;; sampleIndex++, unitIndex = 0) {
      if (sampleIndex >= samples.length) {
        callback();
        return;
      }
      const curUnits = samples[sampleIndex].units;
      for (;; unitIndex++) {
        if (unitIndex >= curUnits.length) {
          break;
        }
        const curUnit = curUnits[unitIndex];
        if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
          continue;
        }
        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);
        if (!this.decrypter.isSync()) {
          return;
        }
      }
    }
  }
}
var PACKET_LENGTH = 188;

class TSDemuxer {
  constructor(observer, config, typeSupported) {
    this.observer = undefined;
    this.config = undefined;
    this.typeSupported = undefined;
    this.sampleAes = null;
    this.pmtParsed = false;
    this.audioCodec = undefined;
    this.videoCodec = undefined;
    this._duration = 0;
    this._pmtId = -1;
    this._videoTrack = undefined;
    this._audioTrack = undefined;
    this._id3Track = undefined;
    this._txtTrack = undefined;
    this.aacOverFlow = null;
    this.remainderData = null;
    this.videoParser = undefined;
    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    this.videoParser = new AvcVideoParser;
  }
  static probe(data) {
    const syncOffset = TSDemuxer.syncOffset(data);
    if (syncOffset > 0) {
      logger.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}`);
    }
    return syncOffset !== -1;
  }
  static syncOffset(data) {
    const length = data.length;
    let scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;
    let i = 0;
    while (i < scanwindow) {
      let foundPat = false;
      let packetStart = -1;
      let tsPackets = 0;
      for (let j = i;j < length; j += PACKET_LENGTH) {
        if (data[j] === 71 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 71)) {
          tsPackets++;
          if (packetStart === -1) {
            packetStart = j;
            if (packetStart !== 0) {
              scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;
            }
          }
          if (!foundPat) {
            foundPat = parsePID(data, j) === 0;
          }
          if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {
            return packetStart;
          }
        } else if (tsPackets) {
          return -1;
        } else {
          break;
        }
      }
      i++;
    }
    return -1;
  }
  static createTrack(type, duration) {
    return {
      container: type === "video" || type === "audio" ? "video/mp2t" : undefined,
      type,
      id: RemuxerTrackIdConfig[type],
      pid: -1,
      inputTimeScale: 90000,
      sequenceNumber: 0,
      samples: [],
      dropped: 0,
      duration: type === "audio" ? duration : undefined
    };
  }
  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
    this.pmtParsed = false;
    this._pmtId = -1;
    this._videoTrack = TSDemuxer.createTrack("video");
    this._audioTrack = TSDemuxer.createTrack("audio", trackDuration);
    this._id3Track = TSDemuxer.createTrack("id3");
    this._txtTrack = TSDemuxer.createTrack("text");
    this._audioTrack.segmentCodec = "aac";
    this.aacOverFlow = null;
    this.remainderData = null;
    this.audioCodec = audioCodec;
    this.videoCodec = videoCodec;
    this._duration = trackDuration;
  }
  resetTimeStamp() {
  }
  resetContiguity() {
    const {
      _audioTrack,
      _videoTrack,
      _id3Track
    } = this;
    if (_audioTrack) {
      _audioTrack.pesData = null;
    }
    if (_videoTrack) {
      _videoTrack.pesData = null;
    }
    if (_id3Track) {
      _id3Track.pesData = null;
    }
    this.aacOverFlow = null;
    this.remainderData = null;
  }
  demux(data, timeOffset, isSampleAes = false, flush = false) {
    if (!isSampleAes) {
      this.sampleAes = null;
    }
    let pes;
    const videoTrack = this._videoTrack;
    const audioTrack = this._audioTrack;
    const id3Track = this._id3Track;
    const textTrack = this._txtTrack;
    let videoPid = videoTrack.pid;
    let videoData = videoTrack.pesData;
    let audioPid = audioTrack.pid;
    let id3Pid = id3Track.pid;
    let audioData = audioTrack.pesData;
    let id3Data = id3Track.pesData;
    let unknownPID = null;
    let pmtParsed = this.pmtParsed;
    let pmtId = this._pmtId;
    let len = data.length;
    if (this.remainderData) {
      data = appendUint8Array(this.remainderData, data);
      len = data.length;
      this.remainderData = null;
    }
    if (len < PACKET_LENGTH && !flush) {
      this.remainderData = data;
      return {
        audioTrack,
        videoTrack,
        id3Track,
        textTrack
      };
    }
    const syncOffset = Math.max(0, TSDemuxer.syncOffset(data));
    len -= (len - syncOffset) % PACKET_LENGTH;
    if (len < data.byteLength && !flush) {
      this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);
    }
    let tsPacketErrors = 0;
    for (let start = syncOffset;start < len; start += PACKET_LENGTH) {
      if (data[start] === 71) {
        const stt = !!(data[start + 1] & 64);
        const pid = parsePID(data, start);
        const atf = (data[start + 3] & 48) >> 4;
        let offset;
        if (atf > 1) {
          offset = start + 5 + data[start + 4];
          if (offset === start + PACKET_LENGTH) {
            continue;
          }
        } else {
          offset = start + 4;
        }
        switch (pid) {
          case videoPid:
            if (stt) {
              if (videoData && (pes = parsePES(videoData))) {
                this.videoParser.parseAVCPES(videoTrack, textTrack, pes, false, this._duration);
              }
              videoData = {
                data: [],
                size: 0
              };
            }
            if (videoData) {
              videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));
              videoData.size += start + PACKET_LENGTH - offset;
            }
            break;
          case audioPid:
            if (stt) {
              if (audioData && (pes = parsePES(audioData))) {
                switch (audioTrack.segmentCodec) {
                  case "aac":
                    this.parseAACPES(audioTrack, pes);
                    break;
                  case "mp3":
                    this.parseMPEGPES(audioTrack, pes);
                    break;
                  case "ac3":
                    {
                      this.parseAC3PES(audioTrack, pes);
                    }
                    break;
                }
              }
              audioData = {
                data: [],
                size: 0
              };
            }
            if (audioData) {
              audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));
              audioData.size += start + PACKET_LENGTH - offset;
            }
            break;
          case id3Pid:
            if (stt) {
              if (id3Data && (pes = parsePES(id3Data))) {
                this.parseID3PES(id3Track, pes);
              }
              id3Data = {
                data: [],
                size: 0
              };
            }
            if (id3Data) {
              id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));
              id3Data.size += start + PACKET_LENGTH - offset;
            }
            break;
          case 0:
            if (stt) {
              offset += data[offset] + 1;
            }
            pmtId = this._pmtId = parsePAT(data, offset);
            break;
          case pmtId: {
            if (stt) {
              offset += data[offset] + 1;
            }
            const parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes, this.observer);
            videoPid = parsedPIDs.videoPid;
            if (videoPid > 0) {
              videoTrack.pid = videoPid;
              videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;
            }
            audioPid = parsedPIDs.audioPid;
            if (audioPid > 0) {
              audioTrack.pid = audioPid;
              audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;
            }
            id3Pid = parsedPIDs.id3Pid;
            if (id3Pid > 0) {
              id3Track.pid = id3Pid;
            }
            if (unknownPID !== null && !pmtParsed) {
              logger.warn(`MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`);
              unknownPID = null;
              start = syncOffset - 188;
            }
            pmtParsed = this.pmtParsed = true;
            break;
          }
          case 17:
          case 8191:
            break;
          default:
            unknownPID = pid;
            break;
        }
      } else {
        tsPacketErrors++;
      }
    }
    if (tsPacketErrors > 0) {
      emitParsingError(this.observer, new Error(`Found ${tsPacketErrors} TS packet/s that do not start with 0x47`));
    }
    videoTrack.pesData = videoData;
    audioTrack.pesData = audioData;
    id3Track.pesData = id3Data;
    const demuxResult = {
      audioTrack,
      videoTrack,
      id3Track,
      textTrack
    };
    if (flush) {
      this.extractRemainingSamples(demuxResult);
    }
    return demuxResult;
  }
  flush() {
    const {
      remainderData
    } = this;
    this.remainderData = null;
    let result;
    if (remainderData) {
      result = this.demux(remainderData, -1, false, true);
    } else {
      result = {
        videoTrack: this._videoTrack,
        audioTrack: this._audioTrack,
        id3Track: this._id3Track,
        textTrack: this._txtTrack
      };
    }
    this.extractRemainingSamples(result);
    if (this.sampleAes) {
      return this.decrypt(result, this.sampleAes);
    }
    return result;
  }
  extractRemainingSamples(demuxResult) {
    const {
      audioTrack,
      videoTrack,
      id3Track,
      textTrack
    } = demuxResult;
    const videoData = videoTrack.pesData;
    const audioData = audioTrack.pesData;
    const id3Data = id3Track.pesData;
    let pes;
    if (videoData && (pes = parsePES(videoData))) {
      this.videoParser.parseAVCPES(videoTrack, textTrack, pes, true, this._duration);
      videoTrack.pesData = null;
    } else {
      videoTrack.pesData = videoData;
    }
    if (audioData && (pes = parsePES(audioData))) {
      switch (audioTrack.segmentCodec) {
        case "aac":
          this.parseAACPES(audioTrack, pes);
          break;
        case "mp3":
          this.parseMPEGPES(audioTrack, pes);
          break;
        case "ac3":
          {
            this.parseAC3PES(audioTrack, pes);
          }
          break;
      }
      audioTrack.pesData = null;
    } else {
      if (audioData != null && audioData.size) {
        logger.log("last AAC PES packet truncated,might overlap between fragments");
      }
      audioTrack.pesData = audioData;
    }
    if (id3Data && (pes = parsePES(id3Data))) {
      this.parseID3PES(id3Track, pes);
      id3Track.pesData = null;
    } else {
      id3Track.pesData = id3Data;
    }
  }
  demuxSampleAes(data, keyData, timeOffset) {
    const demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);
    const sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);
    return this.decrypt(demuxResult, sampleAes);
  }
  decrypt(demuxResult, sampleAes) {
    return new Promise((resolve) => {
      const {
        audioTrack,
        videoTrack
      } = demuxResult;
      if (audioTrack.samples && audioTrack.segmentCodec === "aac") {
        sampleAes.decryptAacSamples(audioTrack.samples, 0, () => {
          if (videoTrack.samples) {
            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {
              resolve(demuxResult);
            });
          } else {
            resolve(demuxResult);
          }
        });
      } else if (videoTrack.samples) {
        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {
          resolve(demuxResult);
        });
      }
    });
  }
  destroy() {
    this._duration = 0;
  }
  parseAACPES(track, pes) {
    let startOffset = 0;
    const aacOverFlow = this.aacOverFlow;
    let data = pes.data;
    if (aacOverFlow) {
      this.aacOverFlow = null;
      const frameMissingBytes = aacOverFlow.missing;
      const sampleLength = aacOverFlow.sample.unit.byteLength;
      if (frameMissingBytes === -1) {
        data = appendUint8Array(aacOverFlow.sample.unit, data);
      } else {
        const frameOverflowBytes = sampleLength - frameMissingBytes;
        aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);
        track.samples.push(aacOverFlow.sample);
        startOffset = aacOverFlow.missing;
      }
    }
    let offset;
    let len;
    for (offset = startOffset, len = data.length;offset < len - 1; offset++) {
      if (isHeader$1(data, offset)) {
        break;
      }
    }
    if (offset !== startOffset) {
      let reason;
      const recoverable = offset < len - 1;
      if (recoverable) {
        reason = `AAC PES did not start with ADTS header,offset:${offset}`;
      } else {
        reason = "No ADTS header found in AAC PES";
      }
      emitParsingError(this.observer, new Error(reason), recoverable);
      if (!recoverable) {
        return;
      }
    }
    initTrackConfig(track, this.observer, data, offset, this.audioCodec);
    let pts;
    if (pes.pts !== undefined) {
      pts = pes.pts;
    } else if (aacOverFlow) {
      const frameDuration = getFrameDuration(track.samplerate);
      pts = aacOverFlow.sample.pts + frameDuration;
    } else {
      logger.warn("[tsdemuxer]: AAC PES unknown PTS");
      return;
    }
    let frameIndex = 0;
    let frame;
    while (offset < len) {
      frame = appendFrame$2(track, data, offset, pts, frameIndex);
      offset += frame.length;
      if (!frame.missing) {
        frameIndex++;
        for (;offset < len - 1; offset++) {
          if (isHeader$1(data, offset)) {
            break;
          }
        }
      } else {
        this.aacOverFlow = frame;
        break;
      }
    }
  }
  parseMPEGPES(track, pes) {
    const data = pes.data;
    const length = data.length;
    let frameIndex = 0;
    let offset = 0;
    const pts = pes.pts;
    if (pts === undefined) {
      logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
      return;
    }
    while (offset < length) {
      if (isHeader(data, offset)) {
        const frame = appendFrame$1(track, data, offset, pts, frameIndex);
        if (frame) {
          offset += frame.length;
          frameIndex++;
        } else {
          break;
        }
      } else {
        offset++;
      }
    }
  }
  parseAC3PES(track, pes) {
    {
      const data = pes.data;
      const pts = pes.pts;
      if (pts === undefined) {
        logger.warn("[tsdemuxer]: AC3 PES unknown PTS");
        return;
      }
      const length = data.length;
      let frameIndex = 0;
      let offset = 0;
      let parsed;
      while (offset < length && (parsed = appendFrame(track, data, offset, pts, frameIndex++)) > 0) {
        offset += parsed;
      }
    }
  }
  parseID3PES(id3Track, pes) {
    if (pes.pts === undefined) {
      logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
      return;
    }
    const id3Sample = _extends({}, pes, {
      type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,
      duration: Number.POSITIVE_INFINITY
    });
    id3Track.samples.push(id3Sample);
  }
}
function parsePID(data, offset) {
  return ((data[offset + 1] & 31) << 8) + data[offset + 2];
}
function parsePAT(data, offset) {
  return (data[offset + 10] & 31) << 8 | data[offset + 11];
}
function parsePMT(data, offset, typeSupported, isSampleAes, observer) {
  const result = {
    audioPid: -1,
    videoPid: -1,
    id3Pid: -1,
    segmentVideoCodec: "avc",
    segmentAudioCodec: "aac"
  };
  const sectionLength = (data[offset + 1] & 15) << 8 | data[offset + 2];
  const tableEnd = offset + 3 + sectionLength - 4;
  const programInfoLength = (data[offset + 10] & 15) << 8 | data[offset + 11];
  offset += 12 + programInfoLength;
  while (offset < tableEnd) {
    const pid = parsePID(data, offset);
    const esInfoLength = (data[offset + 3] & 15) << 8 | data[offset + 4];
    switch (data[offset]) {
      case 207:
        if (!isSampleAes) {
          logEncryptedSamplesFoundInUnencryptedStream("ADTS AAC");
          break;
        }
      case 15:
        if (result.audioPid === -1) {
          result.audioPid = pid;
        }
        break;
      case 21:
        if (result.id3Pid === -1) {
          result.id3Pid = pid;
        }
        break;
      case 219:
        if (!isSampleAes) {
          logEncryptedSamplesFoundInUnencryptedStream("H.264");
          break;
        }
      case 27:
        if (result.videoPid === -1) {
          result.videoPid = pid;
          result.segmentVideoCodec = "avc";
        }
        break;
      case 3:
      case 4:
        if (!typeSupported.mpeg && !typeSupported.mp3) {
          logger.log("MPEG audio found, not supported in this browser");
        } else if (result.audioPid === -1) {
          result.audioPid = pid;
          result.segmentAudioCodec = "mp3";
        }
        break;
      case 193:
        if (!isSampleAes) {
          logEncryptedSamplesFoundInUnencryptedStream("AC-3");
          break;
        }
      case 129:
        {
          if (!typeSupported.ac3) {
            logger.log("AC-3 audio found, not supported in this browser");
          } else if (result.audioPid === -1) {
            result.audioPid = pid;
            result.segmentAudioCodec = "ac3";
          }
        }
        break;
      case 6:
        if (result.audioPid === -1 && esInfoLength > 0) {
          let parsePos = offset + 5;
          let remaining = esInfoLength;
          while (remaining > 2) {
            const descriptorId = data[parsePos];
            switch (descriptorId) {
              case 106:
                {
                  if (typeSupported.ac3 !== true) {
                    logger.log("AC-3 audio found, not supported in this browser for now");
                  } else {
                    result.audioPid = pid;
                    result.segmentAudioCodec = "ac3";
                  }
                }
                break;
            }
            const descriptorLen = data[parsePos + 1] + 2;
            parsePos += descriptorLen;
            remaining -= descriptorLen;
          }
        }
        break;
      case 194:
      case 135:
        emitParsingError(observer, new Error("Unsupported EC-3 in M2TS found"));
        return result;
      case 36:
        emitParsingError(observer, new Error("Unsupported HEVC in M2TS found"));
        return result;
    }
    offset += esInfoLength + 5;
  }
  return result;
}
function emitParsingError(observer, error, levelRetry) {
  logger.warn(`parsing error: ${error.message}`);
  observer.emit(Events.ERROR, Events.ERROR, {
    type: ErrorTypes.MEDIA_ERROR,
    details: ErrorDetails.FRAG_PARSING_ERROR,
    fatal: false,
    levelRetry,
    error,
    reason: error.message
  });
}
function logEncryptedSamplesFoundInUnencryptedStream(type) {
  logger.log(`${type} with AES-128-CBC encryption found in unencrypted stream`);
}
function parsePES(stream) {
  let i = 0;
  let frag;
  let pesLen;
  let pesHdrLen;
  let pesPts;
  let pesDts;
  const data = stream.data;
  if (!stream || stream.size === 0) {
    return null;
  }
  while (data[0].length < 19 && data.length > 1) {
    data[0] = appendUint8Array(data[0], data[1]);
    data.splice(1, 1);
  }
  frag = data[0];
  const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
  if (pesPrefix === 1) {
    pesLen = (frag[4] << 8) + frag[5];
    if (pesLen && pesLen > stream.size - 6) {
      return null;
    }
    const pesFlags = frag[7];
    if (pesFlags & 192) {
      pesPts = (frag[9] & 14) * 536870912 + (frag[10] & 255) * 4194304 + (frag[11] & 254) * 16384 + (frag[12] & 255) * 128 + (frag[13] & 254) / 2;
      if (pesFlags & 64) {
        pesDts = (frag[14] & 14) * 536870912 + (frag[15] & 255) * 4194304 + (frag[16] & 254) * 16384 + (frag[17] & 255) * 128 + (frag[18] & 254) / 2;
        if (pesPts - pesDts > 60 * 90000) {
          logger.warn(`${Math.round((pesPts - pesDts) / 90000)}s delta between PTS and DTS, align them`);
          pesPts = pesDts;
        }
      } else {
        pesDts = pesPts;
      }
    }
    pesHdrLen = frag[8];
    let payloadStartOffset = pesHdrLen + 9;
    if (stream.size <= payloadStartOffset) {
      return null;
    }
    stream.size -= payloadStartOffset;
    const pesData = new Uint8Array(stream.size);
    for (let j = 0, dataLen = data.length;j < dataLen; j++) {
      frag = data[j];
      let len = frag.byteLength;
      if (payloadStartOffset) {
        if (payloadStartOffset > len) {
          payloadStartOffset -= len;
          continue;
        } else {
          frag = frag.subarray(payloadStartOffset);
          len -= payloadStartOffset;
          payloadStartOffset = 0;
        }
      }
      pesData.set(frag, i);
      i += len;
    }
    if (pesLen) {
      pesLen -= pesHdrLen + 3;
    }
    return {
      data: pesData,
      pts: pesPts,
      dts: pesDts,
      len: pesLen
    };
  }
  return null;
}

class MP3Demuxer extends BaseAudioDemuxer {
  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);
    this._audioTrack = {
      container: "audio/mpeg",
      type: "audio",
      id: 2,
      pid: -1,
      sequenceNumber: 0,
      segmentCodec: "mp3",
      samples: [],
      manifestCodec: audioCodec,
      duration: trackDuration,
      inputTimeScale: 90000,
      dropped: 0
    };
  }
  static probe(data) {
    if (!data) {
      return false;
    }
    const id3Data = getID3Data(data, 0);
    let offset = (id3Data == null ? undefined : id3Data.length) || 0;
    if (id3Data && data[offset] === 11 && data[offset + 1] === 119 && getTimeStamp(id3Data) !== undefined && getAudioBSID(data, offset) <= 16) {
      return false;
    }
    for (let length = data.length;offset < length; offset++) {
      if (probe(data, offset)) {
        logger.log("MPEG Audio sync word found !");
        return true;
      }
    }
    return false;
  }
  canParse(data, offset) {
    return canParse(data, offset);
  }
  appendFrame(track, data, offset) {
    if (this.basePTS === null) {
      return;
    }
    return appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);
  }
}

class AAC {
  static getSilentFrame(codec, channelCount) {
    switch (codec) {
      case "mp4a.40.2":
        if (channelCount === 1) {
          return new Uint8Array([0, 200, 0, 128, 35, 128]);
        } else if (channelCount === 2) {
          return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
        } else if (channelCount === 3) {
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
        } else if (channelCount === 4) {
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
        } else if (channelCount === 5) {
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
        } else if (channelCount === 6) {
          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
        }
        break;
      default:
        if (channelCount === 1) {
          return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        } else if (channelCount === 2) {
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        } else if (channelCount === 3) {
          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
        }
        break;
    }
    return;
  }
}
var UINT32_MAX = Math.pow(2, 32) - 1;

class MP4 {
  static init() {
    MP4.types = {
      avc1: [],
      avcC: [],
      btrt: [],
      dinf: [],
      dref: [],
      esds: [],
      ftyp: [],
      hdlr: [],
      mdat: [],
      mdhd: [],
      mdia: [],
      mfhd: [],
      minf: [],
      moof: [],
      moov: [],
      mp4a: [],
      ".mp3": [],
      dac3: [],
      "ac-3": [],
      mvex: [],
      mvhd: [],
      pasp: [],
      sdtp: [],
      stbl: [],
      stco: [],
      stsc: [],
      stsd: [],
      stsz: [],
      stts: [],
      tfdt: [],
      tfhd: [],
      traf: [],
      trak: [],
      trun: [],
      trex: [],
      tkhd: [],
      vmhd: [],
      smhd: []
    };
    let i;
    for (i in MP4.types) {
      if (MP4.types.hasOwnProperty(i)) {
        MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
      }
    }
    const videoHdlr = new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      118,
      105,
      100,
      101,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      86,
      105,
      100,
      101,
      111,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
    ]);
    const audioHdlr = new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      115,
      111,
      117,
      110,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      83,
      111,
      117,
      110,
      100,
      72,
      97,
      110,
      100,
      108,
      101,
      114,
      0
    ]);
    MP4.HDLR_TYPES = {
      video: videoHdlr,
      audio: audioHdlr
    };
    const dref = new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      12,
      117,
      114,
      108,
      32,
      0,
      0,
      0,
      1
    ]);
    const stco = new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    MP4.STTS = MP4.STSC = MP4.STCO = stco;
    MP4.STSZ = new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    MP4.VMHD = new Uint8Array([
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    MP4.SMHD = new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]);
    MP4.STSD = new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1
    ]);
    const majorBrand = new Uint8Array([105, 115, 111, 109]);
    const avc1Brand = new Uint8Array([97, 118, 99, 49]);
    const minorVersion = new Uint8Array([0, 0, 0, 1]);
    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));
  }
  static box(type, ...payload) {
    let size = 8;
    let i = payload.length;
    const len = i;
    while (i--) {
      size += payload[i].byteLength;
    }
    const result = new Uint8Array(size);
    result[0] = size >> 24 & 255;
    result[1] = size >> 16 & 255;
    result[2] = size >> 8 & 255;
    result[3] = size & 255;
    result.set(type, 4);
    for (i = 0, size = 8;i < len; i++) {
      result.set(payload[i], size);
      size += payload[i].byteLength;
    }
    return result;
  }
  static hdlr(type) {
    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);
  }
  static mdat(data) {
    return MP4.box(MP4.types.mdat, data);
  }
  static mdhd(timescale, duration) {
    duration *= timescale;
    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
    return MP4.box(MP4.types.mdhd, new Uint8Array([
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      timescale >> 24 & 255,
      timescale >> 16 & 255,
      timescale >> 8 & 255,
      timescale & 255,
      upperWordDuration >> 24,
      upperWordDuration >> 16 & 255,
      upperWordDuration >> 8 & 255,
      upperWordDuration & 255,
      lowerWordDuration >> 24,
      lowerWordDuration >> 16 & 255,
      lowerWordDuration >> 8 & 255,
      lowerWordDuration & 255,
      85,
      196,
      0,
      0
    ]));
  }
  static mdia(track) {
    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));
  }
  static mfhd(sequenceNumber) {
    return MP4.box(MP4.types.mfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      sequenceNumber >> 24,
      sequenceNumber >> 16 & 255,
      sequenceNumber >> 8 & 255,
      sequenceNumber & 255
    ]));
  }
  static minf(track) {
    if (track.type === "audio") {
      return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));
    } else {
      return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));
    }
  }
  static moof(sn, baseMediaDecodeTime, track) {
    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));
  }
  static moov(tracks) {
    let i = tracks.length;
    const boxes = [];
    while (i--) {
      boxes[i] = MP4.trak(tracks[i]);
    }
    return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));
  }
  static mvex(tracks) {
    let i = tracks.length;
    const boxes = [];
    while (i--) {
      boxes[i] = MP4.trex(tracks[i]);
    }
    return MP4.box.apply(null, [MP4.types.mvex, ...boxes]);
  }
  static mvhd(timescale, duration) {
    duration *= timescale;
    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
    const bytes = new Uint8Array([
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      timescale >> 24 & 255,
      timescale >> 16 & 255,
      timescale >> 8 & 255,
      timescale & 255,
      upperWordDuration >> 24,
      upperWordDuration >> 16 & 255,
      upperWordDuration >> 8 & 255,
      upperWordDuration & 255,
      lowerWordDuration >> 24,
      lowerWordDuration >> 16 & 255,
      lowerWordDuration >> 8 & 255,
      lowerWordDuration & 255,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      255,
      255,
      255,
      255
    ]);
    return MP4.box(MP4.types.mvhd, bytes);
  }
  static sdtp(track) {
    const samples = track.samples || [];
    const bytes = new Uint8Array(4 + samples.length);
    let i;
    let flags;
    for (i = 0;i < samples.length; i++) {
      flags = samples[i].flags;
      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
    }
    return MP4.box(MP4.types.sdtp, bytes);
  }
  static stbl(track) {
    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));
  }
  static avc1(track) {
    let sps = [];
    let pps = [];
    let i;
    let data;
    let len;
    for (i = 0;i < track.sps.length; i++) {
      data = track.sps[i];
      len = data.byteLength;
      sps.push(len >>> 8 & 255);
      sps.push(len & 255);
      sps = sps.concat(Array.prototype.slice.call(data));
    }
    for (i = 0;i < track.pps.length; i++) {
      data = track.pps[i];
      len = data.byteLength;
      pps.push(len >>> 8 & 255);
      pps.push(len & 255);
      pps = pps.concat(Array.prototype.slice.call(data));
    }
    const avcc = MP4.box(MP4.types.avcC, new Uint8Array([
      1,
      sps[3],
      sps[4],
      sps[5],
      252 | 3,
      224 | track.sps.length
    ].concat(sps).concat([
      track.pps.length
    ]).concat(pps)));
    const width = track.width;
    const height = track.height;
    const hSpacing = track.pixelRatio[0];
    const vSpacing = track.pixelRatio[1];
    return MP4.box(MP4.types.avc1, new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      width >> 8 & 255,
      width & 255,
      height >> 8 & 255,
      height & 255,
      0,
      72,
      0,
      0,
      0,
      72,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      18,
      100,
      97,
      105,
      108,
      121,
      109,
      111,
      116,
      105,
      111,
      110,
      47,
      104,
      108,
      115,
      46,
      106,
      115,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      24,
      17,
      17
    ]), avcc, MP4.box(MP4.types.btrt, new Uint8Array([
      0,
      28,
      156,
      128,
      0,
      45,
      198,
      192,
      0,
      45,
      198,
      192
    ])), MP4.box(MP4.types.pasp, new Uint8Array([
      hSpacing >> 24,
      hSpacing >> 16 & 255,
      hSpacing >> 8 & 255,
      hSpacing & 255,
      vSpacing >> 24,
      vSpacing >> 16 & 255,
      vSpacing >> 8 & 255,
      vSpacing & 255
    ])));
  }
  static esds(track) {
    const configlen = track.config.length;
    return new Uint8Array([
      0,
      0,
      0,
      0,
      3,
      23 + configlen,
      0,
      1,
      0,
      4,
      15 + configlen,
      64,
      21,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      5
    ].concat([configlen]).concat(track.config).concat([6, 1, 2]));
  }
  static audioStsd(track) {
    const samplerate = track.samplerate;
    return new Uint8Array([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      track.channelCount,
      0,
      16,
      0,
      0,
      0,
      0,
      samplerate >> 8 & 255,
      samplerate & 255,
      0,
      0
    ]);
  }
  static mp4a(track) {
    return MP4.box(MP4.types.mp4a, MP4.audioStsd(track), MP4.box(MP4.types.esds, MP4.esds(track)));
  }
  static mp3(track) {
    return MP4.box(MP4.types[".mp3"], MP4.audioStsd(track));
  }
  static ac3(track) {
    return MP4.box(MP4.types["ac-3"], MP4.audioStsd(track), MP4.box(MP4.types.dac3, track.config));
  }
  static stsd(track) {
    if (track.type === "audio") {
      if (track.segmentCodec === "mp3" && track.codec === "mp3") {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));
      }
      if (track.segmentCodec === "ac3") {
        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.ac3(track));
      }
      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));
    } else {
      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));
    }
  }
  static tkhd(track) {
    const id = track.id;
    const duration = track.duration * track.timescale;
    const width = track.width;
    const height = track.height;
    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
    return MP4.box(MP4.types.tkhd, new Uint8Array([
      1,
      0,
      0,
      7,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      2,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      3,
      id >> 24 & 255,
      id >> 16 & 255,
      id >> 8 & 255,
      id & 255,
      0,
      0,
      0,
      0,
      upperWordDuration >> 24,
      upperWordDuration >> 16 & 255,
      upperWordDuration >> 8 & 255,
      upperWordDuration & 255,
      lowerWordDuration >> 24,
      lowerWordDuration >> 16 & 255,
      lowerWordDuration >> 8 & 255,
      lowerWordDuration & 255,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      64,
      0,
      0,
      0,
      width >> 8 & 255,
      width & 255,
      0,
      0,
      height >> 8 & 255,
      height & 255,
      0,
      0
    ]));
  }
  static traf(track, baseMediaDecodeTime) {
    const sampleDependencyTable = MP4.sdtp(track);
    const id = track.id;
    const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
    const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
    return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([
      0,
      0,
      0,
      0,
      id >> 24,
      id >> 16 & 255,
      id >> 8 & 255,
      id & 255
    ])), MP4.box(MP4.types.tfdt, new Uint8Array([
      1,
      0,
      0,
      0,
      upperWordBaseMediaDecodeTime >> 24,
      upperWordBaseMediaDecodeTime >> 16 & 255,
      upperWordBaseMediaDecodeTime >> 8 & 255,
      upperWordBaseMediaDecodeTime & 255,
      lowerWordBaseMediaDecodeTime >> 24,
      lowerWordBaseMediaDecodeTime >> 16 & 255,
      lowerWordBaseMediaDecodeTime >> 8 & 255,
      lowerWordBaseMediaDecodeTime & 255
    ])), MP4.trun(track, sampleDependencyTable.length + 16 + 20 + 8 + 16 + 8 + 8), sampleDependencyTable);
  }
  static trak(track) {
    track.duration = track.duration || 4294967295;
    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));
  }
  static trex(track) {
    const id = track.id;
    return MP4.box(MP4.types.trex, new Uint8Array([
      0,
      0,
      0,
      0,
      id >> 24,
      id >> 16 & 255,
      id >> 8 & 255,
      id & 255,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1
    ]));
  }
  static trun(track, offset) {
    const samples = track.samples || [];
    const len = samples.length;
    const arraylen = 12 + 16 * len;
    const array = new Uint8Array(arraylen);
    let i;
    let sample;
    let duration;
    let size;
    let flags;
    let cts;
    offset += 8 + arraylen;
    array.set([
      track.type === "video" ? 1 : 0,
      0,
      15,
      1,
      len >>> 24 & 255,
      len >>> 16 & 255,
      len >>> 8 & 255,
      len & 255,
      offset >>> 24 & 255,
      offset >>> 16 & 255,
      offset >>> 8 & 255,
      offset & 255
    ], 0);
    for (i = 0;i < len; i++) {
      sample = samples[i];
      duration = sample.duration;
      size = sample.size;
      flags = sample.flags;
      cts = sample.cts;
      array.set([
        duration >>> 24 & 255,
        duration >>> 16 & 255,
        duration >>> 8 & 255,
        duration & 255,
        size >>> 24 & 255,
        size >>> 16 & 255,
        size >>> 8 & 255,
        size & 255,
        flags.isLeading << 2 | flags.dependsOn,
        flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync,
        flags.degradPrio & 240 << 8,
        flags.degradPrio & 15,
        cts >>> 24 & 255,
        cts >>> 16 & 255,
        cts >>> 8 & 255,
        cts & 255
      ], 12 + 16 * i);
    }
    return MP4.box(MP4.types.trun, array);
  }
  static initSegment(tracks) {
    if (!MP4.types) {
      MP4.init();
    }
    const movie = MP4.moov(tracks);
    const result = appendUint8Array(MP4.FTYP, movie);
    return result;
  }
}
MP4.types = undefined;
MP4.HDLR_TYPES = undefined;
MP4.STTS = undefined;
MP4.STSC = undefined;
MP4.STCO = undefined;
MP4.STSZ = undefined;
MP4.VMHD = undefined;
MP4.SMHD = undefined;
MP4.STSD = undefined;
MP4.FTYP = undefined;
MP4.DINF = undefined;
var MPEG_TS_CLOCK_FREQ_HZ = 90000;
function toTimescaleFromBase(baseTime, destScale, srcBase = 1, round = false) {
  const result = baseTime * destScale * srcBase;
  return round ? Math.round(result) : result;
}
function toTimescaleFromScale(baseTime, destScale, srcScale = 1, round = false) {
  return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);
}
function toMsFromMpegTsClock(baseTime, round = false) {
  return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);
}
function toMpegTsClockFromTimescale(baseTime, srcScale = 1) {
  return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);
}
var MAX_SILENT_FRAME_DURATION = 10 * 1000;
var AAC_SAMPLES_PER_FRAME = 1024;
var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;
var AC3_SAMPLES_PER_FRAME = 1536;
var chromeVersion = null;
var safariWebkitVersion = null;

class MP4Remuxer {
  constructor(observer, config, typeSupported, vendor = "") {
    this.observer = undefined;
    this.config = undefined;
    this.typeSupported = undefined;
    this.ISGenerated = false;
    this._initPTS = null;
    this._initDTS = null;
    this.nextAvcDts = null;
    this.nextAudioPts = null;
    this.videoSampleDuration = null;
    this.isAudioContiguous = false;
    this.isVideoContiguous = false;
    this.videoTrackConfig = undefined;
    this.observer = observer;
    this.config = config;
    this.typeSupported = typeSupported;
    this.ISGenerated = false;
    if (chromeVersion === null) {
      const userAgent = navigator.userAgent || "";
      const result = userAgent.match(/Chrome\/(\d+)/i);
      chromeVersion = result ? parseInt(result[1]) : 0;
    }
    if (safariWebkitVersion === null) {
      const result = navigator.userAgent.match(/Safari\/(\d+)/i);
      safariWebkitVersion = result ? parseInt(result[1]) : 0;
    }
  }
  destroy() {
    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;
  }
  resetTimeStamp(defaultTimeStamp) {
    logger.log("[mp4-remuxer]: initPTS & initDTS reset");
    this._initPTS = this._initDTS = defaultTimeStamp;
  }
  resetNextTimestamp() {
    logger.log("[mp4-remuxer]: reset next timestamp");
    this.isVideoContiguous = false;
    this.isAudioContiguous = false;
  }
  resetInitSegment() {
    logger.log("[mp4-remuxer]: ISGenerated flag reset");
    this.ISGenerated = false;
    this.videoTrackConfig = undefined;
  }
  getVideoStartPts(videoSamples) {
    let rolloverDetected = false;
    const startPTS = videoSamples.reduce((minPTS, sample) => {
      const delta = sample.pts - minPTS;
      if (delta < -4294967296) {
        rolloverDetected = true;
        return normalizePts(minPTS, sample.pts);
      } else if (delta > 0) {
        return minPTS;
      } else {
        return sample.pts;
      }
    }, videoSamples[0].pts);
    if (rolloverDetected) {
      logger.debug("PTS rollover detected");
    }
    return startPTS;
  }
  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {
    let video;
    let audio;
    let initSegment;
    let text;
    let id3;
    let independent;
    let audioTimeOffset = timeOffset;
    let videoTimeOffset = timeOffset;
    const hasAudio = audioTrack.pid > -1;
    const hasVideo = videoTrack.pid > -1;
    const length = videoTrack.samples.length;
    const enoughAudioSamples = audioTrack.samples.length > 0;
    const enoughVideoSamples = flush && length > 0 || length > 1;
    const canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;
    if (canRemuxAvc) {
      if (this.ISGenerated) {
        var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;
        const config = this.videoTrackConfig;
        if (config && (videoTrack.width !== config.width || videoTrack.height !== config.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? undefined : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config.pixelRatio) == null ? undefined : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? undefined : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config.pixelRatio) == null ? undefined : _config$pixelRatio2[1]))) {
          this.resetInitSegment();
        }
      } else {
        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
      }
      const isVideoContiguous = this.isVideoContiguous;
      let firstKeyFrameIndex = -1;
      let firstKeyFramePTS;
      if (enoughVideoSamples) {
        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);
        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {
          independent = true;
          if (firstKeyFrameIndex > 0) {
            logger.warn(`[mp4-remuxer]: Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`);
            const startPTS = this.getVideoStartPts(videoTrack.samples);
            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);
            videoTrack.dropped += firstKeyFrameIndex;
            videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;
            firstKeyFramePTS = videoTimeOffset;
          } else if (firstKeyFrameIndex === -1) {
            logger.warn(`[mp4-remuxer]: No keyframe found out of ${length} video samples`);
            independent = false;
          }
        }
      }
      if (this.ISGenerated) {
        if (enoughAudioSamples && enoughVideoSamples) {
          const startPTS = this.getVideoStartPts(videoTrack.samples);
          const tsDelta = normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;
          const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;
          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);
          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);
        }
        if (enoughAudioSamples) {
          if (!audioTrack.samplerate) {
            logger.warn("[mp4-remuxer]: regenerate InitSegment as audio detected");
            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
          }
          audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);
          if (enoughVideoSamples) {
            const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;
            if (!videoTrack.inputTimeScale) {
              logger.warn("[mp4-remuxer]: regenerate InitSegment as video detected");
              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
            }
            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);
          }
        } else if (enoughVideoSamples) {
          video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);
        }
        if (video) {
          video.firstKeyFrame = firstKeyFrameIndex;
          video.independent = firstKeyFrameIndex !== -1;
          video.firstKeyFramePTS = firstKeyFramePTS;
        }
      }
    }
    if (this.ISGenerated && this._initPTS && this._initDTS) {
      if (id3Track.samples.length) {
        id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);
      }
      if (textTrack.samples.length) {
        text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);
      }
    }
    return {
      audio,
      video,
      initSegment,
      independent,
      text,
      id3
    };
  }
  generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {
    const audioSamples = audioTrack.samples;
    const videoSamples = videoTrack.samples;
    const typeSupported = this.typeSupported;
    const tracks = {};
    const _initPTS = this._initPTS;
    let computePTSDTS = !_initPTS || accurateTimeOffset;
    let container = "audio/mp4";
    let initPTS;
    let initDTS;
    let timescale;
    if (computePTSDTS) {
      initPTS = initDTS = Infinity;
    }
    if (audioTrack.config && audioSamples.length) {
      audioTrack.timescale = audioTrack.samplerate;
      switch (audioTrack.segmentCodec) {
        case "mp3":
          if (typeSupported.mpeg) {
            container = "audio/mpeg";
            audioTrack.codec = "";
          } else if (typeSupported.mp3) {
            audioTrack.codec = "mp3";
          }
          break;
        case "ac3":
          audioTrack.codec = "ac-3";
          break;
      }
      tracks.audio = {
        id: "audio",
        container,
        codec: audioTrack.codec,
        initSegment: audioTrack.segmentCodec === "mp3" && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),
        metadata: {
          channelCount: audioTrack.channelCount
        }
      };
      if (computePTSDTS) {
        timescale = audioTrack.inputTimeScale;
        if (!_initPTS || timescale !== _initPTS.timescale) {
          initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);
        } else {
          computePTSDTS = false;
        }
      }
    }
    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
      videoTrack.timescale = videoTrack.inputTimeScale;
      tracks.video = {
        id: "main",
        container: "video/mp4",
        codec: videoTrack.codec,
        initSegment: MP4.initSegment([videoTrack]),
        metadata: {
          width: videoTrack.width,
          height: videoTrack.height
        }
      };
      if (computePTSDTS) {
        timescale = videoTrack.inputTimeScale;
        if (!_initPTS || timescale !== _initPTS.timescale) {
          const startPTS = this.getVideoStartPts(videoSamples);
          const startOffset = Math.round(timescale * timeOffset);
          initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);
          initPTS = Math.min(initPTS, startPTS - startOffset);
        } else {
          computePTSDTS = false;
        }
      }
      this.videoTrackConfig = {
        width: videoTrack.width,
        height: videoTrack.height,
        pixelRatio: videoTrack.pixelRatio
      };
    }
    if (Object.keys(tracks).length) {
      this.ISGenerated = true;
      if (computePTSDTS) {
        this._initPTS = {
          baseTime: initPTS,
          timescale
        };
        this._initDTS = {
          baseTime: initDTS,
          timescale
        };
      } else {
        initPTS = timescale = undefined;
      }
      return {
        tracks,
        initPTS,
        timescale
      };
    }
  }
  remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
    const timeScale = track.inputTimeScale;
    const inputSamples = track.samples;
    const outputSamples = [];
    const nbSamples = inputSamples.length;
    const initPTS = this._initPTS;
    let nextAvcDts = this.nextAvcDts;
    let offset = 8;
    let mp4SampleDuration = this.videoSampleDuration;
    let firstDTS;
    let lastDTS;
    let minPTS = Number.POSITIVE_INFINITY;
    let maxPTS = Number.NEGATIVE_INFINITY;
    let sortSamples = false;
    if (!contiguous || nextAvcDts === null) {
      const pts = timeOffset * timeScale;
      const cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);
      if (chromeVersion && nextAvcDts !== null && Math.abs(pts - cts - nextAvcDts) < 15000) {
        contiguous = true;
      } else {
        nextAvcDts = pts - cts;
      }
    }
    const initTime = initPTS.baseTime * timeScale / initPTS.timescale;
    for (let i = 0;i < nbSamples; i++) {
      const sample = inputSamples[i];
      sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);
      sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);
      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {
        sortSamples = true;
      }
    }
    if (sortSamples) {
      inputSamples.sort(function(a, b) {
        const deltadts = a.dts - b.dts;
        const deltapts = a.pts - b.pts;
        return deltadts || deltapts;
      });
    }
    firstDTS = inputSamples[0].dts;
    lastDTS = inputSamples[inputSamples.length - 1].dts;
    const inputDuration = lastDTS - firstDTS;
    const averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;
    if (contiguous) {
      const delta = firstDTS - nextAvcDts;
      const foundHole = delta > averageSampleDuration;
      const foundOverlap = delta < -1;
      if (foundHole || foundOverlap) {
        if (foundHole) {
          logger.warn(`AVC: ${toMsFromMpegTsClock(delta, true)} ms (${delta}dts) hole between fragments detected at ${timeOffset.toFixed(3)}`);
        } else {
          logger.warn(`AVC: ${toMsFromMpegTsClock(-delta, true)} ms (${delta}dts) overlapping between fragments detected at ${timeOffset.toFixed(3)}`);
        }
        if (!foundOverlap || nextAvcDts >= inputSamples[0].pts || chromeVersion) {
          firstDTS = nextAvcDts;
          const firstPTS = inputSamples[0].pts - delta;
          if (foundHole) {
            inputSamples[0].dts = firstDTS;
            inputSamples[0].pts = firstPTS;
          } else {
            for (let i = 0;i < inputSamples.length; i++) {
              if (inputSamples[i].dts > firstPTS) {
                break;
              }
              inputSamples[i].dts -= delta;
              inputSamples[i].pts -= delta;
            }
          }
          logger.log(`Video: Initial PTS/DTS adjusted: ${toMsFromMpegTsClock(firstPTS, true)}/${toMsFromMpegTsClock(firstDTS, true)}, delta: ${toMsFromMpegTsClock(delta, true)} ms`);
        }
      }
    }
    firstDTS = Math.max(0, firstDTS);
    let nbNalu = 0;
    let naluLen = 0;
    let dtsStep = firstDTS;
    for (let i = 0;i < nbSamples; i++) {
      const sample = inputSamples[i];
      const units = sample.units;
      const nbUnits = units.length;
      let sampleLen = 0;
      for (let j = 0;j < nbUnits; j++) {
        sampleLen += units[j].data.length;
      }
      naluLen += sampleLen;
      nbNalu += nbUnits;
      sample.length = sampleLen;
      if (sample.dts < dtsStep) {
        sample.dts = dtsStep;
        dtsStep += averageSampleDuration / 4 | 0 || 1;
      } else {
        dtsStep = sample.dts;
      }
      minPTS = Math.min(sample.pts, minPTS);
      maxPTS = Math.max(sample.pts, maxPTS);
    }
    lastDTS = inputSamples[nbSamples - 1].dts;
    const mdatSize = naluLen + 4 * nbNalu + 8;
    let mdat;
    try {
      mdat = new Uint8Array(mdatSize);
    } catch (err) {
      this.observer.emit(Events.ERROR, Events.ERROR, {
        type: ErrorTypes.MUX_ERROR,
        details: ErrorDetails.REMUX_ALLOC_ERROR,
        fatal: false,
        error: err,
        bytes: mdatSize,
        reason: `fail allocating video mdat ${mdatSize}`
      });
      return;
    }
    const view = new DataView(mdat.buffer);
    view.setUint32(0, mdatSize);
    mdat.set(MP4.types.mdat, 4);
    let stretchedLastFrame = false;
    let minDtsDelta = Number.POSITIVE_INFINITY;
    let minPtsDelta = Number.POSITIVE_INFINITY;
    let maxDtsDelta = Number.NEGATIVE_INFINITY;
    let maxPtsDelta = Number.NEGATIVE_INFINITY;
    for (let i = 0;i < nbSamples; i++) {
      const VideoSample = inputSamples[i];
      const VideoSampleUnits = VideoSample.units;
      let mp4SampleLength = 0;
      for (let j = 0, nbUnits = VideoSampleUnits.length;j < nbUnits; j++) {
        const unit = VideoSampleUnits[j];
        const unitData = unit.data;
        const unitDataLen = unit.data.byteLength;
        view.setUint32(offset, unitDataLen);
        offset += 4;
        mdat.set(unitData, offset);
        offset += unitDataLen;
        mp4SampleLength += 4 + unitDataLen;
      }
      let ptsDelta;
      if (i < nbSamples - 1) {
        mp4SampleDuration = inputSamples[i + 1].dts - VideoSample.dts;
        ptsDelta = inputSamples[i + 1].pts - VideoSample.pts;
      } else {
        const config = this.config;
        const lastFrameDuration = i > 0 ? VideoSample.dts - inputSamples[i - 1].dts : averageSampleDuration;
        ptsDelta = i > 0 ? VideoSample.pts - inputSamples[i - 1].pts : averageSampleDuration;
        if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {
          const gapTolerance = Math.floor(config.maxBufferHole * timeScale);
          const deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - VideoSample.pts;
          if (deltaToFrameEnd > gapTolerance) {
            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
            if (mp4SampleDuration < 0) {
              mp4SampleDuration = lastFrameDuration;
            } else {
              stretchedLastFrame = true;
            }
            logger.log(`[mp4-remuxer]: It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);
          } else {
            mp4SampleDuration = lastFrameDuration;
          }
        } else {
          mp4SampleDuration = lastFrameDuration;
        }
      }
      const compositionTimeOffset = Math.round(VideoSample.pts - VideoSample.dts);
      minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);
      maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);
      minPtsDelta = Math.min(minPtsDelta, ptsDelta);
      maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);
      outputSamples.push(new Mp4Sample(VideoSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));
    }
    if (outputSamples.length) {
      if (chromeVersion) {
        if (chromeVersion < 70) {
          const flags = outputSamples[0].flags;
          flags.dependsOn = 2;
          flags.isNonSync = 0;
        }
      } else if (safariWebkitVersion) {
        if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {
          logger.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
          let dts = firstDTS;
          for (let i = 0, len = outputSamples.length;i < len; i++) {
            const nextDts = dts + outputSamples[i].duration;
            const pts = dts + outputSamples[i].cts;
            if (i < len - 1) {
              const nextPts = nextDts + outputSamples[i + 1].cts;
              outputSamples[i].duration = nextPts - pts;
            } else {
              outputSamples[i].duration = i ? outputSamples[i - 1].duration : averageSampleDuration;
            }
            outputSamples[i].cts = 0;
            dts = nextDts;
          }
        }
      }
    }
    mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;
    this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;
    this.videoSampleDuration = mp4SampleDuration;
    this.isVideoContiguous = true;
    const moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends({}, track, {
      samples: outputSamples
    }));
    const type = "video";
    const data = {
      data1: moof,
      data2: mdat,
      startPTS: minPTS / timeScale,
      endPTS: (maxPTS + mp4SampleDuration) / timeScale,
      startDTS: firstDTS / timeScale,
      endDTS: nextAvcDts / timeScale,
      type,
      hasAudio: false,
      hasVideo: true,
      nb: outputSamples.length,
      dropped: track.dropped
    };
    track.samples = [];
    track.dropped = 0;
    return data;
  }
  getSamplesPerFrame(track) {
    switch (track.segmentCodec) {
      case "mp3":
        return MPEG_AUDIO_SAMPLE_PER_FRAME;
      case "ac3":
        return AC3_SAMPLES_PER_FRAME;
      default:
        return AAC_SAMPLES_PER_FRAME;
    }
  }
  remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {
    const inputTimeScale = track.inputTimeScale;
    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
    const scaleFactor = inputTimeScale / mp4timeScale;
    const mp4SampleDuration = this.getSamplesPerFrame(track);
    const inputSampleDuration = mp4SampleDuration * scaleFactor;
    const initPTS = this._initPTS;
    const rawMPEG = track.segmentCodec === "mp3" && this.typeSupported.mpeg;
    const outputSamples = [];
    const alignedWithVideo = videoTimeOffset !== undefined;
    let inputSamples = track.samples;
    let offset = rawMPEG ? 0 : 8;
    let nextAudioPts = this.nextAudioPts || -1;
    const timeOffsetMpegTS = timeOffset * inputTimeScale;
    const initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;
    this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);
    inputSamples.forEach(function(sample) {
      sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);
    });
    if (!contiguous || nextAudioPts < 0) {
      inputSamples = inputSamples.filter((sample) => sample.pts >= 0);
      if (!inputSamples.length) {
        return;
      }
      if (videoTimeOffset === 0) {
        nextAudioPts = 0;
      } else if (accurateTimeOffset && !alignedWithVideo) {
        nextAudioPts = Math.max(0, timeOffsetMpegTS);
      } else {
        nextAudioPts = inputSamples[0].pts;
      }
    }
    if (track.segmentCodec === "aac") {
      const maxAudioFramesDrift = this.config.maxAudioFramesDrift;
      for (let i = 0, nextPts = nextAudioPts;i < inputSamples.length; i++) {
        const sample = inputSamples[i];
        const pts = sample.pts;
        const delta = pts - nextPts;
        const duration = Math.abs(1000 * delta / inputTimeScale);
        if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {
          if (i === 0) {
            logger.warn(`Audio frame @ ${(pts / inputTimeScale).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1000 * delta / inputTimeScale)} ms.`);
            this.nextAudioPts = nextAudioPts = nextPts = pts;
          }
        } else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {
          let missing = Math.round(delta / inputSampleDuration);
          nextPts = pts - missing * inputSampleDuration;
          if (nextPts < 0) {
            missing--;
            nextPts += inputSampleDuration;
          }
          if (i === 0) {
            this.nextAudioPts = nextAudioPts = nextPts;
          }
          logger.warn(`[mp4-remuxer]: Injecting ${missing} audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(1000 * delta / inputTimeScale)} ms gap.`);
          for (let j = 0;j < missing; j++) {
            const newStamp = Math.max(nextPts, 0);
            let fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
            if (!fillFrame) {
              logger.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.");
              fillFrame = sample.unit.subarray();
            }
            inputSamples.splice(i, 0, {
              unit: fillFrame,
              pts: newStamp
            });
            nextPts += inputSampleDuration;
            i++;
          }
        }
        sample.pts = nextPts;
        nextPts += inputSampleDuration;
      }
    }
    let firstPTS = null;
    let lastPTS = null;
    let mdat;
    let mdatSize = 0;
    let sampleLength = inputSamples.length;
    while (sampleLength--) {
      mdatSize += inputSamples[sampleLength].unit.byteLength;
    }
    for (let j = 0, _nbSamples = inputSamples.length;j < _nbSamples; j++) {
      const audioSample = inputSamples[j];
      const unit = audioSample.unit;
      let pts = audioSample.pts;
      if (lastPTS !== null) {
        const prevSample = outputSamples[j - 1];
        prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);
      } else {
        if (contiguous && track.segmentCodec === "aac") {
          pts = nextAudioPts;
        }
        firstPTS = pts;
        if (mdatSize > 0) {
          mdatSize += offset;
          try {
            mdat = new Uint8Array(mdatSize);
          } catch (err) {
            this.observer.emit(Events.ERROR, Events.ERROR, {
              type: ErrorTypes.MUX_ERROR,
              details: ErrorDetails.REMUX_ALLOC_ERROR,
              fatal: false,
              error: err,
              bytes: mdatSize,
              reason: `fail allocating audio mdat ${mdatSize}`
            });
            return;
          }
          if (!rawMPEG) {
            const view = new DataView(mdat.buffer);
            view.setUint32(0, mdatSize);
            mdat.set(MP4.types.mdat, 4);
          }
        } else {
          return;
        }
      }
      mdat.set(unit, offset);
      const unitLen = unit.byteLength;
      offset += unitLen;
      outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));
      lastPTS = pts;
    }
    const nbSamples = outputSamples.length;
    if (!nbSamples) {
      return;
    }
    const lastSample = outputSamples[outputSamples.length - 1];
    this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;
    const moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {
      samples: outputSamples
    }));
    track.samples = [];
    const start = firstPTS / inputTimeScale;
    const end = nextAudioPts / inputTimeScale;
    const type = "audio";
    const audioData = {
      data1: moof,
      data2: mdat,
      startPTS: start,
      endPTS: end,
      startDTS: start,
      endDTS: end,
      type,
      hasAudio: true,
      hasVideo: false,
      nb: nbSamples
    };
    this.isAudioContiguous = true;
    return audioData;
  }
  remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
    const inputTimeScale = track.inputTimeScale;
    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
    const scaleFactor = inputTimeScale / mp4timeScale;
    const nextAudioPts = this.nextAudioPts;
    const initDTS = this._initDTS;
    const init90kHz = initDTS.baseTime * 90000 / initDTS.timescale;
    const startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;
    const endDTS = videoData.endDTS * inputTimeScale + init90kHz;
    const frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;
    const nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);
    const silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
    logger.warn("[mp4-remuxer]: remux empty Audio");
    if (!silentFrame) {
      logger.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
      return;
    }
    const samples = [];
    for (let i = 0;i < nbSamples; i++) {
      const stamp = startDTS + i * frameDuration;
      samples.push({
        unit: silentFrame,
        pts: stamp,
        dts: stamp
      });
    }
    track.samples = samples;
    return this.remuxAudio(track, timeOffset, contiguous, false);
  }
}
function normalizePts(value, reference) {
  let offset;
  if (reference === null) {
    return value;
  }
  if (reference < value) {
    offset = -8589934592;
  } else {
    offset = 8589934592;
  }
  while (Math.abs(value - reference) > 4294967296) {
    value += offset;
  }
  return value;
}
function findKeyframeIndex(samples) {
  for (let i = 0;i < samples.length; i++) {
    if (samples[i].key) {
      return i;
    }
  }
  return -1;
}
function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {
  const length = track.samples.length;
  if (!length) {
    return;
  }
  const inputTimeScale = track.inputTimeScale;
  for (let index = 0;index < length; index++) {
    const sample = track.samples[index];
    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
    sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
  }
  const samples = track.samples;
  track.samples = [];
  return {
    samples
  };
}
function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {
  const length = track.samples.length;
  if (!length) {
    return;
  }
  const inputTimeScale = track.inputTimeScale;
  for (let index = 0;index < length; index++) {
    const sample = track.samples[index];
    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
  }
  track.samples.sort((a, b) => a.pts - b.pts);
  const samples = track.samples;
  track.samples = [];
  return {
    samples
  };
}

class Mp4Sample {
  constructor(isKeyframe, duration, size, cts) {
    this.size = undefined;
    this.duration = undefined;
    this.cts = undefined;
    this.flags = undefined;
    this.duration = duration;
    this.size = size;
    this.cts = cts;
    this.flags = {
      isLeading: 0,
      isDependedOn: 0,
      hasRedundancy: 0,
      degradPrio: 0,
      dependsOn: isKeyframe ? 2 : 1,
      isNonSync: isKeyframe ? 0 : 1
    };
  }
}

class PassThroughRemuxer {
  constructor() {
    this.emitInitSegment = false;
    this.audioCodec = undefined;
    this.videoCodec = undefined;
    this.initData = undefined;
    this.initPTS = null;
    this.initTracks = undefined;
    this.lastEndTime = null;
  }
  destroy() {
  }
  resetTimeStamp(defaultInitPTS) {
    this.initPTS = defaultInitPTS;
    this.lastEndTime = null;
  }
  resetNextTimestamp() {
    this.lastEndTime = null;
  }
  resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {
    this.audioCodec = audioCodec;
    this.videoCodec = videoCodec;
    this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));
    this.emitInitSegment = true;
  }
  generateInitSegment(initSegment) {
    let {
      audioCodec,
      videoCodec
    } = this;
    if (!(initSegment != null && initSegment.byteLength)) {
      this.initTracks = undefined;
      this.initData = undefined;
      return;
    }
    const initData = this.initData = parseInitSegment(initSegment);
    if (initData.audio) {
      audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);
    }
    if (initData.video) {
      videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);
    }
    const tracks = {};
    if (initData.audio && initData.video) {
      tracks.audiovideo = {
        container: "video/mp4",
        codec: audioCodec + "," + videoCodec,
        initSegment,
        id: "main"
      };
    } else if (initData.audio) {
      tracks.audio = {
        container: "audio/mp4",
        codec: audioCodec,
        initSegment,
        id: "audio"
      };
    } else if (initData.video) {
      tracks.video = {
        container: "video/mp4",
        codec: videoCodec,
        initSegment,
        id: "main"
      };
    } else {
      logger.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.");
    }
    this.initTracks = tracks;
  }
  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {
    var _initData, _initData2;
    let {
      initPTS,
      lastEndTime
    } = this;
    const result = {
      audio: undefined,
      video: undefined,
      text: textTrack,
      id3: id3Track,
      initSegment: undefined
    };
    if (!isFiniteNumber(lastEndTime)) {
      lastEndTime = this.lastEndTime = timeOffset || 0;
    }
    const data = videoTrack.samples;
    if (!(data != null && data.length)) {
      return result;
    }
    const initSegment = {
      initPTS: undefined,
      timescale: 1
    };
    let initData = this.initData;
    if (!((_initData = initData) != null && _initData.length)) {
      this.generateInitSegment(data);
      initData = this.initData;
    }
    if (!((_initData2 = initData) != null && _initData2.length)) {
      logger.warn("[passthrough-remuxer.ts]: Failed to generate initSegment.");
      return result;
    }
    if (this.emitInitSegment) {
      initSegment.tracks = this.initTracks;
      this.emitInitSegment = false;
    }
    const duration = getDuration(data, initData);
    const startDTS = getStartDTS(initData, data);
    const decodeTime = startDTS === null ? timeOffset : startDTS;
    if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {
      initSegment.initPTS = decodeTime - timeOffset;
      if (initPTS && initPTS.timescale === 1) {
        logger.warn(`Adjusting initPTS by ${initSegment.initPTS - initPTS.baseTime}`);
      }
      this.initPTS = initPTS = {
        baseTime: initSegment.initPTS,
        timescale: 1
      };
    }
    const startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;
    const endTime = startTime + duration;
    offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);
    if (duration > 0) {
      this.lastEndTime = endTime;
    } else {
      logger.warn("Duration parsed from mp4 should be greater than zero");
      this.resetNextTimestamp();
    }
    const hasAudio = !!initData.audio;
    const hasVideo = !!initData.video;
    let type = "";
    if (hasAudio) {
      type += "audio";
    }
    if (hasVideo) {
      type += "video";
    }
    const track = {
      data1: data,
      startPTS: startTime,
      startDTS: startTime,
      endPTS: endTime,
      endDTS: endTime,
      type,
      hasAudio,
      hasVideo,
      nb: 1,
      dropped: 0
    };
    result.audio = track.type === "audio" ? track : undefined;
    result.video = track.type !== "audio" ? track : undefined;
    result.initSegment = initSegment;
    result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);
    if (textTrack.samples.length) {
      result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);
    }
    return result;
  }
}
function isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {
  if (initPTS === null) {
    return true;
  }
  const minDuration = Math.max(duration, 1);
  const startTime = startDTS - initPTS.baseTime / initPTS.timescale;
  return Math.abs(startTime - timeOffset) > minDuration;
}
function getParsedTrackCodec(track, type) {
  const parsedCodec = track == null ? undefined : track.codec;
  if (parsedCodec && parsedCodec.length > 4) {
    return parsedCodec;
  }
  if (type === ElementaryStreamTypes.AUDIO) {
    if (parsedCodec === "ec-3" || parsedCodec === "ac-3" || parsedCodec === "alac") {
      return parsedCodec;
    }
    if (parsedCodec === "fLaC" || parsedCodec === "Opus") {
      const preferManagedMediaSource = false;
      return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);
    }
    const result = "mp4a.40.5";
    logger.info(`Parsed audio codec "${parsedCodec}" or audio object type not handled. Using "${result}"`);
    return result;
  }
  logger.warn(`Unhandled video codec "${parsedCodec}"`);
  if (parsedCodec === "hvc1" || parsedCodec === "hev1") {
    return "hvc1.1.6.L120.90";
  }
  if (parsedCodec === "av01") {
    return "av01.0.04M.08";
  }
  return "avc1.42e01e";
}
var now;
try {
  now = self.performance.now.bind(self.performance);
} catch (err) {
  logger.debug("Unable to use Performance API on this environment");
  now = optionalSelf == null ? undefined : optionalSelf.Date.now;
}
var muxConfig = [{
  demux: MP4Demuxer,
  remux: PassThroughRemuxer
}, {
  demux: TSDemuxer,
  remux: MP4Remuxer
}, {
  demux: AACDemuxer,
  remux: MP4Remuxer
}, {
  demux: MP3Demuxer,
  remux: MP4Remuxer
}];
{
  muxConfig.splice(2, 0, {
    demux: AC3Demuxer,
    remux: MP4Remuxer
  });
}

class Transmuxer {
  constructor(observer, typeSupported, config, vendor, id) {
    this.async = false;
    this.observer = undefined;
    this.typeSupported = undefined;
    this.config = undefined;
    this.vendor = undefined;
    this.id = undefined;
    this.demuxer = undefined;
    this.remuxer = undefined;
    this.decrypter = undefined;
    this.probe = undefined;
    this.decryptionPromise = null;
    this.transmuxConfig = undefined;
    this.currentTransmuxState = undefined;
    this.observer = observer;
    this.typeSupported = typeSupported;
    this.config = config;
    this.vendor = vendor;
    this.id = id;
  }
  configure(transmuxConfig) {
    this.transmuxConfig = transmuxConfig;
    if (this.decrypter) {
      this.decrypter.reset();
    }
  }
  push(data, decryptdata, chunkMeta, state) {
    const stats = chunkMeta.transmuxing;
    stats.executeStart = now();
    let uintData = new Uint8Array(data);
    const {
      currentTransmuxState,
      transmuxConfig
    } = this;
    if (state) {
      this.currentTransmuxState = state;
    }
    const {
      contiguous,
      discontinuity,
      trackSwitch,
      accurateTimeOffset,
      timeOffset,
      initSegmentChange
    } = state || currentTransmuxState;
    const {
      audioCodec,
      videoCodec,
      defaultInitPts,
      duration,
      initSegmentData
    } = transmuxConfig;
    const keyData = getEncryptionType(uintData, decryptdata);
    if (keyData && keyData.method === "AES-128") {
      const decrypter = this.getDecrypter();
      if (decrypter.isSync()) {
        let decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);
        const loadingParts = chunkMeta.part > -1;
        if (loadingParts) {
          decryptedData = decrypter.flush();
        }
        if (!decryptedData) {
          stats.executeEnd = now();
          return emptyResult(chunkMeta);
        }
        uintData = new Uint8Array(decryptedData);
      } else {
        this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then((decryptedData) => {
          const result2 = this.push(decryptedData, null, chunkMeta);
          this.decryptionPromise = null;
          return result2;
        });
        return this.decryptionPromise;
      }
    }
    const resetMuxers = this.needsProbing(discontinuity, trackSwitch);
    if (resetMuxers) {
      const error = this.configureTransmuxer(uintData);
      if (error) {
        logger.warn(`[transmuxer] ${error.message}`);
        this.observer.emit(Events.ERROR, Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.FRAG_PARSING_ERROR,
          fatal: false,
          error,
          reason: error.message
        });
        stats.executeEnd = now();
        return emptyResult(chunkMeta);
      }
    }
    if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {
      this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);
    }
    if (discontinuity || initSegmentChange || resetMuxers) {
      this.resetInitialTimestamp(defaultInitPts);
    }
    if (!contiguous) {
      this.resetContiguity();
    }
    const result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);
    const currentState = this.currentTransmuxState;
    currentState.contiguous = true;
    currentState.discontinuity = false;
    currentState.trackSwitch = false;
    stats.executeEnd = now();
    return result;
  }
  flush(chunkMeta) {
    const stats = chunkMeta.transmuxing;
    stats.executeStart = now();
    const {
      decrypter,
      currentTransmuxState,
      decryptionPromise
    } = this;
    if (decryptionPromise) {
      return decryptionPromise.then(() => {
        return this.flush(chunkMeta);
      });
    }
    const transmuxResults = [];
    const {
      timeOffset
    } = currentTransmuxState;
    if (decrypter) {
      const decryptedData = decrypter.flush();
      if (decryptedData) {
        transmuxResults.push(this.push(decryptedData, null, chunkMeta));
      }
    }
    const {
      demuxer,
      remuxer
    } = this;
    if (!demuxer || !remuxer) {
      stats.executeEnd = now();
      return [emptyResult(chunkMeta)];
    }
    const demuxResultOrPromise = demuxer.flush(timeOffset);
    if (isPromise(demuxResultOrPromise)) {
      return demuxResultOrPromise.then((demuxResult) => {
        this.flushRemux(transmuxResults, demuxResult, chunkMeta);
        return transmuxResults;
      });
    }
    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);
    return transmuxResults;
  }
  flushRemux(transmuxResults, demuxResult, chunkMeta) {
    const {
      audioTrack,
      videoTrack,
      id3Track,
      textTrack
    } = demuxResult;
    const {
      accurateTimeOffset,
      timeOffset
    } = this.currentTransmuxState;
    logger.log(`[transmuxer.ts]: Flushed fragment ${chunkMeta.sn}${chunkMeta.part > -1 ? " p: " + chunkMeta.part : ""} of level ${chunkMeta.level}`);
    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);
    transmuxResults.push({
      remuxResult,
      chunkMeta
    });
    chunkMeta.transmuxing.executeEnd = now();
  }
  resetInitialTimestamp(defaultInitPts) {
    const {
      demuxer,
      remuxer
    } = this;
    if (!demuxer || !remuxer) {
      return;
    }
    demuxer.resetTimeStamp(defaultInitPts);
    remuxer.resetTimeStamp(defaultInitPts);
  }
  resetContiguity() {
    const {
      demuxer,
      remuxer
    } = this;
    if (!demuxer || !remuxer) {
      return;
    }
    demuxer.resetContiguity();
    remuxer.resetNextTimestamp();
  }
  resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {
    const {
      demuxer,
      remuxer
    } = this;
    if (!demuxer || !remuxer) {
      return;
    }
    demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);
    remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);
  }
  destroy() {
    if (this.demuxer) {
      this.demuxer.destroy();
      this.demuxer = undefined;
    }
    if (this.remuxer) {
      this.remuxer.destroy();
      this.remuxer = undefined;
    }
  }
  transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {
    let result;
    if (keyData && keyData.method === "SAMPLE-AES") {
      result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);
    } else {
      result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);
    }
    return result;
  }
  transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {
    const {
      audioTrack,
      videoTrack,
      id3Track,
      textTrack
    } = this.demuxer.demux(data, timeOffset, false, !this.config.progressive);
    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);
    return {
      remuxResult,
      chunkMeta
    };
  }
  transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {
    return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then((demuxResult) => {
      const remuxResult = this.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, this.id);
      return {
        remuxResult,
        chunkMeta
      };
    });
  }
  configureTransmuxer(data) {
    const {
      config,
      observer,
      typeSupported,
      vendor
    } = this;
    let mux;
    for (let i = 0, len = muxConfig.length;i < len; i++) {
      var _muxConfig$i$demux;
      if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data)) {
        mux = muxConfig[i];
        break;
      }
    }
    if (!mux) {
      return new Error("Failed to find demuxer by probing fragment data");
    }
    const demuxer = this.demuxer;
    const remuxer = this.remuxer;
    const Remuxer = mux.remux;
    const Demuxer = mux.demux;
    if (!remuxer || !(remuxer instanceof Remuxer)) {
      this.remuxer = new Remuxer(observer, config, typeSupported, vendor);
    }
    if (!demuxer || !(demuxer instanceof Demuxer)) {
      this.demuxer = new Demuxer(observer, config, typeSupported);
      this.probe = Demuxer.probe;
    }
  }
  needsProbing(discontinuity, trackSwitch) {
    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;
  }
  getDecrypter() {
    let decrypter = this.decrypter;
    if (!decrypter) {
      decrypter = this.decrypter = new Decrypter(this.config);
    }
    return decrypter;
  }
}
function getEncryptionType(data, decryptData) {
  let encryptionType = null;
  if (data.byteLength > 0 && (decryptData == null ? undefined : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {
    encryptionType = decryptData;
  }
  return encryptionType;
}
var emptyResult = (chunkMeta) => ({
  remuxResult: {},
  chunkMeta
});
function isPromise(p) {
  return "then" in p && p.then instanceof Function;
}

class TransmuxConfig {
  constructor(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {
    this.audioCodec = undefined;
    this.videoCodec = undefined;
    this.initSegmentData = undefined;
    this.duration = undefined;
    this.defaultInitPts = undefined;
    this.audioCodec = audioCodec;
    this.videoCodec = videoCodec;
    this.initSegmentData = initSegmentData;
    this.duration = duration;
    this.defaultInitPts = defaultInitPts || null;
  }
}

class TransmuxState {
  constructor(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {
    this.discontinuity = undefined;
    this.contiguous = undefined;
    this.accurateTimeOffset = undefined;
    this.trackSwitch = undefined;
    this.timeOffset = undefined;
    this.initSegmentChange = undefined;
    this.discontinuity = discontinuity;
    this.contiguous = contiguous;
    this.accurateTimeOffset = accurateTimeOffset;
    this.trackSwitch = trackSwitch;
    this.timeOffset = timeOffset;
    this.initSegmentChange = initSegmentChange;
  }
}
var eventemitter3 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events2() {
  }
  if (Object.create) {
    Events2.prototype = Object.create(null);
    if (!new Events2().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events2;
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events2;
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1);i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0;i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length;i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events2;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  {
    module.exports = EventEmitter;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
var EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);

class TransmuxerInterface {
  constructor(hls, id, onTransmuxComplete, onFlush) {
    this.error = null;
    this.hls = undefined;
    this.id = undefined;
    this.observer = undefined;
    this.frag = null;
    this.part = null;
    this.useWorker = undefined;
    this.workerContext = null;
    this.onwmsg = undefined;
    this.transmuxer = null;
    this.onTransmuxComplete = undefined;
    this.onFlush = undefined;
    const config = hls.config;
    this.hls = hls;
    this.id = id;
    this.useWorker = !!config.enableWorker;
    this.onTransmuxComplete = onTransmuxComplete;
    this.onFlush = onFlush;
    const forwardMessage = (ev, data) => {
      data = data || {};
      data.frag = this.frag;
      data.id = this.id;
      if (ev === Events.ERROR) {
        this.error = data.error;
      }
      this.hls.trigger(ev, data);
    };
    this.observer = new EventEmitter;
    this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);
    this.observer.on(Events.ERROR, forwardMessage);
    const MediaSource = getMediaSource(config.preferManagedMediaSource) || {
      isTypeSupported: () => false
    };
    const m2tsTypeSupported = {
      mpeg: MediaSource.isTypeSupported("audio/mpeg"),
      mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"'),
      ac3: MediaSource.isTypeSupported('audio/mp4; codecs="ac-3"')
    };
    if (this.useWorker && typeof Worker !== "undefined") {
      const canCreateWorker = config.workerPath || hasUMDWorker();
      if (canCreateWorker) {
        try {
          if (config.workerPath) {
            logger.log(`loading Web Worker ${config.workerPath} for "${id}"`);
            this.workerContext = loadWorker(config.workerPath);
          } else {
            logger.log(`injecting Web Worker for "${id}"`);
            this.workerContext = injectWorker();
          }
          this.onwmsg = (event) => this.onWorkerMessage(event);
          const {
            worker
          } = this.workerContext;
          worker.addEventListener("message", this.onwmsg);
          worker.onerror = (event) => {
            const error = new Error(`${event.message}  (${event.filename}:${event.lineno})`);
            config.enableWorker = false;
            logger.warn(`Error in "${id}" Web Worker, fallback to inline`);
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes.OTHER_ERROR,
              details: ErrorDetails.INTERNAL_EXCEPTION,
              fatal: false,
              event: "demuxerWorker",
              error
            });
          };
          worker.postMessage({
            cmd: "init",
            typeSupported: m2tsTypeSupported,
            vendor: "",
            id,
            config: JSON.stringify(config)
          });
        } catch (err) {
          logger.warn(`Error setting up "${id}" Web Worker, fallback to inline`, err);
          this.resetWorker();
          this.error = null;
          this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, "", id);
        }
        return;
      }
    }
    this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, "", id);
  }
  resetWorker() {
    if (this.workerContext) {
      const {
        worker,
        objectURL
      } = this.workerContext;
      if (objectURL) {
        self.URL.revokeObjectURL(objectURL);
      }
      worker.removeEventListener("message", this.onwmsg);
      worker.onerror = null;
      worker.terminate();
      this.workerContext = null;
    }
  }
  destroy() {
    if (this.workerContext) {
      this.resetWorker();
      this.onwmsg = undefined;
    } else {
      const transmuxer = this.transmuxer;
      if (transmuxer) {
        transmuxer.destroy();
        this.transmuxer = null;
      }
    }
    const observer = this.observer;
    if (observer) {
      observer.removeAllListeners();
    }
    this.frag = null;
    this.observer = null;
    this.hls = null;
  }
  push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {
    var _frag$initSegment, _lastFrag$initSegment;
    chunkMeta.transmuxing.start = self.performance.now();
    const {
      transmuxer
    } = this;
    const timeOffset = part ? part.start : frag.start;
    const decryptdata = frag.decryptdata;
    const lastFrag = this.frag;
    const discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
    const trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);
    const snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;
    const partDiff = this.part ? chunkMeta.part - this.part.index : -1;
    const progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? undefined : lastFrag.stats.chunkCount);
    const contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));
    const now2 = self.performance.now();
    if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {
      frag.stats.parsing.start = now2;
    }
    if (part && (partDiff || !contiguous)) {
      part.stats.parsing.start = now2;
    }
    const initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? undefined : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? undefined : _lastFrag$initSegment.url));
    const state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);
    if (!contiguous || discontinuity || initSegmentChange) {
      logger.log(`[transmuxer-interface, ${frag.type}]: Starting new transmux session for sn: ${chunkMeta.sn} p: ${chunkMeta.part} level: ${chunkMeta.level} id: ${chunkMeta.id}
        discontinuity: ${discontinuity}
        trackSwitch: ${trackSwitch}
        contiguous: ${contiguous}
        accurateTimeOffset: ${accurateTimeOffset}
        timeOffset: ${timeOffset}
        initSegmentChange: ${initSegmentChange}`);
      const config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);
      this.configureTransmuxer(config);
    }
    this.frag = frag;
    this.part = part;
    if (this.workerContext) {
      this.workerContext.worker.postMessage({
        cmd: "demux",
        data,
        decryptdata,
        chunkMeta,
        state
      }, data instanceof ArrayBuffer ? [data] : []);
    } else if (transmuxer) {
      const transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);
      if (isPromise(transmuxResult)) {
        transmuxer.async = true;
        transmuxResult.then((data2) => {
          this.handleTransmuxComplete(data2);
        }).catch((error) => {
          this.transmuxerError(error, chunkMeta, "transmuxer-interface push error");
        });
      } else {
        transmuxer.async = false;
        this.handleTransmuxComplete(transmuxResult);
      }
    }
  }
  flush(chunkMeta) {
    chunkMeta.transmuxing.start = self.performance.now();
    const {
      transmuxer
    } = this;
    if (this.workerContext) {
      this.workerContext.worker.postMessage({
        cmd: "flush",
        chunkMeta
      });
    } else if (transmuxer) {
      let transmuxResult = transmuxer.flush(chunkMeta);
      const asyncFlush = isPromise(transmuxResult);
      if (asyncFlush || transmuxer.async) {
        if (!isPromise(transmuxResult)) {
          transmuxResult = Promise.resolve(transmuxResult);
        }
        transmuxResult.then((data) => {
          this.handleFlushResult(data, chunkMeta);
        }).catch((error) => {
          this.transmuxerError(error, chunkMeta, "transmuxer-interface flush error");
        });
      } else {
        this.handleFlushResult(transmuxResult, chunkMeta);
      }
    }
  }
  transmuxerError(error, chunkMeta, reason) {
    if (!this.hls) {
      return;
    }
    this.error = error;
    this.hls.trigger(Events.ERROR, {
      type: ErrorTypes.MEDIA_ERROR,
      details: ErrorDetails.FRAG_PARSING_ERROR,
      chunkMeta,
      frag: this.frag || undefined,
      fatal: false,
      error,
      err: error,
      reason
    });
  }
  handleFlushResult(results, chunkMeta) {
    results.forEach((result) => {
      this.handleTransmuxComplete(result);
    });
    this.onFlush(chunkMeta);
  }
  onWorkerMessage(event) {
    const data = event.data;
    if (!(data != null && data.event)) {
      logger.warn(`worker message received with no ${data ? "event name" : "data"}`);
      return;
    }
    const hls = this.hls;
    if (!this.hls) {
      return;
    }
    switch (data.event) {
      case "init": {
        var _this$workerContext;
        const objectURL = (_this$workerContext = this.workerContext) == null ? undefined : _this$workerContext.objectURL;
        if (objectURL) {
          self.URL.revokeObjectURL(objectURL);
        }
        break;
      }
      case "transmuxComplete": {
        this.handleTransmuxComplete(data.data);
        break;
      }
      case "flush": {
        this.onFlush(data.data);
        break;
      }
      case "workerLog":
        if (logger[data.data.logType]) {
          logger[data.data.logType](data.data.message);
        }
        break;
      default: {
        data.data = data.data || {};
        data.data.frag = this.frag;
        data.data.id = this.id;
        hls.trigger(data.event, data.data);
        break;
      }
    }
  }
  configureTransmuxer(config) {
    const {
      transmuxer
    } = this;
    if (this.workerContext) {
      this.workerContext.worker.postMessage({
        cmd: "configure",
        config
      });
    } else if (transmuxer) {
      transmuxer.configure(config);
    }
  }
  handleTransmuxComplete(result) {
    result.chunkMeta.transmuxing.end = self.performance.now();
    this.onTransmuxComplete(result);
  }
}
function subtitleOptionsIdentical(trackList1, trackList2) {
  if (trackList1.length !== trackList2.length) {
    return false;
  }
  for (let i = 0;i < trackList1.length; i++) {
    if (!mediaAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {
      return false;
    }
  }
  return true;
}
function mediaAttributesIdentical(attrs1, attrs2, customAttributes) {
  const stableRenditionId = attrs1["STABLE-RENDITION-ID"];
  if (stableRenditionId && !customAttributes) {
    return stableRenditionId === attrs2["STABLE-RENDITION-ID"];
  }
  return !(customAttributes || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some((subtitleAttribute) => attrs1[subtitleAttribute] !== attrs2[subtitleAttribute]);
}
function subtitleTrackMatchesTextTrack(subtitleTrack, textTrack) {
  return textTrack.label.toLowerCase() === subtitleTrack.name.toLowerCase() && (!textTrack.language || textTrack.language.toLowerCase() === (subtitleTrack.lang || "").toLowerCase());
}
var TICK_INTERVAL$2 = 100;

class AudioStreamController extends BaseStreamController {
  constructor(hls, fragmentTracker, keyLoader) {
    super(hls, fragmentTracker, keyLoader, "[audio-stream-controller]", PlaylistLevelType.AUDIO);
    this.videoBuffer = null;
    this.videoTrackCC = -1;
    this.waitingVideoCC = -1;
    this.bufferedTrack = null;
    this.switchingTrack = null;
    this.trackId = -1;
    this.waitingData = null;
    this.mainDetails = null;
    this.flushing = false;
    this.bufferFlushed = false;
    this.cachedTrackLoadedData = null;
    this._registerListeners();
  }
  onHandlerDestroying() {
    this._unregisterListeners();
    super.onHandlerDestroying();
    this.mainDetails = null;
    this.bufferedTrack = null;
    this.switchingTrack = null;
  }
  _registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
    hls.on(Events.ERROR, this.onError, this);
    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);
    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  _unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
    hls.off(Events.ERROR, this.onError, this);
    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);
    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  onInitPtsFound(event, {
    frag,
    id,
    initPTS,
    timescale
  }) {
    if (id === "main") {
      const cc2 = frag.cc;
      this.initPTS[frag.cc] = {
        baseTime: initPTS,
        timescale
      };
      this.log(`InitPTS for cc: ${cc2} found from main: ${initPTS}`);
      this.videoTrackCC = cc2;
      if (this.state === State.WAITING_INIT_PTS) {
        this.tick();
      }
    }
  }
  startLoad(startPosition) {
    if (!this.levels) {
      this.startPosition = startPosition;
      this.state = State.STOPPED;
      return;
    }
    const lastCurrentTime = this.lastCurrentTime;
    this.stopLoad();
    this.setInterval(TICK_INTERVAL$2);
    if (lastCurrentTime > 0 && startPosition === -1) {
      this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);
      startPosition = lastCurrentTime;
      this.state = State.IDLE;
    } else {
      this.loadedmetadata = false;
      this.state = State.WAITING_TRACK;
    }
    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
    this.tick();
  }
  doTick() {
    switch (this.state) {
      case State.IDLE:
        this.doTickIdle();
        break;
      case State.WAITING_TRACK: {
        var _levels$trackId;
        const {
          levels,
          trackId
        } = this;
        const details = levels == null ? undefined : (_levels$trackId = levels[trackId]) == null ? undefined : _levels$trackId.details;
        if (details) {
          if (this.waitForCdnTuneIn(details)) {
            break;
          }
          this.state = State.WAITING_INIT_PTS;
        }
        break;
      }
      case State.FRAG_LOADING_WAITING_RETRY: {
        var _this$media;
        const now2 = performance.now();
        const retryDate = this.retryDate;
        if (!retryDate || now2 >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {
          const {
            levels,
            trackId
          } = this;
          this.log("RetryDate reached, switch back to IDLE state");
          this.resetStartWhenNotLoaded((levels == null ? undefined : levels[trackId]) || null);
          this.state = State.IDLE;
        }
        break;
      }
      case State.WAITING_INIT_PTS: {
        const waitingData = this.waitingData;
        if (waitingData) {
          const {
            frag,
            part,
            cache,
            complete
          } = waitingData;
          if (this.initPTS[frag.cc] !== undefined) {
            this.waitingData = null;
            this.waitingVideoCC = -1;
            this.state = State.FRAG_LOADING;
            const payload = cache.flush();
            const data = {
              frag,
              part,
              payload,
              networkDetails: null
            };
            this._handleFragmentLoadProgress(data);
            if (complete) {
              super._handleFragmentLoadComplete(data);
            }
          } else if (this.videoTrackCC !== this.waitingVideoCC) {
            this.log(`Waiting fragment cc (${frag.cc}) cancelled because video is at cc ${this.videoTrackCC}`);
            this.clearWaitingFragment();
          } else {
            const pos = this.getLoadPosition();
            const bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);
            const waitingFragmentAtPosition = fragmentWithinToleranceTest(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);
            if (waitingFragmentAtPosition < 0) {
              this.log(`Waiting fragment cc (${frag.cc}) @ ${frag.start} cancelled because another fragment at ${bufferInfo.end} is needed`);
              this.clearWaitingFragment();
            }
          }
        } else {
          this.state = State.IDLE;
        }
      }
    }
    this.onTickEnd();
  }
  clearWaitingFragment() {
    const waitingData = this.waitingData;
    if (waitingData) {
      this.fragmentTracker.removeFragment(waitingData.frag);
      this.waitingData = null;
      this.waitingVideoCC = -1;
      this.state = State.IDLE;
    }
  }
  resetLoadingState() {
    this.clearWaitingFragment();
    super.resetLoadingState();
  }
  onTickEnd() {
    const {
      media
    } = this;
    if (!(media != null && media.readyState)) {
      return;
    }
    this.lastCurrentTime = media.currentTime;
  }
  doTickIdle() {
    const {
      hls,
      levels,
      media,
      trackId
    } = this;
    const config = hls.config;
    if (!media && (this.startFragRequested || !config.startFragPrefetch) || !(levels != null && levels[trackId])) {
      return;
    }
    const levelInfo = levels[trackId];
    const trackDetails = levelInfo.details;
    if (!trackDetails || trackDetails.live && this.levelLastLoaded !== levelInfo || this.waitForCdnTuneIn(trackDetails)) {
      this.state = State.WAITING_TRACK;
      return;
    }
    const bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;
    if (this.bufferFlushed && bufferable) {
      this.bufferFlushed = false;
      this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);
    }
    const bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);
    if (bufferInfo === null) {
      return;
    }
    const {
      bufferedTrack,
      switchingTrack
    } = this;
    if (!switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {
      hls.trigger(Events.BUFFER_EOS, {
        type: "audio"
      });
      this.state = State.ENDED;
      return;
    }
    const mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, PlaylistLevelType.MAIN);
    const bufferLen = bufferInfo.len;
    const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? undefined : mainBufferInfo.len);
    const fragments = trackDetails.fragments;
    const start = fragments[0].start;
    let targetBufferTime = this.flushing ? this.getLoadPosition() : bufferInfo.end;
    if (switchingTrack && media) {
      const pos = this.getLoadPosition();
      if (bufferedTrack && !mediaAttributesIdentical(switchingTrack.attrs, bufferedTrack.attrs)) {
        targetBufferTime = pos;
      }
      if (trackDetails.PTSKnown && pos < start) {
        if (bufferInfo.end > start || bufferInfo.nextStart) {
          this.log("Alt audio track ahead of main track, seek to start of alt audio track");
          media.currentTime = start + 0.05;
        }
      }
    }
    if (bufferLen >= maxBufLen && !switchingTrack && targetBufferTime < fragments[fragments.length - 1].start) {
      return;
    }
    let frag = this.getNextFragment(targetBufferTime, trackDetails);
    let atGap = false;
    if (frag && this.isLoopLoading(frag, targetBufferTime)) {
      atGap = !!frag.gap;
      frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
    }
    if (!frag) {
      this.bufferFlushed = true;
      return;
    }
    const atBufferSyncLimit = mainBufferInfo && frag.start > mainBufferInfo.end + trackDetails.targetduration;
    if (atBufferSyncLimit || !(mainBufferInfo != null && mainBufferInfo.len) && bufferInfo.len) {
      const mainFrag = this.getAppendedFrag(frag.start, PlaylistLevelType.MAIN);
      if (mainFrag === null) {
        return;
      }
      atGap || (atGap = !!mainFrag.gap || !!atBufferSyncLimit && mainBufferInfo.len === 0);
      if (atBufferSyncLimit && !atGap || atGap && bufferInfo.nextStart && bufferInfo.nextStart < mainFrag.end) {
        return;
      }
    }
    this.loadFragment(frag, levelInfo, targetBufferTime);
  }
  getMaxBufferLength(mainBufferLength) {
    const maxConfigBuffer = super.getMaxBufferLength();
    if (!mainBufferLength) {
      return maxConfigBuffer;
    }
    return Math.min(Math.max(maxConfigBuffer, mainBufferLength), this.config.maxMaxBufferLength);
  }
  onMediaDetaching() {
    this.videoBuffer = null;
    this.bufferFlushed = this.flushing = false;
    super.onMediaDetaching();
  }
  onAudioTracksUpdated(event, {
    audioTracks
  }) {
    this.resetTransmuxer();
    this.levels = audioTracks.map((mediaPlaylist) => new Level(mediaPlaylist));
  }
  onAudioTrackSwitching(event, data) {
    const altAudio = !!data.url;
    this.trackId = data.id;
    const {
      fragCurrent
    } = this;
    if (fragCurrent) {
      fragCurrent.abortRequests();
      this.removeUnbufferedFrags(fragCurrent.start);
    }
    this.resetLoadingState();
    if (!altAudio) {
      this.resetTransmuxer();
    } else {
      this.setInterval(TICK_INTERVAL$2);
    }
    if (altAudio) {
      this.switchingTrack = data;
      this.state = State.IDLE;
      this.flushAudioIfNeeded(data);
    } else {
      this.switchingTrack = null;
      this.bufferedTrack = data;
      this.state = State.STOPPED;
    }
    this.tick();
  }
  onManifestLoading() {
    this.fragmentTracker.removeAllFragments();
    this.startPosition = this.lastCurrentTime = 0;
    this.bufferFlushed = this.flushing = false;
    this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null;
    this.startFragRequested = false;
    this.trackId = this.videoTrackCC = this.waitingVideoCC = -1;
  }
  onLevelLoaded(event, data) {
    this.mainDetails = data.details;
    if (this.cachedTrackLoadedData !== null) {
      this.hls.trigger(Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);
      this.cachedTrackLoadedData = null;
    }
  }
  onAudioTrackLoaded(event, data) {
    var _track$details;
    if (this.mainDetails == null) {
      this.cachedTrackLoadedData = data;
      return;
    }
    const {
      levels
    } = this;
    const {
      details: newDetails,
      id: trackId
    } = data;
    if (!levels) {
      this.warn(`Audio tracks were reset while loading level ${trackId}`);
      return;
    }
    this.log(`Audio track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ""},duration:${newDetails.totalduration}`);
    const track = levels[trackId];
    let sliding = 0;
    if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {
      this.checkLiveUpdate(newDetails);
      const mainDetails = this.mainDetails;
      if (newDetails.deltaUpdateFailed || !mainDetails) {
        return;
      }
      if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
        alignMediaPlaylistByPDT(newDetails, mainDetails);
        sliding = newDetails.fragments[0].start;
      } else {
        var _this$levelLastLoaded;
        sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? undefined : _this$levelLastLoaded.details);
      }
    }
    track.details = newDetails;
    this.levelLastLoaded = track;
    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
      this.setStartPosition(this.mainDetails || newDetails, sliding);
    }
    if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {
      this.state = State.IDLE;
    }
    this.tick();
  }
  _handleFragmentLoadProgress(data) {
    var _frag$initSegment;
    const {
      frag,
      part,
      payload
    } = data;
    const {
      config,
      trackId,
      levels
    } = this;
    if (!levels) {
      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);
      return;
    }
    const track = levels[trackId];
    if (!track) {
      this.warn("Audio track is undefined on fragment load progress");
      return;
    }
    const details = track.details;
    if (!details) {
      this.warn("Audio track details undefined on fragment load progress");
      this.removeUnbufferedFrags(frag.start);
      return;
    }
    const audioCodec = config.defaultAudioCodec || track.audioCodec || "mp4a.40.2";
    let transmuxer = this.transmuxer;
    if (!transmuxer) {
      transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
    }
    const initPTS = this.initPTS[frag.cc];
    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? undefined : _frag$initSegment.data;
    if (initPTS !== undefined) {
      const accurateTimeOffset = false;
      const partIndex = part ? part.index : -1;
      const partial = partIndex !== -1;
      const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
      transmuxer.push(payload, initSegmentData, audioCodec, "", frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
    } else {
      this.log(`Unknown video PTS for cc ${frag.cc}, waiting for video PTS before demuxing audio frag ${frag.sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);
      const {
        cache
      } = this.waitingData = this.waitingData || {
        frag,
        part,
        cache: new ChunkCache,
        complete: false
      };
      cache.push(new Uint8Array(payload));
      this.waitingVideoCC = this.videoTrackCC;
      this.state = State.WAITING_INIT_PTS;
    }
  }
  _handleFragmentLoadComplete(fragLoadedData) {
    if (this.waitingData) {
      this.waitingData.complete = true;
      return;
    }
    super._handleFragmentLoadComplete(fragLoadedData);
  }
  onBufferReset() {
    this.mediaBuffer = this.videoBuffer = null;
    this.loadedmetadata = false;
  }
  onBufferCreated(event, data) {
    const audioTrack = data.tracks.audio;
    if (audioTrack) {
      this.mediaBuffer = audioTrack.buffer || null;
    }
    if (data.tracks.video) {
      this.videoBuffer = data.tracks.video.buffer || null;
    }
  }
  onFragBuffered(event, data) {
    const {
      frag,
      part
    } = data;
    if (frag.type !== PlaylistLevelType.AUDIO) {
      if (!this.loadedmetadata && frag.type === PlaylistLevelType.MAIN) {
        const bufferable = this.videoBuffer || this.media;
        if (bufferable) {
          const bufferedTimeRanges = BufferHelper.getBuffered(bufferable);
          if (bufferedTimeRanges.length) {
            this.loadedmetadata = true;
          }
        }
      }
      return;
    }
    if (this.fragContextChanged(frag)) {
      this.warn(`Fragment ${frag.sn}${part ? " p: " + part.index : ""} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : "false"}`);
      return;
    }
    if (frag.sn !== "initSegment") {
      this.fragPrevious = frag;
      const track = this.switchingTrack;
      if (track) {
        this.bufferedTrack = track;
        this.switchingTrack = null;
        this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));
      }
    }
    this.fragBufferedComplete(frag, part);
  }
  onError(event, data) {
    var _data$context;
    if (data.fatal) {
      this.state = State.ERROR;
      return;
    }
    switch (data.details) {
      case ErrorDetails.FRAG_GAP:
      case ErrorDetails.FRAG_PARSING_ERROR:
      case ErrorDetails.FRAG_DECRYPT_ERROR:
      case ErrorDetails.FRAG_LOAD_ERROR:
      case ErrorDetails.FRAG_LOAD_TIMEOUT:
      case ErrorDetails.KEY_LOAD_ERROR:
      case ErrorDetails.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);
        break;
      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
      case ErrorDetails.LEVEL_PARSING_ERROR:
        if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? undefined : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {
          this.state = State.IDLE;
        }
        break;
      case ErrorDetails.BUFFER_APPEND_ERROR:
      case ErrorDetails.BUFFER_FULL_ERROR:
        if (!data.parent || data.parent !== "audio") {
          return;
        }
        if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {
          this.resetLoadingState();
          return;
        }
        if (this.reduceLengthAndFlushBuffer(data)) {
          this.bufferedTrack = null;
          super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio");
        }
        break;
      case ErrorDetails.INTERNAL_EXCEPTION:
        this.recoverWorkerError(data);
        break;
    }
  }
  onBufferFlushing(event, {
    type
  }) {
    if (type !== ElementaryStreamTypes.VIDEO) {
      this.flushing = true;
    }
  }
  onBufferFlushed(event, {
    type
  }) {
    if (type !== ElementaryStreamTypes.VIDEO) {
      this.flushing = false;
      this.bufferFlushed = true;
      if (this.state === State.ENDED) {
        this.state = State.IDLE;
      }
      const mediaBuffer = this.mediaBuffer || this.media;
      if (mediaBuffer) {
        this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.AUDIO);
        this.tick();
      }
    }
  }
  _handleTransmuxComplete(transmuxResult) {
    var _id3$samples;
    const id = "audio";
    const {
      hls
    } = this;
    const {
      remuxResult,
      chunkMeta
    } = transmuxResult;
    const context = this.getCurrentContext(chunkMeta);
    if (!context) {
      this.resetWhenMissingContext(chunkMeta);
      return;
    }
    const {
      frag,
      part,
      level
    } = context;
    const {
      details
    } = level;
    const {
      audio,
      text,
      id3,
      initSegment
    } = remuxResult;
    if (this.fragContextChanged(frag) || !details) {
      this.fragmentTracker.removeFragment(frag);
      return;
    }
    this.state = State.PARSING;
    if (this.switchingTrack && audio) {
      this.completeAudioSwitch(this.switchingTrack);
    }
    if (initSegment != null && initSegment.tracks) {
      const mapFragment = frag.initSegment || frag;
      this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);
      hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {
        frag: mapFragment,
        id,
        tracks: initSegment.tracks
      });
    }
    if (audio) {
      const {
        startPTS,
        endPTS,
        startDTS,
        endDTS
      } = audio;
      if (part) {
        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
          startPTS,
          endPTS,
          startDTS,
          endDTS
        };
      }
      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);
      this.bufferFragmentData(audio, frag, part, chunkMeta);
    }
    if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {
      const emittedID3 = _extends({
        id,
        frag,
        details
      }, id3);
      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);
    }
    if (text) {
      const emittedText = _extends({
        id,
        frag,
        details
      }, text);
      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);
    }
  }
  _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
    if (this.state !== State.PARSING) {
      return;
    }
    if (tracks.video) {
      delete tracks.video;
    }
    const track = tracks.audio;
    if (!track) {
      return;
    }
    track.id = "audio";
    const variantAudioCodecs = currentLevel.audioCodec;
    this.log(`Init audio buffer, container:${track.container}, codecs[level/parsed]=[${variantAudioCodecs}/${track.codec}]`);
    if (variantAudioCodecs && variantAudioCodecs.split(",").length === 1) {
      track.levelCodec = variantAudioCodecs;
    }
    this.hls.trigger(Events.BUFFER_CODECS, tracks);
    const initSegment = track.initSegment;
    if (initSegment != null && initSegment.byteLength) {
      const segment = {
        type: "audio",
        frag,
        part: null,
        chunkMeta,
        parent: frag.type,
        data: initSegment
      };
      this.hls.trigger(Events.BUFFER_APPENDING, segment);
    }
    this.tickImmediate();
  }
  loadFragment(frag, track, targetBufferTime) {
    const fragState = this.fragmentTracker.getState(frag);
    this.fragCurrent = frag;
    if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
      var _track$details2;
      if (frag.sn === "initSegment") {
        this._loadInitSegment(frag, track);
      } else if ((_track$details2 = track.details) != null && _track$details2.live && !this.initPTS[frag.cc]) {
        this.log(`Waiting for video PTS in continuity counter ${frag.cc} of live stream before loading audio fragment ${frag.sn} of level ${this.trackId}`);
        this.state = State.WAITING_INIT_PTS;
        const mainDetails = this.mainDetails;
        if (mainDetails && mainDetails.fragments[0].start !== track.details.fragments[0].start) {
          alignMediaPlaylistByPDT(track.details, mainDetails);
        }
      } else {
        this.startFragRequested = true;
        super.loadFragment(frag, track, targetBufferTime);
      }
    } else {
      this.clearTrackerIfNeeded(frag);
    }
  }
  flushAudioIfNeeded(switchingTrack) {
    const {
      media,
      bufferedTrack
    } = this;
    const bufferedAttributes = bufferedTrack == null ? undefined : bufferedTrack.attrs;
    const switchAttributes = switchingTrack.attrs;
    if (media && bufferedAttributes && (bufferedAttributes.CHANNELS !== switchAttributes.CHANNELS || bufferedTrack.name !== switchingTrack.name || bufferedTrack.lang !== switchingTrack.lang)) {
      this.log("Switching audio track : flushing all audio");
      super.flushMainBuffer(0, Number.POSITIVE_INFINITY, "audio");
      this.bufferedTrack = null;
    }
  }
  completeAudioSwitch(switchingTrack) {
    const {
      hls
    } = this;
    this.flushAudioIfNeeded(switchingTrack);
    this.bufferedTrack = switchingTrack;
    this.switchingTrack = null;
    hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));
  }
}

class AudioTrackController extends BasePlaylistController {
  constructor(hls) {
    super(hls, "[audio-track-controller]");
    this.tracks = [];
    this.groupIds = null;
    this.tracksInGroup = [];
    this.trackId = -1;
    this.currentTrack = null;
    this.selectDefaultTrack = true;
    this.registerListeners();
  }
  registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
    hls.on(Events.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
    hls.off(Events.ERROR, this.onError, this);
  }
  destroy() {
    this.unregisterListeners();
    this.tracks.length = 0;
    this.tracksInGroup.length = 0;
    this.currentTrack = null;
    super.destroy();
  }
  onManifestLoading() {
    this.tracks = [];
    this.tracksInGroup = [];
    this.groupIds = null;
    this.currentTrack = null;
    this.trackId = -1;
    this.selectDefaultTrack = true;
  }
  onManifestParsed(event, data) {
    this.tracks = data.audioTracks || [];
  }
  onAudioTrackLoaded(event, data) {
    const {
      id,
      groupId,
      details
    } = data;
    const trackInActiveGroup = this.tracksInGroup[id];
    if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {
      this.warn(`Audio track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? undefined : trackInActiveGroup.groupId}`);
      return;
    }
    const curDetails = trackInActiveGroup.details;
    trackInActiveGroup.details = data.details;
    this.log(`Audio track ${id} "${trackInActiveGroup.name}" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);
    if (id === this.trackId) {
      this.playlistLoaded(id, data, curDetails);
    }
  }
  onLevelLoading(event, data) {
    this.switchLevel(data.level);
  }
  onLevelSwitching(event, data) {
    this.switchLevel(data.level);
  }
  switchLevel(levelIndex) {
    const levelInfo = this.hls.levels[levelIndex];
    if (!levelInfo) {
      return;
    }
    const audioGroups = levelInfo.audioGroups || null;
    const currentGroups = this.groupIds;
    let currentTrack = this.currentTrack;
    if (!audioGroups || (currentGroups == null ? undefined : currentGroups.length) !== (audioGroups == null ? undefined : audioGroups.length) || audioGroups != null && audioGroups.some((groupId) => (currentGroups == null ? undefined : currentGroups.indexOf(groupId)) === -1)) {
      this.groupIds = audioGroups;
      this.trackId = -1;
      this.currentTrack = null;
      const audioTracks = this.tracks.filter((track) => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);
      if (audioTracks.length) {
        if (this.selectDefaultTrack && !audioTracks.some((track) => track.default)) {
          this.selectDefaultTrack = false;
        }
        audioTracks.forEach((track, i) => {
          track.id = i;
        });
      } else if (!currentTrack && !this.tracksInGroup.length) {
        return;
      }
      this.tracksInGroup = audioTracks;
      const audioPreference = this.hls.config.audioPreference;
      if (!currentTrack && audioPreference) {
        const groupIndex = findMatchingOption(audioPreference, audioTracks, audioMatchPredicate);
        if (groupIndex > -1) {
          currentTrack = audioTracks[groupIndex];
        } else {
          const allIndex = findMatchingOption(audioPreference, this.tracks);
          currentTrack = this.tracks[allIndex];
        }
      }
      let trackId = this.findTrackId(currentTrack);
      if (trackId === -1 && currentTrack) {
        trackId = this.findTrackId(null);
      }
      const audioTracksUpdated = {
        audioTracks
      };
      this.log(`Updating audio tracks, ${audioTracks.length} track(s) found in group(s): ${audioGroups == null ? undefined : audioGroups.join(",")}`);
      this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);
      const selectedTrackId = this.trackId;
      if (trackId !== -1 && selectedTrackId === -1) {
        this.setAudioTrack(trackId);
      } else if (audioTracks.length && selectedTrackId === -1) {
        var _this$groupIds;
        const error = new Error(`No audio track selected for current audio group-ID(s): ${(_this$groupIds = this.groupIds) == null ? undefined : _this$groupIds.join(",")} track count: ${audioTracks.length}`);
        this.warn(error.message);
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
          fatal: true,
          error
        });
      }
    } else if (this.shouldReloadPlaylist(currentTrack)) {
      this.setAudioTrack(this.trackId);
    }
  }
  onError(event, data) {
    if (data.fatal || !data.context) {
      return;
    }
    if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {
      this.requestScheduled = -1;
      this.checkRetry(data);
    }
  }
  get allAudioTracks() {
    return this.tracks;
  }
  get audioTracks() {
    return this.tracksInGroup;
  }
  get audioTrack() {
    return this.trackId;
  }
  set audioTrack(newId) {
    this.selectDefaultTrack = false;
    this.setAudioTrack(newId);
  }
  setAudioOption(audioOption) {
    const hls = this.hls;
    hls.config.audioPreference = audioOption;
    if (audioOption) {
      const allAudioTracks = this.allAudioTracks;
      this.selectDefaultTrack = false;
      if (allAudioTracks.length) {
        const currentTrack = this.currentTrack;
        if (currentTrack && matchesOption(audioOption, currentTrack, audioMatchPredicate)) {
          return currentTrack;
        }
        const groupIndex = findMatchingOption(audioOption, this.tracksInGroup, audioMatchPredicate);
        if (groupIndex > -1) {
          const track = this.tracksInGroup[groupIndex];
          this.setAudioTrack(groupIndex);
          return track;
        } else if (currentTrack) {
          let searchIndex = hls.loadLevel;
          if (searchIndex === -1) {
            searchIndex = hls.firstAutoLevel;
          }
          const switchIndex = findClosestLevelWithAudioGroup(audioOption, hls.levels, allAudioTracks, searchIndex, audioMatchPredicate);
          if (switchIndex === -1) {
            return null;
          }
          hls.nextLoadLevel = switchIndex;
        }
        if (audioOption.channels || audioOption.audioCodec) {
          const withoutCodecAndChannelsMatch = findMatchingOption(audioOption, allAudioTracks);
          if (withoutCodecAndChannelsMatch > -1) {
            return allAudioTracks[withoutCodecAndChannelsMatch];
          }
        }
      }
    }
    return null;
  }
  setAudioTrack(newId) {
    const tracks = this.tracksInGroup;
    if (newId < 0 || newId >= tracks.length) {
      this.warn(`Invalid audio track id: ${newId}`);
      return;
    }
    this.clearTimer();
    this.selectDefaultTrack = false;
    const lastTrack = this.currentTrack;
    const track = tracks[newId];
    const trackLoaded = track.details && !track.details.live;
    if (newId === this.trackId && track === lastTrack && trackLoaded) {
      return;
    }
    this.log(`Switching to audio-track ${newId} "${track.name}" lang:${track.lang} group:${track.groupId} channels:${track.channels}`);
    this.trackId = newId;
    this.currentTrack = track;
    this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));
    if (trackLoaded) {
      return;
    }
    const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? undefined : lastTrack.details, track.details);
    this.loadPlaylist(hlsUrlParameters);
  }
  findTrackId(currentTrack) {
    const audioTracks = this.tracksInGroup;
    for (let i = 0;i < audioTracks.length; i++) {
      const track = audioTracks[i];
      if (this.selectDefaultTrack && !track.default) {
        continue;
      }
      if (!currentTrack || matchesOption(currentTrack, track, audioMatchPredicate)) {
        return i;
      }
    }
    if (currentTrack) {
      const {
        name,
        lang,
        assocLang,
        characteristics,
        audioCodec,
        channels
      } = currentTrack;
      for (let i = 0;i < audioTracks.length; i++) {
        const track = audioTracks[i];
        if (matchesOption({
          name,
          lang,
          assocLang,
          characteristics,
          audioCodec,
          channels
        }, track, audioMatchPredicate)) {
          return i;
        }
      }
      for (let i = 0;i < audioTracks.length; i++) {
        const track = audioTracks[i];
        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) {
          return i;
        }
      }
      for (let i = 0;i < audioTracks.length; i++) {
        const track = audioTracks[i];
        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ["LANGUAGE"])) {
          return i;
        }
      }
    }
    return -1;
  }
  loadPlaylist(hlsUrlParameters) {
    const audioTrack = this.currentTrack;
    if (this.shouldLoadPlaylist(audioTrack) && audioTrack) {
      super.loadPlaylist();
      const id = audioTrack.id;
      const groupId = audioTrack.groupId;
      let url = audioTrack.url;
      if (hlsUrlParameters) {
        try {
          url = hlsUrlParameters.addDirectives(url);
        } catch (error) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);
        }
      }
      this.log(`loading audio-track playlist ${id} "${audioTrack.name}" lang:${audioTrack.lang} group:${groupId}`);
      this.clearTimer();
      this.hls.trigger(Events.AUDIO_TRACK_LOADING, {
        url,
        id,
        groupId,
        deliveryDirectives: hlsUrlParameters || null
      });
    }
  }
}
var TICK_INTERVAL$1 = 500;

class SubtitleStreamController extends BaseStreamController {
  constructor(hls, fragmentTracker, keyLoader) {
    super(hls, fragmentTracker, keyLoader, "[subtitle-stream-controller]", PlaylistLevelType.SUBTITLE);
    this.currentTrackId = -1;
    this.tracksBuffered = [];
    this.mainDetails = null;
    this._registerListeners();
  }
  onHandlerDestroying() {
    this._unregisterListeners();
    super.onHandlerDestroying();
    this.mainDetails = null;
  }
  _registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.on(Events.ERROR, this.onError, this);
    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
    hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
    hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  _unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.off(Events.ERROR, this.onError, this);
    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
    hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
    hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  startLoad(startPosition) {
    this.stopLoad();
    this.state = State.IDLE;
    this.setInterval(TICK_INTERVAL$1);
    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
    this.tick();
  }
  onManifestLoading() {
    this.mainDetails = null;
    this.fragmentTracker.removeAllFragments();
  }
  onMediaDetaching() {
    this.tracksBuffered = [];
    super.onMediaDetaching();
  }
  onLevelLoaded(event, data) {
    this.mainDetails = data.details;
  }
  onSubtitleFragProcessed(event, data) {
    const {
      frag,
      success
    } = data;
    this.fragPrevious = frag;
    this.state = State.IDLE;
    if (!success) {
      return;
    }
    const buffered = this.tracksBuffered[this.currentTrackId];
    if (!buffered) {
      return;
    }
    let timeRange;
    const fragStart = frag.start;
    for (let i = 0;i < buffered.length; i++) {
      if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
        timeRange = buffered[i];
        break;
      }
    }
    const fragEnd = frag.start + frag.duration;
    if (timeRange) {
      timeRange.end = fragEnd;
    } else {
      timeRange = {
        start: fragStart,
        end: fragEnd
      };
      buffered.push(timeRange);
    }
    this.fragmentTracker.fragBuffered(frag);
    this.fragBufferedComplete(frag, null);
  }
  onBufferFlushing(event, data) {
    const {
      startOffset,
      endOffset
    } = data;
    if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {
      const endOffsetSubtitles = endOffset - 1;
      if (endOffsetSubtitles <= 0) {
        return;
      }
      data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);
      this.tracksBuffered.forEach((buffered) => {
        for (let i = 0;i < buffered.length; ) {
          if (buffered[i].end <= endOffsetSubtitles) {
            buffered.shift();
            continue;
          } else if (buffered[i].start < endOffsetSubtitles) {
            buffered[i].start = endOffsetSubtitles;
          } else {
            break;
          }
          i++;
        }
      });
      this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);
    }
  }
  onFragBuffered(event, data) {
    if (!this.loadedmetadata && data.frag.type === PlaylistLevelType.MAIN) {
      var _this$media;
      if ((_this$media = this.media) != null && _this$media.buffered.length) {
        this.loadedmetadata = true;
      }
    }
  }
  onError(event, data) {
    const frag = data.frag;
    if ((frag == null ? undefined : frag.type) === PlaylistLevelType.SUBTITLE) {
      if (data.details === ErrorDetails.FRAG_GAP) {
        this.fragmentTracker.fragBuffered(frag, true);
      }
      if (this.fragCurrent) {
        this.fragCurrent.abortRequests();
      }
      if (this.state !== State.STOPPED) {
        this.state = State.IDLE;
      }
    }
  }
  onSubtitleTracksUpdated(event, {
    subtitleTracks
  }) {
    if (this.levels && subtitleOptionsIdentical(this.levels, subtitleTracks)) {
      this.levels = subtitleTracks.map((mediaPlaylist) => new Level(mediaPlaylist));
      return;
    }
    this.tracksBuffered = [];
    this.levels = subtitleTracks.map((mediaPlaylist) => {
      const level = new Level(mediaPlaylist);
      this.tracksBuffered[level.id] = [];
      return level;
    });
    this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);
    this.fragPrevious = null;
    this.mediaBuffer = null;
  }
  onSubtitleTrackSwitch(event, data) {
    var _this$levels;
    this.currentTrackId = data.id;
    if (!((_this$levels = this.levels) != null && _this$levels.length) || this.currentTrackId === -1) {
      this.clearInterval();
      return;
    }
    const currentTrack = this.levels[this.currentTrackId];
    if (currentTrack != null && currentTrack.details) {
      this.mediaBuffer = this.mediaBufferTimeRanges;
    } else {
      this.mediaBuffer = null;
    }
    if (currentTrack) {
      this.setInterval(TICK_INTERVAL$1);
    }
  }
  onSubtitleTrackLoaded(event, data) {
    var _track$details;
    const {
      currentTrackId,
      levels
    } = this;
    const {
      details: newDetails,
      id: trackId
    } = data;
    if (!levels) {
      this.warn(`Subtitle tracks were reset while loading level ${trackId}`);
      return;
    }
    const track = levels[trackId];
    if (trackId >= levels.length || !track) {
      return;
    }
    this.log(`Subtitle track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ""},duration:${newDetails.totalduration}`);
    this.mediaBuffer = this.mediaBufferTimeRanges;
    let sliding = 0;
    if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {
      const mainDetails = this.mainDetails;
      if (newDetails.deltaUpdateFailed || !mainDetails) {
        return;
      }
      const mainSlidingStartFragment = mainDetails.fragments[0];
      if (!track.details) {
        if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
          alignMediaPlaylistByPDT(newDetails, mainDetails);
          sliding = newDetails.fragments[0].start;
        } else if (mainSlidingStartFragment) {
          sliding = mainSlidingStartFragment.start;
          addSliding(newDetails, sliding);
        }
      } else {
        var _this$levelLastLoaded;
        sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? undefined : _this$levelLastLoaded.details);
        if (sliding === 0 && mainSlidingStartFragment) {
          sliding = mainSlidingStartFragment.start;
          addSliding(newDetails, sliding);
        }
      }
    }
    track.details = newDetails;
    this.levelLastLoaded = track;
    if (trackId !== currentTrackId) {
      return;
    }
    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
      this.setStartPosition(this.mainDetails || newDetails, sliding);
    }
    this.tick();
    if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {
      const foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);
      if (!foundFrag) {
        this.warn("Subtitle playlist not aligned with playback");
        track.details = undefined;
      }
    }
  }
  _handleFragmentLoadComplete(fragLoadedData) {
    const {
      frag,
      payload
    } = fragLoadedData;
    const decryptData = frag.decryptdata;
    const hls = this.hls;
    if (this.fragContextChanged(frag)) {
      return;
    }
    if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
      const startTime = performance.now();
      this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch((err) => {
        hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.FRAG_DECRYPT_ERROR,
          fatal: false,
          error: err,
          reason: err.message,
          frag
        });
        throw err;
      }).then((decryptedData) => {
        const endTime = performance.now();
        hls.trigger(Events.FRAG_DECRYPTED, {
          frag,
          payload: decryptedData,
          stats: {
            tstart: startTime,
            tdecrypt: endTime
          }
        });
      }).catch((err) => {
        this.warn(`${err.name}: ${err.message}`);
        this.state = State.IDLE;
      });
    }
  }
  doTick() {
    if (!this.media) {
      this.state = State.IDLE;
      return;
    }
    if (this.state === State.IDLE) {
      const {
        currentTrackId,
        levels
      } = this;
      const track = levels == null ? undefined : levels[currentTrackId];
      if (!track || !levels.length || !track.details) {
        return;
      }
      const {
        config
      } = this;
      const currentTime = this.getLoadPosition();
      const bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);
      const {
        end: targetBufferTime,
        len: bufferLen
      } = bufferedInfo;
      const mainBufferInfo = this.getFwdBufferInfo(this.media, PlaylistLevelType.MAIN);
      const trackDetails = track.details;
      const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? undefined : mainBufferInfo.len) + trackDetails.levelTargetDuration;
      if (bufferLen > maxBufLen) {
        return;
      }
      const fragments = trackDetails.fragments;
      const fragLen = fragments.length;
      const end = trackDetails.edge;
      let foundFrag = null;
      const fragPrevious = this.fragPrevious;
      if (targetBufferTime < end) {
        const tolerance = config.maxFragLookUpTolerance;
        const lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;
        foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);
        if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {
          foundFrag = fragments[0];
        }
      } else {
        foundFrag = fragments[fragLen - 1];
      }
      if (!foundFrag) {
        return;
      }
      foundFrag = this.mapToInitFragWhenRequired(foundFrag);
      if (foundFrag.sn !== "initSegment") {
        const curSNIdx = foundFrag.sn - trackDetails.startSN;
        const prevFrag = fragments[curSNIdx - 1];
        if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {
          foundFrag = prevFrag;
        }
      }
      if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {
        this.loadFragment(foundFrag, track, targetBufferTime);
      }
    }
  }
  getMaxBufferLength(mainBufferLength) {
    const maxConfigBuffer = super.getMaxBufferLength();
    if (!mainBufferLength) {
      return maxConfigBuffer;
    }
    return Math.max(maxConfigBuffer, mainBufferLength);
  }
  loadFragment(frag, level, targetBufferTime) {
    this.fragCurrent = frag;
    if (frag.sn === "initSegment") {
      this._loadInitSegment(frag, level);
    } else {
      this.startFragRequested = true;
      super.loadFragment(frag, level, targetBufferTime);
    }
  }
  get mediaBufferTimeRanges() {
    return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);
  }
}

class BufferableInstance {
  constructor(timeranges) {
    this.buffered = undefined;
    const getRange = (name, index, length) => {
      index = index >>> 0;
      if (index > length - 1) {
        throw new DOMException(`Failed to execute '${name}' on 'TimeRanges': The index provided (${index}) is greater than the maximum bound (${length})`);
      }
      return timeranges[index][name];
    };
    this.buffered = {
      get length() {
        return timeranges.length;
      },
      end(index) {
        return getRange("end", index, timeranges.length);
      },
      start(index) {
        return getRange("start", index, timeranges.length);
      }
    };
  }
}

class SubtitleTrackController extends BasePlaylistController {
  constructor(hls) {
    super(hls, "[subtitle-track-controller]");
    this.media = null;
    this.tracks = [];
    this.groupIds = null;
    this.tracksInGroup = [];
    this.trackId = -1;
    this.currentTrack = null;
    this.selectDefaultTrack = true;
    this.queuedDefaultTrack = -1;
    this.asyncPollTrackChange = () => this.pollTrackChange(0);
    this.useTextTrackPolling = false;
    this.subtitlePollingInterval = -1;
    this._subtitleDisplay = true;
    this.onTextTracksChanged = () => {
      if (!this.useTextTrackPolling) {
        self.clearInterval(this.subtitlePollingInterval);
      }
      if (!this.media || !this.hls.config.renderTextTracksNatively) {
        return;
      }
      let textTrack = null;
      const tracks = filterSubtitleTracks(this.media.textTracks);
      for (let i = 0;i < tracks.length; i++) {
        if (tracks[i].mode === "hidden") {
          textTrack = tracks[i];
        } else if (tracks[i].mode === "showing") {
          textTrack = tracks[i];
          break;
        }
      }
      const trackId = this.findTrackForTextTrack(textTrack);
      if (this.subtitleTrack !== trackId) {
        this.setSubtitleTrack(trackId);
      }
    };
    this.registerListeners();
  }
  destroy() {
    this.unregisterListeners();
    this.tracks.length = 0;
    this.tracksInGroup.length = 0;
    this.currentTrack = null;
    this.onTextTracksChanged = this.asyncPollTrackChange = null;
    super.destroy();
  }
  get subtitleDisplay() {
    return this._subtitleDisplay;
  }
  set subtitleDisplay(value) {
    this._subtitleDisplay = value;
    if (this.trackId > -1) {
      this.toggleTrackModes();
    }
  }
  registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
    hls.on(Events.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
    hls.off(Events.ERROR, this.onError, this);
  }
  onMediaAttached(event, data) {
    this.media = data.media;
    if (!this.media) {
      return;
    }
    if (this.queuedDefaultTrack > -1) {
      this.subtitleTrack = this.queuedDefaultTrack;
      this.queuedDefaultTrack = -1;
    }
    this.useTextTrackPolling = !(this.media.textTracks && ("onchange" in this.media.textTracks));
    if (this.useTextTrackPolling) {
      this.pollTrackChange(500);
    } else {
      this.media.textTracks.addEventListener("change", this.asyncPollTrackChange);
    }
  }
  pollTrackChange(timeout) {
    self.clearInterval(this.subtitlePollingInterval);
    this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, timeout);
  }
  onMediaDetaching() {
    if (!this.media) {
      return;
    }
    self.clearInterval(this.subtitlePollingInterval);
    if (!this.useTextTrackPolling) {
      this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange);
    }
    if (this.trackId > -1) {
      this.queuedDefaultTrack = this.trackId;
    }
    const textTracks = filterSubtitleTracks(this.media.textTracks);
    textTracks.forEach((track) => {
      clearCurrentCues(track);
    });
    this.subtitleTrack = -1;
    this.media = null;
  }
  onManifestLoading() {
    this.tracks = [];
    this.groupIds = null;
    this.tracksInGroup = [];
    this.trackId = -1;
    this.currentTrack = null;
    this.selectDefaultTrack = true;
  }
  onManifestParsed(event, data) {
    this.tracks = data.subtitleTracks;
  }
  onSubtitleTrackLoaded(event, data) {
    const {
      id,
      groupId,
      details
    } = data;
    const trackInActiveGroup = this.tracksInGroup[id];
    if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {
      this.warn(`Subtitle track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? undefined : trackInActiveGroup.groupId}`);
      return;
    }
    const curDetails = trackInActiveGroup.details;
    trackInActiveGroup.details = data.details;
    this.log(`Subtitle track ${id} "${trackInActiveGroup.name}" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);
    if (id === this.trackId) {
      this.playlistLoaded(id, data, curDetails);
    }
  }
  onLevelLoading(event, data) {
    this.switchLevel(data.level);
  }
  onLevelSwitching(event, data) {
    this.switchLevel(data.level);
  }
  switchLevel(levelIndex) {
    const levelInfo = this.hls.levels[levelIndex];
    if (!levelInfo) {
      return;
    }
    const subtitleGroups = levelInfo.subtitleGroups || null;
    const currentGroups = this.groupIds;
    let currentTrack = this.currentTrack;
    if (!subtitleGroups || (currentGroups == null ? undefined : currentGroups.length) !== (subtitleGroups == null ? undefined : subtitleGroups.length) || subtitleGroups != null && subtitleGroups.some((groupId) => (currentGroups == null ? undefined : currentGroups.indexOf(groupId)) === -1)) {
      this.groupIds = subtitleGroups;
      this.trackId = -1;
      this.currentTrack = null;
      const subtitleTracks = this.tracks.filter((track) => !subtitleGroups || subtitleGroups.indexOf(track.groupId) !== -1);
      if (subtitleTracks.length) {
        if (this.selectDefaultTrack && !subtitleTracks.some((track) => track.default)) {
          this.selectDefaultTrack = false;
        }
        subtitleTracks.forEach((track, i) => {
          track.id = i;
        });
      } else if (!currentTrack && !this.tracksInGroup.length) {
        return;
      }
      this.tracksInGroup = subtitleTracks;
      const subtitlePreference = this.hls.config.subtitlePreference;
      if (!currentTrack && subtitlePreference) {
        this.selectDefaultTrack = false;
        const groupIndex = findMatchingOption(subtitlePreference, subtitleTracks);
        if (groupIndex > -1) {
          currentTrack = subtitleTracks[groupIndex];
        } else {
          const allIndex = findMatchingOption(subtitlePreference, this.tracks);
          currentTrack = this.tracks[allIndex];
        }
      }
      let trackId = this.findTrackId(currentTrack);
      if (trackId === -1 && currentTrack) {
        trackId = this.findTrackId(null);
      }
      const subtitleTracksUpdated = {
        subtitleTracks
      };
      this.log(`Updating subtitle tracks, ${subtitleTracks.length} track(s) found in "${subtitleGroups == null ? undefined : subtitleGroups.join(",")}" group-id`);
      this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);
      if (trackId !== -1 && this.trackId === -1) {
        this.setSubtitleTrack(trackId);
      }
    } else if (this.shouldReloadPlaylist(currentTrack)) {
      this.setSubtitleTrack(this.trackId);
    }
  }
  findTrackId(currentTrack) {
    const tracks = this.tracksInGroup;
    const selectDefault = this.selectDefaultTrack;
    for (let i = 0;i < tracks.length; i++) {
      const track = tracks[i];
      if (selectDefault && !track.default || !selectDefault && !currentTrack) {
        continue;
      }
      if (!currentTrack || matchesOption(track, currentTrack)) {
        return i;
      }
    }
    if (currentTrack) {
      for (let i = 0;i < tracks.length; i++) {
        const track = tracks[i];
        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) {
          return i;
        }
      }
      for (let i = 0;i < tracks.length; i++) {
        const track = tracks[i];
        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ["LANGUAGE"])) {
          return i;
        }
      }
    }
    return -1;
  }
  findTrackForTextTrack(textTrack) {
    if (textTrack) {
      const tracks = this.tracksInGroup;
      for (let i = 0;i < tracks.length; i++) {
        const track = tracks[i];
        if (subtitleTrackMatchesTextTrack(track, textTrack)) {
          return i;
        }
      }
    }
    return -1;
  }
  onError(event, data) {
    if (data.fatal || !data.context) {
      return;
    }
    if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {
      this.checkRetry(data);
    }
  }
  get allSubtitleTracks() {
    return this.tracks;
  }
  get subtitleTracks() {
    return this.tracksInGroup;
  }
  get subtitleTrack() {
    return this.trackId;
  }
  set subtitleTrack(newId) {
    this.selectDefaultTrack = false;
    this.setSubtitleTrack(newId);
  }
  setSubtitleOption(subtitleOption) {
    this.hls.config.subtitlePreference = subtitleOption;
    if (subtitleOption) {
      const allSubtitleTracks = this.allSubtitleTracks;
      this.selectDefaultTrack = false;
      if (allSubtitleTracks.length) {
        const currentTrack = this.currentTrack;
        if (currentTrack && matchesOption(subtitleOption, currentTrack)) {
          return currentTrack;
        }
        const groupIndex = findMatchingOption(subtitleOption, this.tracksInGroup);
        if (groupIndex > -1) {
          const track = this.tracksInGroup[groupIndex];
          this.setSubtitleTrack(groupIndex);
          return track;
        } else if (currentTrack) {
          return null;
        } else {
          const allIndex = findMatchingOption(subtitleOption, allSubtitleTracks);
          if (allIndex > -1) {
            return allSubtitleTracks[allIndex];
          }
        }
      }
    }
    return null;
  }
  loadPlaylist(hlsUrlParameters) {
    super.loadPlaylist();
    const currentTrack = this.currentTrack;
    if (this.shouldLoadPlaylist(currentTrack) && currentTrack) {
      const id = currentTrack.id;
      const groupId = currentTrack.groupId;
      let url = currentTrack.url;
      if (hlsUrlParameters) {
        try {
          url = hlsUrlParameters.addDirectives(url);
        } catch (error) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);
        }
      }
      this.log(`Loading subtitle playlist for id ${id}`);
      this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {
        url,
        id,
        groupId,
        deliveryDirectives: hlsUrlParameters || null
      });
    }
  }
  toggleTrackModes() {
    const {
      media
    } = this;
    if (!media) {
      return;
    }
    const textTracks = filterSubtitleTracks(media.textTracks);
    const currentTrack = this.currentTrack;
    let nextTrack;
    if (currentTrack) {
      nextTrack = textTracks.filter((textTrack) => subtitleTrackMatchesTextTrack(currentTrack, textTrack))[0];
      if (!nextTrack) {
        this.warn(`Unable to find subtitle TextTrack with name "${currentTrack.name}" and language "${currentTrack.lang}"`);
      }
    }
    [].slice.call(textTracks).forEach((track) => {
      if (track.mode !== "disabled" && track !== nextTrack) {
        track.mode = "disabled";
      }
    });
    if (nextTrack) {
      const mode = this.subtitleDisplay ? "showing" : "hidden";
      if (nextTrack.mode !== mode) {
        nextTrack.mode = mode;
      }
    }
  }
  setSubtitleTrack(newId) {
    const tracks = this.tracksInGroup;
    if (!this.media) {
      this.queuedDefaultTrack = newId;
      return;
    }
    if (newId < -1 || newId >= tracks.length || !isFiniteNumber(newId)) {
      this.warn(`Invalid subtitle track id: ${newId}`);
      return;
    }
    this.clearTimer();
    this.selectDefaultTrack = false;
    const lastTrack = this.currentTrack;
    const track = tracks[newId] || null;
    this.trackId = newId;
    this.currentTrack = track;
    this.toggleTrackModes();
    if (!track) {
      this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {
        id: newId
      });
      return;
    }
    const trackLoaded = !!track.details && !track.details.live;
    if (newId === this.trackId && track === lastTrack && trackLoaded) {
      return;
    }
    this.log(`Switching to subtitle-track ${newId}` + (track ? ` "${track.name}" lang:${track.lang} group:${track.groupId}` : ""));
    const {
      id,
      groupId = "",
      name,
      type,
      url
    } = track;
    this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {
      id,
      groupId,
      name,
      type,
      url
    });
    const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? undefined : lastTrack.details, track.details);
    this.loadPlaylist(hlsUrlParameters);
  }
}

class BufferOperationQueue {
  constructor(sourceBufferReference) {
    this.buffers = undefined;
    this.queues = {
      video: [],
      audio: [],
      audiovideo: []
    };
    this.buffers = sourceBufferReference;
  }
  append(operation, type, pending) {
    const queue = this.queues[type];
    queue.push(operation);
    if (queue.length === 1 && !pending) {
      this.executeNext(type);
    }
  }
  insertAbort(operation, type) {
    const queue = this.queues[type];
    queue.unshift(operation);
    this.executeNext(type);
  }
  appendBlocker(type) {
    let execute;
    const promise = new Promise((resolve) => {
      execute = resolve;
    });
    const operation = {
      execute,
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: () => {
      }
    };
    this.append(operation, type);
    return promise;
  }
  executeNext(type) {
    const queue = this.queues[type];
    if (queue.length) {
      const operation = queue[0];
      try {
        operation.execute();
      } catch (error) {
        logger.warn(`[buffer-operation-queue]: Exception executing "${type}" SourceBuffer operation: ${error}`);
        operation.onError(error);
        const sb = this.buffers[type];
        if (!(sb != null && sb.updating)) {
          this.shiftAndExecuteNext(type);
        }
      }
    }
  }
  shiftAndExecuteNext(type) {
    this.queues[type].shift();
    this.executeNext(type);
  }
  current(type) {
    return this.queues[type][0];
  }
}
var VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/;

class BufferController {
  constructor(hls) {
    this.details = null;
    this._objectUrl = null;
    this.operationQueue = undefined;
    this.listeners = undefined;
    this.hls = undefined;
    this.bufferCodecEventsExpected = 0;
    this._bufferCodecEventsTotal = 0;
    this.media = null;
    this.mediaSource = null;
    this.lastMpegAudioChunk = null;
    this.appendSource = undefined;
    this.appendErrors = {
      audio: 0,
      video: 0,
      audiovideo: 0
    };
    this.tracks = {};
    this.pendingTracks = {};
    this.sourceBuffer = undefined;
    this.log = undefined;
    this.warn = undefined;
    this.error = undefined;
    this._onEndStreaming = (event) => {
      if (!this.hls) {
        return;
      }
      this.hls.pauseBuffering();
    };
    this._onStartStreaming = (event) => {
      if (!this.hls) {
        return;
      }
      this.hls.resumeBuffering();
    };
    this._onMediaSourceOpen = () => {
      const {
        media,
        mediaSource
      } = this;
      this.log("Media source opened");
      if (media) {
        media.removeEventListener("emptied", this._onMediaEmptied);
        this.updateMediaElementDuration();
        this.hls.trigger(Events.MEDIA_ATTACHED, {
          media,
          mediaSource
        });
      }
      if (mediaSource) {
        mediaSource.removeEventListener("sourceopen", this._onMediaSourceOpen);
      }
      this.checkPendingTracks();
    };
    this._onMediaSourceClose = () => {
      this.log("Media source closed");
    };
    this._onMediaSourceEnded = () => {
      this.log("Media source ended");
    };
    this._onMediaEmptied = () => {
      const {
        mediaSrc,
        _objectUrl
      } = this;
      if (mediaSrc !== _objectUrl) {
        logger.error(`Media element src was set while attaching MediaSource (${_objectUrl} > ${mediaSrc})`);
      }
    };
    this.hls = hls;
    const logPrefix = "[buffer-controller]";
    this.appendSource = isManagedMediaSource(getMediaSource(hls.config.preferManagedMediaSource));
    this.log = logger.log.bind(logger, logPrefix);
    this.warn = logger.warn.bind(logger, logPrefix);
    this.error = logger.error.bind(logger, logPrefix);
    this._initSourceBuffer();
    this.registerListeners();
  }
  hasSourceTypes() {
    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;
  }
  destroy() {
    this.unregisterListeners();
    this.details = null;
    this.lastMpegAudioChunk = null;
    this.hls = null;
  }
  registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);
    hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);
    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
    hls.on(Events.BUFFER_EOS, this.onBufferEos, this);
    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    hls.on(Events.FRAG_PARSED, this.onFragParsed, this);
    hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);
  }
  unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);
    hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);
    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
    hls.off(Events.BUFFER_EOS, this.onBufferEos, this);
    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
    hls.off(Events.FRAG_PARSED, this.onFragParsed, this);
    hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);
  }
  _initSourceBuffer() {
    this.sourceBuffer = {};
    this.operationQueue = new BufferOperationQueue(this.sourceBuffer);
    this.listeners = {
      audio: [],
      video: [],
      audiovideo: []
    };
    this.appendErrors = {
      audio: 0,
      video: 0,
      audiovideo: 0
    };
    this.lastMpegAudioChunk = null;
  }
  onManifestLoading() {
    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;
    this.details = null;
  }
  onManifestParsed(event, data) {
    let codecEvents = 2;
    if (data.audio && !data.video || !data.altAudio || false) {
      codecEvents = 1;
    }
    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;
    this.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`);
  }
  onMediaAttaching(event, data) {
    const media = this.media = data.media;
    const MediaSource = getMediaSource(this.appendSource);
    if (media && MediaSource) {
      var _ms$constructor;
      const ms = this.mediaSource = new MediaSource;
      this.log(`created media source: ${(_ms$constructor = ms.constructor) == null ? undefined : _ms$constructor.name}`);
      ms.addEventListener("sourceopen", this._onMediaSourceOpen);
      ms.addEventListener("sourceended", this._onMediaSourceEnded);
      ms.addEventListener("sourceclose", this._onMediaSourceClose);
      if (this.appendSource) {
        ms.addEventListener("startstreaming", this._onStartStreaming);
        ms.addEventListener("endstreaming", this._onEndStreaming);
      }
      const objectUrl = this._objectUrl = self.URL.createObjectURL(ms);
      if (this.appendSource) {
        try {
          media.removeAttribute("src");
          const MMS = self.ManagedMediaSource;
          media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;
          removeSourceChildren(media);
          addSource(media, objectUrl);
          media.load();
        } catch (error) {
          media.src = objectUrl;
        }
      } else {
        media.src = objectUrl;
      }
      media.addEventListener("emptied", this._onMediaEmptied);
    }
  }
  onMediaDetaching() {
    const {
      media,
      mediaSource,
      _objectUrl
    } = this;
    if (mediaSource) {
      this.log("media source detaching");
      if (mediaSource.readyState === "open") {
        try {
          mediaSource.endOfStream();
        } catch (err) {
          this.warn(`onMediaDetaching: ${err.message} while calling endOfStream`);
        }
      }
      this.onBufferReset();
      mediaSource.removeEventListener("sourceopen", this._onMediaSourceOpen);
      mediaSource.removeEventListener("sourceended", this._onMediaSourceEnded);
      mediaSource.removeEventListener("sourceclose", this._onMediaSourceClose);
      if (this.appendSource) {
        mediaSource.removeEventListener("startstreaming", this._onStartStreaming);
        mediaSource.removeEventListener("endstreaming", this._onEndStreaming);
      }
      if (media) {
        media.removeEventListener("emptied", this._onMediaEmptied);
        if (_objectUrl) {
          self.URL.revokeObjectURL(_objectUrl);
        }
        if (this.mediaSrc === _objectUrl) {
          media.removeAttribute("src");
          if (this.appendSource) {
            removeSourceChildren(media);
          }
          media.load();
        } else {
          this.warn("media|source.src was changed by a third party - skip cleanup");
        }
      }
      this.mediaSource = null;
      this.media = null;
      this._objectUrl = null;
      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;
      this.pendingTracks = {};
      this.tracks = {};
    }
    this.hls.trigger(Events.MEDIA_DETACHED, undefined);
  }
  onBufferReset() {
    this.getSourceBufferTypes().forEach((type) => {
      this.resetBuffer(type);
    });
    this._initSourceBuffer();
  }
  resetBuffer(type) {
    const sb = this.sourceBuffer[type];
    try {
      if (sb) {
        var _this$mediaSource;
        this.removeBufferListeners(type);
        this.sourceBuffer[type] = undefined;
        if ((_this$mediaSource = this.mediaSource) != null && _this$mediaSource.sourceBuffers.length) {
          this.mediaSource.removeSourceBuffer(sb);
        }
      }
    } catch (err) {
      this.warn(`onBufferReset ${type}`, err);
    }
  }
  onBufferCodecs(event, data) {
    const sourceBufferCount = this.getSourceBufferTypes().length;
    const trackNames = Object.keys(data);
    trackNames.forEach((trackName) => {
      if (sourceBufferCount) {
        const track = this.tracks[trackName];
        if (track && typeof track.buffer.changeType === "function") {
          var _trackCodec;
          const {
            id,
            codec,
            levelCodec,
            container,
            metadata
          } = data[trackName];
          const currentCodecFull = pickMostCompleteCodecName(track.codec, track.levelCodec);
          const currentCodec = currentCodecFull == null ? undefined : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, "$1");
          let trackCodec = pickMostCompleteCodecName(codec, levelCodec);
          const nextCodec = (_trackCodec = trackCodec) == null ? undefined : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, "$1");
          if (trackCodec && currentCodec !== nextCodec) {
            if (trackName.slice(0, 5) === "audio") {
              trackCodec = getCodecCompatibleName(trackCodec, this.appendSource);
            }
            const mimeType = `${container};codecs=${trackCodec}`;
            this.appendChangeType(trackName, mimeType);
            this.log(`switching codec ${currentCodecFull} to ${trackCodec}`);
            this.tracks[trackName] = {
              buffer: track.buffer,
              codec,
              container,
              levelCodec,
              metadata,
              id
            };
          }
        }
      } else {
        this.pendingTracks[trackName] = data[trackName];
      }
    });
    if (sourceBufferCount) {
      return;
    }
    const bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
    if (this.bufferCodecEventsExpected !== bufferCodecEventsExpected) {
      this.log(`${bufferCodecEventsExpected} bufferCodec event(s) expected ${trackNames.join(",")}`);
      this.bufferCodecEventsExpected = bufferCodecEventsExpected;
    }
    if (this.mediaSource && this.mediaSource.readyState === "open") {
      this.checkPendingTracks();
    }
  }
  appendChangeType(type, mimeType) {
    const {
      operationQueue
    } = this;
    const operation = {
      execute: () => {
        const sb = this.sourceBuffer[type];
        if (sb) {
          this.log(`changing ${type} sourceBuffer type to ${mimeType}`);
          sb.changeType(mimeType);
        }
        operationQueue.shiftAndExecuteNext(type);
      },
      onStart: () => {
      },
      onComplete: () => {
      },
      onError: (error) => {
        this.warn(`Failed to change ${type} SourceBuffer type`, error);
      }
    };
    operationQueue.append(operation, type, !!this.pendingTracks[type]);
  }
  onBufferAppending(event, eventData) {
    const {
      hls,
      operationQueue,
      tracks
    } = this;
    const {
      data,
      type,
      frag,
      part,
      chunkMeta
    } = eventData;
    const chunkStats = chunkMeta.buffering[type];
    const bufferAppendingStart = self.performance.now();
    chunkStats.start = bufferAppendingStart;
    const fragBuffering = frag.stats.buffering;
    const partBuffering = part ? part.stats.buffering : null;
    if (fragBuffering.start === 0) {
      fragBuffering.start = bufferAppendingStart;
    }
    if (partBuffering && partBuffering.start === 0) {
      partBuffering.start = bufferAppendingStart;
    }
    const audioTrack = tracks.audio;
    let checkTimestampOffset = false;
    if (type === "audio" && (audioTrack == null ? undefined : audioTrack.container) === "audio/mpeg") {
      checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;
      this.lastMpegAudioChunk = chunkMeta;
    }
    const fragStart = frag.start;
    const operation = {
      execute: () => {
        chunkStats.executeStart = self.performance.now();
        if (checkTimestampOffset) {
          const sb = this.sourceBuffer[type];
          if (sb) {
            const delta = fragStart - sb.timestampOffset;
            if (Math.abs(delta) >= 0.1) {
              this.log(`Updating audio SourceBuffer timestampOffset to ${fragStart} (delta: ${delta}) sn: ${frag.sn})`);
              sb.timestampOffset = fragStart;
            }
          }
        }
        this.appendExecutor(data, type);
      },
      onStart: () => {
      },
      onComplete: () => {
        const end = self.performance.now();
        chunkStats.executeEnd = chunkStats.end = end;
        if (fragBuffering.first === 0) {
          fragBuffering.first = end;
        }
        if (partBuffering && partBuffering.first === 0) {
          partBuffering.first = end;
        }
        const {
          sourceBuffer
        } = this;
        const timeRanges = {};
        for (const type2 in sourceBuffer) {
          timeRanges[type2] = BufferHelper.getBuffered(sourceBuffer[type2]);
        }
        this.appendErrors[type] = 0;
        if (type === "audio" || type === "video") {
          this.appendErrors.audiovideo = 0;
        } else {
          this.appendErrors.audio = 0;
          this.appendErrors.video = 0;
        }
        this.hls.trigger(Events.BUFFER_APPENDED, {
          type,
          frag,
          part,
          chunkMeta,
          parent: frag.type,
          timeRanges
        });
      },
      onError: (error) => {
        const event2 = {
          type: ErrorTypes.MEDIA_ERROR,
          parent: frag.type,
          details: ErrorDetails.BUFFER_APPEND_ERROR,
          sourceBufferName: type,
          frag,
          part,
          chunkMeta,
          error,
          err: error,
          fatal: false
        };
        if (error.code === DOMException.QUOTA_EXCEEDED_ERR) {
          event2.details = ErrorDetails.BUFFER_FULL_ERROR;
        } else {
          const appendErrorCount = ++this.appendErrors[type];
          event2.details = ErrorDetails.BUFFER_APPEND_ERROR;
          this.warn(`Failed ${appendErrorCount}/${hls.config.appendErrorMaxRetry} times to append segment in "${type}" sourceBuffer`);
          if (appendErrorCount >= hls.config.appendErrorMaxRetry) {
            event2.fatal = true;
          }
        }
        hls.trigger(Events.ERROR, event2);
      }
    };
    operationQueue.append(operation, type, !!this.pendingTracks[type]);
  }
  onBufferFlushing(event, data) {
    const {
      operationQueue
    } = this;
    const flushOperation = (type) => ({
      execute: this.removeExecutor.bind(this, type, data.startOffset, data.endOffset),
      onStart: () => {
      },
      onComplete: () => {
        this.hls.trigger(Events.BUFFER_FLUSHED, {
          type
        });
      },
      onError: (error) => {
        this.warn(`Failed to remove from ${type} SourceBuffer`, error);
      }
    });
    if (data.type) {
      operationQueue.append(flushOperation(data.type), data.type);
    } else {
      this.getSourceBufferTypes().forEach((type) => {
        operationQueue.append(flushOperation(type), type);
      });
    }
  }
  onFragParsed(event, data) {
    const {
      frag,
      part
    } = data;
    const buffersAppendedTo = [];
    const elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;
    if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {
      buffersAppendedTo.push("audiovideo");
    } else {
      if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {
        buffersAppendedTo.push("audio");
      }
      if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {
        buffersAppendedTo.push("video");
      }
    }
    const onUnblocked = () => {
      const now2 = self.performance.now();
      frag.stats.buffering.end = now2;
      if (part) {
        part.stats.buffering.end = now2;
      }
      const stats = part ? part.stats : frag.stats;
      this.hls.trigger(Events.FRAG_BUFFERED, {
        frag,
        part,
        stats,
        id: frag.type
      });
    };
    if (buffersAppendedTo.length === 0) {
      this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${frag.type} level: ${frag.level} sn: ${frag.sn}`);
    }
    this.blockBuffers(onUnblocked, buffersAppendedTo);
  }
  onFragChanged(event, data) {
    this.trimBuffers();
  }
  onBufferEos(event, data) {
    const ended = this.getSourceBufferTypes().reduce((acc, type) => {
      const sb = this.sourceBuffer[type];
      if (sb && (!data.type || data.type === type)) {
        sb.ending = true;
        if (!sb.ended) {
          sb.ended = true;
          this.log(`${type} sourceBuffer now EOS`);
        }
      }
      return acc && !!(!sb || sb.ended);
    }, true);
    if (ended) {
      this.log(`Queueing mediaSource.endOfStream()`);
      this.blockBuffers(() => {
        this.getSourceBufferTypes().forEach((type) => {
          const sb = this.sourceBuffer[type];
          if (sb) {
            sb.ending = false;
          }
        });
        const {
          mediaSource
        } = this;
        if (!mediaSource || mediaSource.readyState !== "open") {
          if (mediaSource) {
            this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${mediaSource.readyState}`);
          }
          return;
        }
        this.log(`Calling mediaSource.endOfStream()`);
        mediaSource.endOfStream();
      });
    }
  }
  onLevelUpdated(event, {
    details
  }) {
    if (!details.fragments.length) {
      return;
    }
    this.details = details;
    if (this.getSourceBufferTypes().length) {
      this.blockBuffers(this.updateMediaElementDuration.bind(this));
    } else {
      this.updateMediaElementDuration();
    }
  }
  trimBuffers() {
    const {
      hls,
      details,
      media
    } = this;
    if (!media || details === null) {
      return;
    }
    const sourceBufferTypes = this.getSourceBufferTypes();
    if (!sourceBufferTypes.length) {
      return;
    }
    const config = hls.config;
    const currentTime = media.currentTime;
    const targetDuration = details.levelTargetDuration;
    const backBufferLength = details.live && config.liveBackBufferLength !== null ? config.liveBackBufferLength : config.backBufferLength;
    if (isFiniteNumber(backBufferLength) && backBufferLength > 0) {
      const maxBackBufferLength = Math.max(backBufferLength, targetDuration);
      const targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;
      this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);
    }
    if (isFiniteNumber(config.frontBufferFlushThreshold) && config.frontBufferFlushThreshold > 0) {
      const frontBufferLength = Math.max(config.maxBufferLength, config.frontBufferFlushThreshold);
      const maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);
      const targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;
      this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);
    }
  }
  flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {
    const {
      details,
      sourceBuffer
    } = this;
    const sourceBufferTypes = this.getSourceBufferTypes();
    sourceBufferTypes.forEach((type) => {
      const sb = sourceBuffer[type];
      if (sb) {
        const buffered = BufferHelper.getBuffered(sb);
        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
          this.hls.trigger(Events.BACK_BUFFER_REACHED, {
            bufferEnd: targetBackBufferPosition
          });
          if (details != null && details.live) {
            this.hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {
              bufferEnd: targetBackBufferPosition
            });
          } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {
            this.log(`Cannot flush ${type} back buffer while SourceBuffer is in ended state`);
            return;
          }
          this.hls.trigger(Events.BUFFER_FLUSHING, {
            startOffset: 0,
            endOffset: targetBackBufferPosition,
            type
          });
        }
      }
    });
  }
  flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {
    const {
      sourceBuffer
    } = this;
    const sourceBufferTypes = this.getSourceBufferTypes();
    sourceBufferTypes.forEach((type) => {
      const sb = sourceBuffer[type];
      if (sb) {
        const buffered = BufferHelper.getBuffered(sb);
        const numBufferedRanges = buffered.length;
        if (numBufferedRanges < 2) {
          return;
        }
        const bufferStart = buffered.start(numBufferedRanges - 1);
        const bufferEnd = buffered.end(numBufferedRanges - 1);
        if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {
          return;
        } else if (sb.ended && currentTime - bufferEnd < 2 * targetDuration) {
          this.log(`Cannot flush ${type} front buffer while SourceBuffer is in ended state`);
          return;
        }
        this.hls.trigger(Events.BUFFER_FLUSHING, {
          startOffset: bufferStart,
          endOffset: Infinity,
          type
        });
      }
    });
  }
  updateMediaElementDuration() {
    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== "open") {
      return;
    }
    const {
      details,
      hls,
      media,
      mediaSource
    } = this;
    const levelDuration = details.fragments[0].start + details.totalduration;
    const mediaDuration = media.duration;
    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;
    if (details.live && hls.config.liveDurationInfinity) {
      mediaSource.duration = Infinity;
      this.updateSeekableRange(details);
    } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {
      this.log(`Updating Media Source duration to ${levelDuration.toFixed(3)}`);
      mediaSource.duration = levelDuration;
    }
  }
  updateSeekableRange(levelDetails) {
    const mediaSource = this.mediaSource;
    const fragments = levelDetails.fragments;
    const len = fragments.length;
    if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {
      const start = Math.max(0, fragments[0].start);
      const end = Math.max(start, start + levelDetails.totalduration);
      this.log(`Media Source duration is set to ${mediaSource.duration}. Setting seekable range to ${start}-${end}.`);
      mediaSource.setLiveSeekableRange(start, end);
    }
  }
  checkPendingTracks() {
    const {
      bufferCodecEventsExpected,
      operationQueue,
      pendingTracks
    } = this;
    const pendingTracksCount = Object.keys(pendingTracks).length;
    if (pendingTracksCount && (!bufferCodecEventsExpected || pendingTracksCount === 2 || ("audiovideo" in pendingTracks))) {
      this.createSourceBuffers(pendingTracks);
      this.pendingTracks = {};
      const buffers = this.getSourceBufferTypes();
      if (buffers.length) {
        this.hls.trigger(Events.BUFFER_CREATED, {
          tracks: this.tracks
        });
        buffers.forEach((type) => {
          operationQueue.executeNext(type);
        });
      } else {
        const error = new Error("could not create source buffer for media codec(s)");
        this.hls.trigger(Events.ERROR, {
          type: ErrorTypes.MEDIA_ERROR,
          details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,
          fatal: true,
          error,
          reason: error.message
        });
      }
    }
  }
  createSourceBuffers(tracks) {
    const {
      sourceBuffer,
      mediaSource
    } = this;
    if (!mediaSource) {
      throw Error("createSourceBuffers called when mediaSource was null");
    }
    for (const trackName in tracks) {
      if (!sourceBuffer[trackName]) {
        var _track$levelCodec;
        const track = tracks[trackName];
        if (!track) {
          throw Error(`source buffer exists for track ${trackName}, however track does not`);
        }
        let codec = ((_track$levelCodec = track.levelCodec) == null ? undefined : _track$levelCodec.indexOf(",")) === -1 ? track.levelCodec : track.codec;
        if (codec) {
          if (trackName.slice(0, 5) === "audio") {
            codec = getCodecCompatibleName(codec, this.appendSource);
          }
        }
        const mimeType = `${track.container};codecs=${codec}`;
        this.log(`creating sourceBuffer(${mimeType})`);
        try {
          const sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);
          const sbName = trackName;
          this.addBufferListener(sbName, "updatestart", this._onSBUpdateStart);
          this.addBufferListener(sbName, "updateend", this._onSBUpdateEnd);
          this.addBufferListener(sbName, "error", this._onSBUpdateError);
          if (this.appendSource) {
            this.addBufferListener(sbName, "bufferedchange", (type, event) => {
              const removedRanges = event.removedRanges;
              if (removedRanges != null && removedRanges.length) {
                this.hls.trigger(Events.BUFFER_FLUSHED, {
                  type: trackName
                });
              }
            });
          }
          this.tracks[trackName] = {
            buffer: sb,
            codec,
            container: track.container,
            levelCodec: track.levelCodec,
            metadata: track.metadata,
            id: track.id
          };
        } catch (err) {
          this.error(`error while trying to add sourceBuffer: ${err.message}`);
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,
            fatal: false,
            error: err,
            sourceBufferName: trackName,
            mimeType
          });
        }
      }
    }
  }
  get mediaSrc() {
    var _this$media, _this$media$querySele;
    const media = ((_this$media = this.media) == null ? undefined : (_this$media$querySele = _this$media.querySelector) == null ? undefined : _this$media$querySele.call(_this$media, "source")) || this.media;
    return media == null ? undefined : media.src;
  }
  _onSBUpdateStart(type) {
    const {
      operationQueue
    } = this;
    const operation = operationQueue.current(type);
    operation.onStart();
  }
  _onSBUpdateEnd(type) {
    var _this$mediaSource2;
    if (((_this$mediaSource2 = this.mediaSource) == null ? undefined : _this$mediaSource2.readyState) === "closed") {
      this.resetBuffer(type);
      return;
    }
    const {
      operationQueue
    } = this;
    const operation = operationQueue.current(type);
    operation.onComplete();
    operationQueue.shiftAndExecuteNext(type);
  }
  _onSBUpdateError(type, event) {
    var _this$mediaSource3;
    const error = new Error(`${type} SourceBuffer error. MediaSource readyState: ${(_this$mediaSource3 = this.mediaSource) == null ? undefined : _this$mediaSource3.readyState}`);
    this.error(`${error}`, event);
    this.hls.trigger(Events.ERROR, {
      type: ErrorTypes.MEDIA_ERROR,
      details: ErrorDetails.BUFFER_APPENDING_ERROR,
      sourceBufferName: type,
      error,
      fatal: false
    });
    const operation = this.operationQueue.current(type);
    if (operation) {
      operation.onError(error);
    }
  }
  removeExecutor(type, startOffset, endOffset) {
    const {
      media,
      mediaSource,
      operationQueue,
      sourceBuffer
    } = this;
    const sb = sourceBuffer[type];
    if (!media || !mediaSource || !sb) {
      this.warn(`Attempting to remove from the ${type} SourceBuffer, but it does not exist`);
      operationQueue.shiftAndExecuteNext(type);
      return;
    }
    const mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;
    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;
    const removeStart = Math.max(0, startOffset);
    const removeEnd = Math.min(endOffset, mediaDuration, msDuration);
    if (removeEnd > removeStart && (!sb.ending || sb.ended)) {
      sb.ended = false;
      this.log(`Removing [${removeStart},${removeEnd}] from the ${type} SourceBuffer`);
      sb.remove(removeStart, removeEnd);
    } else {
      operationQueue.shiftAndExecuteNext(type);
    }
  }
  appendExecutor(data, type) {
    const sb = this.sourceBuffer[type];
    if (!sb) {
      if (!this.pendingTracks[type]) {
        throw new Error(`Attempting to append to the ${type} SourceBuffer, but it does not exist`);
      }
      return;
    }
    sb.ended = false;
    sb.appendBuffer(data);
  }
  blockBuffers(onUnblocked, buffers = this.getSourceBufferTypes()) {
    if (!buffers.length) {
      this.log("Blocking operation requested, but no SourceBuffers exist");
      Promise.resolve().then(onUnblocked);
      return;
    }
    const {
      operationQueue
    } = this;
    const blockingOperations = buffers.map((type) => operationQueue.appendBlocker(type));
    Promise.all(blockingOperations).then(() => {
      onUnblocked();
      buffers.forEach((type) => {
        const sb = this.sourceBuffer[type];
        if (!(sb != null && sb.updating)) {
          operationQueue.shiftAndExecuteNext(type);
        }
      });
    });
  }
  getSourceBufferTypes() {
    return Object.keys(this.sourceBuffer);
  }
  addBufferListener(type, event, fn) {
    const buffer = this.sourceBuffer[type];
    if (!buffer) {
      return;
    }
    const listener = fn.bind(this, type);
    this.listeners[type].push({
      event,
      listener
    });
    buffer.addEventListener(event, listener);
  }
  removeBufferListeners(type) {
    const buffer = this.sourceBuffer[type];
    if (!buffer) {
      return;
    }
    this.listeners[type].forEach((l) => {
      buffer.removeEventListener(l.event, l.listener);
    });
  }
}
function removeSourceChildren(node) {
  const sourceChildren = node.querySelectorAll("source");
  [].slice.call(sourceChildren).forEach((source) => {
    node.removeChild(source);
  });
}
function addSource(media, url) {
  const source = self.document.createElement("source");
  source.type = "video/mp4";
  source.src = url;
  media.appendChild(source);
}
var specialCea608CharsCodes = {
  42: 225,
  92: 233,
  94: 237,
  95: 243,
  96: 250,
  123: 231,
  124: 247,
  125: 209,
  126: 241,
  127: 9608,
  128: 174,
  129: 176,
  130: 189,
  131: 191,
  132: 8482,
  133: 162,
  134: 163,
  135: 9834,
  136: 224,
  137: 32,
  138: 232,
  139: 226,
  140: 234,
  141: 238,
  142: 244,
  143: 251,
  144: 193,
  145: 201,
  146: 211,
  147: 218,
  148: 220,
  149: 252,
  150: 8216,
  151: 161,
  152: 42,
  153: 8217,
  154: 9473,
  155: 169,
  156: 8480,
  157: 8226,
  158: 8220,
  159: 8221,
  160: 192,
  161: 194,
  162: 199,
  163: 200,
  164: 202,
  165: 203,
  166: 235,
  167: 206,
  168: 207,
  169: 239,
  170: 212,
  171: 217,
  172: 249,
  173: 219,
  174: 171,
  175: 187,
  176: 195,
  177: 227,
  178: 205,
  179: 204,
  180: 236,
  181: 210,
  182: 242,
  183: 213,
  184: 245,
  185: 123,
  186: 125,
  187: 92,
  188: 94,
  189: 95,
  190: 124,
  191: 8764,
  192: 196,
  193: 228,
  194: 214,
  195: 246,
  196: 223,
  197: 165,
  198: 164,
  199: 9475,
  200: 197,
  201: 229,
  202: 216,
  203: 248,
  204: 9487,
  205: 9491,
  206: 9495,
  207: 9499
};
var getCharForByte = (byte) => String.fromCharCode(specialCea608CharsCodes[byte] || byte);
var NR_ROWS = 15;
var NR_COLS = 100;
var rowsLowCh1 = {
  17: 1,
  18: 3,
  21: 5,
  22: 7,
  23: 9,
  16: 11,
  19: 12,
  20: 14
};
var rowsHighCh1 = {
  17: 2,
  18: 4,
  21: 6,
  22: 8,
  23: 10,
  19: 13,
  20: 15
};
var rowsLowCh2 = {
  25: 1,
  26: 3,
  29: 5,
  30: 7,
  31: 9,
  24: 11,
  27: 12,
  28: 14
};
var rowsHighCh2 = {
  25: 2,
  26: 4,
  29: 6,
  30: 8,
  31: 10,
  27: 13,
  28: 15
};
var backgroundColors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];

class CaptionsLogger {
  constructor() {
    this.time = null;
    this.verboseLevel = 0;
  }
  log(severity, msg) {
    if (this.verboseLevel >= severity) {
      const m = typeof msg === "function" ? msg() : msg;
      logger.log(`${this.time} [${severity}] ${m}`);
    }
  }
}
var numArrayToHexArray = function numArrayToHexArray2(numArray) {
  const hexArray = [];
  for (let j = 0;j < numArray.length; j++) {
    hexArray.push(numArray[j].toString(16));
  }
  return hexArray;
};

class PenState {
  constructor() {
    this.foreground = "white";
    this.underline = false;
    this.italics = false;
    this.background = "black";
    this.flash = false;
  }
  reset() {
    this.foreground = "white";
    this.underline = false;
    this.italics = false;
    this.background = "black";
    this.flash = false;
  }
  setStyles(styles) {
    const attribs = ["foreground", "underline", "italics", "background", "flash"];
    for (let i = 0;i < attribs.length; i++) {
      const style = attribs[i];
      if (styles.hasOwnProperty(style)) {
        this[style] = styles[style];
      }
    }
  }
  isDefault() {
    return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
  }
  equals(other) {
    return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
  }
  copy(newPenState) {
    this.foreground = newPenState.foreground;
    this.underline = newPenState.underline;
    this.italics = newPenState.italics;
    this.background = newPenState.background;
    this.flash = newPenState.flash;
  }
  toString() {
    return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
  }
}

class StyledUnicodeChar {
  constructor() {
    this.uchar = " ";
    this.penState = new PenState;
  }
  reset() {
    this.uchar = " ";
    this.penState.reset();
  }
  setChar(uchar, newPenState) {
    this.uchar = uchar;
    this.penState.copy(newPenState);
  }
  setPenState(newPenState) {
    this.penState.copy(newPenState);
  }
  equals(other) {
    return this.uchar === other.uchar && this.penState.equals(other.penState);
  }
  copy(newChar) {
    this.uchar = newChar.uchar;
    this.penState.copy(newChar.penState);
  }
  isEmpty() {
    return this.uchar === " " && this.penState.isDefault();
  }
}

class Row {
  constructor(logger2) {
    this.chars = [];
    this.pos = 0;
    this.currPenState = new PenState;
    this.cueStartTime = null;
    this.logger = undefined;
    for (let i = 0;i < NR_COLS; i++) {
      this.chars.push(new StyledUnicodeChar);
    }
    this.logger = logger2;
  }
  equals(other) {
    for (let i = 0;i < NR_COLS; i++) {
      if (!this.chars[i].equals(other.chars[i])) {
        return false;
      }
    }
    return true;
  }
  copy(other) {
    for (let i = 0;i < NR_COLS; i++) {
      this.chars[i].copy(other.chars[i]);
    }
  }
  isEmpty() {
    let empty = true;
    for (let i = 0;i < NR_COLS; i++) {
      if (!this.chars[i].isEmpty()) {
        empty = false;
        break;
      }
    }
    return empty;
  }
  setCursor(absPos) {
    if (this.pos !== absPos) {
      this.pos = absPos;
    }
    if (this.pos < 0) {
      this.logger.log(3, "Negative cursor position " + this.pos);
      this.pos = 0;
    } else if (this.pos > NR_COLS) {
      this.logger.log(3, "Too large cursor position " + this.pos);
      this.pos = NR_COLS;
    }
  }
  moveCursor(relPos) {
    const newPos = this.pos + relPos;
    if (relPos > 1) {
      for (let i = this.pos + 1;i < newPos + 1; i++) {
        this.chars[i].setPenState(this.currPenState);
      }
    }
    this.setCursor(newPos);
  }
  backSpace() {
    this.moveCursor(-1);
    this.chars[this.pos].setChar(" ", this.currPenState);
  }
  insertChar(byte) {
    if (byte >= 144) {
      this.backSpace();
    }
    const char = getCharForByte(byte);
    if (this.pos >= NR_COLS) {
      this.logger.log(0, () => "Cannot insert " + byte.toString(16) + " (" + char + ") at position " + this.pos + ". Skipping it!");
      return;
    }
    this.chars[this.pos].setChar(char, this.currPenState);
    this.moveCursor(1);
  }
  clearFromPos(startPos) {
    let i;
    for (i = startPos;i < NR_COLS; i++) {
      this.chars[i].reset();
    }
  }
  clear() {
    this.clearFromPos(0);
    this.pos = 0;
    this.currPenState.reset();
  }
  clearToEndOfRow() {
    this.clearFromPos(this.pos);
  }
  getTextString() {
    const chars = [];
    let empty = true;
    for (let i = 0;i < NR_COLS; i++) {
      const char = this.chars[i].uchar;
      if (char !== " ") {
        empty = false;
      }
      chars.push(char);
    }
    if (empty) {
      return "";
    } else {
      return chars.join("");
    }
  }
  setPenStyles(styles) {
    this.currPenState.setStyles(styles);
    const currChar = this.chars[this.pos];
    currChar.setPenState(this.currPenState);
  }
}

class CaptionScreen {
  constructor(logger2) {
    this.rows = [];
    this.currRow = NR_ROWS - 1;
    this.nrRollUpRows = null;
    this.lastOutputScreen = null;
    this.logger = undefined;
    for (let i = 0;i < NR_ROWS; i++) {
      this.rows.push(new Row(logger2));
    }
    this.logger = logger2;
  }
  reset() {
    for (let i = 0;i < NR_ROWS; i++) {
      this.rows[i].clear();
    }
    this.currRow = NR_ROWS - 1;
  }
  equals(other) {
    let equal = true;
    for (let i = 0;i < NR_ROWS; i++) {
      if (!this.rows[i].equals(other.rows[i])) {
        equal = false;
        break;
      }
    }
    return equal;
  }
  copy(other) {
    for (let i = 0;i < NR_ROWS; i++) {
      this.rows[i].copy(other.rows[i]);
    }
  }
  isEmpty() {
    let empty = true;
    for (let i = 0;i < NR_ROWS; i++) {
      if (!this.rows[i].isEmpty()) {
        empty = false;
        break;
      }
    }
    return empty;
  }
  backSpace() {
    const row = this.rows[this.currRow];
    row.backSpace();
  }
  clearToEndOfRow() {
    const row = this.rows[this.currRow];
    row.clearToEndOfRow();
  }
  insertChar(char) {
    const row = this.rows[this.currRow];
    row.insertChar(char);
  }
  setPen(styles) {
    const row = this.rows[this.currRow];
    row.setPenStyles(styles);
  }
  moveCursor(relPos) {
    const row = this.rows[this.currRow];
    row.moveCursor(relPos);
  }
  setCursor(absPos) {
    this.logger.log(2, "setCursor: " + absPos);
    const row = this.rows[this.currRow];
    row.setCursor(absPos);
  }
  setPAC(pacData) {
    this.logger.log(2, () => "pacData = " + JSON.stringify(pacData));
    let newRow = pacData.row - 1;
    if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
      newRow = this.nrRollUpRows - 1;
    }
    if (this.nrRollUpRows && this.currRow !== newRow) {
      for (let i = 0;i < NR_ROWS; i++) {
        this.rows[i].clear();
      }
      const topRowIndex = this.currRow + 1 - this.nrRollUpRows;
      const lastOutputScreen = this.lastOutputScreen;
      if (lastOutputScreen) {
        const prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
        const time = this.logger.time;
        if (prevLineTime !== null && time !== null && prevLineTime < time) {
          for (let i = 0;i < this.nrRollUpRows; i++) {
            this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);
          }
        }
      }
    }
    this.currRow = newRow;
    const row = this.rows[this.currRow];
    if (pacData.indent !== null) {
      const indent = pacData.indent;
      const prevPos = Math.max(indent - 1, 0);
      row.setCursor(pacData.indent);
      pacData.color = row.chars[prevPos].penState.foreground;
    }
    const styles = {
      foreground: pacData.color,
      underline: pacData.underline,
      italics: pacData.italics,
      background: "black",
      flash: false
    };
    this.setPen(styles);
  }
  setBkgData(bkgData) {
    this.logger.log(2, () => "bkgData = " + JSON.stringify(bkgData));
    this.backSpace();
    this.setPen(bkgData);
    this.insertChar(32);
  }
  setRollUpRows(nrRows) {
    this.nrRollUpRows = nrRows;
  }
  rollUp() {
    if (this.nrRollUpRows === null) {
      this.logger.log(3, "roll_up but nrRollUpRows not set yet");
      return;
    }
    this.logger.log(1, () => this.getDisplayText());
    const topRowIndex = this.currRow + 1 - this.nrRollUpRows;
    const topRow = this.rows.splice(topRowIndex, 1)[0];
    topRow.clear();
    this.rows.splice(this.currRow, 0, topRow);
    this.logger.log(2, "Rolling up");
  }
  getDisplayText(asOneRow) {
    asOneRow = asOneRow || false;
    const displayText = [];
    let text = "";
    let rowNr = -1;
    for (let i = 0;i < NR_ROWS; i++) {
      const rowText = this.rows[i].getTextString();
      if (rowText) {
        rowNr = i + 1;
        if (asOneRow) {
          displayText.push("Row " + rowNr + ": '" + rowText + "'");
        } else {
          displayText.push(rowText.trim());
        }
      }
    }
    if (displayText.length > 0) {
      if (asOneRow) {
        text = "[" + displayText.join(" | ") + "]";
      } else {
        text = displayText.join(`
`);
      }
    }
    return text;
  }
  getTextAndFormat() {
    return this.rows;
  }
}

class Cea608Channel {
  constructor(channelNumber, outputFilter, logger2) {
    this.chNr = undefined;
    this.outputFilter = undefined;
    this.mode = undefined;
    this.verbose = undefined;
    this.displayedMemory = undefined;
    this.nonDisplayedMemory = undefined;
    this.lastOutputScreen = undefined;
    this.currRollUpRow = undefined;
    this.writeScreen = undefined;
    this.cueStartTime = undefined;
    this.logger = undefined;
    this.chNr = channelNumber;
    this.outputFilter = outputFilter;
    this.mode = null;
    this.verbose = 0;
    this.displayedMemory = new CaptionScreen(logger2);
    this.nonDisplayedMemory = new CaptionScreen(logger2);
    this.lastOutputScreen = new CaptionScreen(logger2);
    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
    this.writeScreen = this.displayedMemory;
    this.mode = null;
    this.cueStartTime = null;
    this.logger = logger2;
  }
  reset() {
    this.mode = null;
    this.displayedMemory.reset();
    this.nonDisplayedMemory.reset();
    this.lastOutputScreen.reset();
    this.outputFilter.reset();
    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
    this.writeScreen = this.displayedMemory;
    this.mode = null;
    this.cueStartTime = null;
  }
  getHandler() {
    return this.outputFilter;
  }
  setHandler(newHandler) {
    this.outputFilter = newHandler;
  }
  setPAC(pacData) {
    this.writeScreen.setPAC(pacData);
  }
  setBkgData(bkgData) {
    this.writeScreen.setBkgData(bkgData);
  }
  setMode(newMode) {
    if (newMode === this.mode) {
      return;
    }
    this.mode = newMode;
    this.logger.log(2, () => "MODE=" + newMode);
    if (this.mode === "MODE_POP-ON") {
      this.writeScreen = this.nonDisplayedMemory;
    } else {
      this.writeScreen = this.displayedMemory;
      this.writeScreen.reset();
    }
    if (this.mode !== "MODE_ROLL-UP") {
      this.displayedMemory.nrRollUpRows = null;
      this.nonDisplayedMemory.nrRollUpRows = null;
    }
    this.mode = newMode;
  }
  insertChars(chars) {
    for (let i = 0;i < chars.length; i++) {
      this.writeScreen.insertChar(chars[i]);
    }
    const screen = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
    this.logger.log(2, () => screen + ": " + this.writeScreen.getDisplayText(true));
    if (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") {
      this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(true));
      this.outputDataUpdate();
    }
  }
  ccRCL() {
    this.logger.log(2, "RCL - Resume Caption Loading");
    this.setMode("MODE_POP-ON");
  }
  ccBS() {
    this.logger.log(2, "BS - BackSpace");
    if (this.mode === "MODE_TEXT") {
      return;
    }
    this.writeScreen.backSpace();
    if (this.writeScreen === this.displayedMemory) {
      this.outputDataUpdate();
    }
  }
  ccAOF() {
  }
  ccAON() {
  }
  ccDER() {
    this.logger.log(2, "DER- Delete to End of Row");
    this.writeScreen.clearToEndOfRow();
    this.outputDataUpdate();
  }
  ccRU(nrRows) {
    this.logger.log(2, "RU(" + nrRows + ") - Roll Up");
    this.writeScreen = this.displayedMemory;
    this.setMode("MODE_ROLL-UP");
    this.writeScreen.setRollUpRows(nrRows);
  }
  ccFON() {
    this.logger.log(2, "FON - Flash On");
    this.writeScreen.setPen({
      flash: true
    });
  }
  ccRDC() {
    this.logger.log(2, "RDC - Resume Direct Captioning");
    this.setMode("MODE_PAINT-ON");
  }
  ccTR() {
    this.logger.log(2, "TR");
    this.setMode("MODE_TEXT");
  }
  ccRTD() {
    this.logger.log(2, "RTD");
    this.setMode("MODE_TEXT");
  }
  ccEDM() {
    this.logger.log(2, "EDM - Erase Displayed Memory");
    this.displayedMemory.reset();
    this.outputDataUpdate(true);
  }
  ccCR() {
    this.logger.log(2, "CR - Carriage Return");
    this.writeScreen.rollUp();
    this.outputDataUpdate(true);
  }
  ccENM() {
    this.logger.log(2, "ENM - Erase Non-displayed Memory");
    this.nonDisplayedMemory.reset();
  }
  ccEOC() {
    this.logger.log(2, "EOC - End Of Caption");
    if (this.mode === "MODE_POP-ON") {
      const tmp = this.displayedMemory;
      this.displayedMemory = this.nonDisplayedMemory;
      this.nonDisplayedMemory = tmp;
      this.writeScreen = this.nonDisplayedMemory;
      this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText());
    }
    this.outputDataUpdate(true);
  }
  ccTO(nrCols) {
    this.logger.log(2, "TO(" + nrCols + ") - Tab Offset");
    this.writeScreen.moveCursor(nrCols);
  }
  ccMIDROW(secondByte) {
    const styles = {
      flash: false
    };
    styles.underline = secondByte % 2 === 1;
    styles.italics = secondByte >= 46;
    if (!styles.italics) {
      const colorIndex = Math.floor(secondByte / 2) - 16;
      const colors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
      styles.foreground = colors[colorIndex];
    } else {
      styles.foreground = "white";
    }
    this.logger.log(2, "MIDROW: " + JSON.stringify(styles));
    this.writeScreen.setPen(styles);
  }
  outputDataUpdate(dispatch = false) {
    const time = this.logger.time;
    if (time === null) {
      return;
    }
    if (this.outputFilter) {
      if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
        this.cueStartTime = time;
      } else {
        if (!this.displayedMemory.equals(this.lastOutputScreen)) {
          this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);
          if (dispatch && this.outputFilter.dispatchCue) {
            this.outputFilter.dispatchCue();
          }
          this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;
        }
      }
      this.lastOutputScreen.copy(this.displayedMemory);
    }
  }
  cueSplitAtTime(t) {
    if (this.outputFilter) {
      if (!this.displayedMemory.isEmpty()) {
        if (this.outputFilter.newCue) {
          this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
        }
        this.cueStartTime = t;
      }
    }
  }
}

class Cea608Parser {
  constructor(field, out1, out2) {
    this.channels = undefined;
    this.currentChannel = 0;
    this.cmdHistory = createCmdHistory();
    this.logger = undefined;
    const logger2 = this.logger = new CaptionsLogger;
    this.channels = [null, new Cea608Channel(field, out1, logger2), new Cea608Channel(field + 1, out2, logger2)];
  }
  getHandler(channel) {
    return this.channels[channel].getHandler();
  }
  setHandler(channel, newHandler) {
    this.channels[channel].setHandler(newHandler);
  }
  addData(time, byteList) {
    this.logger.time = time;
    for (let i = 0;i < byteList.length; i += 2) {
      const a = byteList[i] & 127;
      const b = byteList[i + 1] & 127;
      let cmdFound = false;
      let charsFound = null;
      if (a === 0 && b === 0) {
        continue;
      } else {
        this.logger.log(3, () => "[" + numArrayToHexArray([byteList[i], byteList[i + 1]]) + "] -> (" + numArrayToHexArray([a, b]) + ")");
      }
      const cmdHistory = this.cmdHistory;
      const isControlCode = a >= 16 && a <= 31;
      if (isControlCode) {
        if (hasCmdRepeated(a, b, cmdHistory)) {
          setLastCmd(null, null, cmdHistory);
          this.logger.log(3, () => "Repeated command (" + numArrayToHexArray([a, b]) + ") is dropped");
          continue;
        }
        setLastCmd(a, b, this.cmdHistory);
        cmdFound = this.parseCmd(a, b);
        if (!cmdFound) {
          cmdFound = this.parseMidrow(a, b);
        }
        if (!cmdFound) {
          cmdFound = this.parsePAC(a, b);
        }
        if (!cmdFound) {
          cmdFound = this.parseBackgroundAttributes(a, b);
        }
      } else {
        setLastCmd(null, null, cmdHistory);
      }
      if (!cmdFound) {
        charsFound = this.parseChars(a, b);
        if (charsFound) {
          const currChNr = this.currentChannel;
          if (currChNr && currChNr > 0) {
            const channel = this.channels[currChNr];
            channel.insertChars(charsFound);
          } else {
            this.logger.log(2, "No channel found yet. TEXT-MODE?");
          }
        }
      }
      if (!cmdFound && !charsFound) {
        this.logger.log(2, () => "Couldn't parse cleaned data " + numArrayToHexArray([a, b]) + " orig: " + numArrayToHexArray([byteList[i], byteList[i + 1]]));
      }
    }
  }
  parseCmd(a, b) {
    const cond1 = (a === 20 || a === 28 || a === 21 || a === 29) && b >= 32 && b <= 47;
    const cond2 = (a === 23 || a === 31) && b >= 33 && b <= 35;
    if (!(cond1 || cond2)) {
      return false;
    }
    const chNr = a === 20 || a === 21 || a === 23 ? 1 : 2;
    const channel = this.channels[chNr];
    if (a === 20 || a === 21 || a === 28 || a === 29) {
      if (b === 32) {
        channel.ccRCL();
      } else if (b === 33) {
        channel.ccBS();
      } else if (b === 34) {
        channel.ccAOF();
      } else if (b === 35) {
        channel.ccAON();
      } else if (b === 36) {
        channel.ccDER();
      } else if (b === 37) {
        channel.ccRU(2);
      } else if (b === 38) {
        channel.ccRU(3);
      } else if (b === 39) {
        channel.ccRU(4);
      } else if (b === 40) {
        channel.ccFON();
      } else if (b === 41) {
        channel.ccRDC();
      } else if (b === 42) {
        channel.ccTR();
      } else if (b === 43) {
        channel.ccRTD();
      } else if (b === 44) {
        channel.ccEDM();
      } else if (b === 45) {
        channel.ccCR();
      } else if (b === 46) {
        channel.ccENM();
      } else if (b === 47) {
        channel.ccEOC();
      }
    } else {
      channel.ccTO(b - 32);
    }
    this.currentChannel = chNr;
    return true;
  }
  parseMidrow(a, b) {
    let chNr = 0;
    if ((a === 17 || a === 25) && b >= 32 && b <= 47) {
      if (a === 17) {
        chNr = 1;
      } else {
        chNr = 2;
      }
      if (chNr !== this.currentChannel) {
        this.logger.log(0, "Mismatch channel in midrow parsing");
        return false;
      }
      const channel = this.channels[chNr];
      if (!channel) {
        return false;
      }
      channel.ccMIDROW(b);
      this.logger.log(3, () => "MIDROW (" + numArrayToHexArray([a, b]) + ")");
      return true;
    }
    return false;
  }
  parsePAC(a, b) {
    let row;
    const case1 = (a >= 17 && a <= 23 || a >= 25 && a <= 31) && b >= 64 && b <= 127;
    const case2 = (a === 16 || a === 24) && b >= 64 && b <= 95;
    if (!(case1 || case2)) {
      return false;
    }
    const chNr = a <= 23 ? 1 : 2;
    if (b >= 64 && b <= 95) {
      row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
    } else {
      row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
    }
    const channel = this.channels[chNr];
    if (!channel) {
      return false;
    }
    channel.setPAC(this.interpretPAC(row, b));
    this.currentChannel = chNr;
    return true;
  }
  interpretPAC(row, byte) {
    let pacIndex;
    const pacData = {
      color: null,
      italics: false,
      indent: null,
      underline: false,
      row
    };
    if (byte > 95) {
      pacIndex = byte - 96;
    } else {
      pacIndex = byte - 64;
    }
    pacData.underline = (pacIndex & 1) === 1;
    if (pacIndex <= 13) {
      pacData.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(pacIndex / 2)];
    } else if (pacIndex <= 15) {
      pacData.italics = true;
      pacData.color = "white";
    } else {
      pacData.indent = Math.floor((pacIndex - 16) / 2) * 4;
    }
    return pacData;
  }
  parseChars(a, b) {
    let channelNr;
    let charCodes = null;
    let charCode1 = null;
    if (a >= 25) {
      channelNr = 2;
      charCode1 = a - 8;
    } else {
      channelNr = 1;
      charCode1 = a;
    }
    if (charCode1 >= 17 && charCode1 <= 19) {
      let oneCode;
      if (charCode1 === 17) {
        oneCode = b + 80;
      } else if (charCode1 === 18) {
        oneCode = b + 112;
      } else {
        oneCode = b + 144;
      }
      this.logger.log(2, () => "Special char '" + getCharForByte(oneCode) + "' in channel " + channelNr);
      charCodes = [oneCode];
    } else if (a >= 32 && a <= 127) {
      charCodes = b === 0 ? [a] : [a, b];
    }
    if (charCodes) {
      this.logger.log(3, () => "Char codes =  " + numArrayToHexArray(charCodes).join(","));
    }
    return charCodes;
  }
  parseBackgroundAttributes(a, b) {
    const case1 = (a === 16 || a === 24) && b >= 32 && b <= 47;
    const case2 = (a === 23 || a === 31) && b >= 45 && b <= 47;
    if (!(case1 || case2)) {
      return false;
    }
    let index;
    const bkgData = {};
    if (a === 16 || a === 24) {
      index = Math.floor((b - 32) / 2);
      bkgData.background = backgroundColors[index];
      if (b % 2 === 1) {
        bkgData.background = bkgData.background + "_semi";
      }
    } else if (b === 45) {
      bkgData.background = "transparent";
    } else {
      bkgData.foreground = "black";
      if (b === 47) {
        bkgData.underline = true;
      }
    }
    const chNr = a <= 23 ? 1 : 2;
    const channel = this.channels[chNr];
    channel.setBkgData(bkgData);
    return true;
  }
  reset() {
    for (let i = 0;i < Object.keys(this.channels).length; i++) {
      const channel = this.channels[i];
      if (channel) {
        channel.reset();
      }
    }
    setLastCmd(null, null, this.cmdHistory);
  }
  cueSplitAtTime(t) {
    for (let i = 0;i < this.channels.length; i++) {
      const channel = this.channels[i];
      if (channel) {
        channel.cueSplitAtTime(t);
      }
    }
  }
}
function setLastCmd(a, b, cmdHistory) {
  cmdHistory.a = a;
  cmdHistory.b = b;
}
function hasCmdRepeated(a, b, cmdHistory) {
  return cmdHistory.a === a && cmdHistory.b === b;
}
function createCmdHistory() {
  return {
    a: null,
    b: null
  };
}

class OutputFilter {
  constructor(timelineController, trackName) {
    this.timelineController = undefined;
    this.cueRanges = [];
    this.trackName = undefined;
    this.startTime = null;
    this.endTime = null;
    this.screen = null;
    this.timelineController = timelineController;
    this.trackName = trackName;
  }
  dispatchCue() {
    if (this.startTime === null) {
      return;
    }
    this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);
    this.startTime = null;
  }
  newCue(startTime, endTime, screen) {
    if (this.startTime === null || this.startTime > startTime) {
      this.startTime = startTime;
    }
    this.endTime = endTime;
    this.screen = screen;
    this.timelineController.createCaptionsTrack(this.trackName);
  }
  reset() {
    this.cueRanges = [];
    this.startTime = null;
  }
}
var VTTCue = function() {
  if (optionalSelf != null && optionalSelf.VTTCue) {
    return self.VTTCue;
  }
  const AllowedDirections = ["", "lr", "rl"];
  const AllowedAlignments = ["start", "middle", "end", "left", "right"];
  function isAllowedValue(allowed, value) {
    if (typeof value !== "string") {
      return false;
    }
    if (!Array.isArray(allowed)) {
      return false;
    }
    const lcValue = value.toLowerCase();
    if (~allowed.indexOf(lcValue)) {
      return lcValue;
    }
    return false;
  }
  function findDirectionSetting(value) {
    return isAllowedValue(AllowedDirections, value);
  }
  function findAlignSetting(value) {
    return isAllowedValue(AllowedAlignments, value);
  }
  function extend(obj, ...rest) {
    let i = 1;
    for (;i < arguments.length; i++) {
      const cobj = arguments[i];
      for (const p in cobj) {
        obj[p] = cobj[p];
      }
    }
    return obj;
  }
  function VTTCue2(startTime, endTime, text) {
    const cue = this;
    const baseObj = {
      enumerable: true
    };
    cue.hasBeenReset = false;
    let _id = "";
    let _pauseOnExit = false;
    let _startTime = startTime;
    let _endTime = endTime;
    let _text = text;
    let _region = null;
    let _vertical = "";
    let _snapToLines = true;
    let _line = "auto";
    let _lineAlign = "start";
    let _position = 50;
    let _positionAlign = "middle";
    let _size = 50;
    let _align = "middle";
    Object.defineProperty(cue, "id", extend({}, baseObj, {
      get: function() {
        return _id;
      },
      set: function(value) {
        _id = "" + value;
      }
    }));
    Object.defineProperty(cue, "pauseOnExit", extend({}, baseObj, {
      get: function() {
        return _pauseOnExit;
      },
      set: function(value) {
        _pauseOnExit = !!value;
      }
    }));
    Object.defineProperty(cue, "startTime", extend({}, baseObj, {
      get: function() {
        return _startTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("Start time must be set to a number.");
        }
        _startTime = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "endTime", extend({}, baseObj, {
      get: function() {
        return _endTime;
      },
      set: function(value) {
        if (typeof value !== "number") {
          throw new TypeError("End time must be set to a number.");
        }
        _endTime = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "text", extend({}, baseObj, {
      get: function() {
        return _text;
      },
      set: function(value) {
        _text = "" + value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "region", extend({}, baseObj, {
      get: function() {
        return _region;
      },
      set: function(value) {
        _region = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "vertical", extend({}, baseObj, {
      get: function() {
        return _vertical;
      },
      set: function(value) {
        const setting = findDirectionSetting(value);
        if (setting === false) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _vertical = setting;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "snapToLines", extend({}, baseObj, {
      get: function() {
        return _snapToLines;
      },
      set: function(value) {
        _snapToLines = !!value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "line", extend({}, baseObj, {
      get: function() {
        return _line;
      },
      set: function(value) {
        if (typeof value !== "number" && value !== "auto") {
          throw new SyntaxError("An invalid number or illegal string was specified.");
        }
        _line = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "lineAlign", extend({}, baseObj, {
      get: function() {
        return _lineAlign;
      },
      set: function(value) {
        const setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _lineAlign = setting;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "position", extend({}, baseObj, {
      get: function() {
        return _position;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Position must be between 0 and 100.");
        }
        _position = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "positionAlign", extend({}, baseObj, {
      get: function() {
        return _positionAlign;
      },
      set: function(value) {
        const setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _positionAlign = setting;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "size", extend({}, baseObj, {
      get: function() {
        return _size;
      },
      set: function(value) {
        if (value < 0 || value > 100) {
          throw new Error("Size must be between 0 and 100.");
        }
        _size = value;
        this.hasBeenReset = true;
      }
    }));
    Object.defineProperty(cue, "align", extend({}, baseObj, {
      get: function() {
        return _align;
      },
      set: function(value) {
        const setting = findAlignSetting(value);
        if (!setting) {
          throw new SyntaxError("An invalid or illegal string was specified.");
        }
        _align = setting;
        this.hasBeenReset = true;
      }
    }));
    cue.displayState = undefined;
  }
  VTTCue2.prototype.getCueAsHTML = function() {
    const WebVTT = self.WebVTT;
    return WebVTT.convertCueToDOMTree(self, this.text);
  };
  return VTTCue2;
}();

class StringDecoder {
  decode(data, options) {
    if (!data) {
      return "";
    }
    if (typeof data !== "string") {
      throw new Error("Error - expected string data.");
    }
    return decodeURIComponent(encodeURIComponent(data));
  }
}
function parseTimeStamp(input) {
  function computeSeconds(h, m2, s, f) {
    return (h | 0) * 3600 + (m2 | 0) * 60 + (s | 0) + parseFloat(f || 0);
  }
  const m = input.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
  if (!m) {
    return null;
  }
  if (parseFloat(m[2]) > 59) {
    return computeSeconds(m[2], m[3], 0, m[4]);
  }
  return computeSeconds(m[1], m[2], m[3], m[4]);
}

class Settings {
  constructor() {
    this.values = Object.create(null);
  }
  set(k, v2) {
    if (!this.get(k) && v2 !== "") {
      this.values[k] = v2;
    }
  }
  get(k, dflt, defaultKey) {
    if (defaultKey) {
      return this.has(k) ? this.values[k] : dflt[defaultKey];
    }
    return this.has(k) ? this.values[k] : dflt;
  }
  has(k) {
    return k in this.values;
  }
  alt(k, v2, a) {
    for (let n = 0;n < a.length; ++n) {
      if (v2 === a[n]) {
        this.set(k, v2);
        break;
      }
    }
  }
  integer(k, v2) {
    if (/^-?\d+$/.test(v2)) {
      this.set(k, parseInt(v2, 10));
    }
  }
  percent(k, v2) {
    if (/^([\d]{1,3})(\.[\d]*)?%$/.test(v2)) {
      const percent = parseFloat(v2);
      if (percent >= 0 && percent <= 100) {
        this.set(k, percent);
        return true;
      }
    }
    return false;
  }
}
function parseOptions(input, callback, keyValueDelim, groupDelim) {
  const groups = groupDelim ? input.split(groupDelim) : [input];
  for (const i in groups) {
    if (typeof groups[i] !== "string") {
      continue;
    }
    const kv = groups[i].split(keyValueDelim);
    if (kv.length !== 2) {
      continue;
    }
    const k = kv[0];
    const v2 = kv[1];
    callback(k, v2);
  }
}
var defaults = new VTTCue(0, 0, "");
var center = defaults.align === "middle" ? "middle" : "center";
function parseCue(input, cue, regionList) {
  const oInput = input;
  function consumeTimeStamp() {
    const ts = parseTimeStamp(input);
    if (ts === null) {
      throw new Error("Malformed timestamp: " + oInput);
    }
    input = input.replace(/^[^\sa-zA-Z-]+/, "");
    return ts;
  }
  function consumeCueSettings(input2, cue2) {
    const settings = new Settings;
    parseOptions(input2, function(k, v2) {
      let vals;
      switch (k) {
        case "region":
          for (let i = regionList.length - 1;i >= 0; i--) {
            if (regionList[i].id === v2) {
              settings.set(k, regionList[i].region);
              break;
            }
          }
          break;
        case "vertical":
          settings.alt(k, v2, ["rl", "lr"]);
          break;
        case "line":
          vals = v2.split(",");
          settings.integer(k, vals[0]);
          if (settings.percent(k, vals[0])) {
            settings.set("snapToLines", false);
          }
          settings.alt(k, vals[0], ["auto"]);
          if (vals.length === 2) {
            settings.alt("lineAlign", vals[1], ["start", center, "end"]);
          }
          break;
        case "position":
          vals = v2.split(",");
          settings.percent(k, vals[0]);
          if (vals.length === 2) {
            settings.alt("positionAlign", vals[1], ["start", center, "end", "line-left", "line-right", "auto"]);
          }
          break;
        case "size":
          settings.percent(k, v2);
          break;
        case "align":
          settings.alt(k, v2, ["start", center, "end", "left", "right"]);
          break;
      }
    }, /:/, /\s/);
    cue2.region = settings.get("region", null);
    cue2.vertical = settings.get("vertical", "");
    let line = settings.get("line", "auto");
    if (line === "auto" && defaults.line === -1) {
      line = -1;
    }
    cue2.line = line;
    cue2.lineAlign = settings.get("lineAlign", "start");
    cue2.snapToLines = settings.get("snapToLines", true);
    cue2.size = settings.get("size", 100);
    cue2.align = settings.get("align", center);
    let position = settings.get("position", "auto");
    if (position === "auto" && defaults.position === 50) {
      position = cue2.align === "start" || cue2.align === "left" ? 0 : cue2.align === "end" || cue2.align === "right" ? 100 : 50;
    }
    cue2.position = position;
  }
  function skipWhitespace() {
    input = input.replace(/^\s+/, "");
  }
  skipWhitespace();
  cue.startTime = consumeTimeStamp();
  skipWhitespace();
  if (input.slice(0, 3) !== "-->") {
    throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
  }
  input = input.slice(3);
  skipWhitespace();
  cue.endTime = consumeTimeStamp();
  skipWhitespace();
  consumeCueSettings(input, cue);
}
function fixLineBreaks(input) {
  return input.replace(/<br(?: \/)?>/gi, `
`);
}

class VTTParser {
  constructor() {
    this.state = "INITIAL";
    this.buffer = "";
    this.decoder = new StringDecoder;
    this.regionList = [];
    this.cue = null;
    this.oncue = undefined;
    this.onparsingerror = undefined;
    this.onflush = undefined;
  }
  parse(data) {
    const _this = this;
    if (data) {
      _this.buffer += _this.decoder.decode(data, {
        stream: true
      });
    }
    function collectNextLine() {
      let buffer = _this.buffer;
      let pos = 0;
      buffer = fixLineBreaks(buffer);
      while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== `
`) {
        ++pos;
      }
      const line = buffer.slice(0, pos);
      if (buffer[pos] === "\r") {
        ++pos;
      }
      if (buffer[pos] === `
`) {
        ++pos;
      }
      _this.buffer = buffer.slice(pos);
      return line;
    }
    function parseHeader2(input) {
      parseOptions(input, function(k, v2) {
      }, /:/);
    }
    try {
      let line = "";
      if (_this.state === "INITIAL") {
        if (!/\r\n|\n/.test(_this.buffer)) {
          return this;
        }
        line = collectNextLine();
        const m = line.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
        if (!(m != null && m[0])) {
          throw new Error("Malformed WebVTT signature.");
        }
        _this.state = "HEADER";
      }
      let alreadyCollectedLine = false;
      while (_this.buffer) {
        if (!/\r\n|\n/.test(_this.buffer)) {
          return this;
        }
        if (!alreadyCollectedLine) {
          line = collectNextLine();
        } else {
          alreadyCollectedLine = false;
        }
        switch (_this.state) {
          case "HEADER":
            if (/:/.test(line)) {
              parseHeader2(line);
            } else if (!line) {
              _this.state = "ID";
            }
            continue;
          case "NOTE":
            if (!line) {
              _this.state = "ID";
            }
            continue;
          case "ID":
            if (/^NOTE($|[ \t])/.test(line)) {
              _this.state = "NOTE";
              break;
            }
            if (!line) {
              continue;
            }
            _this.cue = new VTTCue(0, 0, "");
            _this.state = "CUE";
            if (line.indexOf("-->") === -1) {
              _this.cue.id = line;
              continue;
            }
          case "CUE":
            if (!_this.cue) {
              _this.state = "BADCUE";
              continue;
            }
            try {
              parseCue(line, _this.cue, _this.regionList);
            } catch (e) {
              _this.cue = null;
              _this.state = "BADCUE";
              continue;
            }
            _this.state = "CUETEXT";
            continue;
          case "CUETEXT":
            {
              const hasSubstring = line.indexOf("-->") !== -1;
              if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                if (_this.oncue && _this.cue) {
                  _this.oncue(_this.cue);
                }
                _this.cue = null;
                _this.state = "ID";
                continue;
              }
              if (_this.cue === null) {
                continue;
              }
              if (_this.cue.text) {
                _this.cue.text += `
`;
              }
              _this.cue.text += line;
            }
            continue;
          case "BADCUE":
            if (!line) {
              _this.state = "ID";
            }
        }
      }
    } catch (e) {
      if (_this.state === "CUETEXT" && _this.cue && _this.oncue) {
        _this.oncue(_this.cue);
      }
      _this.cue = null;
      _this.state = _this.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
    }
    return this;
  }
  flush() {
    const _this = this;
    try {
      if (_this.cue || _this.state === "HEADER") {
        _this.buffer += `

`;
        _this.parse();
      }
      if (_this.state === "INITIAL" || _this.state === "BADWEBVTT") {
        throw new Error("Malformed WebVTT signature.");
      }
    } catch (e) {
      if (_this.onparsingerror) {
        _this.onparsingerror(e);
      }
    }
    if (_this.onflush) {
      _this.onflush();
    }
    return this;
  }
}
var LINEBREAKS = /\r\n|\n\r|\n|\r/g;
var startsWith = function startsWith2(inputString, searchString, position = 0) {
  return inputString.slice(position, position + searchString.length) === searchString;
};
var cueString2millis = function cueString2millis2(timeString) {
  let ts = parseInt(timeString.slice(-3));
  const secs = parseInt(timeString.slice(-6, -4));
  const mins = parseInt(timeString.slice(-9, -7));
  const hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(":"))) : 0;
  if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {
    throw Error(`Malformed X-TIMESTAMP-MAP: Local:${timeString}`);
  }
  ts += 1000 * secs;
  ts += 60 * 1000 * mins;
  ts += 60 * 60 * 1000 * hours;
  return ts;
};
var hash = function hash2(text) {
  let _hash = 5381;
  let i = text.length;
  while (i) {
    _hash = _hash * 33 ^ text.charCodeAt(--i);
  }
  return (_hash >>> 0).toString();
};
function generateCueId(startTime, endTime, text) {
  return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);
}
var calculateOffset = function calculateOffset2(vttCCs, cc2, presentationTime) {
  let currCC = vttCCs[cc2];
  let prevCC = vttCCs[currCC.prevCC];
  if (!prevCC || !prevCC.new && currCC.new) {
    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
    currCC.new = false;
    return;
  }
  while ((_prevCC = prevCC) != null && _prevCC.new) {
    var _prevCC;
    vttCCs.ccOffset += currCC.start - prevCC.start;
    currCC.new = false;
    currCC = prevCC;
    prevCC = vttCCs[currCC.prevCC];
  }
  vttCCs.presentationOffset = presentationTime;
};
function parseWebVTT(vttByteArray, initPTS, vttCCs, cc2, timeOffset, callBack, errorCallBack) {
  const parser = new VTTParser;
  const vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, `
`).split(`
`);
  const cues = [];
  const init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;
  let cueTime = "00:00.000";
  let timestampMapMPEGTS = 0;
  let timestampMapLOCAL = 0;
  let parsingError;
  let inHeader = true;
  parser.oncue = function(cue) {
    const currCC = vttCCs[cc2];
    let cueOffset = vttCCs.ccOffset;
    const webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 90000;
    if (currCC != null && currCC.new) {
      if (timestampMapLOCAL !== undefined) {
        cueOffset = vttCCs.ccOffset = currCC.start;
      } else {
        calculateOffset(vttCCs, cc2, webVttMpegTsMapOffset);
      }
    }
    if (webVttMpegTsMapOffset) {
      if (!initPTS) {
        parsingError = new Error("Missing initPTS for VTT MPEGTS");
        return;
      }
      cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;
    }
    const duration = cue.endTime - cue.startTime;
    const startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;
    cue.startTime = Math.max(startTime, 0);
    cue.endTime = Math.max(startTime + duration, 0);
    const text = cue.text.trim();
    cue.text = decodeURIComponent(encodeURIComponent(text));
    if (!cue.id) {
      cue.id = generateCueId(cue.startTime, cue.endTime, text);
    }
    if (cue.endTime > 0) {
      cues.push(cue);
    }
  };
  parser.onparsingerror = function(error) {
    parsingError = error;
  };
  parser.onflush = function() {
    if (parsingError) {
      errorCallBack(parsingError);
      return;
    }
    callBack(cues);
  };
  vttLines.forEach((line) => {
    if (inHeader) {
      if (startsWith(line, "X-TIMESTAMP-MAP=")) {
        inHeader = false;
        line.slice(16).split(",").forEach((timestamp) => {
          if (startsWith(timestamp, "LOCAL:")) {
            cueTime = timestamp.slice(6);
          } else if (startsWith(timestamp, "MPEGTS:")) {
            timestampMapMPEGTS = parseInt(timestamp.slice(7));
          }
        });
        try {
          timestampMapLOCAL = cueString2millis(cueTime) / 1000;
        } catch (error) {
          parsingError = error;
        }
        return;
      } else if (line === "") {
        inHeader = false;
      }
    }
    parser.parse(line + `
`);
  });
  parser.flush();
}
var IMSC1_CODEC = "stpp.ttml.im1t";
var HMSF_REGEX = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;
var TIME_UNIT_REGEX = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/;
var textAlignToLineAlign = {
  left: "start",
  center: "center",
  right: "end",
  start: "start",
  end: "end"
};
function parseIMSC1(payload, initPTS, callBack, errorCallBack) {
  const results = findBox(new Uint8Array(payload), ["mdat"]);
  if (results.length === 0) {
    errorCallBack(new Error("Could not parse IMSC1 mdat"));
    return;
  }
  const ttmlList = results.map((mdat) => utf8ArrayToStr(mdat));
  const syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);
  try {
    ttmlList.forEach((ttml) => callBack(parseTTML(ttml, syncTime)));
  } catch (error) {
    errorCallBack(error);
  }
}
function parseTTML(ttml, syncTime) {
  const parser = new DOMParser;
  const xmlDoc = parser.parseFromString(ttml, "text/xml");
  const tt = xmlDoc.getElementsByTagName("tt")[0];
  if (!tt) {
    throw new Error("Invalid ttml");
  }
  const defaultRateInfo = {
    frameRate: 30,
    subFrameRate: 1,
    frameRateMultiplier: 0,
    tickRate: 0
  };
  const rateInfo = Object.keys(defaultRateInfo).reduce((result, key) => {
    result[key] = tt.getAttribute(`ttp:${key}`) || defaultRateInfo[key];
    return result;
  }, {});
  const trim = tt.getAttribute("xml:space") !== "preserve";
  const styleElements = collectionToDictionary(getElementCollection(tt, "styling", "style"));
  const regionElements = collectionToDictionary(getElementCollection(tt, "layout", "region"));
  const cueElements = getElementCollection(tt, "body", "[begin]");
  return [].map.call(cueElements, (cueElement) => {
    const cueText = getTextContent(cueElement, trim);
    if (!cueText || !cueElement.hasAttribute("begin")) {
      return null;
    }
    const startTime = parseTtmlTime(cueElement.getAttribute("begin"), rateInfo);
    const duration = parseTtmlTime(cueElement.getAttribute("dur"), rateInfo);
    let endTime = parseTtmlTime(cueElement.getAttribute("end"), rateInfo);
    if (startTime === null) {
      throw timestampParsingError(cueElement);
    }
    if (endTime === null) {
      if (duration === null) {
        throw timestampParsingError(cueElement);
      }
      endTime = startTime + duration;
    }
    const cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);
    cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);
    const region = regionElements[cueElement.getAttribute("region")];
    const style = styleElements[cueElement.getAttribute("style")];
    const styles = getTtmlStyles(region, style, styleElements);
    const {
      textAlign
    } = styles;
    if (textAlign) {
      const lineAlign = textAlignToLineAlign[textAlign];
      if (lineAlign) {
        cue.lineAlign = lineAlign;
      }
      cue.align = textAlign;
    }
    _extends(cue, styles);
    return cue;
  }).filter((cue) => cue !== null);
}
function getElementCollection(fromElement, parentName, childName) {
  const parent = fromElement.getElementsByTagName(parentName)[0];
  if (parent) {
    return [].slice.call(parent.querySelectorAll(childName));
  }
  return [];
}
function collectionToDictionary(elementsWithId) {
  return elementsWithId.reduce((dict, element) => {
    const id = element.getAttribute("xml:id");
    if (id) {
      dict[id] = element;
    }
    return dict;
  }, {});
}
function getTextContent(element, trim) {
  return [].slice.call(element.childNodes).reduce((str, node, i) => {
    var _node$childNodes;
    if (node.nodeName === "br" && i) {
      return str + `
`;
    }
    if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {
      return getTextContent(node, trim);
    } else if (trim) {
      return str + node.textContent.trim().replace(/\s+/g, " ");
    }
    return str + node.textContent;
  }, "");
}
function getTtmlStyles(region, style, styleElements) {
  const ttsNs = "http://www.w3.org/ns/ttml#styling";
  let regionStyle = null;
  const styleAttributes = [
    "displayAlign",
    "textAlign",
    "color",
    "backgroundColor",
    "fontSize",
    "fontFamily"
  ];
  const regionStyleName = region != null && region.hasAttribute("style") ? region.getAttribute("style") : null;
  if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {
    regionStyle = styleElements[regionStyleName];
  }
  return styleAttributes.reduce((styles, name) => {
    const value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);
    if (value) {
      styles[name] = value;
    }
    return styles;
  }, {});
}
function getAttributeNS(element, ns, name) {
  if (!element) {
    return null;
  }
  return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;
}
function timestampParsingError(node) {
  return new Error(`Could not parse ttml timestamp ${node}`);
}
function parseTtmlTime(timeAttributeValue, rateInfo) {
  if (!timeAttributeValue) {
    return null;
  }
  let seconds = parseTimeStamp(timeAttributeValue);
  if (seconds === null) {
    if (HMSF_REGEX.test(timeAttributeValue)) {
      seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);
    } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {
      seconds = parseTimeUnits(timeAttributeValue, rateInfo);
    }
  }
  return seconds;
}
function parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {
  const m = HMSF_REGEX.exec(timeAttributeValue);
  const frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;
  return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;
}
function parseTimeUnits(timeAttributeValue, rateInfo) {
  const m = TIME_UNIT_REGEX.exec(timeAttributeValue);
  const value = Number(m[1]);
  const unit = m[2];
  switch (unit) {
    case "h":
      return value * 3600;
    case "m":
      return value * 60;
    case "ms":
      return value * 1000;
    case "f":
      return value / rateInfo.frameRate;
    case "t":
      return value / rateInfo.tickRate;
  }
  return value;
}

class TimelineController {
  constructor(hls) {
    this.hls = undefined;
    this.media = null;
    this.config = undefined;
    this.enabled = true;
    this.Cues = undefined;
    this.textTracks = [];
    this.tracks = [];
    this.initPTS = [];
    this.unparsedVttFrags = [];
    this.captionsTracks = {};
    this.nonNativeCaptionsTracks = {};
    this.cea608Parser1 = undefined;
    this.cea608Parser2 = undefined;
    this.lastCc = -1;
    this.lastSn = -1;
    this.lastPartIndex = -1;
    this.prevCC = -1;
    this.vttCCs = newVTTCCs();
    this.captionsProperties = undefined;
    this.hls = hls;
    this.config = hls.config;
    this.Cues = hls.config.cueHandler;
    this.captionsProperties = {
      textTrack1: {
        label: this.config.captionsTextTrack1Label,
        languageCode: this.config.captionsTextTrack1LanguageCode
      },
      textTrack2: {
        label: this.config.captionsTextTrack2Label,
        languageCode: this.config.captionsTextTrack2LanguageCode
      },
      textTrack3: {
        label: this.config.captionsTextTrack3Label,
        languageCode: this.config.captionsTextTrack3LanguageCode
      },
      textTrack4: {
        label: this.config.captionsTextTrack4Label,
        languageCode: this.config.captionsTextTrack4LanguageCode
      }
    };
    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
    hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
    hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
    hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
  }
  destroy() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
    hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
    hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
    hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
    this.hls = this.config = null;
    this.cea608Parser1 = this.cea608Parser2 = undefined;
  }
  initCea608Parsers() {
    if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) {
      const channel1 = new OutputFilter(this, "textTrack1");
      const channel2 = new OutputFilter(this, "textTrack2");
      const channel3 = new OutputFilter(this, "textTrack3");
      const channel4 = new OutputFilter(this, "textTrack4");
      this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);
      this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);
    }
  }
  addCues(trackName, startTime, endTime, screen, cueRanges) {
    let merged = false;
    for (let i = cueRanges.length;i--; ) {
      const cueRange = cueRanges[i];
      const overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
      if (overlap >= 0) {
        cueRange[0] = Math.min(cueRange[0], startTime);
        cueRange[1] = Math.max(cueRange[1], endTime);
        merged = true;
        if (overlap / (endTime - startTime) > 0.5) {
          return;
        }
      }
    }
    if (!merged) {
      cueRanges.push([startTime, endTime]);
    }
    if (this.config.renderTextTracksNatively) {
      const track = this.captionsTracks[trackName];
      this.Cues.newCue(track, startTime, endTime, screen);
    } else {
      const cues = this.Cues.newCue(null, startTime, endTime, screen);
      this.hls.trigger(Events.CUES_PARSED, {
        type: "captions",
        cues,
        track: trackName
      });
    }
  }
  onInitPtsFound(event, {
    frag,
    id,
    initPTS,
    timescale
  }) {
    const {
      unparsedVttFrags
    } = this;
    if (id === "main") {
      this.initPTS[frag.cc] = {
        baseTime: initPTS,
        timescale
      };
    }
    if (unparsedVttFrags.length) {
      this.unparsedVttFrags = [];
      unparsedVttFrags.forEach((frag2) => {
        this.onFragLoaded(Events.FRAG_LOADED, frag2);
      });
    }
  }
  getExistingTrack(label, language) {
    const {
      media
    } = this;
    if (media) {
      for (let i = 0;i < media.textTracks.length; i++) {
        const textTrack = media.textTracks[i];
        if (canReuseVttTextTrack(textTrack, {
          name: label,
          lang: language,
          attrs: {}
        })) {
          return textTrack;
        }
      }
    }
    return null;
  }
  createCaptionsTrack(trackName) {
    if (this.config.renderTextTracksNatively) {
      this.createNativeTrack(trackName);
    } else {
      this.createNonNativeTrack(trackName);
    }
  }
  createNativeTrack(trackName) {
    if (this.captionsTracks[trackName]) {
      return;
    }
    const {
      captionsProperties,
      captionsTracks,
      media
    } = this;
    const {
      label,
      languageCode
    } = captionsProperties[trackName];
    const existingTrack = this.getExistingTrack(label, languageCode);
    if (!existingTrack) {
      const textTrack = this.createTextTrack("captions", label, languageCode);
      if (textTrack) {
        textTrack[trackName] = true;
        captionsTracks[trackName] = textTrack;
      }
    } else {
      captionsTracks[trackName] = existingTrack;
      clearCurrentCues(captionsTracks[trackName]);
      sendAddTrackEvent(captionsTracks[trackName], media);
    }
  }
  createNonNativeTrack(trackName) {
    if (this.nonNativeCaptionsTracks[trackName]) {
      return;
    }
    const trackProperties = this.captionsProperties[trackName];
    if (!trackProperties) {
      return;
    }
    const label = trackProperties.label;
    const track = {
      _id: trackName,
      label,
      kind: "captions",
      default: trackProperties.media ? !!trackProperties.media.default : false,
      closedCaptions: trackProperties.media
    };
    this.nonNativeCaptionsTracks[trackName] = track;
    this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
      tracks: [track]
    });
  }
  createTextTrack(kind, label, lang) {
    const media = this.media;
    if (!media) {
      return;
    }
    return media.addTextTrack(kind, label, lang);
  }
  onMediaAttaching(event, data) {
    this.media = data.media;
    this._cleanTracks();
  }
  onMediaDetaching() {
    const {
      captionsTracks
    } = this;
    Object.keys(captionsTracks).forEach((trackName) => {
      clearCurrentCues(captionsTracks[trackName]);
      delete captionsTracks[trackName];
    });
    this.nonNativeCaptionsTracks = {};
  }
  onManifestLoading() {
    this.lastCc = -1;
    this.lastSn = -1;
    this.lastPartIndex = -1;
    this.prevCC = -1;
    this.vttCCs = newVTTCCs();
    this._cleanTracks();
    this.tracks = [];
    this.captionsTracks = {};
    this.nonNativeCaptionsTracks = {};
    this.textTracks = [];
    this.unparsedVttFrags = [];
    this.initPTS = [];
    if (this.cea608Parser1 && this.cea608Parser2) {
      this.cea608Parser1.reset();
      this.cea608Parser2.reset();
    }
  }
  _cleanTracks() {
    const {
      media
    } = this;
    if (!media) {
      return;
    }
    const textTracks = media.textTracks;
    if (textTracks) {
      for (let i = 0;i < textTracks.length; i++) {
        clearCurrentCues(textTracks[i]);
      }
    }
  }
  onSubtitleTracksUpdated(event, data) {
    const tracks = data.subtitleTracks || [];
    const hasIMSC1 = tracks.some((track) => track.textCodec === IMSC1_CODEC);
    if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {
      const listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);
      if (listIsIdentical) {
        this.tracks = tracks;
        return;
      }
      this.textTracks = [];
      this.tracks = tracks;
      if (this.config.renderTextTracksNatively) {
        const media = this.media;
        const inUseTracks = media ? filterSubtitleTracks(media.textTracks) : null;
        this.tracks.forEach((track, index) => {
          let textTrack;
          if (inUseTracks) {
            let inUseTrack = null;
            for (let i = 0;i < inUseTracks.length; i++) {
              if (inUseTracks[i] && canReuseVttTextTrack(inUseTracks[i], track)) {
                inUseTrack = inUseTracks[i];
                inUseTracks[i] = null;
                break;
              }
            }
            if (inUseTrack) {
              textTrack = inUseTrack;
            }
          }
          if (textTrack) {
            clearCurrentCues(textTrack);
          } else {
            const textTrackKind = captionsOrSubtitlesFromCharacteristics(track);
            textTrack = this.createTextTrack(textTrackKind, track.name, track.lang);
            if (textTrack) {
              textTrack.mode = "disabled";
            }
          }
          if (textTrack) {
            this.textTracks.push(textTrack);
          }
        });
        if (inUseTracks != null && inUseTracks.length) {
          const unusedTextTracks = inUseTracks.filter((t) => t !== null).map((t) => t.label);
          if (unusedTextTracks.length) {
            logger.warn(`Media element contains unused subtitle tracks: ${unusedTextTracks.join(", ")}. Replace media element for each source to clear TextTracks and captions menu.`);
          }
        }
      } else if (this.tracks.length) {
        const tracksList = this.tracks.map((track) => {
          return {
            label: track.name,
            kind: track.type.toLowerCase(),
            default: track.default,
            subtitleTrack: track
          };
        });
        this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
          tracks: tracksList
        });
      }
    }
  }
  onManifestLoaded(event, data) {
    if (this.config.enableCEA708Captions && data.captions) {
      data.captions.forEach((captionsTrack) => {
        const instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);
        if (!instreamIdMatch) {
          return;
        }
        const trackName = `textTrack${instreamIdMatch[1]}`;
        const trackProperties = this.captionsProperties[trackName];
        if (!trackProperties) {
          return;
        }
        trackProperties.label = captionsTrack.name;
        if (captionsTrack.lang) {
          trackProperties.languageCode = captionsTrack.lang;
        }
        trackProperties.media = captionsTrack;
      });
    }
  }
  closedCaptionsForLevel(frag) {
    const level = this.hls.levels[frag.level];
    return level == null ? undefined : level.attrs["CLOSED-CAPTIONS"];
  }
  onFragLoading(event, data) {
    if (this.enabled && data.frag.type === PlaylistLevelType.MAIN) {
      var _data$part$index, _data$part;
      const {
        cea608Parser1,
        cea608Parser2,
        lastSn
      } = this;
      const {
        cc: cc2,
        sn
      } = data.frag;
      const partIndex = (_data$part$index = (_data$part = data.part) == null ? undefined : _data$part.index) != null ? _data$part$index : -1;
      if (cea608Parser1 && cea608Parser2) {
        if (sn !== lastSn + 1 || sn === lastSn && partIndex !== this.lastPartIndex + 1 || cc2 !== this.lastCc) {
          cea608Parser1.reset();
          cea608Parser2.reset();
        }
      }
      this.lastCc = cc2;
      this.lastSn = sn;
      this.lastPartIndex = partIndex;
    }
  }
  onFragLoaded(event, data) {
    const {
      frag,
      payload
    } = data;
    if (frag.type === PlaylistLevelType.SUBTITLE) {
      if (payload.byteLength) {
        const decryptData = frag.decryptdata;
        const decrypted = "stats" in data;
        if (decryptData == null || !decryptData.encrypted || decrypted) {
          const trackPlaylistMedia = this.tracks[frag.level];
          const vttCCs = this.vttCCs;
          if (!vttCCs[frag.cc]) {
            vttCCs[frag.cc] = {
              start: frag.start,
              prevCC: this.prevCC,
              new: true
            };
            this.prevCC = frag.cc;
          }
          if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {
            this._parseIMSC1(frag, payload);
          } else {
            this._parseVTTs(data);
          }
        }
      } else {
        this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
          success: false,
          frag,
          error: new Error("Empty subtitle payload")
        });
      }
    }
  }
  _parseIMSC1(frag, payload) {
    const hls = this.hls;
    parseIMSC1(payload, this.initPTS[frag.cc], (cues) => {
      this._appendCues(cues, frag.level);
      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
        success: true,
        frag
      });
    }, (error) => {
      logger.log(`Failed to parse IMSC1: ${error}`);
      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
        success: false,
        frag,
        error
      });
    });
  }
  _parseVTTs(data) {
    var _frag$initSegment;
    const {
      frag,
      payload
    } = data;
    const {
      initPTS,
      unparsedVttFrags
    } = this;
    const maxAvCC = initPTS.length - 1;
    if (!initPTS[frag.cc] && maxAvCC === -1) {
      unparsedVttFrags.push(data);
      return;
    }
    const hls = this.hls;
    const payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)) : payload;
    parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, (cues) => {
      this._appendCues(cues, frag.level);
      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
        success: true,
        frag
      });
    }, (error) => {
      const missingInitPTS = error.message === "Missing initPTS for VTT MPEGTS";
      if (missingInitPTS) {
        unparsedVttFrags.push(data);
      } else {
        this._fallbackToIMSC1(frag, payload);
      }
      logger.log(`Failed to parse VTT cue: ${error}`);
      if (missingInitPTS && maxAvCC > frag.cc) {
        return;
      }
      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
        success: false,
        frag,
        error
      });
    });
  }
  _fallbackToIMSC1(frag, payload) {
    const trackPlaylistMedia = this.tracks[frag.level];
    if (!trackPlaylistMedia.textCodec) {
      parseIMSC1(payload, this.initPTS[frag.cc], () => {
        trackPlaylistMedia.textCodec = IMSC1_CODEC;
        this._parseIMSC1(frag, payload);
      }, () => {
        trackPlaylistMedia.textCodec = "wvtt";
      });
    }
  }
  _appendCues(cues, fragLevel) {
    const hls = this.hls;
    if (this.config.renderTextTracksNatively) {
      const textTrack = this.textTracks[fragLevel];
      if (!textTrack || textTrack.mode === "disabled") {
        return;
      }
      cues.forEach((cue) => addCueToTrack(textTrack, cue));
    } else {
      const currentTrack = this.tracks[fragLevel];
      if (!currentTrack) {
        return;
      }
      const track = currentTrack.default ? "default" : "subtitles" + fragLevel;
      hls.trigger(Events.CUES_PARSED, {
        type: "subtitles",
        cues,
        track
      });
    }
  }
  onFragDecrypted(event, data) {
    const {
      frag
    } = data;
    if (frag.type === PlaylistLevelType.SUBTITLE) {
      this.onFragLoaded(Events.FRAG_LOADED, data);
    }
  }
  onSubtitleTracksCleared() {
    this.tracks = [];
    this.captionsTracks = {};
  }
  onFragParsingUserdata(event, data) {
    this.initCea608Parsers();
    const {
      cea608Parser1,
      cea608Parser2
    } = this;
    if (!this.enabled || !cea608Parser1 || !cea608Parser2) {
      return;
    }
    const {
      frag,
      samples
    } = data;
    if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === "NONE") {
      return;
    }
    for (let i = 0;i < samples.length; i++) {
      const ccBytes = samples[i].bytes;
      if (ccBytes) {
        const ccdatas = this.extractCea608Data(ccBytes);
        cea608Parser1.addData(samples[i].pts, ccdatas[0]);
        cea608Parser2.addData(samples[i].pts, ccdatas[1]);
      }
    }
  }
  onBufferFlushing(event, {
    startOffset,
    endOffset,
    endOffsetSubtitles,
    type
  }) {
    const {
      media
    } = this;
    if (!media || media.currentTime < endOffset) {
      return;
    }
    if (!type || type === "video") {
      const {
        captionsTracks
      } = this;
      Object.keys(captionsTracks).forEach((trackName) => removeCuesInRange(captionsTracks[trackName], startOffset, endOffset));
    }
    if (this.config.renderTextTracksNatively) {
      if (startOffset === 0 && endOffsetSubtitles !== undefined) {
        const {
          textTracks
        } = this;
        Object.keys(textTracks).forEach((trackName) => removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles));
      }
    }
  }
  extractCea608Data(byteArray) {
    const actualCCBytes = [[], []];
    const count = byteArray[0] & 31;
    let position = 2;
    for (let j = 0;j < count; j++) {
      const tmpByte = byteArray[position++];
      const ccbyte1 = 127 & byteArray[position++];
      const ccbyte2 = 127 & byteArray[position++];
      if (ccbyte1 === 0 && ccbyte2 === 0) {
        continue;
      }
      const ccValid = (4 & tmpByte) !== 0;
      if (ccValid) {
        const ccType = 3 & tmpByte;
        if (ccType === 0 || ccType === 1) {
          actualCCBytes[ccType].push(ccbyte1);
          actualCCBytes[ccType].push(ccbyte2);
        }
      }
    }
    return actualCCBytes;
  }
}
function captionsOrSubtitlesFromCharacteristics(track) {
  if (track.characteristics) {
    if (/transcribes-spoken-dialog/gi.test(track.characteristics) && /describes-music-and-sound/gi.test(track.characteristics)) {
      return "captions";
    }
  }
  return "subtitles";
}
function canReuseVttTextTrack(inUseTrack, manifestTrack) {
  return !!inUseTrack && inUseTrack.kind === captionsOrSubtitlesFromCharacteristics(manifestTrack) && subtitleTrackMatchesTextTrack(manifestTrack, inUseTrack);
}
function intersection(x1, x2, y1, y2) {
  return Math.min(x2, y2) - Math.max(x1, y1);
}
function newVTTCCs() {
  return {
    ccOffset: 0,
    presentationOffset: 0,
    0: {
      start: 0,
      prevCC: -1,
      new: true
    }
  };
}

class CapLevelController {
  constructor(hls) {
    this.hls = undefined;
    this.autoLevelCapping = undefined;
    this.firstLevel = undefined;
    this.media = undefined;
    this.restrictedLevels = undefined;
    this.timer = undefined;
    this.clientRect = undefined;
    this.streamController = undefined;
    this.hls = hls;
    this.autoLevelCapping = Number.POSITIVE_INFINITY;
    this.firstLevel = -1;
    this.media = null;
    this.restrictedLevels = [];
    this.timer = undefined;
    this.clientRect = null;
    this.registerListeners();
  }
  setStreamController(streamController) {
    this.streamController = streamController;
  }
  destroy() {
    if (this.hls) {
      this.unregisterListener();
    }
    if (this.timer) {
      this.stopCapping();
    }
    this.media = null;
    this.clientRect = null;
    this.hls = this.streamController = null;
  }
  registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  unregisterListener() {
    const {
      hls
    } = this;
    hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
  }
  onFpsDropLevelCapping(event, data) {
    const level = this.hls.levels[data.droppedLevel];
    if (this.isLevelAllowed(level)) {
      this.restrictedLevels.push({
        bitrate: level.bitrate,
        height: level.height,
        width: level.width
      });
    }
  }
  onMediaAttaching(event, data) {
    this.media = data.media instanceof HTMLVideoElement ? data.media : null;
    this.clientRect = null;
    if (this.timer && this.hls.levels.length) {
      this.detectPlayerSize();
    }
  }
  onManifestParsed(event, data) {
    const hls = this.hls;
    this.restrictedLevels = [];
    this.firstLevel = data.firstLevel;
    if (hls.config.capLevelToPlayerSize && data.video) {
      this.startCapping();
    }
  }
  onLevelsUpdated(event, data) {
    if (this.timer && isFiniteNumber(this.autoLevelCapping)) {
      this.detectPlayerSize();
    }
  }
  onBufferCodecs(event, data) {
    const hls = this.hls;
    if (hls.config.capLevelToPlayerSize && data.video) {
      this.startCapping();
    }
  }
  onMediaDetaching() {
    this.stopCapping();
  }
  detectPlayerSize() {
    if (this.media) {
      if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
        this.clientRect = null;
        return;
      }
      const levels = this.hls.levels;
      if (levels.length) {
        const hls = this.hls;
        const maxLevel = this.getMaxLevel(levels.length - 1);
        if (maxLevel !== this.autoLevelCapping) {
          logger.log(`Setting autoLevelCapping to ${maxLevel}: ${levels[maxLevel].height}p@${levels[maxLevel].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`);
        }
        hls.autoLevelCapping = maxLevel;
        if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {
          this.streamController.nextLevelSwitch();
        }
        this.autoLevelCapping = hls.autoLevelCapping;
      }
    }
  }
  getMaxLevel(capLevelIndex) {
    const levels = this.hls.levels;
    if (!levels.length) {
      return -1;
    }
    const validLevels = levels.filter((level, index) => this.isLevelAllowed(level) && index <= capLevelIndex);
    this.clientRect = null;
    return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
  }
  startCapping() {
    if (this.timer) {
      return;
    }
    this.autoLevelCapping = Number.POSITIVE_INFINITY;
    self.clearInterval(this.timer);
    this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);
    this.detectPlayerSize();
  }
  stopCapping() {
    this.restrictedLevels = [];
    this.firstLevel = -1;
    this.autoLevelCapping = Number.POSITIVE_INFINITY;
    if (this.timer) {
      self.clearInterval(this.timer);
      this.timer = undefined;
    }
  }
  getDimensions() {
    if (this.clientRect) {
      return this.clientRect;
    }
    const media = this.media;
    const boundsRect = {
      width: 0,
      height: 0
    };
    if (media) {
      const clientRect = media.getBoundingClientRect();
      boundsRect.width = clientRect.width;
      boundsRect.height = clientRect.height;
      if (!boundsRect.width && !boundsRect.height) {
        boundsRect.width = clientRect.right - clientRect.left || media.width || 0;
        boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;
      }
    }
    this.clientRect = boundsRect;
    return boundsRect;
  }
  get mediaWidth() {
    return this.getDimensions().width * this.contentScaleFactor;
  }
  get mediaHeight() {
    return this.getDimensions().height * this.contentScaleFactor;
  }
  get contentScaleFactor() {
    let pixelRatio = 1;
    if (!this.hls.config.ignoreDevicePixelRatio) {
      try {
        pixelRatio = self.devicePixelRatio;
      } catch (e) {
      }
    }
    return pixelRatio;
  }
  isLevelAllowed(level) {
    const restrictedLevels = this.restrictedLevels;
    return !restrictedLevels.some((restrictedLevel) => {
      return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;
    });
  }
  static getMaxLevelByMediaSize(levels, width, height) {
    if (!(levels != null && levels.length)) {
      return -1;
    }
    const atGreatestBandwidth = (curLevel, nextLevel) => {
      if (!nextLevel) {
        return true;
      }
      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
    };
    let maxLevelIndex = levels.length - 1;
    const squareSize = Math.max(width, height);
    for (let i = 0;i < levels.length; i += 1) {
      const level = levels[i];
      if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {
        maxLevelIndex = i;
        break;
      }
    }
    return maxLevelIndex;
  }
}

class FPSController {
  constructor(hls) {
    this.hls = undefined;
    this.isVideoPlaybackQualityAvailable = false;
    this.timer = undefined;
    this.media = null;
    this.lastTime = undefined;
    this.lastDroppedFrames = 0;
    this.lastDecodedFrames = 0;
    this.streamController = undefined;
    this.hls = hls;
    this.registerListeners();
  }
  setStreamController(streamController) {
    this.streamController = streamController;
  }
  registerListeners() {
    this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
  }
  unregisterListeners() {
    this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
  }
  destroy() {
    if (this.timer) {
      clearInterval(this.timer);
    }
    this.unregisterListeners();
    this.isVideoPlaybackQualityAvailable = false;
    this.media = null;
  }
  onMediaAttaching(event, data) {
    const config = this.hls.config;
    if (config.capLevelOnFPSDrop) {
      const media = data.media instanceof self.HTMLVideoElement ? data.media : null;
      this.media = media;
      if (media && typeof media.getVideoPlaybackQuality === "function") {
        this.isVideoPlaybackQualityAvailable = true;
      }
      self.clearInterval(this.timer);
      this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
    }
  }
  checkFPS(video, decodedFrames, droppedFrames) {
    const currentTime = performance.now();
    if (decodedFrames) {
      if (this.lastTime) {
        const currentPeriod = currentTime - this.lastTime;
        const currentDropped = droppedFrames - this.lastDroppedFrames;
        const currentDecoded = decodedFrames - this.lastDecodedFrames;
        const droppedFPS = 1000 * currentDropped / currentPeriod;
        const hls = this.hls;
        hls.trigger(Events.FPS_DROP, {
          currentDropped,
          currentDecoded,
          totalDroppedFrames: droppedFrames
        });
        if (droppedFPS > 0) {
          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
            let currentLevel = hls.currentLevel;
            logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + currentLevel);
            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
              currentLevel = currentLevel - 1;
              hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {
                level: currentLevel,
                droppedLevel: hls.currentLevel
              });
              hls.autoLevelCapping = currentLevel;
              this.streamController.nextLevelSwitch();
            }
          }
        }
      }
      this.lastTime = currentTime;
      this.lastDroppedFrames = droppedFrames;
      this.lastDecodedFrames = decodedFrames;
    }
  }
  checkFPSInterval() {
    const video = this.media;
    if (video) {
      if (this.isVideoPlaybackQualityAvailable) {
        const videoPlaybackQuality = video.getVideoPlaybackQuality();
        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
      } else {
        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
      }
    }
  }
}
var LOGGER_PREFIX = "[eme]";

class EMEController {
  constructor(hls) {
    this.hls = undefined;
    this.config = undefined;
    this.media = null;
    this.keyFormatPromise = null;
    this.keySystemAccessPromises = {};
    this._requestLicenseFailureCount = 0;
    this.mediaKeySessions = [];
    this.keyIdToKeySessionPromise = {};
    this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [EMEController.CDMCleanupPromise] : [];
    this.onMediaEncrypted = this._onMediaEncrypted.bind(this);
    this.onWaitingForKey = this._onWaitingForKey.bind(this);
    this.debug = logger.debug.bind(logger, LOGGER_PREFIX);
    this.log = logger.log.bind(logger, LOGGER_PREFIX);
    this.warn = logger.warn.bind(logger, LOGGER_PREFIX);
    this.error = logger.error.bind(logger, LOGGER_PREFIX);
    this.hls = hls;
    this.config = hls.config;
    this.registerListeners();
  }
  destroy() {
    this.unregisterListeners();
    this.onMediaDetached();
    const config = this.config;
    config.requestMediaKeySystemAccessFunc = null;
    config.licenseXhrSetup = config.licenseResponseCallback = undefined;
    config.drmSystems = config.drmSystemOptions = {};
    this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;
    this.config = null;
  }
  registerListeners() {
    this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);
    this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
  }
  unregisterListeners() {
    this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);
    this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
  }
  getLicenseServerUrl(keySystem) {
    const {
      drmSystems,
      widevineLicenseUrl
    } = this.config;
    const keySystemConfiguration = drmSystems[keySystem];
    if (keySystemConfiguration) {
      return keySystemConfiguration.licenseUrl;
    }
    if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {
      return widevineLicenseUrl;
    }
    throw new Error(`no license server URL configured for key-system "${keySystem}"`);
  }
  getServerCertificateUrl(keySystem) {
    const {
      drmSystems
    } = this.config;
    const keySystemConfiguration = drmSystems[keySystem];
    if (keySystemConfiguration) {
      return keySystemConfiguration.serverCertificateUrl;
    } else {
      this.log(`No Server Certificate in config.drmSystems["${keySystem}"]`);
    }
  }
  attemptKeySystemAccess(keySystemsToAttempt) {
    const levels = this.hls.levels;
    const uniqueCodec = (value, i, a) => !!value && a.indexOf(value) === i;
    const audioCodecs = levels.map((level) => level.audioCodec).filter(uniqueCodec);
    const videoCodecs = levels.map((level) => level.videoCodec).filter(uniqueCodec);
    if (audioCodecs.length + videoCodecs.length === 0) {
      videoCodecs.push("avc1.42e01e");
    }
    return new Promise((resolve, reject) => {
      const attempt = (keySystems) => {
        const keySystem = keySystems.shift();
        this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then((mediaKeys) => resolve({
          keySystem,
          mediaKeys
        })).catch((error) => {
          if (keySystems.length) {
            attempt(keySystems);
          } else if (error instanceof EMEKeyError) {
            reject(error);
          } else {
            reject(new EMEKeyError({
              type: ErrorTypes.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,
              error,
              fatal: true
            }, error.message));
          }
        });
      };
      attempt(keySystemsToAttempt);
    });
  }
  requestMediaKeySystemAccess(keySystem, supportedConfigurations) {
    const {
      requestMediaKeySystemAccessFunc
    } = this.config;
    if (!(typeof requestMediaKeySystemAccessFunc === "function")) {
      let errMessage = `Configured requestMediaKeySystemAccess is not a function ${requestMediaKeySystemAccessFunc}`;
      if (requestMediaKeySystemAccess === null && self.location.protocol === "http:") {
        errMessage = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`;
      }
      return Promise.reject(new Error(errMessage));
    }
    return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);
  }
  getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {
    const mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);
    const keySystemAccessPromises = this.keySystemAccessPromises[keySystem];
    let keySystemAccess = keySystemAccessPromises == null ? undefined : keySystemAccessPromises.keySystemAccess;
    if (!keySystemAccess) {
      this.log(`Requesting encrypted media "${keySystem}" key-system access with config: ${JSON.stringify(mediaKeySystemConfigs)}`);
      keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);
      const _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {
        keySystemAccess
      };
      keySystemAccess.catch((error) => {
        this.log(`Failed to obtain access to key-system "${keySystem}": ${error}`);
      });
      return keySystemAccess.then((mediaKeySystemAccess) => {
        this.log(`Access for key-system "${mediaKeySystemAccess.keySystem}" obtained`);
        const certificateRequest = this.fetchServerCertificate(keySystem);
        this.log(`Create media-keys for "${keySystem}"`);
        _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then((mediaKeys) => {
          this.log(`Media-keys created for "${keySystem}"`);
          return certificateRequest.then((certificate) => {
            if (certificate) {
              return this.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);
            }
            return mediaKeys;
          });
        });
        _keySystemAccessPromises.mediaKeys.catch((error) => {
          this.error(`Failed to create media-keys for "${keySystem}"}: ${error}`);
        });
        return _keySystemAccessPromises.mediaKeys;
      });
    }
    return keySystemAccess.then(() => keySystemAccessPromises.mediaKeys);
  }
  createMediaKeySessionContext({
    decryptdata,
    keySystem,
    mediaKeys
  }) {
    this.log(`Creating key-system session "${keySystem}" keyId: ${Hex.hexDump(decryptdata.keyId || [])}`);
    const mediaKeysSession = mediaKeys.createSession();
    const mediaKeySessionContext = {
      decryptdata,
      keySystem,
      mediaKeys,
      mediaKeysSession,
      keyStatus: "status-pending"
    };
    this.mediaKeySessions.push(mediaKeySessionContext);
    return mediaKeySessionContext;
  }
  renewKeySession(mediaKeySessionContext) {
    const decryptdata = mediaKeySessionContext.decryptdata;
    if (decryptdata.pssh) {
      const keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);
      const keyId = this.getKeyIdString(decryptdata);
      const scheme = "cenc";
      this.keyIdToKeySessionPromise[keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, "expired");
    } else {
      this.warn(`Could not renew expired session. Missing pssh initData.`);
    }
    this.removeSession(mediaKeySessionContext);
  }
  getKeyIdString(decryptdata) {
    if (!decryptdata) {
      throw new Error("Could not read keyId of undefined decryptdata");
    }
    if (decryptdata.keyId === null) {
      throw new Error("keyId is null");
    }
    return Hex.hexDump(decryptdata.keyId);
  }
  updateKeySession(mediaKeySessionContext, data) {
    var _mediaKeySessionConte;
    const keySession = mediaKeySessionContext.mediaKeysSession;
    this.log(`Updating key-session "${keySession.sessionId}" for keyID ${Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? undefined : _mediaKeySessionConte.keyId) || [])}
      } (data length: ${data ? data.byteLength : data})`);
    return keySession.update(data);
  }
  selectKeySystemFormat(frag) {
    const keyFormats = Object.keys(frag.levelkeys || {});
    if (!this.keyFormatPromise) {
      this.log(`Selecting key-system from fragment (sn: ${frag.sn} ${frag.type}: ${frag.level}) key formats ${keyFormats.join(", ")}`);
      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
    }
    return this.keyFormatPromise;
  }
  getKeyFormatPromise(keyFormats) {
    return new Promise((resolve, reject) => {
      const keySystemsInConfig = getKeySystemsForConfig(this.config);
      const keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter((value) => !!value && keySystemsInConfig.indexOf(value) !== -1);
      return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({
        keySystem
      }) => {
        const keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);
        if (keySystemFormat) {
          resolve(keySystemFormat);
        } else {
          reject(new Error(`Unable to find format for key-system "${keySystem}"`));
        }
      }).catch(reject);
    });
  }
  loadKey(data) {
    const decryptdata = data.keyInfo.decryptdata;
    const keyId = this.getKeyIdString(decryptdata);
    const keyDetails = `(keyId: ${keyId} format: "${decryptdata.keyFormat}" method: ${decryptdata.method} uri: ${decryptdata.uri})`;
    this.log(`Starting session for key ${keyDetails}`);
    let keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];
    if (!keySessionContextPromise) {
      keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(({
        keySystem,
        mediaKeys
      }) => {
        this.throwIfDestroyed();
        this.log(`Handle encrypted media sn: ${data.frag.sn} ${data.frag.type}: ${data.frag.level} using key ${keyDetails}`);
        return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {
          this.throwIfDestroyed();
          const keySessionContext = this.createMediaKeySessionContext({
            keySystem,
            mediaKeys,
            decryptdata
          });
          const scheme = "cenc";
          return this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, "playlist-key");
        });
      });
      keySessionContextPromise.catch((error) => this.handleError(error));
    }
    return keySessionContextPromise;
  }
  throwIfDestroyed(message = "Invalid state") {
    if (!this.hls) {
      throw new Error("invalid state");
    }
  }
  handleError(error) {
    if (!this.hls) {
      return;
    }
    this.error(error.message);
    if (error instanceof EMEKeyError) {
      this.hls.trigger(Events.ERROR, error.data);
    } else {
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.KEY_SYSTEM_ERROR,
        details: ErrorDetails.KEY_SYSTEM_NO_KEYS,
        error,
        fatal: true
      });
    }
  }
  getKeySystemForKeyPromise(decryptdata) {
    const keyId = this.getKeyIdString(decryptdata);
    const mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];
    if (!mediaKeySessionContext) {
      const keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);
      const keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);
      return this.attemptKeySystemAccess(keySystemsToAttempt);
    }
    return mediaKeySessionContext;
  }
  getKeySystemSelectionPromise(keySystemsToAttempt) {
    if (!keySystemsToAttempt.length) {
      keySystemsToAttempt = getKeySystemsForConfig(this.config);
    }
    if (keySystemsToAttempt.length === 0) {
      throw new EMEKeyError({
        type: ErrorTypes.KEY_SYSTEM_ERROR,
        details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
        fatal: true
      }, `Missing key-system license configuration options ${JSON.stringify({
        drmSystems: this.config.drmSystems
      })}`);
    }
    return this.attemptKeySystemAccess(keySystemsToAttempt);
  }
  _onMediaEncrypted(event) {
    const {
      initDataType,
      initData
    } = event;
    const logMessage = `"${event.type}" event: init data type: "${initDataType}"`;
    this.debug(logMessage);
    if (initData === null) {
      return;
    }
    let keyId;
    let keySystemDomain;
    if (initDataType === "sinf" && this.config.drmSystems[KeySystems.FAIRPLAY]) {
      const json = bin2str(new Uint8Array(initData));
      try {
        const sinf = base64Decode(JSON.parse(json).sinf);
        const tenc = parseSinf(new Uint8Array(sinf));
        if (!tenc) {
          throw new Error(`'schm' box missing or not cbcs/cenc with schi > tenc`);
        }
        keyId = tenc.subarray(8, 24);
        keySystemDomain = KeySystems.FAIRPLAY;
      } catch (error) {
        this.warn(`${logMessage} Failed to parse sinf: ${error}`);
        return;
      }
    } else {
      const psshResults = parseMultiPssh(initData);
      const psshInfo = psshResults.filter((pssh) => pssh.systemId === KeySystemIds.WIDEVINE)[0];
      if (!psshInfo) {
        if (psshResults.length === 0 || psshResults.some((pssh) => !pssh.systemId)) {
          this.warn(`${logMessage} contains incomplete or invalid pssh data`);
        } else {
          this.log(`ignoring ${logMessage} for ${psshResults.map((pssh) => keySystemIdToKeySystemDomain(pssh.systemId)).join(",")} pssh data in favor of playlist keys`);
        }
        return;
      }
      keySystemDomain = keySystemIdToKeySystemDomain(psshInfo.systemId);
      if (psshInfo.version === 0 && psshInfo.data) {
        const offset = psshInfo.data.length - 22;
        keyId = psshInfo.data.subarray(offset, offset + 16);
      }
    }
    if (!keySystemDomain || !keyId) {
      return;
    }
    const keyIdHex = Hex.hexDump(keyId);
    const {
      keyIdToKeySessionPromise,
      mediaKeySessions
    } = this;
    let keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];
    for (let i = 0;i < mediaKeySessions.length; i++) {
      const keyContext = mediaKeySessions[i];
      const decryptdata = keyContext.decryptdata;
      if (!decryptdata.keyId) {
        continue;
      }
      const oldKeyIdHex = Hex.hexDump(decryptdata.keyId);
      if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, "").indexOf(keyIdHex) !== -1) {
        keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];
        if (decryptdata.pssh) {
          break;
        }
        delete keyIdToKeySessionPromise[oldKeyIdHex];
        decryptdata.pssh = new Uint8Array(initData);
        decryptdata.keyId = keyId;
        keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(() => {
          return this.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, "encrypted-event-key-match");
        });
        break;
      }
    }
    if (!keySessionContextPromise) {
      keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([keySystemDomain]).then(({
        keySystem,
        mediaKeys
      }) => {
        var _keySystemToKeySystem;
        this.throwIfDestroyed();
        const decryptdata = new LevelKey("ISO-23001-7", keyIdHex, (_keySystemToKeySystem = keySystemDomainToKeySystemFormat(keySystem)) != null ? _keySystemToKeySystem : "");
        decryptdata.pssh = new Uint8Array(initData);
        decryptdata.keyId = keyId;
        return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {
          this.throwIfDestroyed();
          const keySessionContext = this.createMediaKeySessionContext({
            decryptdata,
            keySystem,
            mediaKeys
          });
          return this.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, "encrypted-event-no-match");
        });
      });
    }
    keySessionContextPromise.catch((error) => this.handleError(error));
  }
  _onWaitingForKey(event) {
    this.log(`"${event.type}" event`);
  }
  attemptSetMediaKeys(keySystem, mediaKeys) {
    const queue = this.setMediaKeysQueue.slice();
    this.log(`Setting media-keys for "${keySystem}"`);
    const setMediaKeysPromise = Promise.all(queue).then(() => {
      if (!this.media) {
        throw new Error("Attempted to set mediaKeys without media element attached");
      }
      return this.media.setMediaKeys(mediaKeys);
    });
    this.setMediaKeysQueue.push(setMediaKeysPromise);
    return setMediaKeysPromise.then(() => {
      this.log(`Media-keys set for "${keySystem}"`);
      queue.push(setMediaKeysPromise);
      this.setMediaKeysQueue = this.setMediaKeysQueue.filter((p) => queue.indexOf(p) === -1);
    });
  }
  generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {
    var _this$config$drmSyste, _this$config$drmSyste2;
    const generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? undefined : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? undefined : _this$config$drmSyste2.generateRequest;
    if (generateRequestFilter) {
      try {
        const mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);
        if (!mappedInitData) {
          throw new Error("Invalid response from configured generateRequest filter");
        }
        initDataType = mappedInitData.initDataType;
        initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;
      } catch (error) {
        var _this$hls;
        this.warn(error.message);
        if ((_this$hls = this.hls) != null && _this$hls.config.debug) {
          throw error;
        }
      }
    }
    if (initData === null) {
      this.log(`Skipping key-session request for "${reason}" (no initData)`);
      return Promise.resolve(context);
    }
    const keyId = this.getKeyIdString(context.decryptdata);
    this.log(`Generating key-session request for "${reason}": ${keyId} (init data type: ${initDataType} length: ${initData ? initData.byteLength : null})`);
    const licenseStatus = new EventEmitter;
    const onmessage = context._onmessage = (event) => {
      const keySession = context.mediaKeysSession;
      if (!keySession) {
        licenseStatus.emit("error", new Error("invalid state"));
        return;
      }
      const {
        messageType,
        message
      } = event;
      this.log(`"${messageType}" message event for session "${keySession.sessionId}" message size: ${message.byteLength}`);
      if (messageType === "license-request" || messageType === "license-renewal") {
        this.renewLicense(context, message).catch((error) => {
          this.handleError(error);
          licenseStatus.emit("error", error);
        });
      } else if (messageType === "license-release") {
        if (context.keySystem === KeySystems.FAIRPLAY) {
          this.updateKeySession(context, strToUtf8array("acknowledged"));
          this.removeSession(context);
        }
      } else {
        this.warn(`unhandled media key message type "${messageType}"`);
      }
    };
    const onkeystatuseschange = context._onkeystatuseschange = (event) => {
      const keySession = context.mediaKeysSession;
      if (!keySession) {
        licenseStatus.emit("error", new Error("invalid state"));
        return;
      }
      this.onKeyStatusChange(context);
      const keyStatus = context.keyStatus;
      licenseStatus.emit("keyStatus", keyStatus);
      if (keyStatus === "expired") {
        this.warn(`${context.keySystem} expired for key ${keyId}`);
        this.renewKeySession(context);
      }
    };
    context.mediaKeysSession.addEventListener("message", onmessage);
    context.mediaKeysSession.addEventListener("keystatuseschange", onkeystatuseschange);
    const keyUsablePromise = new Promise((resolve, reject) => {
      licenseStatus.on("error", reject);
      licenseStatus.on("keyStatus", (keyStatus) => {
        if (keyStatus.startsWith("usable")) {
          resolve();
        } else if (keyStatus === "output-restricted") {
          reject(new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
            fatal: false
          }, "HDCP level output restricted"));
        } else if (keyStatus === "internal-error") {
          reject(new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
            fatal: true
          }, `key status changed to "${keyStatus}"`));
        } else if (keyStatus === "expired") {
          reject(new Error("key expired while generating request"));
        } else {
          this.warn(`unhandled key status change "${keyStatus}"`);
        }
      });
    });
    return context.mediaKeysSession.generateRequest(initDataType, initData).then(() => {
      var _context$mediaKeysSes;
      this.log(`Request generated for key-session "${(_context$mediaKeysSes = context.mediaKeysSession) == null ? undefined : _context$mediaKeysSes.sessionId}" keyId: ${keyId}`);
    }).catch((error) => {
      throw new EMEKeyError({
        type: ErrorTypes.KEY_SYSTEM_ERROR,
        details: ErrorDetails.KEY_SYSTEM_NO_SESSION,
        error,
        fatal: false
      }, `Error generating key-session request: ${error}`);
    }).then(() => keyUsablePromise).catch((error) => {
      licenseStatus.removeAllListeners();
      this.removeSession(context);
      throw error;
    }).then(() => {
      licenseStatus.removeAllListeners();
      return context;
    });
  }
  onKeyStatusChange(mediaKeySessionContext) {
    mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach((status2, keyId) => {
      this.log(`key status change "${status2}" for keyStatuses keyId: ${Hex.hexDump("buffer" in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId))} session keyId: ${Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || []))} uri: ${mediaKeySessionContext.decryptdata.uri}`);
      mediaKeySessionContext.keyStatus = status2;
    });
  }
  fetchServerCertificate(keySystem) {
    const config = this.config;
    const Loader = config.loader;
    const certLoader = new Loader(config);
    const url = this.getServerCertificateUrl(keySystem);
    if (!url) {
      return Promise.resolve();
    }
    this.log(`Fetching server certificate for "${keySystem}"`);
    return new Promise((resolve, reject) => {
      const loaderContext = {
        responseType: "arraybuffer",
        url
      };
      const loadPolicy = config.certLoadPolicy.default;
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      };
      const loaderCallbacks = {
        onSuccess: (response, stats, context, networkDetails) => {
          resolve(response.data);
        },
        onError: (response, contex, networkDetails, stats) => {
          reject(new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: true,
            networkDetails,
            response: _objectSpread2({
              url: loaderContext.url,
              data: undefined
            }, response)
          }, `"${keySystem}" certificate request failed (${url}). Status: ${response.code} (${response.text})`));
        },
        onTimeout: (stats, context, networkDetails) => {
          reject(new EMEKeyError({
            type: ErrorTypes.KEY_SYSTEM_ERROR,
            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
            fatal: true,
            networkDetails,
            response: {
              url: loaderContext.url,
              data: undefined
            }
          }, `"${keySystem}" certificate request timed out (${url})`));
        },
        onAbort: (stats, context, networkDetails) => {
          reject(new Error("aborted"));
        }
      };
      certLoader.load(loaderContext, loaderConfig, loaderCallbacks);
    });
  }
  setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {
    return new Promise((resolve, reject) => {
      mediaKeys.setServerCertificate(cert).then((success) => {
        this.log(`setServerCertificate ${success ? "success" : "not supported by CDM"} (${cert == null ? undefined : cert.byteLength}) on "${keySystem}"`);
        resolve(mediaKeys);
      }).catch((error) => {
        reject(new EMEKeyError({
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
          error,
          fatal: true
        }, error.message));
      });
    });
  }
  renewLicense(context, keyMessage) {
    return this.requestLicense(context, new Uint8Array(keyMessage)).then((data) => {
      return this.updateKeySession(context, new Uint8Array(data)).catch((error) => {
        throw new EMEKeyError({
          type: ErrorTypes.KEY_SYSTEM_ERROR,
          details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,
          error,
          fatal: true
        }, error.message);
      });
    });
  }
  unpackPlayReadyKeyMessage(xhr, licenseChallenge) {
    const xmlString = String.fromCharCode.apply(null, new Uint16Array(licenseChallenge.buffer));
    if (!xmlString.includes("PlayReadyKeyMessage")) {
      xhr.setRequestHeader("Content-Type", "text/xml; charset=utf-8");
      return licenseChallenge;
    }
    const keyMessageXml = new DOMParser().parseFromString(xmlString, "application/xml");
    const headers = keyMessageXml.querySelectorAll("HttpHeader");
    if (headers.length > 0) {
      let header;
      for (let i = 0, len = headers.length;i < len; i++) {
        var _header$querySelector, _header$querySelector2;
        header = headers[i];
        const name = (_header$querySelector = header.querySelector("name")) == null ? undefined : _header$querySelector.textContent;
        const value = (_header$querySelector2 = header.querySelector("value")) == null ? undefined : _header$querySelector2.textContent;
        if (name && value) {
          xhr.setRequestHeader(name, value);
        }
      }
    }
    const challengeElement = keyMessageXml.querySelector("Challenge");
    const challengeText = challengeElement == null ? undefined : challengeElement.textContent;
    if (!challengeText) {
      throw new Error(`Cannot find <Challenge> in key message`);
    }
    return strToUtf8array(atob(challengeText));
  }
  setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {
    const licenseXhrSetup = this.config.licenseXhrSetup;
    if (!licenseXhrSetup) {
      xhr.open("POST", url, true);
      return Promise.resolve({
        xhr,
        licenseChallenge
      });
    }
    return Promise.resolve().then(() => {
      if (!keysListItem.decryptdata) {
        throw new Error("Key removed");
      }
      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);
    }).catch((error) => {
      if (!keysListItem.decryptdata) {
        throw error;
      }
      xhr.open("POST", url, true);
      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);
    }).then((licenseXhrSetupResult) => {
      if (!xhr.readyState) {
        xhr.open("POST", url, true);
      }
      const finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;
      return {
        xhr,
        licenseChallenge: finalLicenseChallenge
      };
    });
  }
  requestLicense(keySessionContext, licenseChallenge) {
    const keyLoadPolicy = this.config.keyLoadPolicy.default;
    return new Promise((resolve, reject) => {
      const url = this.getLicenseServerUrl(keySessionContext.keySystem);
      this.log(`Sending license request to URL: ${url}`);
      const xhr = new XMLHttpRequest;
      xhr.responseType = "arraybuffer";
      xhr.onreadystatechange = () => {
        if (!this.hls || !keySessionContext.mediaKeysSession) {
          return reject(new Error("invalid state"));
        }
        if (xhr.readyState === 4) {
          if (xhr.status === 200) {
            this._requestLicenseFailureCount = 0;
            let data = xhr.response;
            this.log(`License received ${data instanceof ArrayBuffer ? data.byteLength : data}`);
            const licenseResponseCallback = this.config.licenseResponseCallback;
            if (licenseResponseCallback) {
              try {
                data = licenseResponseCallback.call(this.hls, xhr, url, keySessionContext);
              } catch (error) {
                this.error(error);
              }
            }
            resolve(data);
          } else {
            const retryConfig = keyLoadPolicy.errorRetry;
            const maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;
            this._requestLicenseFailureCount++;
            if (this._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {
              reject(new EMEKeyError({
                type: ErrorTypes.KEY_SYSTEM_ERROR,
                details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                fatal: true,
                networkDetails: xhr,
                response: {
                  url,
                  data: undefined,
                  code: xhr.status,
                  text: xhr.statusText
                }
              }, `License Request XHR failed (${url}). Status: ${xhr.status} (${xhr.statusText})`));
            } else {
              const attemptsLeft = maxNumRetry - this._requestLicenseFailureCount + 1;
              this.warn(`Retrying license request, ${attemptsLeft} attempts left`);
              this.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);
            }
          }
        }
      };
      if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {
        keySessionContext.licenseXhr.abort();
      }
      keySessionContext.licenseXhr = xhr;
      this.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(({
        xhr: xhr2,
        licenseChallenge: licenseChallenge2
      }) => {
        if (keySessionContext.keySystem == KeySystems.PLAYREADY) {
          licenseChallenge2 = this.unpackPlayReadyKeyMessage(xhr2, licenseChallenge2);
        }
        xhr2.send(licenseChallenge2);
      });
    });
  }
  onMediaAttached(event, data) {
    if (!this.config.emeEnabled) {
      return;
    }
    const media = data.media;
    this.media = media;
    media.addEventListener("encrypted", this.onMediaEncrypted);
    media.addEventListener("waitingforkey", this.onWaitingForKey);
  }
  onMediaDetached() {
    const media = this.media;
    const mediaKeysList = this.mediaKeySessions;
    if (media) {
      media.removeEventListener("encrypted", this.onMediaEncrypted);
      media.removeEventListener("waitingforkey", this.onWaitingForKey);
      this.media = null;
    }
    this._requestLicenseFailureCount = 0;
    this.setMediaKeysQueue = [];
    this.mediaKeySessions = [];
    this.keyIdToKeySessionPromise = {};
    LevelKey.clearKeyUriToKeyIdMap();
    const keySessionCount = mediaKeysList.length;
    EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map((mediaKeySessionContext) => this.removeSession(mediaKeySessionContext)).concat(media == null ? undefined : media.setMediaKeys(null).catch((error) => {
      this.log(`Could not clear media keys: ${error}`);
    }))).then(() => {
      if (keySessionCount) {
        this.log("finished closing key sessions and clearing media keys");
        mediaKeysList.length = 0;
      }
    }).catch((error) => {
      this.log(`Could not close sessions and clear media keys: ${error}`);
    });
  }
  onManifestLoading() {
    this.keyFormatPromise = null;
  }
  onManifestLoaded(event, {
    sessionKeys
  }) {
    if (!sessionKeys || !this.config.emeEnabled) {
      return;
    }
    if (!this.keyFormatPromise) {
      const keyFormats = sessionKeys.reduce((formats, sessionKey) => {
        if (formats.indexOf(sessionKey.keyFormat) === -1) {
          formats.push(sessionKey.keyFormat);
        }
        return formats;
      }, []);
      this.log(`Selecting key-system from session-keys ${keyFormats.join(", ")}`);
      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
    }
  }
  removeSession(mediaKeySessionContext) {
    const {
      mediaKeysSession,
      licenseXhr
    } = mediaKeySessionContext;
    if (mediaKeysSession) {
      this.log(`Remove licenses and keys and close session ${mediaKeysSession.sessionId}`);
      if (mediaKeySessionContext._onmessage) {
        mediaKeysSession.removeEventListener("message", mediaKeySessionContext._onmessage);
        mediaKeySessionContext._onmessage = undefined;
      }
      if (mediaKeySessionContext._onkeystatuseschange) {
        mediaKeysSession.removeEventListener("keystatuseschange", mediaKeySessionContext._onkeystatuseschange);
        mediaKeySessionContext._onkeystatuseschange = undefined;
      }
      if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {
        licenseXhr.abort();
      }
      mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = undefined;
      const index = this.mediaKeySessions.indexOf(mediaKeySessionContext);
      if (index > -1) {
        this.mediaKeySessions.splice(index, 1);
      }
      return mediaKeysSession.remove().catch((error) => {
        this.log(`Could not remove session: ${error}`);
      }).then(() => {
        return mediaKeysSession.close();
      }).catch((error) => {
        this.log(`Could not close session: ${error}`);
      });
    }
  }
}
EMEController.CDMCleanupPromise = undefined;

class EMEKeyError extends Error {
  constructor(data, message) {
    super(message);
    this.data = undefined;
    data.error || (data.error = new Error(message));
    this.data = data;
    data.err = data.error;
  }
}
var CmObjectType;
(function(CmObjectType2) {
  CmObjectType2["MANIFEST"] = "m";
  CmObjectType2["AUDIO"] = "a";
  CmObjectType2["VIDEO"] = "v";
  CmObjectType2["MUXED"] = "av";
  CmObjectType2["INIT"] = "i";
  CmObjectType2["CAPTION"] = "c";
  CmObjectType2["TIMED_TEXT"] = "tt";
  CmObjectType2["KEY"] = "k";
  CmObjectType2["OTHER"] = "o";
})(CmObjectType || (CmObjectType = {}));
var CmStreamingFormat;
(function(CmStreamingFormat2) {
  CmStreamingFormat2["DASH"] = "d";
  CmStreamingFormat2["HLS"] = "h";
  CmStreamingFormat2["SMOOTH"] = "s";
  CmStreamingFormat2["OTHER"] = "o";
})(CmStreamingFormat || (CmStreamingFormat = {}));
var CmcdHeaderField;
(function(CmcdHeaderField2) {
  CmcdHeaderField2["OBJECT"] = "CMCD-Object";
  CmcdHeaderField2["REQUEST"] = "CMCD-Request";
  CmcdHeaderField2["SESSION"] = "CMCD-Session";
  CmcdHeaderField2["STATUS"] = "CMCD-Status";
})(CmcdHeaderField || (CmcdHeaderField = {}));
var CmcdHeaderMap = {
  [CmcdHeaderField.OBJECT]: ["br", "d", "ot", "tb"],
  [CmcdHeaderField.REQUEST]: ["bl", "dl", "mtp", "nor", "nrr", "su"],
  [CmcdHeaderField.SESSION]: ["cid", "pr", "sf", "sid", "st", "v"],
  [CmcdHeaderField.STATUS]: ["bs", "rtp"]
};

class SfItem {
  constructor(value, params) {
    this.value = undefined;
    this.params = undefined;
    if (Array.isArray(value)) {
      value = value.map((v2) => v2 instanceof SfItem ? v2 : new SfItem(v2));
    }
    this.value = value;
    this.params = params;
  }
}

class SfToken {
  constructor(description) {
    this.description = undefined;
    this.description = description;
  }
}
var DICT = "Dict";
function format(value) {
  if (Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (value instanceof Map) {
    return "Map{}";
  }
  if (value instanceof Set) {
    return "Set{}";
  }
  if (typeof value === "object") {
    return JSON.stringify(value);
  }
  return String(value);
}
function throwError(action, src, type, cause) {
  return new Error(`failed to ${action} "${format(src)}" as ${type}`, {
    cause
  });
}
var BARE_ITEM = "Bare Item";
var BOOLEAN = "Boolean";
var BYTES = "Byte Sequence";
var DECIMAL = "Decimal";
var INTEGER = "Integer";
function isInvalidInt(value) {
  return value < -999999999999999 || 999999999999999 < value;
}
var STRING_REGEX = /[\x00-\x1f\x7f]+/;
var TOKEN = "Token";
var KEY = "Key";
function serializeError(src, type, cause) {
  return throwError("serialize", src, type, cause);
}
function serializeBoolean(value) {
  if (typeof value !== "boolean") {
    throw serializeError(value, BOOLEAN);
  }
  return value ? "?1" : "?0";
}
function base64encode(binary) {
  return btoa(String.fromCharCode(...binary));
}
function serializeByteSequence(value) {
  if (ArrayBuffer.isView(value) === false) {
    throw serializeError(value, BYTES);
  }
  return `:${base64encode(value)}:`;
}
function serializeInteger(value) {
  if (isInvalidInt(value)) {
    throw serializeError(value, INTEGER);
  }
  return value.toString();
}
function serializeDate(value) {
  return `@${serializeInteger(value.getTime() / 1000)}`;
}
function roundToEven(value, precision) {
  if (value < 0) {
    return -roundToEven(-value, precision);
  }
  const decimalShift = Math.pow(10, precision);
  const isEquidistant = Math.abs(value * decimalShift % 1 - 0.5) < Number.EPSILON;
  if (isEquidistant) {
    const flooredValue = Math.floor(value * decimalShift);
    return (flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift;
  } else {
    return Math.round(value * decimalShift) / decimalShift;
  }
}
function serializeDecimal(value) {
  const roundedValue = roundToEven(value, 3);
  if (Math.floor(Math.abs(roundedValue)).toString().length > 12) {
    throw serializeError(value, DECIMAL);
  }
  const stringValue = roundedValue.toString();
  return stringValue.includes(".") ? stringValue : `${stringValue}.0`;
}
var STRING = "String";
function serializeString(value) {
  if (STRING_REGEX.test(value)) {
    throw serializeError(value, STRING);
  }
  return `"${value.replace(/\\/g, `\\\\`).replace(/"/g, `\\"`)}"`;
}
function symbolToStr(symbol) {
  return symbol.description || symbol.toString().slice(7, -1);
}
function serializeToken(token) {
  const value = symbolToStr(token);
  if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(value) === false) {
    throw serializeError(value, TOKEN);
  }
  return value;
}
function serializeBareItem(value) {
  switch (typeof value) {
    case "number":
      if (!isFiniteNumber(value)) {
        throw serializeError(value, BARE_ITEM);
      }
      if (Number.isInteger(value)) {
        return serializeInteger(value);
      }
      return serializeDecimal(value);
    case "string":
      return serializeString(value);
    case "symbol":
      return serializeToken(value);
    case "boolean":
      return serializeBoolean(value);
    case "object":
      if (value instanceof Date) {
        return serializeDate(value);
      }
      if (value instanceof Uint8Array) {
        return serializeByteSequence(value);
      }
      if (value instanceof SfToken) {
        return serializeToken(value);
      }
    default:
      throw serializeError(value, BARE_ITEM);
  }
}
function serializeKey(value) {
  if (/^[a-z*][a-z0-9\-_.*]*$/.test(value) === false) {
    throw serializeError(value, KEY);
  }
  return value;
}
function serializeParams(params) {
  if (params == null) {
    return "";
  }
  return Object.entries(params).map(([key, value]) => {
    if (value === true) {
      return `;${serializeKey(key)}`;
    }
    return `;${serializeKey(key)}=${serializeBareItem(value)}`;
  }).join("");
}
function serializeItem(value) {
  if (value instanceof SfItem) {
    return `${serializeBareItem(value.value)}${serializeParams(value.params)}`;
  } else {
    return serializeBareItem(value);
  }
}
function serializeInnerList(value) {
  return `(${value.value.map(serializeItem).join(" ")})${serializeParams(value.params)}`;
}
function serializeDict(dict, options = {
  whitespace: true
}) {
  if (typeof dict !== "object") {
    throw serializeError(dict, DICT);
  }
  const entries = dict instanceof Map ? dict.entries() : Object.entries(dict);
  const optionalWhiteSpace = options != null && options.whitespace ? " " : "";
  return Array.from(entries).map(([key, item]) => {
    if (item instanceof SfItem === false) {
      item = new SfItem(item);
    }
    let output = serializeKey(key);
    if (item.value === true) {
      output += serializeParams(item.params);
    } else {
      output += "=";
      if (Array.isArray(item.value)) {
        output += serializeInnerList(item);
      } else {
        output += serializeItem(item);
      }
    }
    return output;
  }).join(`,${optionalWhiteSpace}`);
}
function encodeSfDict(value, options) {
  return serializeDict(value, options);
}
var isTokenField = (key) => key === "ot" || key === "sf" || key === "st";
var isValid = (value) => {
  if (typeof value === "number") {
    return isFiniteNumber(value);
  }
  return value != null && value !== "" && value !== false;
};
function urlToRelativePath(url, base) {
  const to = new URL(url);
  const from = new URL(base);
  if (to.origin !== from.origin) {
    return url;
  }
  const toPath = to.pathname.split("/").slice(1);
  const fromPath = from.pathname.split("/").slice(1, -1);
  while (toPath[0] === fromPath[0]) {
    toPath.shift();
    fromPath.shift();
  }
  while (fromPath.length) {
    fromPath.shift();
    toPath.unshift("..");
  }
  return toPath.join("/");
}
function uuid() {
  try {
    return crypto.randomUUID();
  } catch (error) {
    try {
      const url = URL.createObjectURL(new Blob);
      const uuid2 = url.toString();
      URL.revokeObjectURL(url);
      return uuid2.slice(uuid2.lastIndexOf("/") + 1);
    } catch (error2) {
      let dt = new Date().getTime();
      const uuid2 = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = (dt + Math.random() * 16) % 16 | 0;
        dt = Math.floor(dt / 16);
        return (c == "x" ? r : r & 3 | 8).toString(16);
      });
      return uuid2;
    }
  }
}
var toRounded = (value) => Math.round(value);
var toUrlSafe = (value, options) => {
  if (options != null && options.baseUrl) {
    value = urlToRelativePath(value, options.baseUrl);
  }
  return encodeURIComponent(value);
};
var toHundred = (value) => toRounded(value / 100) * 100;
var CmcdFormatters = {
  br: toRounded,
  d: toRounded,
  bl: toHundred,
  dl: toHundred,
  mtp: toHundred,
  nor: toUrlSafe,
  rtp: toHundred,
  tb: toRounded
};
function processCmcd(obj, options) {
  const results = {};
  if (obj == null || typeof obj !== "object") {
    return results;
  }
  const keys = Object.keys(obj).sort();
  const formatters = _extends({}, CmcdFormatters, options == null ? undefined : options.formatters);
  const filter = options == null ? undefined : options.filter;
  keys.forEach((key) => {
    if (filter != null && filter(key)) {
      return;
    }
    let value = obj[key];
    const formatter = formatters[key];
    if (formatter) {
      value = formatter(value, options);
    }
    if (key === "v" && value === 1) {
      return;
    }
    if (key == "pr" && value === 1) {
      return;
    }
    if (!isValid(value)) {
      return;
    }
    if (isTokenField(key) && typeof value === "string") {
      value = new SfToken(value);
    }
    results[key] = value;
  });
  return results;
}
function encodeCmcd(cmcd, options = {}) {
  if (!cmcd) {
    return "";
  }
  return encodeSfDict(processCmcd(cmcd, options), _extends({
    whitespace: false
  }, options));
}
function toCmcdHeaders(cmcd, options = {}) {
  if (!cmcd) {
    return {};
  }
  const entries = Object.entries(cmcd);
  const headerMap = Object.entries(CmcdHeaderMap).concat(Object.entries((options == null ? undefined : options.customHeaderMap) || {}));
  const shards = entries.reduce((acc, entry) => {
    var _headerMap$find, _acc$field;
    const [key, value] = entry;
    const field = ((_headerMap$find = headerMap.find((entry2) => entry2[1].includes(key))) == null ? undefined : _headerMap$find[0]) || CmcdHeaderField.REQUEST;
    (_acc$field = acc[field]) != null || (acc[field] = {});
    acc[field][key] = value;
    return acc;
  }, {});
  return Object.entries(shards).reduce((acc, [field, value]) => {
    acc[field] = encodeCmcd(value, options);
    return acc;
  }, {});
}
function appendCmcdHeaders(headers, cmcd, options) {
  return _extends(headers, toCmcdHeaders(cmcd, options));
}
var CMCD_PARAM = "CMCD";
function toCmcdQuery(cmcd, options = {}) {
  if (!cmcd) {
    return "";
  }
  const params = encodeCmcd(cmcd, options);
  return `${CMCD_PARAM}=${encodeURIComponent(params)}`;
}
var REGEX = /CMCD=[^&#]+/;
function appendCmcdQuery(url, cmcd, options) {
  const query = toCmcdQuery(cmcd, options);
  if (!query) {
    return url;
  }
  if (REGEX.test(url)) {
    return url.replace(REGEX, query);
  }
  const separator = url.includes("?") ? "&" : "?";
  return `${url}${separator}${query}`;
}

class CMCDController {
  constructor(hls) {
    this.hls = undefined;
    this.config = undefined;
    this.media = undefined;
    this.sid = undefined;
    this.cid = undefined;
    this.useHeaders = false;
    this.includeKeys = undefined;
    this.initialized = false;
    this.starved = false;
    this.buffering = true;
    this.audioBuffer = undefined;
    this.videoBuffer = undefined;
    this.onWaiting = () => {
      if (this.initialized) {
        this.starved = true;
      }
      this.buffering = true;
    };
    this.onPlaying = () => {
      if (!this.initialized) {
        this.initialized = true;
      }
      this.buffering = false;
    };
    this.applyPlaylistData = (context) => {
      try {
        this.apply(context, {
          ot: CmObjectType.MANIFEST,
          su: !this.initialized
        });
      } catch (error) {
        logger.warn("Could not generate manifest CMCD data.", error);
      }
    };
    this.applyFragmentData = (context) => {
      try {
        const fragment = context.frag;
        const level = this.hls.levels[fragment.level];
        const ot = this.getObjectType(fragment);
        const data = {
          d: fragment.duration * 1000,
          ot
        };
        if (ot === CmObjectType.VIDEO || ot === CmObjectType.AUDIO || ot == CmObjectType.MUXED) {
          data.br = level.bitrate / 1000;
          data.tb = this.getTopBandwidth(ot) / 1000;
          data.bl = this.getBufferLength(ot);
        }
        this.apply(context, data);
      } catch (error) {
        logger.warn("Could not generate segment CMCD data.", error);
      }
    };
    this.hls = hls;
    const config = this.config = hls.config;
    const {
      cmcd
    } = config;
    if (cmcd != null) {
      config.pLoader = this.createPlaylistLoader();
      config.fLoader = this.createFragmentLoader();
      this.sid = cmcd.sessionId || uuid();
      this.cid = cmcd.contentId;
      this.useHeaders = cmcd.useHeaders === true;
      this.includeKeys = cmcd.includeKeys;
      this.registerListeners();
    }
  }
  registerListeners() {
    const hls = this.hls;
    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);
    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
  }
  unregisterListeners() {
    const hls = this.hls;
    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);
    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
  }
  destroy() {
    this.unregisterListeners();
    this.onMediaDetached();
    this.hls = this.config = this.audioBuffer = this.videoBuffer = null;
    this.onWaiting = this.onPlaying = null;
  }
  onMediaAttached(event, data) {
    this.media = data.media;
    this.media.addEventListener("waiting", this.onWaiting);
    this.media.addEventListener("playing", this.onPlaying);
  }
  onMediaDetached() {
    if (!this.media) {
      return;
    }
    this.media.removeEventListener("waiting", this.onWaiting);
    this.media.removeEventListener("playing", this.onPlaying);
    this.media = null;
  }
  onBufferCreated(event, data) {
    var _data$tracks$audio, _data$tracks$video;
    this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? undefined : _data$tracks$audio.buffer;
    this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? undefined : _data$tracks$video.buffer;
  }
  createData() {
    var _this$media;
    return {
      v: 1,
      sf: CmStreamingFormat.HLS,
      sid: this.sid,
      cid: this.cid,
      pr: (_this$media = this.media) == null ? undefined : _this$media.playbackRate,
      mtp: this.hls.bandwidthEstimate / 1000
    };
  }
  apply(context, data = {}) {
    _extends(data, this.createData());
    const isVideo = data.ot === CmObjectType.INIT || data.ot === CmObjectType.VIDEO || data.ot === CmObjectType.MUXED;
    if (this.starved && isVideo) {
      data.bs = true;
      data.su = true;
      this.starved = false;
    }
    if (data.su == null) {
      data.su = this.buffering;
    }
    const {
      includeKeys
    } = this;
    if (includeKeys) {
      data = Object.keys(data).reduce((acc, key) => {
        includeKeys.includes(key) && (acc[key] = data[key]);
        return acc;
      }, {});
    }
    if (this.useHeaders) {
      if (!context.headers) {
        context.headers = {};
      }
      appendCmcdHeaders(context.headers, data);
    } else {
      context.url = appendCmcdQuery(context.url, data);
    }
  }
  getObjectType(fragment) {
    const {
      type
    } = fragment;
    if (type === "subtitle") {
      return CmObjectType.TIMED_TEXT;
    }
    if (fragment.sn === "initSegment") {
      return CmObjectType.INIT;
    }
    if (type === "audio") {
      return CmObjectType.AUDIO;
    }
    if (type === "main") {
      if (!this.hls.audioTracks.length) {
        return CmObjectType.MUXED;
      }
      return CmObjectType.VIDEO;
    }
    return;
  }
  getTopBandwidth(type) {
    let bitrate = 0;
    let levels;
    const hls = this.hls;
    if (type === CmObjectType.AUDIO) {
      levels = hls.audioTracks;
    } else {
      const max = hls.maxAutoLevel;
      const len = max > -1 ? max + 1 : hls.levels.length;
      levels = hls.levels.slice(0, len);
    }
    for (const level of levels) {
      if (level.bitrate > bitrate) {
        bitrate = level.bitrate;
      }
    }
    return bitrate > 0 ? bitrate : NaN;
  }
  getBufferLength(type) {
    const media = this.hls.media;
    const buffer = type === CmObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;
    if (!buffer || !media) {
      return NaN;
    }
    const info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);
    return info.len * 1000;
  }
  createPlaylistLoader() {
    const {
      pLoader
    } = this.config;
    const apply = this.applyPlaylistData;
    const Ctor = pLoader || this.config.loader;
    return class CmcdPlaylistLoader {
      constructor(config) {
        this.loader = undefined;
        this.loader = new Ctor(config);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(context, config, callbacks) {
        apply(context);
        this.loader.load(context, config, callbacks);
      }
    };
  }
  createFragmentLoader() {
    const {
      fLoader
    } = this.config;
    const apply = this.applyFragmentData;
    const Ctor = fLoader || this.config.loader;
    return class CmcdFragmentLoader {
      constructor(config) {
        this.loader = undefined;
        this.loader = new Ctor(config);
      }
      get stats() {
        return this.loader.stats;
      }
      get context() {
        return this.loader.context;
      }
      destroy() {
        this.loader.destroy();
      }
      abort() {
        this.loader.abort();
      }
      load(context, config, callbacks) {
        apply(context);
        this.loader.load(context, config, callbacks);
      }
    };
  }
}
var PATHWAY_PENALTY_DURATION_MS = 300000;

class ContentSteeringController {
  constructor(hls) {
    this.hls = undefined;
    this.log = undefined;
    this.loader = null;
    this.uri = null;
    this.pathwayId = ".";
    this.pathwayPriority = null;
    this.timeToLoad = 300;
    this.reloadTimer = -1;
    this.updated = 0;
    this.started = false;
    this.enabled = true;
    this.levels = null;
    this.audioTracks = null;
    this.subtitleTracks = null;
    this.penalizedPathways = {};
    this.hls = hls;
    this.log = logger.log.bind(logger, `[content-steering]:`);
    this.registerListeners();
  }
  registerListeners() {
    const hls = this.hls;
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(Events.ERROR, this.onError, this);
  }
  unregisterListeners() {
    const hls = this.hls;
    if (!hls) {
      return;
    }
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(Events.ERROR, this.onError, this);
  }
  startLoad() {
    this.started = true;
    this.clearTimeout();
    if (this.enabled && this.uri) {
      if (this.updated) {
        const ttl = this.timeToLoad * 1000 - (performance.now() - this.updated);
        if (ttl > 0) {
          this.scheduleRefresh(this.uri, ttl);
          return;
        }
      }
      this.loadSteeringManifest(this.uri);
    }
  }
  stopLoad() {
    this.started = false;
    if (this.loader) {
      this.loader.destroy();
      this.loader = null;
    }
    this.clearTimeout();
  }
  clearTimeout() {
    if (this.reloadTimer !== -1) {
      self.clearTimeout(this.reloadTimer);
      this.reloadTimer = -1;
    }
  }
  destroy() {
    this.unregisterListeners();
    this.stopLoad();
    this.hls = null;
    this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  removeLevel(levelToRemove) {
    const levels = this.levels;
    if (levels) {
      this.levels = levels.filter((level) => level !== levelToRemove);
    }
  }
  onManifestLoading() {
    this.stopLoad();
    this.enabled = true;
    this.timeToLoad = 300;
    this.updated = 0;
    this.uri = null;
    this.pathwayId = ".";
    this.levels = this.audioTracks = this.subtitleTracks = null;
  }
  onManifestLoaded(event, data) {
    const {
      contentSteering
    } = data;
    if (contentSteering === null) {
      return;
    }
    this.pathwayId = contentSteering.pathwayId;
    this.uri = contentSteering.uri;
    if (this.started) {
      this.startLoad();
    }
  }
  onManifestParsed(event, data) {
    this.audioTracks = data.audioTracks;
    this.subtitleTracks = data.subtitleTracks;
  }
  onError(event, data) {
    const {
      errorAction
    } = data;
    if ((errorAction == null ? undefined : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {
      const levels = this.levels;
      let pathwayPriority = this.pathwayPriority;
      let errorPathway = this.pathwayId;
      if (data.context) {
        const {
          groupId,
          pathwayId,
          type
        } = data.context;
        if (groupId && levels) {
          errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);
        } else if (pathwayId) {
          errorPathway = pathwayId;
        }
      }
      if (!(errorPathway in this.penalizedPathways)) {
        this.penalizedPathways[errorPathway] = performance.now();
      }
      if (!pathwayPriority && levels) {
        pathwayPriority = levels.reduce((pathways, level) => {
          if (pathways.indexOf(level.pathwayId) === -1) {
            pathways.push(level.pathwayId);
          }
          return pathways;
        }, []);
      }
      if (pathwayPriority && pathwayPriority.length > 1) {
        this.updatePathwayPriority(pathwayPriority);
        errorAction.resolved = this.pathwayId !== errorPathway;
      }
      if (!errorAction.resolved) {
        logger.warn(`Could not resolve ${data.details} ("${data.error.message}") with content-steering for Pathway: ${errorPathway} levels: ${levels ? levels.length : levels} priorities: ${JSON.stringify(pathwayPriority)} penalized: ${JSON.stringify(this.penalizedPathways)}`);
      }
    }
  }
  filterParsedLevels(levels) {
    this.levels = levels;
    let pathwayLevels = this.getLevelsForPathway(this.pathwayId);
    if (pathwayLevels.length === 0) {
      const pathwayId = levels[0].pathwayId;
      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to "${pathwayId}"`);
      pathwayLevels = this.getLevelsForPathway(pathwayId);
      this.pathwayId = pathwayId;
    }
    if (pathwayLevels.length !== levels.length) {
      this.log(`Found ${pathwayLevels.length}/${levels.length} levels in Pathway "${this.pathwayId}"`);
    }
    return pathwayLevels;
  }
  getLevelsForPathway(pathwayId) {
    if (this.levels === null) {
      return [];
    }
    return this.levels.filter((level) => pathwayId === level.pathwayId);
  }
  updatePathwayPriority(pathwayPriority) {
    this.pathwayPriority = pathwayPriority;
    let levels;
    const penalizedPathways = this.penalizedPathways;
    const now2 = performance.now();
    Object.keys(penalizedPathways).forEach((pathwayId) => {
      if (now2 - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {
        delete penalizedPathways[pathwayId];
      }
    });
    for (let i = 0;i < pathwayPriority.length; i++) {
      const pathwayId = pathwayPriority[i];
      if (pathwayId in penalizedPathways) {
        continue;
      }
      if (pathwayId === this.pathwayId) {
        return;
      }
      const selectedIndex = this.hls.nextLoadLevel;
      const selectedLevel = this.hls.levels[selectedIndex];
      levels = this.getLevelsForPathway(pathwayId);
      if (levels.length > 0) {
        this.log(`Setting Pathway to "${pathwayId}"`);
        this.pathwayId = pathwayId;
        reassignFragmentLevelIndexes(levels);
        this.hls.trigger(Events.LEVELS_UPDATED, {
          levels
        });
        const levelAfterChange = this.hls.levels[selectedIndex];
        if (selectedLevel && levelAfterChange && this.levels) {
          if (levelAfterChange.attrs["STABLE-VARIANT-ID"] !== selectedLevel.attrs["STABLE-VARIANT-ID"] && levelAfterChange.bitrate !== selectedLevel.bitrate) {
            this.log(`Unstable Pathways change from bitrate ${selectedLevel.bitrate} to ${levelAfterChange.bitrate}`);
          }
          this.hls.nextLoadLevel = selectedIndex;
        }
        break;
      }
    }
  }
  getPathwayForGroupId(groupId, type, defaultPathway) {
    const levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);
    for (let i = 0;i < levels.length; i++) {
      if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {
        return levels[i].pathwayId;
      }
    }
    return defaultPathway;
  }
  clonePathways(pathwayClones) {
    const levels = this.levels;
    if (!levels) {
      return;
    }
    const audioGroupCloneMap = {};
    const subtitleGroupCloneMap = {};
    pathwayClones.forEach((pathwayClone) => {
      const {
        ID: cloneId,
        "BASE-ID": baseId,
        "URI-REPLACEMENT": uriReplacement
      } = pathwayClone;
      if (levels.some((level) => level.pathwayId === cloneId)) {
        return;
      }
      const clonedVariants = this.getLevelsForPathway(baseId).map((baseLevel) => {
        const attributes = new AttrList(baseLevel.attrs);
        attributes["PATHWAY-ID"] = cloneId;
        const clonedAudioGroupId = attributes.AUDIO && `${attributes.AUDIO}_clone_${cloneId}`;
        const clonedSubtitleGroupId = attributes.SUBTITLES && `${attributes.SUBTITLES}_clone_${cloneId}`;
        if (clonedAudioGroupId) {
          audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;
          attributes.AUDIO = clonedAudioGroupId;
        }
        if (clonedSubtitleGroupId) {
          subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;
          attributes.SUBTITLES = clonedSubtitleGroupId;
        }
        const url = performUriReplacement(baseLevel.uri, attributes["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", uriReplacement);
        const clonedLevel = new Level({
          attrs: attributes,
          audioCodec: baseLevel.audioCodec,
          bitrate: baseLevel.bitrate,
          height: baseLevel.height,
          name: baseLevel.name,
          url,
          videoCodec: baseLevel.videoCodec,
          width: baseLevel.width
        });
        if (baseLevel.audioGroups) {
          for (let i = 1;i < baseLevel.audioGroups.length; i++) {
            clonedLevel.addGroupId("audio", `${baseLevel.audioGroups[i]}_clone_${cloneId}`);
          }
        }
        if (baseLevel.subtitleGroups) {
          for (let i = 1;i < baseLevel.subtitleGroups.length; i++) {
            clonedLevel.addGroupId("text", `${baseLevel.subtitleGroups[i]}_clone_${cloneId}`);
          }
        }
        return clonedLevel;
      });
      levels.push(...clonedVariants);
      cloneRenditionGroups(this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);
      cloneRenditionGroups(this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);
    });
  }
  loadSteeringManifest(uri) {
    const config = this.hls.config;
    const Loader = config.loader;
    if (this.loader) {
      this.loader.destroy();
    }
    this.loader = new Loader(config);
    let url;
    try {
      url = new self.URL(uri);
    } catch (error) {
      this.enabled = false;
      this.log(`Failed to parse Steering Manifest URI: ${uri}`);
      return;
    }
    if (url.protocol !== "data:") {
      const throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;
      url.searchParams.set("_HLS_pathway", this.pathwayId);
      url.searchParams.set("_HLS_throughput", "" + throughput);
    }
    const context = {
      responseType: "json",
      url: url.href
    };
    const loadPolicy = config.steeringManifestLoadPolicy.default;
    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
    const loaderConfig = {
      loadPolicy,
      timeout: loadPolicy.maxLoadTimeMs,
      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
    };
    const callbacks = {
      onSuccess: (response, stats, context2, networkDetails) => {
        this.log(`Loaded steering manifest: "${url}"`);
        const steeringData = response.data;
        if (steeringData.VERSION !== 1) {
          this.log(`Steering VERSION ${steeringData.VERSION} not supported!`);
          return;
        }
        this.updated = performance.now();
        this.timeToLoad = steeringData.TTL;
        const {
          "RELOAD-URI": reloadUri,
          "PATHWAY-CLONES": pathwayClones,
          "PATHWAY-PRIORITY": pathwayPriority
        } = steeringData;
        if (reloadUri) {
          try {
            this.uri = new self.URL(reloadUri, url).href;
          } catch (error) {
            this.enabled = false;
            this.log(`Failed to parse Steering Manifest RELOAD-URI: ${reloadUri}`);
            return;
          }
        }
        this.scheduleRefresh(this.uri || context2.url);
        if (pathwayClones) {
          this.clonePathways(pathwayClones);
        }
        const loadedSteeringData = {
          steeringManifest: steeringData,
          url: url.toString()
        };
        this.hls.trigger(Events.STEERING_MANIFEST_LOADED, loadedSteeringData);
        if (pathwayPriority) {
          this.updatePathwayPriority(pathwayPriority);
        }
      },
      onError: (error, context2, networkDetails, stats) => {
        this.log(`Error loading steering manifest: ${error.code} ${error.text} (${context2.url})`);
        this.stopLoad();
        if (error.code === 410) {
          this.enabled = false;
          this.log(`Steering manifest ${context2.url} no longer available`);
          return;
        }
        let ttl = this.timeToLoad * 1000;
        if (error.code === 429) {
          const loader = this.loader;
          if (typeof (loader == null ? undefined : loader.getResponseHeader) === "function") {
            const retryAfter = loader.getResponseHeader("Retry-After");
            if (retryAfter) {
              ttl = parseFloat(retryAfter) * 1000;
            }
          }
          this.log(`Steering manifest ${context2.url} rate limited`);
          return;
        }
        this.scheduleRefresh(this.uri || context2.url, ttl);
      },
      onTimeout: (stats, context2, networkDetails) => {
        this.log(`Timeout loading steering manifest (${context2.url})`);
        this.scheduleRefresh(this.uri || context2.url);
      }
    };
    this.log(`Requesting steering manifest: ${url}`);
    this.loader.load(context, loaderConfig, callbacks);
  }
  scheduleRefresh(uri, ttlMs = this.timeToLoad * 1000) {
    this.clearTimeout();
    this.reloadTimer = self.setTimeout(() => {
      var _this$hls;
      const media = (_this$hls = this.hls) == null ? undefined : _this$hls.media;
      if (media && !media.ended) {
        this.loadSteeringManifest(uri);
        return;
      }
      this.scheduleRefresh(uri, this.timeToLoad * 1000);
    }, ttlMs);
  }
}
function cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {
  if (!tracks) {
    return;
  }
  Object.keys(groupCloneMap).forEach((audioGroupId) => {
    const clonedTracks = tracks.filter((track) => track.groupId === audioGroupId).map((track) => {
      const clonedTrack = _extends({}, track);
      clonedTrack.details = undefined;
      clonedTrack.attrs = new AttrList(clonedTrack.attrs);
      clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", uriReplacement);
      clonedTrack.groupId = clonedTrack.attrs["GROUP-ID"] = groupCloneMap[audioGroupId];
      clonedTrack.attrs["PATHWAY-ID"] = cloneId;
      return clonedTrack;
    });
    tracks.push(...clonedTracks);
  });
}
function performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {
  const {
    HOST: host,
    PARAMS: params,
    [perOptionKey]: perOptionUris
  } = uriReplacement;
  let perVariantUri;
  if (stableId) {
    perVariantUri = perOptionUris == null ? undefined : perOptionUris[stableId];
    if (perVariantUri) {
      uri = perVariantUri;
    }
  }
  const url = new self.URL(uri);
  if (host && !perVariantUri) {
    url.host = host;
  }
  if (params) {
    Object.keys(params).sort().forEach((key) => {
      if (key) {
        url.searchParams.set(key, params[key]);
      }
    });
  }
  return url.href;
}
var AGE_HEADER_LINE_REGEX = /^age:\s*[\d.]+\s*$/im;

class XhrLoader {
  constructor(config) {
    this.xhrSetup = undefined;
    this.requestTimeout = undefined;
    this.retryTimeout = undefined;
    this.retryDelay = undefined;
    this.config = null;
    this.callbacks = null;
    this.context = null;
    this.loader = null;
    this.stats = undefined;
    this.xhrSetup = config ? config.xhrSetup || null : null;
    this.stats = new LoadStats;
    this.retryDelay = 0;
  }
  destroy() {
    this.callbacks = null;
    this.abortInternal();
    this.loader = null;
    this.config = null;
    this.context = null;
    this.xhrSetup = null;
  }
  abortInternal() {
    const loader = this.loader;
    self.clearTimeout(this.requestTimeout);
    self.clearTimeout(this.retryTimeout);
    if (loader) {
      loader.onreadystatechange = null;
      loader.onprogress = null;
      if (loader.readyState !== 4) {
        this.stats.aborted = true;
        loader.abort();
      }
    }
  }
  abort() {
    var _this$callbacks;
    this.abortInternal();
    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
      this.callbacks.onAbort(this.stats, this.context, this.loader);
    }
  }
  load(context, config, callbacks) {
    if (this.stats.loading.start) {
      throw new Error("Loader can only be used once.");
    }
    this.stats.loading.start = self.performance.now();
    this.context = context;
    this.config = config;
    this.callbacks = callbacks;
    this.loadInternal();
  }
  loadInternal() {
    const {
      config,
      context
    } = this;
    if (!config || !context) {
      return;
    }
    const xhr = this.loader = new self.XMLHttpRequest;
    const stats = this.stats;
    stats.loading.first = 0;
    stats.loaded = 0;
    stats.aborted = false;
    const xhrSetup = this.xhrSetup;
    if (xhrSetup) {
      Promise.resolve().then(() => {
        if (this.loader !== xhr || this.stats.aborted)
          return;
        return xhrSetup(xhr, context.url);
      }).catch((error) => {
        if (this.loader !== xhr || this.stats.aborted)
          return;
        xhr.open("GET", context.url, true);
        return xhrSetup(xhr, context.url);
      }).then(() => {
        if (this.loader !== xhr || this.stats.aborted)
          return;
        this.openAndSendXhr(xhr, context, config);
      }).catch((error) => {
        this.callbacks.onError({
          code: xhr.status,
          text: error.message
        }, context, xhr, stats);
        return;
      });
    } else {
      this.openAndSendXhr(xhr, context, config);
    }
  }
  openAndSendXhr(xhr, context, config) {
    if (!xhr.readyState) {
      xhr.open("GET", context.url, true);
    }
    const headers = context.headers;
    const {
      maxTimeToFirstByteMs,
      maxLoadTimeMs
    } = config.loadPolicy;
    if (headers) {
      for (const header in headers) {
        xhr.setRequestHeader(header, headers[header]);
      }
    }
    if (context.rangeEnd) {
      xhr.setRequestHeader("Range", "bytes=" + context.rangeStart + "-" + (context.rangeEnd - 1));
    }
    xhr.onreadystatechange = this.readystatechange.bind(this);
    xhr.onprogress = this.loadprogress.bind(this);
    xhr.responseType = context.responseType;
    self.clearTimeout(this.requestTimeout);
    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
    xhr.send();
  }
  readystatechange() {
    const {
      context,
      loader: xhr,
      stats
    } = this;
    if (!context || !xhr) {
      return;
    }
    const readyState = xhr.readyState;
    const config = this.config;
    if (stats.aborted) {
      return;
    }
    if (readyState >= 2) {
      if (stats.loading.first === 0) {
        stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
        if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {
          self.clearTimeout(this.requestTimeout);
          config.timeout = config.loadPolicy.maxLoadTimeMs;
          this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));
        }
      }
      if (readyState === 4) {
        self.clearTimeout(this.requestTimeout);
        xhr.onreadystatechange = null;
        xhr.onprogress = null;
        const status2 = xhr.status;
        const useResponse = xhr.responseType !== "text";
        if (status2 >= 200 && status2 < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {
          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
          const data = useResponse ? xhr.response : xhr.responseText;
          const len = xhr.responseType === "arraybuffer" ? data.byteLength : data.length;
          stats.loaded = stats.total = len;
          stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);
          if (!this.callbacks) {
            return;
          }
          const onProgress = this.callbacks.onProgress;
          if (onProgress) {
            onProgress(stats, context, data, xhr);
          }
          if (!this.callbacks) {
            return;
          }
          const response = {
            url: xhr.responseURL,
            data,
            code: status2
          };
          this.callbacks.onSuccess(response, stats, context, xhr);
        } else {
          const retryConfig = config.loadPolicy.errorRetry;
          const retryCount = stats.retry;
          const response = {
            url: context.url,
            data: undefined,
            code: status2
          };
          if (shouldRetry(retryConfig, retryCount, false, response)) {
            this.retry(retryConfig);
          } else {
            logger.error(`${status2} while loading ${context.url}`);
            this.callbacks.onError({
              code: status2,
              text: xhr.statusText
            }, context, xhr, stats);
          }
        }
      }
    }
  }
  loadtimeout() {
    if (!this.config)
      return;
    const retryConfig = this.config.loadPolicy.timeoutRetry;
    const retryCount = this.stats.retry;
    if (shouldRetry(retryConfig, retryCount, true)) {
      this.retry(retryConfig);
    } else {
      var _this$context;
      logger.warn(`timeout while loading ${(_this$context = this.context) == null ? undefined : _this$context.url}`);
      const callbacks = this.callbacks;
      if (callbacks) {
        this.abortInternal();
        callbacks.onTimeout(this.stats, this.context, this.loader);
      }
    }
  }
  retry(retryConfig) {
    const {
      context,
      stats
    } = this;
    this.retryDelay = getRetryDelay(retryConfig, stats.retry);
    stats.retry++;
    logger.warn(`${status ? "HTTP Status " + status : "Timeout"} while loading ${context == null ? undefined : context.url}, retrying ${stats.retry}/${retryConfig.maxNumRetry} in ${this.retryDelay}ms`);
    this.abortInternal();
    this.loader = null;
    self.clearTimeout(this.retryTimeout);
    this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
  }
  loadprogress(event) {
    const stats = this.stats;
    stats.loaded = event.loaded;
    if (event.lengthComputable) {
      stats.total = event.total;
    }
  }
  getCacheAge() {
    let result = null;
    if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {
      const ageHeader = this.loader.getResponseHeader("age");
      result = ageHeader ? parseFloat(ageHeader) : null;
    }
    return result;
  }
  getResponseHeader(name) {
    if (this.loader && new RegExp(`^${name}:\\s*[\\d.]+\\s*$`, "im").test(this.loader.getAllResponseHeaders())) {
      return this.loader.getResponseHeader(name);
    }
    return null;
  }
}
function fetchSupported() {
  if (self.fetch && self.AbortController && self.ReadableStream && self.Request) {
    try {
      new self.ReadableStream({});
      return true;
    } catch (e) {
    }
  }
  return false;
}
var BYTERANGE = /(\d+)-(\d+)\/(\d+)/;

class FetchLoader {
  constructor(config) {
    this.fetchSetup = undefined;
    this.requestTimeout = undefined;
    this.request = null;
    this.response = null;
    this.controller = undefined;
    this.context = null;
    this.config = null;
    this.callbacks = null;
    this.stats = undefined;
    this.loader = null;
    this.fetchSetup = config.fetchSetup || getRequest;
    this.controller = new self.AbortController;
    this.stats = new LoadStats;
  }
  destroy() {
    this.loader = this.callbacks = this.context = this.config = this.request = null;
    this.abortInternal();
    this.response = null;
    this.fetchSetup = this.controller = this.stats = null;
  }
  abortInternal() {
    if (this.controller && !this.stats.loading.end) {
      this.stats.aborted = true;
      this.controller.abort();
    }
  }
  abort() {
    var _this$callbacks;
    this.abortInternal();
    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
      this.callbacks.onAbort(this.stats, this.context, this.response);
    }
  }
  load(context, config, callbacks) {
    const stats = this.stats;
    if (stats.loading.start) {
      throw new Error("Loader can only be used once.");
    }
    stats.loading.start = self.performance.now();
    const initParams = getRequestParameters(context, this.controller.signal);
    const onProgress = callbacks.onProgress;
    const isArrayBuffer = context.responseType === "arraybuffer";
    const LENGTH = isArrayBuffer ? "byteLength" : "length";
    const {
      maxTimeToFirstByteMs,
      maxLoadTimeMs
    } = config.loadPolicy;
    this.context = context;
    this.config = config;
    this.callbacks = callbacks;
    this.request = this.fetchSetup(context, initParams);
    self.clearTimeout(this.requestTimeout);
    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
    this.requestTimeout = self.setTimeout(() => {
      this.abortInternal();
      callbacks.onTimeout(stats, context, this.response);
    }, config.timeout);
    self.fetch(this.request).then((response) => {
      this.response = this.loader = response;
      const first = Math.max(self.performance.now(), stats.loading.start);
      self.clearTimeout(this.requestTimeout);
      config.timeout = maxLoadTimeMs;
      this.requestTimeout = self.setTimeout(() => {
        this.abortInternal();
        callbacks.onTimeout(stats, context, this.response);
      }, maxLoadTimeMs - (first - stats.loading.start));
      if (!response.ok) {
        const {
          status: status2,
          statusText
        } = response;
        throw new FetchError(statusText || "fetch, bad network response", status2, response);
      }
      stats.loading.first = first;
      stats.total = getContentLength(response.headers) || stats.total;
      if (onProgress && isFiniteNumber(config.highWaterMark)) {
        return this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);
      }
      if (isArrayBuffer) {
        return response.arrayBuffer();
      }
      if (context.responseType === "json") {
        return response.json();
      }
      return response.text();
    }).then((responseData) => {
      const response = this.response;
      if (!response) {
        throw new Error("loader destroyed");
      }
      self.clearTimeout(this.requestTimeout);
      stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
      const total = responseData[LENGTH];
      if (total) {
        stats.loaded = stats.total = total;
      }
      const loaderResponse = {
        url: response.url,
        data: responseData,
        code: response.status
      };
      if (onProgress && !isFiniteNumber(config.highWaterMark)) {
        onProgress(stats, context, responseData, response);
      }
      callbacks.onSuccess(loaderResponse, stats, context, response);
    }).catch((error) => {
      self.clearTimeout(this.requestTimeout);
      if (stats.aborted) {
        return;
      }
      const code = !error ? 0 : error.code || 0;
      const text = !error ? null : error.message;
      callbacks.onError({
        code,
        text
      }, context, error ? error.details : null, stats);
    });
  }
  getCacheAge() {
    let result = null;
    if (this.response) {
      const ageHeader = this.response.headers.get("age");
      result = ageHeader ? parseFloat(ageHeader) : null;
    }
    return result;
  }
  getResponseHeader(name) {
    return this.response ? this.response.headers.get(name) : null;
  }
  loadProgressively(response, stats, context, highWaterMark = 0, onProgress) {
    const chunkCache = new ChunkCache;
    const reader = response.body.getReader();
    const pump = () => {
      return reader.read().then((data) => {
        if (data.done) {
          if (chunkCache.dataLength) {
            onProgress(stats, context, chunkCache.flush(), response);
          }
          return Promise.resolve(new ArrayBuffer(0));
        }
        const chunk = data.value;
        const len = chunk.length;
        stats.loaded += len;
        if (len < highWaterMark || chunkCache.dataLength) {
          chunkCache.push(chunk);
          if (chunkCache.dataLength >= highWaterMark) {
            onProgress(stats, context, chunkCache.flush(), response);
          }
        } else {
          onProgress(stats, context, chunk, response);
        }
        return pump();
      }).catch(() => {
        return Promise.reject();
      });
    };
    return pump();
  }
}
function getRequestParameters(context, signal) {
  const initParams = {
    method: "GET",
    mode: "cors",
    credentials: "same-origin",
    signal,
    headers: new self.Headers(_extends({}, context.headers))
  };
  if (context.rangeEnd) {
    initParams.headers.set("Range", "bytes=" + context.rangeStart + "-" + String(context.rangeEnd - 1));
  }
  return initParams;
}
function getByteRangeLength(byteRangeHeader) {
  const result = BYTERANGE.exec(byteRangeHeader);
  if (result) {
    return parseInt(result[2]) - parseInt(result[1]) + 1;
  }
}
function getContentLength(headers) {
  const contentRange = headers.get("Content-Range");
  if (contentRange) {
    const byteRangeLength = getByteRangeLength(contentRange);
    if (isFiniteNumber(byteRangeLength)) {
      return byteRangeLength;
    }
  }
  const contentLength = headers.get("Content-Length");
  if (contentLength) {
    return parseInt(contentLength);
  }
}
function getRequest(context, initParams) {
  return new self.Request(context.url, initParams);
}

class FetchError extends Error {
  constructor(message, code, details) {
    super(message);
    this.code = undefined;
    this.details = undefined;
    this.code = code;
    this.details = details;
  }
}
var WHITESPACE_CHAR = /\s/;
var Cues = {
  newCue(track, startTime, endTime, captionScreen) {
    const result = [];
    let row;
    let cue;
    let indenting;
    let indent;
    let text;
    const Cue = self.VTTCue || self.TextTrackCue;
    for (let r = 0;r < captionScreen.rows.length; r++) {
      row = captionScreen.rows[r];
      indenting = true;
      indent = 0;
      text = "";
      if (!row.isEmpty()) {
        var _track$cues;
        for (let c = 0;c < row.chars.length; c++) {
          if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {
            indent++;
          } else {
            text += row.chars[c].uchar;
            indenting = false;
          }
        }
        row.cueStartTime = startTime;
        if (startTime === endTime) {
          endTime += 0.0001;
        }
        if (indent >= 16) {
          indent--;
        } else {
          indent++;
        }
        const cueText = fixLineBreaks(text.trim());
        const id = generateCueId(startTime, endTime, cueText);
        if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {
          cue = new Cue(startTime, endTime, cueText);
          cue.id = id;
          cue.line = r + 1;
          cue.align = "left";
          cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);
          result.push(cue);
        }
      }
    }
    if (track && result.length) {
      result.sort((cueA, cueB) => {
        if (cueA.line === "auto" || cueB.line === "auto") {
          return 0;
        }
        if (cueA.line > 8 && cueB.line > 8) {
          return cueB.line - cueA.line;
        }
        return cueA.line - cueB.line;
      });
      result.forEach((cue2) => addCueToTrack(track, cue2));
    }
    return result;
  }
};
var defaultLoadPolicy = {
  maxTimeToFirstByteMs: 8000,
  maxLoadTimeMs: 20000,
  timeoutRetry: null,
  errorRetry: null
};
var hlsDefaultConfig = _objectSpread2(_objectSpread2({
  autoStartLoad: true,
  startPosition: -1,
  defaultAudioCodec: undefined,
  debug: false,
  capLevelOnFPSDrop: false,
  capLevelToPlayerSize: false,
  ignoreDevicePixelRatio: false,
  preferManagedMediaSource: true,
  initialLiveManifestSize: 1,
  maxBufferLength: 30,
  backBufferLength: Infinity,
  frontBufferFlushThreshold: Infinity,
  maxBufferSize: 60 * 1000 * 1000,
  maxBufferHole: 0.1,
  highBufferWatchdogPeriod: 2,
  nudgeOffset: 0.1,
  nudgeMaxRetry: 3,
  maxFragLookUpTolerance: 0.25,
  liveSyncDurationCount: 3,
  liveMaxLatencyDurationCount: Infinity,
  liveSyncDuration: undefined,
  liveMaxLatencyDuration: undefined,
  maxLiveSyncPlaybackRate: 1,
  liveDurationInfinity: false,
  liveBackBufferLength: null,
  maxMaxBufferLength: 600,
  enableWorker: true,
  workerPath: null,
  enableSoftwareAES: true,
  startLevel: undefined,
  startFragPrefetch: false,
  fpsDroppedMonitoringPeriod: 5000,
  fpsDroppedMonitoringThreshold: 0.2,
  appendErrorMaxRetry: 3,
  loader: XhrLoader,
  fLoader: undefined,
  pLoader: undefined,
  xhrSetup: undefined,
  licenseXhrSetup: undefined,
  licenseResponseCallback: undefined,
  abrController: AbrController,
  bufferController: BufferController,
  capLevelController: CapLevelController,
  errorController: ErrorController,
  fpsController: FPSController,
  stretchShortVideoTrack: false,
  maxAudioFramesDrift: 1,
  forceKeyFrameOnDiscontinuity: true,
  abrEwmaFastLive: 3,
  abrEwmaSlowLive: 9,
  abrEwmaFastVoD: 3,
  abrEwmaSlowVoD: 9,
  abrEwmaDefaultEstimate: 500000,
  abrEwmaDefaultEstimateMax: 5000000,
  abrBandWidthFactor: 0.95,
  abrBandWidthUpFactor: 0.7,
  abrMaxWithRealBitrate: false,
  maxStarvationDelay: 4,
  maxLoadingDelay: 4,
  minAutoBitrate: 0,
  emeEnabled: false,
  widevineLicenseUrl: undefined,
  drmSystems: {},
  drmSystemOptions: {},
  requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess,
  testBandwidth: true,
  progressive: false,
  lowLatencyMode: true,
  cmcd: undefined,
  enableDateRangeMetadataCues: true,
  enableEmsgMetadataCues: true,
  enableID3MetadataCues: true,
  useMediaCapabilities: true,
  certLoadPolicy: {
    default: defaultLoadPolicy
  },
  keyLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 8000,
      maxLoadTimeMs: 20000,
      timeoutRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1000,
        maxRetryDelayMs: 20000,
        backoff: "linear"
      },
      errorRetry: {
        maxNumRetry: 8,
        retryDelayMs: 1000,
        maxRetryDelayMs: 20000,
        backoff: "linear"
      }
    }
  },
  manifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: Infinity,
      maxLoadTimeMs: 20000,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1000,
        maxRetryDelayMs: 8000
      }
    }
  },
  playlistLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 20000,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 2,
        retryDelayMs: 1000,
        maxRetryDelayMs: 8000
      }
    }
  },
  fragLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 120000,
      timeoutRetry: {
        maxNumRetry: 4,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 6,
        retryDelayMs: 1000,
        maxRetryDelayMs: 8000
      }
    }
  },
  steeringManifestLoadPolicy: {
    default: {
      maxTimeToFirstByteMs: 1e4,
      maxLoadTimeMs: 20000,
      timeoutRetry: {
        maxNumRetry: 2,
        retryDelayMs: 0,
        maxRetryDelayMs: 0
      },
      errorRetry: {
        maxNumRetry: 1,
        retryDelayMs: 1000,
        maxRetryDelayMs: 8000
      }
    }
  },
  manifestLoadingTimeOut: 1e4,
  manifestLoadingMaxRetry: 1,
  manifestLoadingRetryDelay: 1000,
  manifestLoadingMaxRetryTimeout: 64000,
  levelLoadingTimeOut: 1e4,
  levelLoadingMaxRetry: 4,
  levelLoadingRetryDelay: 1000,
  levelLoadingMaxRetryTimeout: 64000,
  fragLoadingTimeOut: 20000,
  fragLoadingMaxRetry: 6,
  fragLoadingRetryDelay: 1000,
  fragLoadingMaxRetryTimeout: 64000
}, timelineConfig()), {}, {
  subtitleStreamController: SubtitleStreamController,
  subtitleTrackController: SubtitleTrackController,
  timelineController: TimelineController,
  audioStreamController: AudioStreamController,
  audioTrackController: AudioTrackController,
  emeController: EMEController,
  cmcdController: CMCDController,
  contentSteeringController: ContentSteeringController
});
function timelineConfig() {
  return {
    cueHandler: Cues,
    enableWebVTT: true,
    enableIMSC1: true,
    enableCEA708Captions: true,
    captionsTextTrack1Label: "English",
    captionsTextTrack1LanguageCode: "en",
    captionsTextTrack2Label: "Spanish",
    captionsTextTrack2LanguageCode: "es",
    captionsTextTrack3Label: "Unknown CC",
    captionsTextTrack3LanguageCode: "",
    captionsTextTrack4Label: "Unknown CC",
    captionsTextTrack4LanguageCode: "",
    renderTextTracksNatively: true
  };
}
function mergeConfig(defaultConfig, userConfig) {
  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {
    throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
  }
  if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {
    throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
  }
  if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {
    throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
  }
  const defaultsCopy = deepCpy(defaultConfig);
  const deprecatedSettingTypes = ["manifest", "level", "frag"];
  const deprecatedSettings = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
  deprecatedSettingTypes.forEach((type) => {
    const policyName = `${type === "level" ? "playlist" : type}LoadPolicy`;
    const policyNotSet = userConfig[policyName] === undefined;
    const report = [];
    deprecatedSettings.forEach((setting) => {
      const deprecatedSetting = `${type}Loading${setting}`;
      const value = userConfig[deprecatedSetting];
      if (value !== undefined && policyNotSet) {
        report.push(deprecatedSetting);
        const settings = defaultsCopy[policyName].default;
        userConfig[policyName] = {
          default: settings
        };
        switch (setting) {
          case "TimeOut":
            settings.maxLoadTimeMs = value;
            settings.maxTimeToFirstByteMs = value;
            break;
          case "MaxRetry":
            settings.errorRetry.maxNumRetry = value;
            settings.timeoutRetry.maxNumRetry = value;
            break;
          case "RetryDelay":
            settings.errorRetry.retryDelayMs = value;
            settings.timeoutRetry.retryDelayMs = value;
            break;
          case "MaxRetryTimeout":
            settings.errorRetry.maxRetryDelayMs = value;
            settings.timeoutRetry.maxRetryDelayMs = value;
            break;
        }
      }
    });
    if (report.length) {
      logger.warn(`hls.js config: "${report.join('", "')}" setting(s) are deprecated, use "${policyName}": ${JSON.stringify(userConfig[policyName])}`);
    }
  });
  return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);
}
function deepCpy(obj) {
  if (obj && typeof obj === "object") {
    if (Array.isArray(obj)) {
      return obj.map(deepCpy);
    }
    return Object.keys(obj).reduce((result, key) => {
      result[key] = deepCpy(obj[key]);
      return result;
    }, {});
  }
  return obj;
}
function enableStreamingMode(config) {
  const currentLoader = config.loader;
  if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {
    logger.log("[config]: Custom loader detected, cannot enable progressive streaming");
    config.progressive = false;
  } else {
    const canStreamProgressively = fetchSupported();
    if (canStreamProgressively) {
      config.loader = FetchLoader;
      config.progressive = true;
      config.enableSoftwareAES = true;
      logger.log("[config]: Progressive streaming enabled, using FetchLoader");
    }
  }
}
var chromeOrFirefox;

class LevelController extends BasePlaylistController {
  constructor(hls, contentSteeringController) {
    super(hls, "[level-controller]");
    this._levels = [];
    this._firstLevel = -1;
    this._maxAutoLevel = -1;
    this._startLevel = undefined;
    this.currentLevel = null;
    this.currentLevelIndex = -1;
    this.manualLevelIndex = -1;
    this.steering = undefined;
    this.onParsedComplete = undefined;
    this.steering = contentSteeringController;
    this._registerListeners();
  }
  _registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    hls.on(Events.ERROR, this.onError, this);
  }
  _unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
    hls.off(Events.ERROR, this.onError, this);
  }
  destroy() {
    this._unregisterListeners();
    this.steering = null;
    this.resetLevels();
    super.destroy();
  }
  stopLoad() {
    const levels = this._levels;
    levels.forEach((level) => {
      level.loadError = 0;
      level.fragmentError = 0;
    });
    super.stopLoad();
  }
  resetLevels() {
    this._startLevel = undefined;
    this.manualLevelIndex = -1;
    this.currentLevelIndex = -1;
    this.currentLevel = null;
    this._levels = [];
    this._maxAutoLevel = -1;
  }
  onManifestLoading(event, data) {
    this.resetLevels();
  }
  onManifestLoaded(event, data) {
    const preferManagedMediaSource = this.hls.config.preferManagedMediaSource;
    const levels = [];
    const redundantSet = {};
    const generatePathwaySet = {};
    let resolutionFound = false;
    let videoCodecFound = false;
    let audioCodecFound = false;
    data.levels.forEach((levelParsed) => {
      var _audioCodec, _videoCodec;
      const attributes = levelParsed.attrs;
      let {
        audioCodec,
        videoCodec
      } = levelParsed;
      if (((_audioCodec = audioCodec) == null ? undefined : _audioCodec.indexOf("mp4a.40.34")) !== -1) {
        chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));
        if (chromeOrFirefox) {
          levelParsed.audioCodec = audioCodec = undefined;
        }
      }
      if (audioCodec) {
        levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource);
      }
      if (((_videoCodec = videoCodec) == null ? undefined : _videoCodec.indexOf("avc1")) === 0) {
        videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);
      }
      const {
        width,
        height,
        unknownCodecs
      } = levelParsed;
      resolutionFound || (resolutionFound = !!(width && height));
      videoCodecFound || (videoCodecFound = !!videoCodec);
      audioCodecFound || (audioCodecFound = !!audioCodec);
      if (unknownCodecs != null && unknownCodecs.length || audioCodec && !areCodecsMediaSourceSupported(audioCodec, "audio", preferManagedMediaSource) || videoCodec && !areCodecsMediaSourceSupported(videoCodec, "video", preferManagedMediaSource)) {
        return;
      }
      const {
        CODECS,
        "FRAME-RATE": FRAMERATE,
        "HDCP-LEVEL": HDCP,
        "PATHWAY-ID": PATHWAY,
        RESOLUTION,
        "VIDEO-RANGE": VIDEO_RANGE
      } = attributes;
      const contentSteeringPrefix = `${PATHWAY || "."}-`;
      const levelKey = `${contentSteeringPrefix}${levelParsed.bitrate}-${RESOLUTION}-${FRAMERATE}-${CODECS}-${VIDEO_RANGE}-${HDCP}`;
      if (!redundantSet[levelKey]) {
        const level = new Level(levelParsed);
        redundantSet[levelKey] = level;
        generatePathwaySet[levelKey] = 1;
        levels.push(level);
      } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs["PATHWAY-ID"]) {
        const pathwayCount = generatePathwaySet[levelKey] += 1;
        levelParsed.attrs["PATHWAY-ID"] = new Array(pathwayCount + 1).join(".");
        const level = new Level(levelParsed);
        redundantSet[levelKey] = level;
        levels.push(level);
      } else {
        redundantSet[levelKey].addGroupId("audio", attributes.AUDIO);
        redundantSet[levelKey].addGroupId("text", attributes.SUBTITLES);
      }
    });
    this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);
  }
  filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {
    let audioTracks = [];
    let subtitleTracks = [];
    let levels = filteredLevels;
    if ((resolutionFound || videoCodecFound) && audioCodecFound) {
      levels = levels.filter(({
        videoCodec,
        videoRange,
        width,
        height
      }) => (!!videoCodec || !!(width && height)) && isVideoRange(videoRange));
    }
    if (levels.length === 0) {
      Promise.resolve().then(() => {
        if (this.hls) {
          if (data.levels.length) {
            this.warn(`One or more CODECS in variant not supported: ${JSON.stringify(data.levels[0].attrs)}`);
          }
          const error = new Error("no level with compatible codecs found in manifest");
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
            fatal: true,
            url: data.url,
            error,
            reason: error.message
          });
        }
      });
      return;
    }
    if (data.audioTracks) {
      const {
        preferManagedMediaSource
      } = this.hls.config;
      audioTracks = data.audioTracks.filter((track) => !track.audioCodec || areCodecsMediaSourceSupported(track.audioCodec, "audio", preferManagedMediaSource));
      assignTrackIdsByGroup(audioTracks);
    }
    if (data.subtitles) {
      subtitleTracks = data.subtitles;
      assignTrackIdsByGroup(subtitleTracks);
    }
    const unsortedLevels = levels.slice(0);
    levels.sort((a, b) => {
      if (a.attrs["HDCP-LEVEL"] !== b.attrs["HDCP-LEVEL"]) {
        return (a.attrs["HDCP-LEVEL"] || "") > (b.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
      }
      if (resolutionFound && a.height !== b.height) {
        return a.height - b.height;
      }
      if (a.frameRate !== b.frameRate) {
        return a.frameRate - b.frameRate;
      }
      if (a.videoRange !== b.videoRange) {
        return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);
      }
      if (a.videoCodec !== b.videoCodec) {
        const valueA = videoCodecPreferenceValue(a.videoCodec);
        const valueB = videoCodecPreferenceValue(b.videoCodec);
        if (valueA !== valueB) {
          return valueB - valueA;
        }
      }
      if (a.uri === b.uri && a.codecSet !== b.codecSet) {
        const valueA = codecsSetSelectionPreferenceValue(a.codecSet);
        const valueB = codecsSetSelectionPreferenceValue(b.codecSet);
        if (valueA !== valueB) {
          return valueB - valueA;
        }
      }
      if (a.averageBitrate !== b.averageBitrate) {
        return a.averageBitrate - b.averageBitrate;
      }
      return 0;
    });
    let firstLevelInPlaylist = unsortedLevels[0];
    if (this.steering) {
      levels = this.steering.filterParsedLevels(levels);
      if (levels.length !== unsortedLevels.length) {
        for (let i = 0;i < unsortedLevels.length; i++) {
          if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {
            firstLevelInPlaylist = unsortedLevels[i];
            break;
          }
        }
      }
    }
    this._levels = levels;
    for (let i = 0;i < levels.length; i++) {
      if (levels[i] === firstLevelInPlaylist) {
        var _this$hls$userConfig;
        this._firstLevel = i;
        const firstLevelBitrate = firstLevelInPlaylist.bitrate;
        const bandwidthEstimate = this.hls.bandwidthEstimate;
        this.log(`manifest loaded, ${levels.length} level(s) found, first bitrate: ${firstLevelBitrate}`);
        if (((_this$hls$userConfig = this.hls.userConfig) == null ? undefined : _this$hls$userConfig.abrEwmaDefaultEstimate) === undefined) {
          const startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);
          if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === hlsDefaultConfig.abrEwmaDefaultEstimate) {
            this.hls.bandwidthEstimate = startingBwEstimate;
          }
        }
        break;
      }
    }
    const audioOnly = audioCodecFound && !videoCodecFound;
    const edata = {
      levels,
      audioTracks,
      subtitleTracks,
      sessionData: data.sessionData,
      sessionKeys: data.sessionKeys,
      firstLevel: this._firstLevel,
      stats: data.stats,
      audio: audioCodecFound,
      video: videoCodecFound,
      altAudio: !audioOnly && audioTracks.some((t) => !!t.url)
    };
    this.hls.trigger(Events.MANIFEST_PARSED, edata);
    if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {
      this.hls.startLoad(this.hls.config.startPosition);
    }
  }
  get levels() {
    if (this._levels.length === 0) {
      return null;
    }
    return this._levels;
  }
  get level() {
    return this.currentLevelIndex;
  }
  set level(newLevel) {
    const levels = this._levels;
    if (levels.length === 0) {
      return;
    }
    if (newLevel < 0 || newLevel >= levels.length) {
      const error = new Error("invalid level idx");
      const fatal = newLevel < 0;
      this.hls.trigger(Events.ERROR, {
        type: ErrorTypes.OTHER_ERROR,
        details: ErrorDetails.LEVEL_SWITCH_ERROR,
        level: newLevel,
        fatal,
        error,
        reason: error.message
      });
      if (fatal) {
        return;
      }
      newLevel = Math.min(newLevel, levels.length - 1);
    }
    const lastLevelIndex = this.currentLevelIndex;
    const lastLevel = this.currentLevel;
    const lastPathwayId = lastLevel ? lastLevel.attrs["PATHWAY-ID"] : undefined;
    const level = levels[newLevel];
    const pathwayId = level.attrs["PATHWAY-ID"];
    this.currentLevelIndex = newLevel;
    this.currentLevel = level;
    if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {
      return;
    }
    this.log(`Switching to level ${newLevel} (${level.height ? level.height + "p " : ""}${level.videoRange ? level.videoRange + " " : ""}${level.codecSet ? level.codecSet + " " : ""}@${level.bitrate})${pathwayId ? " with Pathway " + pathwayId : ""} from level ${lastLevelIndex}${lastPathwayId ? " with Pathway " + lastPathwayId : ""}`);
    const levelSwitchingData = {
      level: newLevel,
      attrs: level.attrs,
      details: level.details,
      bitrate: level.bitrate,
      averageBitrate: level.averageBitrate,
      maxBitrate: level.maxBitrate,
      realBitrate: level.realBitrate,
      width: level.width,
      height: level.height,
      codecSet: level.codecSet,
      audioCodec: level.audioCodec,
      videoCodec: level.videoCodec,
      audioGroups: level.audioGroups,
      subtitleGroups: level.subtitleGroups,
      loaded: level.loaded,
      loadError: level.loadError,
      fragmentError: level.fragmentError,
      name: level.name,
      id: level.id,
      uri: level.uri,
      url: level.url,
      urlId: 0,
      audioGroupIds: level.audioGroupIds,
      textGroupIds: level.textGroupIds
    };
    this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);
    const levelDetails = level.details;
    if (!levelDetails || levelDetails.live) {
      const hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? undefined : lastLevel.details, levelDetails);
      this.loadPlaylist(hlsUrlParameters);
    }
  }
  get manualLevel() {
    return this.manualLevelIndex;
  }
  set manualLevel(newLevel) {
    this.manualLevelIndex = newLevel;
    if (this._startLevel === undefined) {
      this._startLevel = newLevel;
    }
    if (newLevel !== -1) {
      this.level = newLevel;
    }
  }
  get firstLevel() {
    return this._firstLevel;
  }
  set firstLevel(newLevel) {
    this._firstLevel = newLevel;
  }
  get startLevel() {
    if (this._startLevel === undefined) {
      const configStartLevel = this.hls.config.startLevel;
      if (configStartLevel !== undefined) {
        return configStartLevel;
      }
      return this.hls.firstAutoLevel;
    }
    return this._startLevel;
  }
  set startLevel(newLevel) {
    this._startLevel = newLevel;
  }
  onError(event, data) {
    if (data.fatal || !data.context) {
      return;
    }
    if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {
      this.checkRetry(data);
    }
  }
  onFragBuffered(event, {
    frag
  }) {
    if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {
      const el = frag.elementaryStreams;
      if (!Object.keys(el).some((type) => !!el[type])) {
        return;
      }
      const level = this._levels[frag.level];
      if (level != null && level.loadError) {
        this.log(`Resetting level error count of ${level.loadError} on frag buffered`);
        level.loadError = 0;
      }
    }
  }
  onLevelLoaded(event, data) {
    var _data$deliveryDirecti2;
    const {
      level,
      details
    } = data;
    const curLevel = this._levels[level];
    if (!curLevel) {
      var _data$deliveryDirecti;
      this.warn(`Invalid level index ${level}`);
      if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {
        details.deltaUpdateFailed = true;
      }
      return;
    }
    if (level === this.currentLevelIndex) {
      if (curLevel.fragmentError === 0) {
        curLevel.loadError = 0;
      }
      this.playlistLoaded(level, data, curLevel.details);
    } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {
      details.deltaUpdateFailed = true;
    }
  }
  loadPlaylist(hlsUrlParameters) {
    super.loadPlaylist();
    const currentLevelIndex = this.currentLevelIndex;
    const currentLevel = this.currentLevel;
    if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {
      let url = currentLevel.uri;
      if (hlsUrlParameters) {
        try {
          url = hlsUrlParameters.addDirectives(url);
        } catch (error) {
          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);
        }
      }
      const pathwayId = currentLevel.attrs["PATHWAY-ID"];
      this.log(`Loading level index ${currentLevelIndex}${(hlsUrlParameters == null ? undefined : hlsUrlParameters.msn) !== undefined ? " at sn " + hlsUrlParameters.msn + " part " + hlsUrlParameters.part : ""} with${pathwayId ? " Pathway " + pathwayId : ""} ${url}`);
      this.clearTimer();
      this.hls.trigger(Events.LEVEL_LOADING, {
        url,
        level: currentLevelIndex,
        pathwayId: currentLevel.attrs["PATHWAY-ID"],
        id: 0,
        deliveryDirectives: hlsUrlParameters || null
      });
    }
  }
  get nextLoadLevel() {
    if (this.manualLevelIndex !== -1) {
      return this.manualLevelIndex;
    } else {
      return this.hls.nextAutoLevel;
    }
  }
  set nextLoadLevel(nextLevel) {
    this.level = nextLevel;
    if (this.manualLevelIndex === -1) {
      this.hls.nextAutoLevel = nextLevel;
    }
  }
  removeLevel(levelIndex) {
    var _this$currentLevel;
    const levels = this._levels.filter((level, index) => {
      if (index !== levelIndex) {
        return true;
      }
      if (this.steering) {
        this.steering.removeLevel(level);
      }
      if (level === this.currentLevel) {
        this.currentLevel = null;
        this.currentLevelIndex = -1;
        if (level.details) {
          level.details.fragments.forEach((f) => f.level = -1);
        }
      }
      return false;
    });
    reassignFragmentLevelIndexes(levels);
    this._levels = levels;
    if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {
      this.currentLevelIndex = this.currentLevel.details.fragments[0].level;
    }
    this.hls.trigger(Events.LEVELS_UPDATED, {
      levels
    });
  }
  onLevelsUpdated(event, {
    levels
  }) {
    this._levels = levels;
  }
  checkMaxAutoUpdated() {
    const {
      autoLevelCapping,
      maxAutoLevel,
      maxHdcpLevel
    } = this.hls;
    if (this._maxAutoLevel !== maxAutoLevel) {
      this._maxAutoLevel = maxAutoLevel;
      this.hls.trigger(Events.MAX_AUTO_LEVEL_UPDATED, {
        autoLevelCapping,
        levels: this.levels,
        maxAutoLevel,
        minAutoLevel: this.hls.minAutoLevel,
        maxHdcpLevel
      });
    }
  }
}
function assignTrackIdsByGroup(tracks) {
  const groups = {};
  tracks.forEach((track) => {
    const groupId = track.groupId || "";
    track.id = groups[groupId] = groups[groupId] || 0;
    groups[groupId]++;
  });
}

class KeyLoader {
  constructor(config) {
    this.config = undefined;
    this.keyUriToKeyInfo = {};
    this.emeController = null;
    this.config = config;
  }
  abort(type) {
    for (const uri in this.keyUriToKeyInfo) {
      const loader = this.keyUriToKeyInfo[uri].loader;
      if (loader) {
        var _loader$context;
        if (type && type !== ((_loader$context = loader.context) == null ? undefined : _loader$context.frag.type)) {
          return;
        }
        loader.abort();
      }
    }
  }
  detach() {
    for (const uri in this.keyUriToKeyInfo) {
      const keyInfo = this.keyUriToKeyInfo[uri];
      if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {
        delete this.keyUriToKeyInfo[uri];
      }
    }
  }
  destroy() {
    this.detach();
    for (const uri in this.keyUriToKeyInfo) {
      const loader = this.keyUriToKeyInfo[uri].loader;
      if (loader) {
        loader.destroy();
      }
    }
    this.keyUriToKeyInfo = {};
  }
  createKeyLoadError(frag, details = ErrorDetails.KEY_LOAD_ERROR, error, networkDetails, response) {
    return new LoadError({
      type: ErrorTypes.NETWORK_ERROR,
      details,
      fatal: false,
      frag,
      response,
      error,
      networkDetails
    });
  }
  loadClear(loadingFrag, encryptedFragments) {
    if (this.emeController && this.config.emeEnabled) {
      const {
        sn,
        cc: cc2
      } = loadingFrag;
      for (let i = 0;i < encryptedFragments.length; i++) {
        const frag = encryptedFragments[i];
        if (cc2 <= frag.cc && (sn === "initSegment" || frag.sn === "initSegment" || sn < frag.sn)) {
          this.emeController.selectKeySystemFormat(frag).then((keySystemFormat) => {
            frag.setKeyFormat(keySystemFormat);
          });
          break;
        }
      }
    }
  }
  load(frag) {
    if (!frag.decryptdata && frag.encrypted && this.emeController) {
      return this.emeController.selectKeySystemFormat(frag).then((keySystemFormat) => {
        return this.loadInternal(frag, keySystemFormat);
      });
    }
    return this.loadInternal(frag);
  }
  loadInternal(frag, keySystemFormat) {
    var _keyInfo, _keyInfo2;
    if (keySystemFormat) {
      frag.setKeyFormat(keySystemFormat);
    }
    const decryptdata = frag.decryptdata;
    if (!decryptdata) {
      const error = new Error(keySystemFormat ? `Expected frag.decryptdata to be defined after setting format ${keySystemFormat}` : "Missing decryption data on fragment in onKeyLoading");
      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));
    }
    const uri = decryptdata.uri;
    if (!uri) {
      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Invalid key URI: "${uri}"`)));
    }
    let keyInfo = this.keyUriToKeyInfo[uri];
    if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {
      decryptdata.key = keyInfo.decryptdata.key;
      return Promise.resolve({
        frag,
        keyInfo
      });
    }
    if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {
      var _keyInfo$mediaKeySess;
      switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? undefined : _keyInfo$mediaKeySess.keyStatus) {
        case undefined:
        case "status-pending":
        case "usable":
        case "usable-in-future":
          return keyInfo.keyLoadPromise.then((keyLoadedData) => {
            decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;
            return {
              frag,
              keyInfo
            };
          });
      }
    }
    keyInfo = this.keyUriToKeyInfo[uri] = {
      decryptdata,
      keyLoadPromise: null,
      loader: null,
      mediaKeySessionContext: null
    };
    switch (decryptdata.method) {
      case "ISO-23001-7":
      case "SAMPLE-AES":
      case "SAMPLE-AES-CENC":
      case "SAMPLE-AES-CTR":
        if (decryptdata.keyFormat === "identity") {
          return this.loadKeyHTTP(keyInfo, frag);
        }
        return this.loadKeyEME(keyInfo, frag);
      case "AES-128":
        return this.loadKeyHTTP(keyInfo, frag);
      default:
        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: "${decryptdata.method}"`)));
    }
  }
  loadKeyEME(keyInfo, frag) {
    const keyLoadedData = {
      frag,
      keyInfo
    };
    if (this.emeController && this.config.emeEnabled) {
      const keySessionContextPromise = this.emeController.loadKey(keyLoadedData);
      if (keySessionContextPromise) {
        return (keyInfo.keyLoadPromise = keySessionContextPromise.then((keySessionContext) => {
          keyInfo.mediaKeySessionContext = keySessionContext;
          return keyLoadedData;
        })).catch((error) => {
          keyInfo.keyLoadPromise = null;
          throw error;
        });
      }
    }
    return Promise.resolve(keyLoadedData);
  }
  loadKeyHTTP(keyInfo, frag) {
    const config = this.config;
    const Loader = config.loader;
    const keyLoader = new Loader(config);
    frag.keyLoader = keyInfo.loader = keyLoader;
    return keyInfo.keyLoadPromise = new Promise((resolve, reject) => {
      const loaderContext = {
        keyInfo,
        frag,
        responseType: "arraybuffer",
        url: keyInfo.decryptdata.uri
      };
      const loadPolicy = config.keyLoadPolicy.default;
      const loaderConfig = {
        loadPolicy,
        timeout: loadPolicy.maxLoadTimeMs,
        maxRetry: 0,
        retryDelay: 0,
        maxRetryDelay: 0
      };
      const loaderCallbacks = {
        onSuccess: (response, stats, context, networkDetails) => {
          const {
            frag: frag2,
            keyInfo: keyInfo2,
            url: uri
          } = context;
          if (!frag2.decryptdata || keyInfo2 !== this.keyUriToKeyInfo[uri]) {
            return reject(this.createKeyLoadError(frag2, ErrorDetails.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), networkDetails));
          }
          keyInfo2.decryptdata.key = frag2.decryptdata.key = new Uint8Array(response.data);
          frag2.keyLoader = null;
          keyInfo2.loader = null;
          resolve({
            frag: frag2,
            keyInfo: keyInfo2
          });
        },
        onError: (response, context, networkDetails, stats) => {
          this.resetLoader(context);
          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`HTTP Error ${response.code} loading key ${response.text}`), networkDetails, _objectSpread2({
            url: loaderContext.url,
            data: undefined
          }, response)));
        },
        onTimeout: (stats, context, networkDetails) => {
          this.resetLoader(context);
          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), networkDetails));
        },
        onAbort: (stats, context, networkDetails) => {
          this.resetLoader(context);
          reject(this.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error("key loading aborted"), networkDetails));
        }
      };
      keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);
    });
  }
  resetLoader(context) {
    const {
      frag,
      keyInfo,
      url: uri
    } = context;
    const loader = keyInfo.loader;
    if (frag.keyLoader === loader) {
      frag.keyLoader = null;
      keyInfo.loader = null;
    }
    delete this.keyUriToKeyInfo[uri];
    if (loader) {
      loader.destroy();
    }
  }
}
function getSourceBuffer() {
  return self.SourceBuffer || self.WebKitSourceBuffer;
}
function isMSESupported() {
  const mediaSource = getMediaSource();
  if (!mediaSource) {
    return false;
  }
  const sourceBuffer = getSourceBuffer();
  return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === "function" && typeof sourceBuffer.prototype.remove === "function";
}
function isSupported() {
  if (!isMSESupported()) {
    return false;
  }
  const mediaSource = getMediaSource();
  return typeof (mediaSource == null ? undefined : mediaSource.isTypeSupported) === "function" && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some((codecsForVideoContainer) => mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, "video"))) || ["mp4a.40.2", "fLaC"].some((codecForAudioContainer) => mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, "audio"))));
}
function changeTypeSupported() {
  var _sourceBuffer$prototy;
  const sourceBuffer = getSourceBuffer();
  return typeof (sourceBuffer == null ? undefined : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? undefined : _sourceBuffer$prototy.changeType) === "function";
}
var STALL_MINIMUM_DURATION_MS = 250;
var MAX_START_GAP_JUMP = 2;
var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
var SKIP_BUFFER_RANGE_START = 0.05;

class GapController {
  constructor(config, media, fragmentTracker, hls) {
    this.config = undefined;
    this.media = null;
    this.fragmentTracker = undefined;
    this.hls = undefined;
    this.nudgeRetry = 0;
    this.stallReported = false;
    this.stalled = null;
    this.moved = false;
    this.seeking = false;
    this.config = config;
    this.media = media;
    this.fragmentTracker = fragmentTracker;
    this.hls = hls;
  }
  destroy() {
    this.media = null;
    this.hls = this.fragmentTracker = null;
  }
  poll(lastCurrentTime, activeFrag) {
    const {
      config,
      media,
      stalled
    } = this;
    if (media === null) {
      return;
    }
    const {
      currentTime,
      seeking
    } = media;
    const seeked = this.seeking && !seeking;
    const beginSeek = !this.seeking && seeking;
    this.seeking = seeking;
    if (currentTime !== lastCurrentTime) {
      this.moved = true;
      if (!seeking) {
        this.nudgeRetry = 0;
      }
      if (stalled !== null) {
        if (this.stallReported) {
          const _stalledDuration = self.performance.now() - stalled;
          logger.warn(`playback not stuck anymore @${currentTime}, after ${Math.round(_stalledDuration)}ms`);
          this.stallReported = false;
        }
        this.stalled = null;
      }
      return;
    }
    if (beginSeek || seeked) {
      this.stalled = null;
      return;
    }
    if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {
      this.nudgeRetry = 0;
      return;
    }
    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
    const nextStart = bufferInfo.nextStart || 0;
    if (seeking) {
      const hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;
      const noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);
      if (hasEnoughBuffer || noBufferGap) {
        return;
      }
      this.moved = false;
    }
    if (!this.moved && this.stalled !== null) {
      var _level$details;
      const isBuffered = bufferInfo.len > 0;
      if (!isBuffered && !nextStart) {
        return;
      }
      const startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;
      const level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;
      const isLive = level == null ? undefined : (_level$details = level.details) == null ? undefined : _level$details.live;
      const maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;
      const partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);
      if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {
        if (!media.paused) {
          this._trySkipBufferHole(partialOrGap);
        }
        return;
      }
    }
    const tnow = self.performance.now();
    if (stalled === null) {
      this.stalled = tnow;
      return;
    }
    const stalledDuration = tnow - stalled;
    if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {
      this._reportStall(bufferInfo);
      if (!this.media) {
        return;
      }
    }
    const bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
    this._tryFixBufferStall(bufferedWithHoles, stalledDuration);
  }
  _tryFixBufferStall(bufferInfo, stalledDurationMs) {
    const {
      config,
      fragmentTracker,
      media
    } = this;
    if (media === null) {
      return;
    }
    const currentTime = media.currentTime;
    const partial = fragmentTracker.getPartialFragment(currentTime);
    if (partial) {
      const targetTime = this._trySkipBufferHole(partial);
      if (targetTime || !this.media) {
        return;
      }
    }
    if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {
      logger.warn("Trying to nudge playhead over buffer-hole");
      this.stalled = null;
      this._tryNudgeBuffer();
    }
  }
  _reportStall(bufferInfo) {
    const {
      hls,
      media,
      stallReported
    } = this;
    if (!stallReported && media) {
      this.stallReported = true;
      const error = new Error(`Playback stalling at @${media.currentTime} due to low buffer (${JSON.stringify(bufferInfo)})`);
      logger.warn(error.message);
      hls.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.BUFFER_STALLED_ERROR,
        fatal: false,
        error,
        buffer: bufferInfo.len
      });
    }
  }
  _trySkipBufferHole(partial) {
    const {
      config,
      hls,
      media
    } = this;
    if (media === null) {
      return 0;
    }
    const currentTime = media.currentTime;
    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
    const startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;
    if (startTime) {
      const bufferStarved = bufferInfo.len <= config.maxBufferHole;
      const waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;
      const gapLength = startTime - currentTime;
      if (gapLength > 0 && (bufferStarved || waiting)) {
        if (gapLength > config.maxBufferHole) {
          const {
            fragmentTracker
          } = this;
          let startGap = false;
          if (currentTime === 0) {
            const startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);
            if (startFrag && startTime < startFrag.end) {
              startGap = true;
            }
          }
          if (!startGap) {
            const startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);
            if (startProvisioned) {
              let moreToLoad = false;
              let pos = startProvisioned.end;
              while (pos < startTime) {
                const provisioned = fragmentTracker.getPartialFragment(pos);
                if (provisioned) {
                  pos += provisioned.duration;
                } else {
                  moreToLoad = true;
                  break;
                }
              }
              if (moreToLoad) {
                return 0;
              }
            }
          }
        }
        const targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);
        logger.warn(`skipping hole, adjusting currentTime from ${currentTime} to ${targetTime}`);
        this.moved = true;
        this.stalled = null;
        media.currentTime = targetTime;
        if (partial && !partial.gap) {
          const error = new Error(`fragment loaded with buffer holes, seeking from ${currentTime} to ${targetTime}`);
          hls.trigger(Events.ERROR, {
            type: ErrorTypes.MEDIA_ERROR,
            details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,
            fatal: false,
            error,
            reason: error.message,
            frag: partial
          });
        }
        return targetTime;
      }
    }
    return 0;
  }
  _tryNudgeBuffer() {
    const {
      config,
      hls,
      media,
      nudgeRetry
    } = this;
    if (media === null) {
      return;
    }
    const currentTime = media.currentTime;
    this.nudgeRetry++;
    if (nudgeRetry < config.nudgeMaxRetry) {
      const targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;
      const error = new Error(`Nudging 'currentTime' from ${currentTime} to ${targetTime}`);
      logger.warn(error.message);
      media.currentTime = targetTime;
      hls.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.BUFFER_NUDGE_ON_STALL,
        error,
        fatal: false
      });
    } else {
      const error = new Error(`Playhead still not moving while enough data buffered @${currentTime} after ${config.nudgeMaxRetry} nudges`);
      logger.error(error.message);
      hls.trigger(Events.ERROR, {
        type: ErrorTypes.MEDIA_ERROR,
        details: ErrorDetails.BUFFER_STALLED_ERROR,
        error,
        fatal: true
      });
    }
  }
}
var TICK_INTERVAL = 100;

class StreamController extends BaseStreamController {
  constructor(hls, fragmentTracker, keyLoader) {
    super(hls, fragmentTracker, keyLoader, "[stream-controller]", PlaylistLevelType.MAIN);
    this.audioCodecSwap = false;
    this.gapController = null;
    this.level = -1;
    this._forceStartLoad = false;
    this.altAudio = false;
    this.audioOnly = false;
    this.fragPlaying = null;
    this.onvplaying = null;
    this.onvseeked = null;
    this.fragLastKbps = 0;
    this.couldBacktrack = false;
    this.backtrackFragment = null;
    this.audioCodecSwitch = false;
    this.videoBuffer = null;
    this._registerListeners();
  }
  _registerListeners() {
    const {
      hls
    } = this;
    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
    hls.on(Events.ERROR, this.onError, this);
    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
    hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  _unregisterListeners() {
    const {
      hls
    } = this;
    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
    hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
    hls.off(Events.ERROR, this.onError, this);
    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
    hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
  }
  onHandlerDestroying() {
    this._unregisterListeners();
    super.onHandlerDestroying();
  }
  startLoad(startPosition) {
    if (this.levels) {
      const {
        lastCurrentTime,
        hls
      } = this;
      this.stopLoad();
      this.setInterval(TICK_INTERVAL);
      this.level = -1;
      if (!this.startFragRequested) {
        let startLevel = hls.startLevel;
        if (startLevel === -1) {
          if (hls.config.testBandwidth && this.levels.length > 1) {
            startLevel = 0;
            this.bitrateTest = true;
          } else {
            startLevel = hls.firstAutoLevel;
          }
        }
        hls.nextLoadLevel = startLevel;
        this.level = hls.loadLevel;
        this.loadedmetadata = false;
      }
      if (lastCurrentTime > 0 && startPosition === -1) {
        this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);
        startPosition = lastCurrentTime;
      }
      this.state = State.IDLE;
      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
      this.tick();
    } else {
      this._forceStartLoad = true;
      this.state = State.STOPPED;
    }
  }
  stopLoad() {
    this._forceStartLoad = false;
    super.stopLoad();
  }
  doTick() {
    switch (this.state) {
      case State.WAITING_LEVEL: {
        const {
          levels,
          level
        } = this;
        const currentLevel = levels == null ? undefined : levels[level];
        const details = currentLevel == null ? undefined : currentLevel.details;
        if (details && (!details.live || this.levelLastLoaded === currentLevel)) {
          if (this.waitForCdnTuneIn(details)) {
            break;
          }
          this.state = State.IDLE;
          break;
        } else if (this.hls.nextLoadLevel !== this.level) {
          this.state = State.IDLE;
          break;
        }
        break;
      }
      case State.FRAG_LOADING_WAITING_RETRY:
        {
          var _this$media;
          const now2 = self.performance.now();
          const retryDate = this.retryDate;
          if (!retryDate || now2 >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {
            const {
              levels,
              level
            } = this;
            const currentLevel = levels == null ? undefined : levels[level];
            this.resetStartWhenNotLoaded(currentLevel || null);
            this.state = State.IDLE;
          }
        }
        break;
    }
    if (this.state === State.IDLE) {
      this.doTickIdle();
    }
    this.onTickEnd();
  }
  onTickEnd() {
    super.onTickEnd();
    this.checkBuffer();
    this.checkFragmentChanged();
  }
  doTickIdle() {
    const {
      hls,
      levelLastLoaded,
      levels,
      media
    } = this;
    if (levelLastLoaded === null || !media && (this.startFragRequested || !hls.config.startFragPrefetch)) {
      return;
    }
    if (this.altAudio && this.audioOnly) {
      return;
    }
    const level = hls.nextLoadLevel;
    if (!(levels != null && levels[level])) {
      return;
    }
    const levelInfo = levels[level];
    const bufferInfo = this.getMainFwdBufferInfo();
    if (bufferInfo === null) {
      return;
    }
    const lastDetails = this.getLevelDetails();
    if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {
      const data = {};
      if (this.altAudio) {
        data.type = "video";
      }
      this.hls.trigger(Events.BUFFER_EOS, data);
      this.state = State.ENDED;
      return;
    }
    if (hls.loadLevel !== level && hls.manualLevel === -1) {
      this.log(`Adapting to level ${level} from level ${this.level}`);
    }
    this.level = hls.nextLoadLevel = level;
    const levelDetails = levelInfo.details;
    if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== levelInfo) {
      this.level = level;
      this.state = State.WAITING_LEVEL;
      return;
    }
    const bufferLen = bufferInfo.len;
    const maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);
    if (bufferLen >= maxBufLen) {
      return;
    }
    if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {
      this.backtrackFragment = null;
    }
    const targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;
    let frag = this.getNextFragment(targetBufferTime, levelDetails);
    if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== "initSegment" && this.fragmentTracker.getState(frag) !== FragmentState.OK) {
      var _this$backtrackFragme;
      const backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;
      const fragIdx = backtrackSn - levelDetails.startSN;
      const backtrackFrag = levelDetails.fragments[fragIdx - 1];
      if (backtrackFrag && frag.cc === backtrackFrag.cc) {
        frag = backtrackFrag;
        this.fragmentTracker.removeFragment(backtrackFrag);
      }
    } else if (this.backtrackFragment && bufferInfo.len) {
      this.backtrackFragment = null;
    }
    if (frag && this.isLoopLoading(frag, targetBufferTime)) {
      const gapStart = frag.gap;
      if (!gapStart) {
        const type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;
        const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
        if (mediaBuffer) {
          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
        }
      }
      frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
    }
    if (!frag) {
      return;
    }
    if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {
      frag = frag.initSegment;
    }
    this.loadFragment(frag, levelInfo, targetBufferTime);
  }
  loadFragment(frag, level, targetBufferTime) {
    const fragState = this.fragmentTracker.getState(frag);
    this.fragCurrent = frag;
    if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
      if (frag.sn === "initSegment") {
        this._loadInitSegment(frag, level);
      } else if (this.bitrateTest) {
        this.log(`Fragment ${frag.sn} of level ${frag.level} is being downloaded to test bitrate and will not be buffered`);
        this._loadBitrateTestFrag(frag, level);
      } else {
        this.startFragRequested = true;
        super.loadFragment(frag, level, targetBufferTime);
      }
    } else {
      this.clearTrackerIfNeeded(frag);
    }
  }
  getBufferedFrag(position) {
    return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);
  }
  followingBufferedFrag(frag) {
    if (frag) {
      return this.getBufferedFrag(frag.end + 0.5);
    }
    return null;
  }
  immediateLevelSwitch() {
    this.abortCurrentFrag();
    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
  }
  nextLevelSwitch() {
    const {
      levels,
      media
    } = this;
    if (media != null && media.readyState) {
      let fetchdelay;
      const fragPlayingCurrent = this.getAppendedFrag(media.currentTime);
      if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {
        this.flushMainBuffer(0, fragPlayingCurrent.start - 1);
      }
      const levelDetails = this.getLevelDetails();
      if (levelDetails != null && levelDetails.live) {
        const bufferInfo = this.getMainFwdBufferInfo();
        if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {
          return;
        }
      }
      if (!media.paused && levels) {
        const nextLevelId = this.hls.nextLoadLevel;
        const nextLevel = levels[nextLevelId];
        const fragLastKbps = this.fragLastKbps;
        if (fragLastKbps && this.fragCurrent) {
          fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;
        } else {
          fetchdelay = 0;
        }
      } else {
        fetchdelay = 0;
      }
      const bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
      if (bufferedFrag) {
        const nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);
        if (nextBufferedFrag) {
          this.abortCurrentFrag();
          const maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;
          const fragDuration = nextBufferedFrag.duration;
          const startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));
          this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);
        }
      }
    }
  }
  abortCurrentFrag() {
    const fragCurrent = this.fragCurrent;
    this.fragCurrent = null;
    this.backtrackFragment = null;
    if (fragCurrent) {
      fragCurrent.abortRequests();
      this.fragmentTracker.removeFragment(fragCurrent);
    }
    switch (this.state) {
      case State.KEY_LOADING:
      case State.FRAG_LOADING:
      case State.FRAG_LOADING_WAITING_RETRY:
      case State.PARSING:
      case State.PARSED:
        this.state = State.IDLE;
        break;
    }
    this.nextLoadPosition = this.getLoadPosition();
  }
  flushMainBuffer(startOffset, endOffset) {
    super.flushMainBuffer(startOffset, endOffset, this.altAudio ? "video" : null);
  }
  onMediaAttached(event, data) {
    super.onMediaAttached(event, data);
    const media = data.media;
    this.onvplaying = this.onMediaPlaying.bind(this);
    this.onvseeked = this.onMediaSeeked.bind(this);
    media.addEventListener("playing", this.onvplaying);
    media.addEventListener("seeked", this.onvseeked);
    this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);
  }
  onMediaDetaching() {
    const {
      media
    } = this;
    if (media && this.onvplaying && this.onvseeked) {
      media.removeEventListener("playing", this.onvplaying);
      media.removeEventListener("seeked", this.onvseeked);
      this.onvplaying = this.onvseeked = null;
      this.videoBuffer = null;
    }
    this.fragPlaying = null;
    if (this.gapController) {
      this.gapController.destroy();
      this.gapController = null;
    }
    super.onMediaDetaching();
  }
  onMediaPlaying() {
    this.tick();
  }
  onMediaSeeked() {
    const media = this.media;
    const currentTime = media ? media.currentTime : null;
    if (isFiniteNumber(currentTime)) {
      this.log(`Media seeked to ${currentTime.toFixed(3)}`);
    }
    const bufferInfo = this.getMainFwdBufferInfo();
    if (bufferInfo === null || bufferInfo.len === 0) {
      this.warn(`Main forward buffer length on "seeked" event ${bufferInfo ? bufferInfo.len : "empty"})`);
      return;
    }
    this.tick();
  }
  onManifestLoading() {
    this.log("Trigger BUFFER_RESET");
    this.hls.trigger(Events.BUFFER_RESET, undefined);
    this.fragmentTracker.removeAllFragments();
    this.couldBacktrack = false;
    this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0;
    this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null;
    this.altAudio = this.audioOnly = this.startFragRequested = false;
  }
  onManifestParsed(event, data) {
    let aac = false;
    let heaac = false;
    data.levels.forEach((level) => {
      const codec = level.audioCodec;
      if (codec) {
        aac = aac || codec.indexOf("mp4a.40.2") !== -1;
        heaac = heaac || codec.indexOf("mp4a.40.5") !== -1;
      }
    });
    this.audioCodecSwitch = aac && heaac && !changeTypeSupported();
    if (this.audioCodecSwitch) {
      this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC");
    }
    this.levels = data.levels;
    this.startFragRequested = false;
  }
  onLevelLoading(event, data) {
    const {
      levels
    } = this;
    if (!levels || this.state !== State.IDLE) {
      return;
    }
    const level = levels[data.level];
    if (!level.details || level.details.live && this.levelLastLoaded !== level || this.waitForCdnTuneIn(level.details)) {
      this.state = State.WAITING_LEVEL;
    }
  }
  onLevelLoaded(event, data) {
    var _curLevel$details;
    const {
      levels
    } = this;
    const newLevelId = data.level;
    const newDetails = data.details;
    const duration = newDetails.totalduration;
    if (!levels) {
      this.warn(`Levels were reset while loading level ${newLevelId}`);
      return;
    }
    this.log(`Level ${newLevelId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ""}, cc [${newDetails.startCC}, ${newDetails.endCC}] duration:${duration}`);
    const curLevel = levels[newLevelId];
    const fragCurrent = this.fragCurrent;
    if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {
      if (fragCurrent.level !== data.level && fragCurrent.loader) {
        this.abortCurrentFrag();
      }
    }
    let sliding = 0;
    if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {
      var _this$levelLastLoaded;
      this.checkLiveUpdate(newDetails);
      if (newDetails.deltaUpdateFailed) {
        return;
      }
      sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? undefined : _this$levelLastLoaded.details);
    }
    curLevel.details = newDetails;
    this.levelLastLoaded = curLevel;
    this.hls.trigger(Events.LEVEL_UPDATED, {
      details: newDetails,
      level: newLevelId
    });
    if (this.state === State.WAITING_LEVEL) {
      if (this.waitForCdnTuneIn(newDetails)) {
        return;
      }
      this.state = State.IDLE;
    }
    if (!this.startFragRequested) {
      this.setStartPosition(newDetails, sliding);
    } else if (newDetails.live) {
      this.synchronizeToLiveEdge(newDetails);
    }
    this.tick();
  }
  _handleFragmentLoadProgress(data) {
    var _frag$initSegment;
    const {
      frag,
      part,
      payload
    } = data;
    const {
      levels
    } = this;
    if (!levels) {
      this.warn(`Levels were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);
      return;
    }
    const currentLevel = levels[frag.level];
    const details = currentLevel.details;
    if (!details) {
      this.warn(`Dropping fragment ${frag.sn} of level ${frag.level} after level details were reset`);
      this.fragmentTracker.removeFragment(frag);
      return;
    }
    const videoCodec = currentLevel.videoCodec;
    const accurateTimeOffset = details.PTSKnown || !details.live;
    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? undefined : _frag$initSegment.data;
    const audioCodec = this._getAudioCodec(currentLevel);
    const transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
    const partIndex = part ? part.index : -1;
    const partial = partIndex !== -1;
    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
    const initPTS = this.initPTS[frag.cc];
    transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
  }
  onAudioTrackSwitching(event, data) {
    const fromAltAudio = this.altAudio;
    const altAudio = !!data.url;
    if (!altAudio) {
      if (this.mediaBuffer !== this.media) {
        this.log("Switching on main audio, use media.buffered to schedule main fragment loading");
        this.mediaBuffer = this.media;
        const fragCurrent = this.fragCurrent;
        if (fragCurrent) {
          this.log("Switching to main audio track, cancel main fragment load");
          fragCurrent.abortRequests();
          this.fragmentTracker.removeFragment(fragCurrent);
        }
        this.resetTransmuxer();
        this.resetLoadingState();
      } else if (this.audioOnly) {
        this.resetTransmuxer();
      }
      const hls = this.hls;
      if (fromAltAudio) {
        hls.trigger(Events.BUFFER_FLUSHING, {
          startOffset: 0,
          endOffset: Number.POSITIVE_INFINITY,
          type: null
        });
        this.fragmentTracker.removeAllFragments();
      }
      hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);
    }
  }
  onAudioTrackSwitched(event, data) {
    const trackId = data.id;
    const altAudio = !!this.hls.audioTracks[trackId].url;
    if (altAudio) {
      const videoBuffer = this.videoBuffer;
      if (videoBuffer && this.mediaBuffer !== videoBuffer) {
        this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading");
        this.mediaBuffer = videoBuffer;
      }
    }
    this.altAudio = altAudio;
    this.tick();
  }
  onBufferCreated(event, data) {
    const tracks = data.tracks;
    let mediaTrack;
    let name;
    let alternate = false;
    for (const type in tracks) {
      const track = tracks[type];
      if (track.id === "main") {
        name = type;
        mediaTrack = track;
        if (type === "video") {
          const videoTrack = tracks[type];
          if (videoTrack) {
            this.videoBuffer = videoTrack.buffer;
          }
        }
      } else {
        alternate = true;
      }
    }
    if (alternate && mediaTrack) {
      this.log(`Alternate track found, use ${name}.buffered to schedule main fragment loading`);
      this.mediaBuffer = mediaTrack.buffer;
    } else {
      this.mediaBuffer = this.media;
    }
  }
  onFragBuffered(event, data) {
    const {
      frag,
      part
    } = data;
    if (frag && frag.type !== PlaylistLevelType.MAIN) {
      return;
    }
    if (this.fragContextChanged(frag)) {
      this.warn(`Fragment ${frag.sn}${part ? " p: " + part.index : ""} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}`);
      if (this.state === State.PARSED) {
        this.state = State.IDLE;
      }
      return;
    }
    const stats = part ? part.stats : frag.stats;
    this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));
    if (frag.sn !== "initSegment") {
      this.fragPrevious = frag;
    }
    this.fragBufferedComplete(frag, part);
  }
  onError(event, data) {
    var _data$context;
    if (data.fatal) {
      this.state = State.ERROR;
      return;
    }
    switch (data.details) {
      case ErrorDetails.FRAG_GAP:
      case ErrorDetails.FRAG_PARSING_ERROR:
      case ErrorDetails.FRAG_DECRYPT_ERROR:
      case ErrorDetails.FRAG_LOAD_ERROR:
      case ErrorDetails.FRAG_LOAD_TIMEOUT:
      case ErrorDetails.KEY_LOAD_ERROR:
      case ErrorDetails.KEY_LOAD_TIMEOUT:
        this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);
        break;
      case ErrorDetails.LEVEL_LOAD_ERROR:
      case ErrorDetails.LEVEL_LOAD_TIMEOUT:
      case ErrorDetails.LEVEL_PARSING_ERROR:
        if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? undefined : _data$context.type) === PlaylistContextType.LEVEL) {
          this.state = State.IDLE;
        }
        break;
      case ErrorDetails.BUFFER_APPEND_ERROR:
      case ErrorDetails.BUFFER_FULL_ERROR:
        if (!data.parent || data.parent !== "main") {
          return;
        }
        if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {
          this.resetLoadingState();
          return;
        }
        if (this.reduceLengthAndFlushBuffer(data)) {
          this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
        }
        break;
      case ErrorDetails.INTERNAL_EXCEPTION:
        this.recoverWorkerError(data);
        break;
    }
  }
  checkBuffer() {
    const {
      media,
      gapController
    } = this;
    if (!media || !gapController || !media.readyState) {
      return;
    }
    if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {
      const activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;
      gapController.poll(this.lastCurrentTime, activeFrag);
    }
    this.lastCurrentTime = media.currentTime;
  }
  onFragLoadEmergencyAborted() {
    this.state = State.IDLE;
    if (!this.loadedmetadata) {
      this.startFragRequested = false;
      this.nextLoadPosition = this.startPosition;
    }
    this.tickImmediate();
  }
  onBufferFlushed(event, {
    type
  }) {
    if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {
      const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
      this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
      this.tick();
    }
  }
  onLevelsUpdated(event, data) {
    if (this.level > -1 && this.fragCurrent) {
      this.level = this.fragCurrent.level;
    }
    this.levels = data.levels;
  }
  swapAudioCodec() {
    this.audioCodecSwap = !this.audioCodecSwap;
  }
  seekToStartPos() {
    const {
      media
    } = this;
    if (!media) {
      return;
    }
    const currentTime = media.currentTime;
    let startPosition = this.startPosition;
    if (startPosition >= 0 && currentTime < startPosition) {
      if (media.seeking) {
        this.log(`could not seek to ${startPosition}, already seeking at ${currentTime}`);
        return;
      }
      const buffered = BufferHelper.getBuffered(media);
      const bufferStart = buffered.length ? buffered.start(0) : 0;
      const delta = bufferStart - startPosition;
      if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {
        this.log(`adjusting start position by ${delta} to match buffer start`);
        startPosition += delta;
        this.startPosition = startPosition;
      }
      this.log(`seek to target start position ${startPosition} from current time ${currentTime}`);
      media.currentTime = startPosition;
    }
  }
  _getAudioCodec(currentLevel) {
    let audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
    if (this.audioCodecSwap && audioCodec) {
      this.log("Swapping audio codec");
      if (audioCodec.indexOf("mp4a.40.5") !== -1) {
        audioCodec = "mp4a.40.2";
      } else {
        audioCodec = "mp4a.40.5";
      }
    }
    return audioCodec;
  }
  _loadBitrateTestFrag(frag, level) {
    frag.bitrateTest = true;
    this._doFragLoad(frag, level).then((data) => {
      const {
        hls
      } = this;
      if (!data || this.fragContextChanged(frag)) {
        return;
      }
      level.fragmentError = 0;
      this.state = State.IDLE;
      this.startFragRequested = false;
      this.bitrateTest = false;
      const stats = frag.stats;
      stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();
      hls.trigger(Events.FRAG_LOADED, data);
      frag.bitrateTest = false;
    });
  }
  _handleTransmuxComplete(transmuxResult) {
    var _id3$samples;
    const id = "main";
    const {
      hls
    } = this;
    const {
      remuxResult,
      chunkMeta
    } = transmuxResult;
    const context = this.getCurrentContext(chunkMeta);
    if (!context) {
      this.resetWhenMissingContext(chunkMeta);
      return;
    }
    const {
      frag,
      part,
      level
    } = context;
    const {
      video,
      text,
      id3,
      initSegment
    } = remuxResult;
    const {
      details
    } = level;
    const audio = this.altAudio ? undefined : remuxResult.audio;
    if (this.fragContextChanged(frag)) {
      this.fragmentTracker.removeFragment(frag);
      return;
    }
    this.state = State.PARSING;
    if (initSegment) {
      if (initSegment != null && initSegment.tracks) {
        const mapFragment = frag.initSegment || frag;
        this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);
        hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {
          frag: mapFragment,
          id,
          tracks: initSegment.tracks
        });
      }
      const initPTS = initSegment.initPTS;
      const timescale = initSegment.timescale;
      if (isFiniteNumber(initPTS)) {
        this.initPTS[frag.cc] = {
          baseTime: initPTS,
          timescale
        };
        hls.trigger(Events.INIT_PTS_FOUND, {
          frag,
          id,
          initPTS,
          timescale
        });
      }
    }
    if (video && details && frag.sn !== "initSegment") {
      const prevFrag = details.fragments[frag.sn - 1 - details.startSN];
      const isFirstFragment = frag.sn === details.startSN;
      const isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;
      if (remuxResult.independent !== false) {
        const {
          startPTS,
          endPTS,
          startDTS,
          endDTS
        } = video;
        if (part) {
          part.elementaryStreams[video.type] = {
            startPTS,
            endPTS,
            startDTS,
            endDTS
          };
        } else {
          if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {
            this.couldBacktrack = true;
          }
          if (video.dropped && video.independent) {
            const bufferInfo = this.getMainFwdBufferInfo();
            const targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;
            const startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;
            if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {
              this.backtrack(frag);
              return;
            } else if (isFirstInDiscontinuity) {
              frag.gap = true;
            }
            frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);
          } else if (isFirstFragment && startPTS > MAX_START_GAP_JUMP) {
            frag.gap = true;
          }
        }
        frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);
        if (this.backtrackFragment) {
          this.backtrackFragment = frag;
        }
        this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);
      } else if (isFirstFragment || isFirstInDiscontinuity) {
        frag.gap = true;
      } else {
        this.backtrack(frag);
        return;
      }
    }
    if (audio) {
      const {
        startPTS,
        endPTS,
        startDTS,
        endDTS
      } = audio;
      if (part) {
        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
          startPTS,
          endPTS,
          startDTS,
          endDTS
        };
      }
      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);
      this.bufferFragmentData(audio, frag, part, chunkMeta);
    }
    if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {
      const emittedID3 = {
        id,
        frag,
        details,
        samples: id3.samples
      };
      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);
    }
    if (details && text) {
      const emittedText = {
        id,
        frag,
        details,
        samples: text.samples
      };
      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);
    }
  }
  _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
    if (this.state !== State.PARSING) {
      return;
    }
    this.audioOnly = !!tracks.audio && !tracks.video;
    if (this.altAudio && !this.audioOnly) {
      delete tracks.audio;
    }
    const {
      audio,
      video,
      audiovideo
    } = tracks;
    if (audio) {
      let audioCodec = currentLevel.audioCodec;
      const ua = navigator.userAgent.toLowerCase();
      if (this.audioCodecSwitch) {
        if (audioCodec) {
          if (audioCodec.indexOf("mp4a.40.5") !== -1) {
            audioCodec = "mp4a.40.2";
          } else {
            audioCodec = "mp4a.40.5";
          }
        }
        const audioMetadata = audio.metadata;
        if (audioMetadata && "channelCount" in audioMetadata && (audioMetadata.channelCount || 1) !== 1 && ua.indexOf("firefox") === -1) {
          audioCodec = "mp4a.40.5";
        }
      }
      if (audioCodec && audioCodec.indexOf("mp4a.40.5") !== -1 && ua.indexOf("android") !== -1 && audio.container !== "audio/mpeg") {
        audioCodec = "mp4a.40.2";
        this.log(`Android: force audio codec to ${audioCodec}`);
      }
      if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {
        this.log(`Swapping manifest audio codec "${currentLevel.audioCodec}" for "${audioCodec}"`);
      }
      audio.levelCodec = audioCodec;
      audio.id = "main";
      this.log(`Init audio buffer, container:${audio.container}, codecs[selected/level/parsed]=[${audioCodec || ""}/${currentLevel.audioCodec || ""}/${audio.codec}]`);
    }
    if (video) {
      video.levelCodec = currentLevel.videoCodec;
      video.id = "main";
      this.log(`Init video buffer, container:${video.container}, codecs[level/parsed]=[${currentLevel.videoCodec || ""}/${video.codec}]`);
    }
    if (audiovideo) {
      this.log(`Init audiovideo buffer, container:${audiovideo.container}, codecs[level/parsed]=[${currentLevel.codecs}/${audiovideo.codec}]`);
    }
    this.hls.trigger(Events.BUFFER_CODECS, tracks);
    Object.keys(tracks).forEach((trackName) => {
      const track = tracks[trackName];
      const initSegment = track.initSegment;
      if (initSegment != null && initSegment.byteLength) {
        this.hls.trigger(Events.BUFFER_APPENDING, {
          type: trackName,
          data: initSegment,
          frag,
          part: null,
          chunkMeta,
          parent: frag.type
        });
      }
    });
    this.tickImmediate();
  }
  getMainFwdBufferInfo() {
    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);
  }
  backtrack(frag) {
    this.couldBacktrack = true;
    this.backtrackFragment = frag;
    this.resetTransmuxer();
    this.flushBufferGap(frag);
    this.fragmentTracker.removeFragment(frag);
    this.fragPrevious = null;
    this.nextLoadPosition = frag.start;
    this.state = State.IDLE;
  }
  checkFragmentChanged() {
    const video = this.media;
    let fragPlayingCurrent = null;
    if (video && video.readyState > 1 && video.seeking === false) {
      const currentTime = video.currentTime;
      if (BufferHelper.isBuffered(video, currentTime)) {
        fragPlayingCurrent = this.getAppendedFrag(currentTime);
      } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {
        fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);
      }
      if (fragPlayingCurrent) {
        this.backtrackFragment = null;
        const fragPlaying = this.fragPlaying;
        const fragCurrentLevel = fragPlayingCurrent.level;
        if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {
          this.fragPlaying = fragPlayingCurrent;
          this.hls.trigger(Events.FRAG_CHANGED, {
            frag: fragPlayingCurrent
          });
          if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {
            this.hls.trigger(Events.LEVEL_SWITCHED, {
              level: fragCurrentLevel
            });
          }
        }
      }
    }
  }
  get nextLevel() {
    const frag = this.nextBufferedFrag;
    if (frag) {
      return frag.level;
    }
    return -1;
  }
  get currentFrag() {
    const media = this.media;
    if (media) {
      return this.fragPlaying || this.getAppendedFrag(media.currentTime);
    }
    return null;
  }
  get currentProgramDateTime() {
    const media = this.media;
    if (media) {
      const currentTime = media.currentTime;
      const frag = this.currentFrag;
      if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {
        const epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;
        return new Date(epocMs);
      }
    }
    return null;
  }
  get currentLevel() {
    const frag = this.currentFrag;
    if (frag) {
      return frag.level;
    }
    return -1;
  }
  get nextBufferedFrag() {
    const frag = this.currentFrag;
    if (frag) {
      return this.followingBufferedFrag(frag);
    }
    return null;
  }
  get forceStartLoad() {
    return this._forceStartLoad;
  }
}

class Hls {
  static get version() {
    return "1.5.17";
  }
  static isMSESupported() {
    return isMSESupported();
  }
  static isSupported() {
    return isSupported();
  }
  static getMediaSource() {
    return getMediaSource();
  }
  static get Events() {
    return Events;
  }
  static get ErrorTypes() {
    return ErrorTypes;
  }
  static get ErrorDetails() {
    return ErrorDetails;
  }
  static get DefaultConfig() {
    if (!Hls.defaultConfig) {
      return hlsDefaultConfig;
    }
    return Hls.defaultConfig;
  }
  static set DefaultConfig(defaultConfig) {
    Hls.defaultConfig = defaultConfig;
  }
  constructor(userConfig = {}) {
    this.config = undefined;
    this.userConfig = undefined;
    this.coreComponents = undefined;
    this.networkControllers = undefined;
    this.started = false;
    this._emitter = new EventEmitter;
    this._autoLevelCapping = -1;
    this._maxHdcpLevel = null;
    this.abrController = undefined;
    this.bufferController = undefined;
    this.capLevelController = undefined;
    this.latencyController = undefined;
    this.levelController = undefined;
    this.streamController = undefined;
    this.audioTrackController = undefined;
    this.subtitleTrackController = undefined;
    this.emeController = undefined;
    this.cmcdController = undefined;
    this._media = null;
    this.url = null;
    this.triggeringException = undefined;
    enableLogs(userConfig.debug || false, "Hls instance");
    const config = this.config = mergeConfig(Hls.DefaultConfig, userConfig);
    this.userConfig = userConfig;
    if (config.progressive) {
      enableStreamingMode(config);
    }
    const {
      abrController: ConfigAbrController,
      bufferController: ConfigBufferController,
      capLevelController: ConfigCapLevelController,
      errorController: ConfigErrorController,
      fpsController: ConfigFpsController
    } = config;
    const errorController = new ConfigErrorController(this);
    const abrController = this.abrController = new ConfigAbrController(this);
    const bufferController = this.bufferController = new ConfigBufferController(this);
    const capLevelController = this.capLevelController = new ConfigCapLevelController(this);
    const fpsController = new ConfigFpsController(this);
    const playListLoader = new PlaylistLoader(this);
    const id3TrackController = new ID3TrackController(this);
    const ConfigContentSteeringController = config.contentSteeringController;
    const contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;
    const levelController = this.levelController = new LevelController(this, contentSteering);
    const fragmentTracker = new FragmentTracker(this);
    const keyLoader = new KeyLoader(this.config);
    const streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);
    capLevelController.setStreamController(streamController);
    fpsController.setStreamController(streamController);
    const networkControllers = [playListLoader, levelController, streamController];
    if (contentSteering) {
      networkControllers.splice(1, 0, contentSteering);
    }
    this.networkControllers = networkControllers;
    const coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];
    this.audioTrackController = this.createController(config.audioTrackController, networkControllers);
    const AudioStreamControllerClass = config.audioStreamController;
    if (AudioStreamControllerClass) {
      networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));
    }
    this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);
    const SubtitleStreamControllerClass = config.subtitleStreamController;
    if (SubtitleStreamControllerClass) {
      networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));
    }
    this.createController(config.timelineController, coreComponents);
    keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);
    this.cmcdController = this.createController(config.cmcdController, coreComponents);
    this.latencyController = this.createController(LatencyController, coreComponents);
    this.coreComponents = coreComponents;
    networkControllers.push(errorController);
    const onErrorOut = errorController.onErrorOut;
    if (typeof onErrorOut === "function") {
      this.on(Events.ERROR, onErrorOut, errorController);
    }
  }
  createController(ControllerClass, components) {
    if (ControllerClass) {
      const controllerInstance = new ControllerClass(this);
      if (components) {
        components.push(controllerInstance);
      }
      return controllerInstance;
    }
    return null;
  }
  on(event, listener, context = this) {
    this._emitter.on(event, listener, context);
  }
  once(event, listener, context = this) {
    this._emitter.once(event, listener, context);
  }
  removeAllListeners(event) {
    this._emitter.removeAllListeners(event);
  }
  off(event, listener, context = this, once) {
    this._emitter.off(event, listener, context, once);
  }
  listeners(event) {
    return this._emitter.listeners(event);
  }
  emit(event, name, eventObject) {
    return this._emitter.emit(event, name, eventObject);
  }
  trigger(event, eventObject) {
    if (this.config.debug) {
      return this.emit(event, event, eventObject);
    } else {
      try {
        return this.emit(event, event, eventObject);
      } catch (error) {
        logger.error("An internal error happened while handling event " + event + '. Error message: "' + error.message + '". Here is a stacktrace:', error);
        if (!this.triggeringException) {
          this.triggeringException = true;
          const fatal = event === Events.ERROR;
          this.trigger(Events.ERROR, {
            type: ErrorTypes.OTHER_ERROR,
            details: ErrorDetails.INTERNAL_EXCEPTION,
            fatal,
            event,
            error
          });
          this.triggeringException = false;
        }
      }
    }
    return false;
  }
  listenerCount(event) {
    return this._emitter.listenerCount(event);
  }
  destroy() {
    logger.log("destroy");
    this.trigger(Events.DESTROYING, undefined);
    this.detachMedia();
    this.removeAllListeners();
    this._autoLevelCapping = -1;
    this.url = null;
    this.networkControllers.forEach((component) => component.destroy());
    this.networkControllers.length = 0;
    this.coreComponents.forEach((component) => component.destroy());
    this.coreComponents.length = 0;
    const config = this.config;
    config.xhrSetup = config.fetchSetup = undefined;
    this.userConfig = null;
  }
  attachMedia(media) {
    logger.log("attachMedia");
    this._media = media;
    this.trigger(Events.MEDIA_ATTACHING, {
      media
    });
  }
  detachMedia() {
    logger.log("detachMedia");
    this.trigger(Events.MEDIA_DETACHING, undefined);
    this._media = null;
  }
  loadSource(url) {
    this.stopLoad();
    const media = this.media;
    const loadedSource = this.url;
    const loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {
      alwaysNormalize: true
    });
    this._autoLevelCapping = -1;
    this._maxHdcpLevel = null;
    logger.log(`loadSource:${loadingSource}`);
    if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {
      this.detachMedia();
      this.attachMedia(media);
    }
    this.trigger(Events.MANIFEST_LOADING, {
      url
    });
  }
  startLoad(startPosition = -1) {
    logger.log(`startLoad(${startPosition})`);
    this.started = true;
    this.networkControllers.forEach((controller) => {
      controller.startLoad(startPosition);
    });
  }
  stopLoad() {
    logger.log("stopLoad");
    this.started = false;
    this.networkControllers.forEach((controller) => {
      controller.stopLoad();
    });
  }
  resumeBuffering() {
    if (this.started) {
      this.networkControllers.forEach((controller) => {
        if ("fragmentLoader" in controller) {
          controller.startLoad(-1);
        }
      });
    }
  }
  pauseBuffering() {
    this.networkControllers.forEach((controller) => {
      if ("fragmentLoader" in controller) {
        controller.stopLoad();
      }
    });
  }
  swapAudioCodec() {
    logger.log("swapAudioCodec");
    this.streamController.swapAudioCodec();
  }
  recoverMediaError() {
    logger.log("recoverMediaError");
    const media = this._media;
    this.detachMedia();
    if (media) {
      this.attachMedia(media);
    }
  }
  removeLevel(levelIndex) {
    this.levelController.removeLevel(levelIndex);
  }
  get levels() {
    const levels = this.levelController.levels;
    return levels ? levels : [];
  }
  get currentLevel() {
    return this.streamController.currentLevel;
  }
  set currentLevel(newLevel) {
    logger.log(`set currentLevel:${newLevel}`);
    this.levelController.manualLevel = newLevel;
    this.streamController.immediateLevelSwitch();
  }
  get nextLevel() {
    return this.streamController.nextLevel;
  }
  set nextLevel(newLevel) {
    logger.log(`set nextLevel:${newLevel}`);
    this.levelController.manualLevel = newLevel;
    this.streamController.nextLevelSwitch();
  }
  get loadLevel() {
    return this.levelController.level;
  }
  set loadLevel(newLevel) {
    logger.log(`set loadLevel:${newLevel}`);
    this.levelController.manualLevel = newLevel;
  }
  get nextLoadLevel() {
    return this.levelController.nextLoadLevel;
  }
  set nextLoadLevel(level) {
    this.levelController.nextLoadLevel = level;
  }
  get firstLevel() {
    return Math.max(this.levelController.firstLevel, this.minAutoLevel);
  }
  set firstLevel(newLevel) {
    logger.log(`set firstLevel:${newLevel}`);
    this.levelController.firstLevel = newLevel;
  }
  get startLevel() {
    const startLevel = this.levelController.startLevel;
    if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {
      return this.abrController.forcedAutoLevel;
    }
    return startLevel;
  }
  set startLevel(newLevel) {
    logger.log(`set startLevel:${newLevel}`);
    if (newLevel !== -1) {
      newLevel = Math.max(newLevel, this.minAutoLevel);
    }
    this.levelController.startLevel = newLevel;
  }
  get capLevelToPlayerSize() {
    return this.config.capLevelToPlayerSize;
  }
  set capLevelToPlayerSize(shouldStartCapping) {
    const newCapLevelToPlayerSize = !!shouldStartCapping;
    if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {
      if (newCapLevelToPlayerSize) {
        this.capLevelController.startCapping();
      } else {
        this.capLevelController.stopCapping();
        this.autoLevelCapping = -1;
        this.streamController.nextLevelSwitch();
      }
      this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;
    }
  }
  get autoLevelCapping() {
    return this._autoLevelCapping;
  }
  get bandwidthEstimate() {
    const {
      bwEstimator
    } = this.abrController;
    if (!bwEstimator) {
      return NaN;
    }
    return bwEstimator.getEstimate();
  }
  set bandwidthEstimate(abrEwmaDefaultEstimate) {
    this.abrController.resetEstimator(abrEwmaDefaultEstimate);
  }
  get ttfbEstimate() {
    const {
      bwEstimator
    } = this.abrController;
    if (!bwEstimator) {
      return NaN;
    }
    return bwEstimator.getEstimateTTFB();
  }
  set autoLevelCapping(newLevel) {
    if (this._autoLevelCapping !== newLevel) {
      logger.log(`set autoLevelCapping:${newLevel}`);
      this._autoLevelCapping = newLevel;
      this.levelController.checkMaxAutoUpdated();
    }
  }
  get maxHdcpLevel() {
    return this._maxHdcpLevel;
  }
  set maxHdcpLevel(value) {
    if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {
      this._maxHdcpLevel = value;
      this.levelController.checkMaxAutoUpdated();
    }
  }
  get autoLevelEnabled() {
    return this.levelController.manualLevel === -1;
  }
  get manualLevel() {
    return this.levelController.manualLevel;
  }
  get minAutoLevel() {
    const {
      levels,
      config: {
        minAutoBitrate
      }
    } = this;
    if (!levels)
      return 0;
    const len = levels.length;
    for (let i = 0;i < len; i++) {
      if (levels[i].maxBitrate >= minAutoBitrate) {
        return i;
      }
    }
    return 0;
  }
  get maxAutoLevel() {
    const {
      levels,
      autoLevelCapping,
      maxHdcpLevel
    } = this;
    let maxAutoLevel;
    if (autoLevelCapping === -1 && levels != null && levels.length) {
      maxAutoLevel = levels.length - 1;
    } else {
      maxAutoLevel = autoLevelCapping;
    }
    if (maxHdcpLevel) {
      for (let i = maxAutoLevel;i--; ) {
        const hdcpLevel = levels[i].attrs["HDCP-LEVEL"];
        if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {
          return i;
        }
      }
    }
    return maxAutoLevel;
  }
  get firstAutoLevel() {
    return this.abrController.firstAutoLevel;
  }
  get nextAutoLevel() {
    return this.abrController.nextAutoLevel;
  }
  set nextAutoLevel(nextLevel) {
    this.abrController.nextAutoLevel = nextLevel;
  }
  get playingDate() {
    return this.streamController.currentProgramDateTime;
  }
  get mainForwardBufferInfo() {
    return this.streamController.getMainFwdBufferInfo();
  }
  setAudioOption(audioOption) {
    var _this$audioTrackContr;
    return (_this$audioTrackContr = this.audioTrackController) == null ? undefined : _this$audioTrackContr.setAudioOption(audioOption);
  }
  setSubtitleOption(subtitleOption) {
    var _this$subtitleTrackCo;
    (_this$subtitleTrackCo = this.subtitleTrackController) == null || _this$subtitleTrackCo.setSubtitleOption(subtitleOption);
    return null;
  }
  get allAudioTracks() {
    const audioTrackController = this.audioTrackController;
    return audioTrackController ? audioTrackController.allAudioTracks : [];
  }
  get audioTracks() {
    const audioTrackController = this.audioTrackController;
    return audioTrackController ? audioTrackController.audioTracks : [];
  }
  get audioTrack() {
    const audioTrackController = this.audioTrackController;
    return audioTrackController ? audioTrackController.audioTrack : -1;
  }
  set audioTrack(audioTrackId) {
    const audioTrackController = this.audioTrackController;
    if (audioTrackController) {
      audioTrackController.audioTrack = audioTrackId;
    }
  }
  get allSubtitleTracks() {
    const subtitleTrackController = this.subtitleTrackController;
    return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];
  }
  get subtitleTracks() {
    const subtitleTrackController = this.subtitleTrackController;
    return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
  }
  get subtitleTrack() {
    const subtitleTrackController = this.subtitleTrackController;
    return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
  }
  get media() {
    return this._media;
  }
  set subtitleTrack(subtitleTrackId) {
    const subtitleTrackController = this.subtitleTrackController;
    if (subtitleTrackController) {
      subtitleTrackController.subtitleTrack = subtitleTrackId;
    }
  }
  get subtitleDisplay() {
    const subtitleTrackController = this.subtitleTrackController;
    return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
  }
  set subtitleDisplay(value) {
    const subtitleTrackController = this.subtitleTrackController;
    if (subtitleTrackController) {
      subtitleTrackController.subtitleDisplay = value;
    }
  }
  get lowLatencyMode() {
    return this.config.lowLatencyMode;
  }
  set lowLatencyMode(mode) {
    this.config.lowLatencyMode = mode;
  }
  get liveSyncPosition() {
    return this.latencyController.liveSyncPosition;
  }
  get latency() {
    return this.latencyController.latency;
  }
  get maxLatency() {
    return this.latencyController.maxLatency;
  }
  get targetLatency() {
    return this.latencyController.targetLatency;
  }
  get drift() {
    return this.latencyController.drift;
  }
  get forceStartLoad() {
    return this.streamController.forceStartLoad;
  }
}
Hls.defaultConfig = undefined;

// src/client/EventBus.ts
class EventBus {
  _subs;
  constructor() {
    this._subs = new Map;
  }
  on(eventName, subId, func) {
    this._subs.get(eventName)?.set(subId, { eventName, subId, type: 1 /* Recur */, func });
  }
  once(eventName, subId, func) {
    this._subs.get(eventName)?.set(subId, { eventName, subId, type: 0 /* Once */, func });
  }
  off(eventName, subId) {
    this._subs.get(eventName)?.delete(subId);
  }
  clearEvent(eventName) {
    this._subs.delete(eventName);
  }
  clearAll() {
    this._subs.clear();
  }
  emit(eventName, args) {
    this._subs.get(eventName)?.forEach((v2) => v2.func(args));
  }
}
var eventBus = new EventBus;

// src/client/AudioLiveStream.ts
class AudioLiveStream {
  _state = 0 /* closed */;
  _streamUrl;
  _fadeTime;
  _supported;
  _streamBackend;
  _audioElement;
  _audioCtx;
  _gainNode;
  _streamSrc;
  _hls;
  fadeIn() {
    this._gainNode.gain.setValueAtTime(0, this._audioCtx.currentTime);
    this._gainNode.gain.linearRampToValueAtTime(1, this._audioCtx.currentTime + this._fadeTime / 1000);
  }
  fadeOut() {
    this._gainNode.gain.setValueAtTime(this._gainNode.gain.value, this._audioCtx.currentTime);
    this._gainNode.gain.linearRampToValueAtTime(0, this._audioCtx.currentTime + this._fadeTime / 1000);
  }
  async free(event_to_emit) {
    this._hls?.destroy();
    this._audioElement.src = "";
    this._audioCtx?.close().then(() => {
      this._streamSrc = null;
      this._audioCtx = null;
      this._gainNode = null;
      this._streamSrc = null;
      this._state = 0 /* closed */;
      console.log("stream closed");
      if (event_to_emit) {
        eventBus.emit(get_event_name("stream", event_to_emit), {});
      }
    }).catch((error) => {
      console.error("error trying to free stream");
    });
  }
  constructor(stream_url, fade_time = 4000) {
    this._hls = null;
    this._audioCtx = null;
    this._gainNode = null;
    this._streamSrc = null;
    this._streamUrl = stream_url;
    this._fadeTime = fade_time;
    this._audioElement = new Audio;
    this._audioElement.setAttribute("id", "audio_element");
    this._audioElement.hidden = true;
    document.body.append(this._audioElement);
    this._supported = Hls.isSupported() || this._audioElement.canPlayType("application/vnd.apple.mpegurl") === "probably";
    if (this._supported) {
      this._streamBackend = Hls.isSupported() ? "hls" : "mext";
    } else {
      this._streamBackend = "none";
    }
  }
  setstreamUrl(url) {
    this._streamUrl = url;
  }
  stream_supported() {
    return this._supported;
  }
  open_stream() {
    if (this._supported && this._state == 0 /* closed */) {
      this._audioCtx = new AudioContext;
      this._gainNode = this._audioCtx.createGain();
      this._streamSrc = this._audioCtx.createMediaElementSource(this._audioElement);
      this._streamSrc.connect(this._gainNode);
      this._gainNode.connect(this._audioCtx.destination);
      if (this._streamBackend === "hls") {
        this._hls = new Hls({ maxBufferHole: 2, debug: true });
        try {
          this._hls.loadSource(this._streamUrl);
          this._hls.attachMedia(this._audioElement);
        } catch (error) {
          console.error(error);
          this.free("cannot_load");
          return;
        }
        this._audioElement.muted = true;
        this._audioElement.play().then(() => {
          console.log("stream is playing");
          this._state = 2 /* playing */;
          this._audioElement.muted = false;
          this.fadeIn();
        }).catch((err) => {
          this._audioElement.muted = false;
          console.log("autoplay failed");
          this.free("autoplay_failed");
          return;
        });
        this._hls.on(Events.ERROR, (event, data) => {
          const { type, details, fatal } = data;
          console.log("Error Type:", type);
          console.log("Error Details:", details);
          console.log("Is Fatal:", fatal);
          if (fatal) {
            switch (type) {
              case ErrorTypes.NETWORK_ERROR:
                try {
                  this._hls.startLoad();
                } catch (error) {
                  console.error(error);
                  this.free("network_error");
                }
                break;
              case ErrorTypes.MEDIA_ERROR:
                try {
                  this._hls.recoverMediaError();
                } catch (error) {
                  console.error(error);
                  this.free("media_error");
                }
                break;
              default:
                console.error(data.type);
                this.free("fatal_error");
                break;
            }
          }
        });
      }
      if (this._streamBackend === "mext") {
        try {
          console.log("mext!");
          this._audioElement.src = this._streamUrl;
        } catch (error) {
          console.log("cannot load");
          this.free("cannot_load");
          return;
        }
        this._audioElement.muted = true;
        this._state = 1 /* open */;
        this._audioElement.play().then(() => {
          console.log("stream is playing");
          this._state = 2 /* playing */;
          this._audioElement.muted = false;
          this.fadeIn();
        }).catch((err) => {
          this._audioElement.muted = false;
          console.log("autoplay failed");
          this.free("autoplay_failed");
        });
      }
    } else {
      console.error("unexpected call to AudioLiveStream");
    }
  }
  close_stream() {
    if (this._state == 1 /* open */) {
      console.log("stream is closing");
      this.free("stream_closed");
    }
    if (this._state == 2 /* playing */) {
      setTimeout(() => {
        console.log("stream is closing");
        this.free("stream_closed");
      }, this._fadeTime);
    }
  }
  kill_stream() {
    if (this._state == 1 /* open */ || this._state == 2 /* playing */) {
      this.free("stream_killed");
    }
  }
  getState() {
    return this._state;
  }
  mute() {
    if (this._state == 2 /* playing */) {
      this._audioElement.muted = true;
    }
  }
  unmute() {
    if (this._state == 2 /* playing */) {
      this._audioElement.muted = false;
    }
  }
}

// src/client/client.ts
var inside_map_pos = [65.8725, 23.3226];
var inside_perim_pos = [65.9297, 23.795];
var test = location.pathname == "/tidstangsel/test";
var nonce = getNonce();
var audioStreamer = new AudioLiveStream("/tidstangsel/stream/tidsstangsel.m3u8", 4000);
var glmap = null;
var geotracker = null;
var prev_pos = map_default_center;
var prev_pos_within_perim = false;
function withinMapBounds(pos) {
  return booleanPointInPolygon(point(pos), bboxPolygon(map_bounds_turf));
}
function withinPerim(pos) {
  return booleanPointInPolygon(point(pos), polygon([perim_coords_turf]));
}
console.log(location.origin + "/stream/tidsstangsel.m3u8");
console.log(withinMapBounds(inside_map_pos));
console.log(withinPerim(inside_perim_pos));
function try_get_geoposition(onsuccess) {
  navigator.geolocation.getCurrentPosition((geopos) => onsuccess(geopos), (error) => {
    switch (error.code) {
      case error.PERMISSION_DENIED:
        alert("Åtkomst till geoposition nekad! Aktivera åtkomst, klicka på knappen för att försöka igen!");
        break;
      case error.POSITION_UNAVAILABLE:
        alert("Geoposition ej tillgänglig, klicka på knappen för att försöka igen!");
        break;
      case error.TIMEOUT:
        alert("Geoposition ej tillgänglig pga: tidsgärns för anrop har utgått, Kontrollera ditt nätverk och försök igen!");
        break;
      default:
        alert("Geoposition ej tillgänglig pga okänt fel, klicka på knappen för att försöka igen!");
        break;
    }
    const retryBtn = document.createElement("button");
    retryBtn.textContent = "Try Again";
    document.body.insertBefore(retryBtn, document.body.firstChild);
    retryBtn.addEventListener("click", function() {
      retryBtn.remove();
      try_get_geoposition(onsuccess);
    });
  }, { enableHighAccuracy: true, maximumAge: 0, timeout: 1e4 });
}
function activateSession(onsuccess, onerror) {
  fetch("/tidstangsel/activatesession/" + nonce, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json"
    },
    credentials: "same-origin"
  }).then((response) => {
    if (response.status === 200) {
      console.log("activate session success");
      onsuccess();
    } else {
      onerror(response);
    }
  }).catch((error) => {
    onerror(error);
  });
}
function reportPerimEnter(onsuccess, onerror) {
  fetch("/tidstangsel/enter/", {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json"
    },
    credentials: "same-origin"
  }).then((response) => {
    if (response.status === 200) {
      console.log("report enter success");
      onsuccess();
    } else {
      console.log("report enter error");
      onerror(response);
    }
  }).catch((error) => {
    onerror(error);
  });
}
function GLMapInit() {
  if (!glmap) {
    glmap = new import_maplibre_gl.Map(map_description);
    glmap.on("load", () => {
      geotracker = new import_maplibre_gl.GeolocateControl({
        positionOptions: {
          enableHighAccuracy: true,
          timeout: 1e4,
          maximumAge: 0
        },
        trackUserLocation: true,
        showUserLocation: true
      });
      glmap.addControl(geotracker);
      geotracker.on("userlocationlostfocus", () => eventBus.emit(get_event_name("geopps", "lostfocus"), {}));
      geotracker.on("userlocationfocus", () => eventBus.emit(get_event_name("geopos", "focus"), {}));
      geotracker.on("geolocate", (geopos) => eventBus.emit(get_event_name("geopos", "update"), geopos));
      geotracker.on("error", (err) => eventBus.emit(get_event_name("geopos", "error"), err));
      geotracker.on("outofmaxbounds", () => eventBus.emit(get_event_name("geopos", "outofbounds"), {}));
      eventBus.emit(get_event_name("geomap", "ready"), {});
    });
  }
}
function HandleStreamError(usrmsg) {
  document.getElementById("usrmsg").textContent = usrmsg;
  const retryBtn = document.createElement("button");
  retryBtn.textContent = "Försök öppna ljudström";
  document.body.insertBefore(retryBtn, document.body.firstChild);
  retryBtn.addEventListener("click", function() {
    document.getElementById("usrmsg").textContent = "";
    audioStreamer.open_stream();
    retryBtn.remove();
  });
}
function HandleOutOfBounds() {
  if (glmap) {
    glmap.removeControl(geotracker);
    glmap.remove();
    eventBus.clearAll();
    audioStreamer?.kill_stream();
    glmap = null;
    geotracker = null;
  }
  document.getElementById("map")?.remove();
  document.getElementById("tidstangsel_script").removeAttribute("data-nonce");
  document.body.innerHTML = `
    <div>
      <p id='usermsg'>Du befinner dig för långt bortom tidstängslet, ladda om sidan när du befinner dig på kartan</p>
    </div>
    <img id='static_map' src='/assets/tidstangsel_static_map.png' width='512px' height='512px'></img>
  `;
}
function HandleEvents() {
  eventBus.on(get_event_name("stream", "network_error"), "main", (_) => {
    HandleStreamError("ljudströmmen avslutade pga nätverksfel, kontrollera din internet uppkoppling, försök sedan öppna ljudströmmen igen");
  });
  eventBus.on(get_event_name("stream", "media_error"), "main", (_) => {
    HandleStreamError("ljudströmmen avslutades pga okänt medialäsningsfel, tryck på knappen för att försöka öppna ljudströmmen igen");
  });
  eventBus.on(get_event_name("stream", "fatal_error"), "main", (_) => {
    HandleStreamError("ljudströmmen avslutades pga okänt fel, tryck på knappen för att försöka öppna ljudströmmen igen");
  });
  eventBus.on(get_event_name("stream", "autoplay_failed"), "main", (_) => {
    HandleStreamError("ljudström kunde ej öppnas automatiskt tryck på knappen för att öppna ljudström");
  });
  eventBus.on(get_event_name("stream", "cannot_load"), "main", (_) => {
    console.log("stream could not load");
  });
  eventBus.on(get_event_name("geopos", "lostfocus"), "main", () => {
    alert("Förlorade kontakten till platstjänst, klicka på knappen för att försöka igen");
    const retryBtn = document.createElement("button");
    retryBtn.textContent = "Återupprätta kontakt med plaststjänst";
    document.body.insertBefore(retryBtn, document.body.firstChild);
    retryBtn.addEventListener("click", function() {
      retryBtn.remove();
      try_get_geoposition((geopos) => eventBus.emit(get_event_name("geopos", "update"), { geopos }));
    });
  });
  eventBus.on(get_event_name("geomap", "ready"), "main", () => {
    eventBus.on(get_event_name("geopos", "outofbounds"), "main", () => HandleOutOfBounds());
    eventBus.on(get_event_name("geopos", "update"), "main", (geopos) => {
      const new_pos = [geopos.coords.longitude, geopos.coords.latitude];
      if (exceedDistance(prev_pos, new_pos, update_dist)) {
        const inside = pointInPolygon2(new_pos, perim_coords);
        const perim_enter = !prev_pos_within_perim && inside;
        const perim_exit = prev_pos_within_perim && !inside;
        if (perim_enter) {
          reportPerimEnter(() => {
            audioStreamer.open_stream();
          }, (error) => console.error(error));
        }
        if (perim_exit) {
          reportPerimEnter(() => {
            audioStreamer.close_stream();
          }, (error) => console.error(error));
        }
      }
    });
    eventBus.on(get_event_name("geopos", "error"), "main", (error) => {
      switch (error.code) {
        case error.PERMISSION_DENIED:
          alert("Åtkomst till geoposition nekad! Aktivera åtkomst, klicka på knappen för att försöka igen!");
          break;
        case error.POSITION_UNAVAILABLE:
          alert("Geoposition ej tillgänglig, klicka på knappen för att försöka igen!");
          break;
        case error.TIMEOUT:
          alert("Geoposition ej tillgänglig pga: tidsgärns för anrop har utgått, Kontrollera ditt nätverk och försök igen!");
          break;
        default:
          alert("Geoposition ej tillgänglig pga okänt fel, klicka på knappen för att försöka igen!");
          break;
      }
      const retryBtn = document.createElement("button");
      retryBtn.textContent = "Try Again";
      document.body.insertBefore(retryBtn, document.body.firstChild);
      retryBtn.addEventListener("click", function() {
        retryBtn.remove();
        try_get_geoposition((geopos) => eventBus.emit(get_event_name("geopos", "update"), { geopos }));
      });
    });
  });
}
window.addEventListener("load", () => {
  if (navigator.geolocation && audioStreamer.stream_supported()) {
    try_get_geoposition((geopos) => {
      if (withinMapBounds([geopos.coords.latitude, geopos.coords.longitude])) {
        console.log("inside map!");
        prev_pos = [geopos.coords.longitude, geopos.coords.latitude];
        prev_pos_within_perim = withinPerim([prev_pos[1], prev_pos[0]]);
        activateSession(() => {
          console.log("session activated!");
          if (prev_pos_within_perim) {
            console.log("perim enter!");
            reportPerimEnter(() => {
              const start_stream_btn = document.createElement("button");
              start_stream_btn.textContent = "starta ljudström";
              start_stream_btn.setAttribute("id", "start_stream_btn");
              document.body.insertBefore(start_stream_btn, document.body.firstChild);
              start_stream_btn.addEventListener("click", function() {
                start_stream_btn.remove();
                console.log("opening stream");
                audioStreamer.open_stream();
              });
            }, (error) => {
              console.log("cant open stream");
              console.log(error);
            });
          }
          HandleEvents();
          GLMapInit();
          setInterval(() => {
            navigator.sendBeacon("/tidstangsel/beacon/");
          }, 60000);
        }, (error) => {
          console.error(error);
        });
      } else {
        console.log("out of bounds");
        HandleOutOfBounds();
      }
    });
  } else {
    document.getElementById("tidstangsel_script").removeAttribute("data-nonce");
    document.getElementById("usrmsg").textContent = "din webläsare stöds ej";
  }
});
