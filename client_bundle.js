var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);

// lib/maplibre-gl.js
var require_maplibre_gl = __commonJS((exports, module) => {
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.maplibregl = factory());
  })(exports, function() {
    var maplibregl = {};
    var modules = {};
    function define2(moduleName, _dependencies, moduleFactory) {
      modules[moduleName] = moduleFactory;
      if (moduleName !== "index") {
        return;
      }
      var workerBundleString = "var sharedModule = {}; (" + modules.shared + ")(sharedModule); (" + modules.worker + ")(sharedModule);";
      var sharedModule = {};
      modules.shared(sharedModule);
      modules.index(maplibregl, sharedModule);
      if (typeof window !== "undefined") {
        maplibregl.setWorkerUrl(window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" })));
      }
      return maplibregl;
    }
    define2("shared", ["exports"], function(t) {
      function e(t2, e2, r2, n2) {
        return new (r2 || (r2 = Promise))(function(i2, s2) {
          function a2(t3) {
            try {
              l2(n2.next(t3));
            } catch (t4) {
              s2(t4);
            }
          }
          function o2(t3) {
            try {
              l2(n2.throw(t3));
            } catch (t4) {
              s2(t4);
            }
          }
          function l2(t3) {
            var e3;
            t3.done ? i2(t3.value) : (e3 = t3.value, e3 instanceof r2 ? e3 : new r2(function(t4) {
              t4(e3);
            })).then(a2, o2);
          }
          l2((n2 = n2.apply(t2, e2 || [])).next());
        });
      }
      function r(t2) {
        return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
      }
      typeof SuppressedError == "function" && SuppressedError;
      var n = i;
      function i(t2, e2) {
        this.x = t2, this.y = e2;
      }
      i.prototype = {
        clone: function() {
          return new i(this.x, this.y);
        },
        add: function(t2) {
          return this.clone()._add(t2);
        },
        sub: function(t2) {
          return this.clone()._sub(t2);
        },
        multByPoint: function(t2) {
          return this.clone()._multByPoint(t2);
        },
        divByPoint: function(t2) {
          return this.clone()._divByPoint(t2);
        },
        mult: function(t2) {
          return this.clone()._mult(t2);
        },
        div: function(t2) {
          return this.clone()._div(t2);
        },
        rotate: function(t2) {
          return this.clone()._rotate(t2);
        },
        rotateAround: function(t2, e2) {
          return this.clone()._rotateAround(t2, e2);
        },
        matMult: function(t2) {
          return this.clone()._matMult(t2);
        },
        unit: function() {
          return this.clone()._unit();
        },
        perp: function() {
          return this.clone()._perp();
        },
        round: function() {
          return this.clone()._round();
        },
        mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        equals: function(t2) {
          return this.x === t2.x && this.y === t2.y;
        },
        dist: function(t2) {
          return Math.sqrt(this.distSqr(t2));
        },
        distSqr: function(t2) {
          var e2 = t2.x - this.x, r2 = t2.y - this.y;
          return e2 * e2 + r2 * r2;
        },
        angle: function() {
          return Math.atan2(this.y, this.x);
        },
        angleTo: function(t2) {
          return Math.atan2(this.y - t2.y, this.x - t2.x);
        },
        angleWith: function(t2) {
          return this.angleWithSep(t2.x, t2.y);
        },
        angleWithSep: function(t2, e2) {
          return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
        },
        _matMult: function(t2) {
          var e2 = t2[2] * this.x + t2[3] * this.y;
          return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
        },
        _add: function(t2) {
          return this.x += t2.x, this.y += t2.y, this;
        },
        _sub: function(t2) {
          return this.x -= t2.x, this.y -= t2.y, this;
        },
        _mult: function(t2) {
          return this.x *= t2, this.y *= t2, this;
        },
        _div: function(t2) {
          return this.x /= t2, this.y /= t2, this;
        },
        _multByPoint: function(t2) {
          return this.x *= t2.x, this.y *= t2.y, this;
        },
        _divByPoint: function(t2) {
          return this.x /= t2.x, this.y /= t2.y, this;
        },
        _unit: function() {
          return this._div(this.mag()), this;
        },
        _perp: function() {
          var t2 = this.y;
          return this.y = this.x, this.x = -t2, this;
        },
        _rotate: function(t2) {
          var e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e2 * this.y;
          return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
        },
        _rotateAround: function(t2, e2) {
          var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
          return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
        },
        _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
      }, i.convert = function(t2) {
        return t2 instanceof i ? t2 : Array.isArray(t2) ? new i(t2[0], t2[1]) : t2;
      };
      var s = r(n), a = o;
      function o(t2, e2, r2, n2) {
        this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r2, this.p2y = n2;
      }
      o.prototype = {
        sampleCurveX: function(t2) {
          return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
        },
        sampleCurveY: function(t2) {
          return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
        },
        sampleCurveDerivativeX: function(t2) {
          return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
        },
        solveCurveX: function(t2, e2) {
          if (e2 === undefined && (e2 = 0.000001), t2 < 0)
            return 0;
          if (t2 > 1)
            return 1;
          for (var r2 = t2, n2 = 0;n2 < 8; n2++) {
            var i2 = this.sampleCurveX(r2) - t2;
            if (Math.abs(i2) < e2)
              return r2;
            var s2 = this.sampleCurveDerivativeX(r2);
            if (Math.abs(s2) < 0.000001)
              break;
            r2 -= i2 / s2;
          }
          var a2 = 0, o2 = 1;
          for (r2 = t2, n2 = 0;n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e2)); n2++)
            t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
          return r2;
        },
        solve: function(t2, e2) {
          return this.sampleCurveY(this.solveCurveX(t2, e2));
        }
      };
      var l = r(a);
      let u, c;
      function h() {
        return u == null && (u = typeof OffscreenCanvas != "undefined" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), u;
      }
      function p() {
        if (c == null && (c = false, h())) {
          const t2 = 5, e2 = new OffscreenCanvas(t2, t2).getContext("2d", { willReadFrequently: true });
          if (e2) {
            for (let r3 = 0;r3 < t2 * t2; r3++) {
              const n2 = 4 * r3;
              e2.fillStyle = `rgb(${n2},${n2 + 1},${n2 + 2})`, e2.fillRect(r3 % t2, Math.floor(r3 / t2), 1, 1);
            }
            const r2 = e2.getImageData(0, 0, t2, t2).data;
            for (let e3 = 0;e3 < t2 * t2 * 4; e3++)
              if (e3 % 4 != 3 && r2[e3] !== e3) {
                c = true;
                break;
              }
          }
        }
        return c || false;
      }
      function f(t2, e2, r2, n2) {
        const i2 = new l(t2, e2, r2, n2);
        return (t3) => i2.solve(t3);
      }
      const d = f(0.25, 0.1, 0.25, 1);
      function y(t2, e2, r2) {
        return Math.min(r2, Math.max(e2, t2));
      }
      function m(t2, e2, r2) {
        const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
        return i2 === e2 ? r2 : i2;
      }
      function g(t2, ...e2) {
        for (const r2 of e2)
          for (const e3 in r2)
            t2[e3] = r2[e3];
        return t2;
      }
      let x = 1;
      function v(t2, e2, r2) {
        const n2 = {};
        for (const r3 in t2)
          n2[r3] = e2.call(this, t2[r3], r3, t2);
        return n2;
      }
      function b(t2, e2, r2) {
        const n2 = {};
        for (const r3 in t2)
          e2.call(this, t2[r3], r3, t2) && (n2[r3] = t2[r3]);
        return n2;
      }
      function w(t2) {
        return Array.isArray(t2) ? t2.map(w) : typeof t2 == "object" && t2 ? v(t2, w) : t2;
      }
      const _ = {};
      function A(t2) {
        _[t2] || (typeof console != "undefined" && console.warn(t2), _[t2] = true);
      }
      function S(t2, e2, r2) {
        return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
      }
      function k(t2) {
        return typeof WorkerGlobalScope != "undefined" && t2 !== undefined && t2 instanceof WorkerGlobalScope;
      }
      let M = null;
      function I(t2) {
        return typeof ImageBitmap != "undefined" && t2 instanceof ImageBitmap;
      }
      const z = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function P(t2, r2, n2, i2, s2) {
        return e(this, undefined, undefined, function* () {
          if (typeof VideoFrame == "undefined")
            throw new Error("VideoFrame not supported");
          const e2 = new VideoFrame(t2, { timestamp: 0 });
          try {
            const a2 = e2 == null ? undefined : e2.format;
            if (!a2 || !a2.startsWith("BGR") && !a2.startsWith("RGB"))
              throw new Error(`Unrecognized format ${a2}`);
            const o2 = a2.startsWith("BGR"), l2 = new Uint8ClampedArray(i2 * s2 * 4);
            if (yield e2.copyTo(l2, function(t3, e3, r3, n3, i3) {
              const s3 = 4 * Math.max(-e3, 0), a3 = (Math.max(0, r3) - r3) * n3 * 4 + s3, o3 = 4 * n3, l3 = Math.max(0, e3), u2 = Math.max(0, r3);
              return {
                rect: {
                  x: l3,
                  y: u2,
                  width: Math.min(t3.width, e3 + n3) - l3,
                  height: Math.min(t3.height, r3 + i3) - u2
                },
                layout: [{ offset: a3, stride: o3 }]
              };
            }(t2, r2, n2, i2, s2)), o2)
              for (let t3 = 0;t3 < l2.length; t3 += 4) {
                const e3 = l2[t3];
                l2[t3] = l2[t3 + 2], l2[t3 + 2] = e3;
              }
            return l2;
          } finally {
            e2.close();
          }
        });
      }
      let C, B;
      const V = "AbortError";
      function E() {
        return new Error(V);
      }
      const F = {
        MAX_PARALLEL_IMAGE_REQUESTS: 16,
        MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
        MAX_TILE_CACHE_ZOOM_LEVELS: 5,
        REGISTERED_PROTOCOLS: {},
        WORKER_URL: ""
      };
      function T(t2) {
        return F.REGISTERED_PROTOCOLS[t2.substring(0, t2.indexOf("://"))];
      }
      const $ = "global-dispatcher";

      class L extends Error {
        constructor(t2, e2, r2, n2) {
          super(`AJAXError: ${e2} (${t2}): ${r2}`), this.status = t2, this.statusText = e2, this.url = r2, this.body = n2;
        }
      }
      const D = () => k(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, O = function(t2, r2) {
        if (/:\/\//.test(t2.url) && !/^https?:|^file:/.test(t2.url)) {
          const e2 = T(t2.url);
          if (e2)
            return e2(t2, r2);
          if (k(self) && self.worker && self.worker.actor)
            return self.worker.actor.sendAsync({ type: "GR", data: t2, targetMapId: $ }, r2);
        }
        if (!(/^file:/.test(n2 = t2.url) || /^file:/.test(D()) && !/^\w+:/.test(n2))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
            return function(t3, r3) {
              return e(this, undefined, undefined, function* () {
                const e2 = new Request(t3.url, {
                  method: t3.method || "GET",
                  body: t3.body,
                  credentials: t3.credentials,
                  headers: t3.headers,
                  cache: t3.cache,
                  referrer: D(),
                  signal: r3.signal
                });
                t3.type !== "json" || e2.headers.has("Accept") || e2.headers.set("Accept", "application/json");
                const n3 = yield fetch(e2);
                if (!n3.ok) {
                  const e3 = yield n3.blob();
                  throw new L(n3.status, n3.statusText, t3.url, e3);
                }
                let i2;
                i2 = t3.type === "arrayBuffer" || t3.type === "image" ? n3.arrayBuffer() : t3.type === "json" ? n3.json() : n3.text();
                const s2 = yield i2;
                if (r3.signal.aborted)
                  throw E();
                return {
                  data: s2,
                  cacheControl: n3.headers.get("Cache-Control"),
                  expires: n3.headers.get("Expires")
                };
              });
            }(t2, r2);
          if (k(self) && self.worker && self.worker.actor)
            return self.worker.actor.sendAsync({ type: "GR", data: t2, mustQueue: true, targetMapId: $ }, r2);
        }
        var n2;
        return function(t3, e2) {
          return new Promise((r3, n3) => {
            var i2;
            const s2 = new XMLHttpRequest;
            s2.open(t3.method || "GET", t3.url, true), t3.type !== "arrayBuffer" && t3.type !== "image" || (s2.responseType = "arraybuffer");
            for (const e3 in t3.headers)
              s2.setRequestHeader(e3, t3.headers[e3]);
            t3.type === "json" && (s2.responseType = "text", ((i2 = t3.headers) === null || i2 === undefined ? undefined : i2.Accept) || s2.setRequestHeader("Accept", "application/json")), s2.withCredentials = t3.credentials === "include", s2.onerror = () => {
              n3(new Error(s2.statusText));
            }, s2.onload = () => {
              if (!e2.signal.aborted)
                if ((s2.status >= 200 && s2.status < 300 || s2.status === 0) && s2.response !== null) {
                  let e3 = s2.response;
                  if (t3.type === "json")
                    try {
                      e3 = JSON.parse(s2.response);
                    } catch (t4) {
                      return void n3(t4);
                    }
                  r3({
                    data: e3,
                    cacheControl: s2.getResponseHeader("Cache-Control"),
                    expires: s2.getResponseHeader("Expires")
                  });
                } else {
                  const e3 = new Blob([s2.response], {
                    type: s2.getResponseHeader("Content-Type")
                  });
                  n3(new L(s2.status, s2.statusText, t3.url, e3));
                }
            }, e2.signal.addEventListener("abort", () => {
              s2.abort(), n3(E());
            }), s2.send(t3.body);
          });
        }(t2, r2);
      };
      function j(t2) {
        if (!t2 || t2.indexOf("://") <= 0 || t2.indexOf("data:image/") === 0 || t2.indexOf("blob:") === 0)
          return true;
        const e2 = new URL(t2), r2 = window.location;
        return e2.protocol === r2.protocol && e2.host === r2.host;
      }
      function R(t2, e2, r2) {
        r2[t2] && r2[t2].indexOf(e2) !== -1 || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
      }
      function U(t2, e2, r2) {
        if (r2 && r2[t2]) {
          const n2 = r2[t2].indexOf(e2);
          n2 !== -1 && r2[t2].splice(n2, 1);
        }
      }

      class q {
        constructor(t2, e2 = {}) {
          g(this, e2), this.type = t2;
        }
      }

      class N extends q {
        constructor(t2, e2 = {}) {
          super("error", g({ error: t2 }, e2));
        }
      }

      class Z {
        on(t2, e2) {
          return this._listeners = this._listeners || {}, R(t2, e2, this._listeners), this;
        }
        off(t2, e2) {
          return U(t2, e2, this._listeners), U(t2, e2, this._oneTimeListeners), this;
        }
        once(t2, e2) {
          return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, R(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => this.once(t2, e3));
        }
        fire(t2, e2) {
          typeof t2 == "string" && (t2 = new q(t2, e2 || {}));
          const r2 = t2.type;
          if (this.listens(r2)) {
            t2.target = this;
            const e3 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : [];
            for (const r3 of e3)
              r3.call(this, t2);
            const n2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : [];
            for (const e4 of n2)
              U(r2, e4, this._oneTimeListeners), e4.call(this, t2);
            const i2 = this._eventedParent;
            i2 && (g(t2, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), i2.fire(t2));
          } else
            t2 instanceof N && console.error(t2.error);
          return this;
        }
        listens(t2) {
          return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
        }
        setEventedParent(t2, e2) {
          return this._eventedParent = t2, this._eventedParentData = e2, this;
        }
      }
      var G = {
        $version: 8,
        $root: {
          version: { required: true, type: "enum", values: [8] },
          name: { type: "string" },
          metadata: { type: "*" },
          center: { type: "array", value: "number" },
          zoom: { type: "number" },
          bearing: { type: "number", default: 0, period: 360, units: "degrees" },
          pitch: { type: "number", default: 0, units: "degrees" },
          light: { type: "light" },
          sky: { type: "sky" },
          projection: { type: "projection" },
          terrain: { type: "terrain" },
          sources: { required: true, type: "sources" },
          sprite: { type: "sprite" },
          glyphs: { type: "string" },
          transition: { type: "transition" },
          layers: { required: true, type: "array", value: "layer" }
        },
        sources: { "*": { type: "source" } },
        source: [
          "source_vector",
          "source_raster",
          "source_raster_dem",
          "source_geojson",
          "source_video",
          "source_image"
        ],
        source_vector: {
          type: { required: true, type: "enum", values: { vector: {} } },
          url: { type: "string" },
          tiles: { type: "array", value: "string" },
          bounds: {
            type: "array",
            value: "number",
            length: 4,
            default: [-180, -85.051129, 180, 85.051129]
          },
          scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" },
          minzoom: { type: "number", default: 0 },
          maxzoom: { type: "number", default: 22 },
          attribution: { type: "string" },
          promoteId: { type: "promoteId" },
          volatile: { type: "boolean", default: false },
          "*": { type: "*" }
        },
        source_raster: {
          type: { required: true, type: "enum", values: { raster: {} } },
          url: { type: "string" },
          tiles: { type: "array", value: "string" },
          bounds: {
            type: "array",
            value: "number",
            length: 4,
            default: [-180, -85.051129, 180, 85.051129]
          },
          minzoom: { type: "number", default: 0 },
          maxzoom: { type: "number", default: 22 },
          tileSize: { type: "number", default: 512, units: "pixels" },
          scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" },
          attribution: { type: "string" },
          volatile: { type: "boolean", default: false },
          "*": { type: "*" }
        },
        source_raster_dem: {
          type: { required: true, type: "enum", values: { "raster-dem": {} } },
          url: { type: "string" },
          tiles: { type: "array", value: "string" },
          bounds: {
            type: "array",
            value: "number",
            length: 4,
            default: [-180, -85.051129, 180, 85.051129]
          },
          minzoom: { type: "number", default: 0 },
          maxzoom: { type: "number", default: 22 },
          tileSize: { type: "number", default: 512, units: "pixels" },
          attribution: { type: "string" },
          encoding: {
            type: "enum",
            values: { terrarium: {}, mapbox: {}, custom: {} },
            default: "mapbox"
          },
          redFactor: { type: "number", default: 1 },
          blueFactor: { type: "number", default: 1 },
          greenFactor: { type: "number", default: 1 },
          baseShift: { type: "number", default: 0 },
          volatile: { type: "boolean", default: false },
          "*": { type: "*" }
        },
        source_geojson: {
          type: { required: true, type: "enum", values: { geojson: {} } },
          data: { required: true, type: "*" },
          maxzoom: { type: "number", default: 18 },
          attribution: { type: "string" },
          buffer: { type: "number", default: 128, maximum: 512, minimum: 0 },
          filter: { type: "*" },
          tolerance: { type: "number", default: 0.375 },
          cluster: { type: "boolean", default: false },
          clusterRadius: { type: "number", default: 50, minimum: 0 },
          clusterMaxZoom: { type: "number" },
          clusterMinPoints: { type: "number" },
          clusterProperties: { type: "*" },
          lineMetrics: { type: "boolean", default: false },
          generateId: { type: "boolean", default: false },
          promoteId: { type: "promoteId" }
        },
        source_video: {
          type: { required: true, type: "enum", values: { video: {} } },
          urls: { required: true, type: "array", value: "string" },
          coordinates: {
            required: true,
            type: "array",
            length: 4,
            value: { type: "array", length: 2, value: "number" }
          }
        },
        source_image: {
          type: { required: true, type: "enum", values: { image: {} } },
          url: { required: true, type: "string" },
          coordinates: {
            required: true,
            type: "array",
            length: 4,
            value: { type: "array", length: 2, value: "number" }
          }
        },
        layer: {
          id: { type: "string", required: true },
          type: {
            type: "enum",
            values: {
              fill: {},
              line: {},
              symbol: {},
              circle: {},
              heatmap: {},
              "fill-extrusion": {},
              raster: {},
              hillshade: {},
              background: {}
            },
            required: true
          },
          metadata: { type: "*" },
          source: { type: "string" },
          "source-layer": { type: "string" },
          minzoom: { type: "number", minimum: 0, maximum: 24 },
          maxzoom: { type: "number", minimum: 0, maximum: 24 },
          filter: { type: "filter" },
          layout: { type: "layout" },
          paint: { type: "paint" }
        },
        layout: [
          "layout_fill",
          "layout_line",
          "layout_circle",
          "layout_heatmap",
          "layout_fill-extrusion",
          "layout_symbol",
          "layout_raster",
          "layout_hillshade",
          "layout_background"
        ],
        layout_background: {
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant"
          }
        },
        layout_fill: {
          "fill-sort-key": {
            type: "number",
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant"
          }
        },
        layout_circle: {
          "circle-sort-key": {
            type: "number",
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant"
          }
        },
        layout_heatmap: {
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant"
          }
        },
        "layout_fill-extrusion": {
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant"
          }
        },
        layout_line: {
          "line-cap": {
            type: "enum",
            values: { butt: {}, round: {}, square: {} },
            default: "butt",
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "line-join": {
            type: "enum",
            values: { bevel: {}, round: {}, miter: {} },
            default: "miter",
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "line-miter-limit": {
            type: "number",
            default: 2,
            requires: [{ "line-join": "miter" }],
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "line-round-limit": {
            type: "number",
            default: 1.05,
            requires: [{ "line-join": "round" }],
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "line-sort-key": {
            type: "number",
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant"
          }
        },
        layout_symbol: {
          "symbol-placement": {
            type: "enum",
            values: { point: {}, line: {}, "line-center": {} },
            default: "point",
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "symbol-spacing": {
            type: "number",
            default: 250,
            minimum: 1,
            units: "pixels",
            requires: [{ "symbol-placement": "line" }],
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "symbol-avoid-edges": {
            type: "boolean",
            default: false,
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "symbol-sort-key": {
            type: "number",
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "symbol-z-order": {
            type: "enum",
            values: { auto: {}, "viewport-y": {}, source: {} },
            default: "auto",
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "icon-allow-overlap": {
            type: "boolean",
            default: false,
            requires: ["icon-image", { "!": "icon-overlap" }],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "icon-overlap": {
            type: "enum",
            values: { never: {}, always: {}, cooperative: {} },
            requires: ["icon-image"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "icon-ignore-placement": {
            type: "boolean",
            default: false,
            requires: ["icon-image"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "icon-optional": {
            type: "boolean",
            default: false,
            requires: ["icon-image", "text-field"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "icon-rotation-alignment": {
            type: "enum",
            values: { map: {}, viewport: {}, auto: {} },
            default: "auto",
            requires: ["icon-image"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "icon-size": {
            type: "number",
            default: 1,
            minimum: 0,
            units: "factor of the original icon size",
            requires: ["icon-image"],
            expression: { interpolated: true, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "icon-text-fit": {
            type: "enum",
            values: { none: {}, width: {}, height: {}, both: {} },
            default: "none",
            requires: ["icon-image", "text-field"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "icon-text-fit-padding": {
            type: "array",
            value: "number",
            length: 4,
            default: [0, 0, 0, 0],
            units: "pixels",
            requires: [
              "icon-image",
              "text-field",
              { "icon-text-fit": ["both", "width", "height"] }
            ],
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "icon-image": {
            type: "resolvedImage",
            tokens: true,
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "icon-rotate": {
            type: "number",
            default: 0,
            period: 360,
            units: "degrees",
            requires: ["icon-image"],
            expression: { interpolated: true, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "icon-padding": {
            type: "padding",
            default: [2],
            units: "pixels",
            requires: ["icon-image"],
            expression: { interpolated: true, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "icon-keep-upright": {
            type: "boolean",
            default: false,
            requires: [
              "icon-image",
              { "icon-rotation-alignment": "map" },
              { "symbol-placement": ["line", "line-center"] }
            ],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "icon-offset": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            requires: ["icon-image"],
            expression: { interpolated: true, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "icon-anchor": {
            type: "enum",
            values: {
              center: {},
              left: {},
              right: {},
              top: {},
              bottom: {},
              "top-left": {},
              "top-right": {},
              "bottom-left": {},
              "bottom-right": {}
            },
            default: "center",
            requires: ["icon-image"],
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "icon-pitch-alignment": {
            type: "enum",
            values: { map: {}, viewport: {}, auto: {} },
            default: "auto",
            requires: ["icon-image"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-pitch-alignment": {
            type: "enum",
            values: { map: {}, viewport: {}, auto: {} },
            default: "auto",
            requires: ["text-field"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-rotation-alignment": {
            type: "enum",
            values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} },
            default: "auto",
            requires: ["text-field"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-field": {
            type: "formatted",
            default: "",
            tokens: true,
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "text-font": {
            type: "array",
            value: "string",
            default: ["Open Sans Regular", "Arial Unicode MS Regular"],
            requires: ["text-field"],
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "text-size": {
            type: "number",
            default: 16,
            minimum: 0,
            units: "pixels",
            requires: ["text-field"],
            expression: { interpolated: true, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "text-max-width": {
            type: "number",
            default: 10,
            minimum: 0,
            units: "ems",
            requires: ["text-field"],
            expression: { interpolated: true, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "text-line-height": {
            type: "number",
            default: 1.2,
            units: "ems",
            requires: ["text-field"],
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-letter-spacing": {
            type: "number",
            default: 0,
            units: "ems",
            requires: ["text-field"],
            expression: { interpolated: true, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "text-justify": {
            type: "enum",
            values: { auto: {}, left: {}, center: {}, right: {} },
            default: "center",
            requires: ["text-field"],
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "text-radial-offset": {
            type: "number",
            units: "ems",
            default: 0,
            requires: ["text-field"],
            "property-type": "data-driven",
            expression: { interpolated: true, parameters: ["zoom", "feature"] }
          },
          "text-variable-anchor": {
            type: "array",
            value: "enum",
            values: {
              center: {},
              left: {},
              right: {},
              top: {},
              bottom: {},
              "top-left": {},
              "top-right": {},
              "bottom-left": {},
              "bottom-right": {}
            },
            requires: ["text-field", { "symbol-placement": ["point"] }],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-variable-anchor-offset": {
            type: "variableAnchorOffsetCollection",
            requires: ["text-field", { "symbol-placement": ["point"] }],
            expression: { interpolated: true, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "text-anchor": {
            type: "enum",
            values: {
              center: {},
              left: {},
              right: {},
              top: {},
              bottom: {},
              "top-left": {},
              "top-right": {},
              "bottom-left": {},
              "bottom-right": {}
            },
            default: "center",
            requires: ["text-field", { "!": "text-variable-anchor" }],
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "text-max-angle": {
            type: "number",
            default: 45,
            units: "degrees",
            requires: ["text-field", { "symbol-placement": ["line", "line-center"] }],
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-writing-mode": {
            type: "array",
            value: "enum",
            values: { horizontal: {}, vertical: {} },
            requires: ["text-field", { "symbol-placement": ["point"] }],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-rotate": {
            type: "number",
            default: 0,
            period: 360,
            units: "degrees",
            requires: ["text-field"],
            expression: { interpolated: true, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "text-padding": {
            type: "number",
            default: 2,
            minimum: 0,
            units: "pixels",
            requires: ["text-field"],
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-keep-upright": {
            type: "boolean",
            default: true,
            requires: [
              "text-field",
              { "text-rotation-alignment": "map" },
              { "symbol-placement": ["line", "line-center"] }
            ],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-transform": {
            type: "enum",
            values: { none: {}, uppercase: {}, lowercase: {} },
            default: "none",
            requires: ["text-field"],
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "text-offset": {
            type: "array",
            value: "number",
            units: "ems",
            length: 2,
            default: [0, 0],
            requires: ["text-field", { "!": "text-radial-offset" }],
            expression: { interpolated: true, parameters: ["zoom", "feature"] },
            "property-type": "data-driven"
          },
          "text-allow-overlap": {
            type: "boolean",
            default: false,
            requires: ["text-field", { "!": "text-overlap" }],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-overlap": {
            type: "enum",
            values: { never: {}, always: {}, cooperative: {} },
            requires: ["text-field"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-ignore-placement": {
            type: "boolean",
            default: false,
            requires: ["text-field"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-optional": {
            type: "boolean",
            default: false,
            requires: ["text-field", "icon-image"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant"
          }
        },
        layout_raster: {
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant"
          }
        },
        layout_hillshade: {
          visibility: {
            type: "enum",
            values: { visible: {}, none: {} },
            default: "visible",
            "property-type": "constant"
          }
        },
        filter: { type: "array", value: "*" },
        filter_operator: {
          type: "enum",
          values: {
            "==": {},
            "!=": {},
            ">": {},
            ">=": {},
            "<": {},
            "<=": {},
            in: {},
            "!in": {},
            all: {},
            any: {},
            none: {},
            has: {},
            "!has": {}
          }
        },
        geometry_type: {
          type: "enum",
          values: { Point: {}, LineString: {}, Polygon: {} }
        },
        function: {
          expression: { type: "expression" },
          stops: { type: "array", value: "function_stop" },
          base: { type: "number", default: 1, minimum: 0 },
          property: { type: "string", default: "$zoom" },
          type: {
            type: "enum",
            values: { identity: {}, exponential: {}, interval: {}, categorical: {} },
            default: "exponential"
          },
          colorSpace: {
            type: "enum",
            values: { rgb: {}, lab: {}, hcl: {} },
            default: "rgb"
          },
          default: { type: "*", required: false }
        },
        function_stop: {
          type: "array",
          minimum: 0,
          maximum: 24,
          value: ["number", "color"],
          length: 2
        },
        expression: { type: "array", value: "*", minimum: 1 },
        light: {
          anchor: {
            type: "enum",
            default: "viewport",
            values: { map: {}, viewport: {} },
            "property-type": "data-constant",
            transition: false,
            expression: { interpolated: false, parameters: ["zoom"] }
          },
          position: {
            type: "array",
            default: [1.15, 210, 30],
            length: 3,
            value: "number",
            "property-type": "data-constant",
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] }
          },
          color: {
            type: "color",
            "property-type": "data-constant",
            default: "#ffffff",
            expression: { interpolated: true, parameters: ["zoom"] },
            transition: true
          },
          intensity: {
            type: "number",
            "property-type": "data-constant",
            default: 0.5,
            minimum: 0,
            maximum: 1,
            expression: { interpolated: true, parameters: ["zoom"] },
            transition: true
          }
        },
        sky: {
          "sky-color": {
            type: "color",
            "property-type": "data-constant",
            default: "#88C6FC",
            expression: { interpolated: true, parameters: ["zoom"] },
            transition: true
          },
          "horizon-color": {
            type: "color",
            "property-type": "data-constant",
            default: "#ffffff",
            expression: { interpolated: true, parameters: ["zoom"] },
            transition: true
          },
          "fog-color": {
            type: "color",
            "property-type": "data-constant",
            default: "#ffffff",
            expression: { interpolated: true, parameters: ["zoom"] },
            transition: true
          },
          "fog-ground-blend": {
            type: "number",
            "property-type": "data-constant",
            default: 0.5,
            minimum: 0,
            maximum: 1,
            expression: { interpolated: true, parameters: ["zoom"] },
            transition: true
          },
          "horizon-fog-blend": {
            type: "number",
            "property-type": "data-constant",
            default: 0.8,
            minimum: 0,
            maximum: 1,
            expression: { interpolated: true, parameters: ["zoom"] },
            transition: true
          },
          "sky-horizon-blend": {
            type: "number",
            "property-type": "data-constant",
            default: 0.8,
            minimum: 0,
            maximum: 1,
            expression: { interpolated: true, parameters: ["zoom"] },
            transition: true
          },
          "atmosphere-blend": {
            type: "number",
            "property-type": "data-constant",
            default: 0.8,
            minimum: 0,
            maximum: 1,
            expression: { interpolated: true, parameters: ["zoom"] },
            transition: true
          }
        },
        terrain: {
          source: { type: "string", required: true },
          exaggeration: { type: "number", minimum: 0, default: 1 }
        },
        projection: {
          type: {
            type: "enum",
            default: "mercator",
            values: { mercator: {}, globe: {} }
          }
        },
        paint: [
          "paint_fill",
          "paint_line",
          "paint_circle",
          "paint_heatmap",
          "paint_fill-extrusion",
          "paint_symbol",
          "paint_raster",
          "paint_hillshade",
          "paint_background"
        ],
        paint_fill: {
          "fill-antialias": {
            type: "boolean",
            default: true,
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "fill-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: true,
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "fill-color": {
            type: "color",
            default: "#000000",
            transition: true,
            requires: [{ "!": "fill-pattern" }],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "fill-outline-color": {
            type: "color",
            transition: true,
            requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "fill-translate": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            transition: true,
            units: "pixels",
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "fill-translate-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            requires: ["fill-translate"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "fill-pattern": {
            type: "resolvedImage",
            transition: true,
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "cross-faded-data-driven"
          }
        },
        "paint_fill-extrusion": {
          "fill-extrusion-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "fill-extrusion-color": {
            type: "color",
            default: "#000000",
            transition: true,
            requires: [{ "!": "fill-extrusion-pattern" }],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "fill-extrusion-translate": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            transition: true,
            units: "pixels",
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "fill-extrusion-translate-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            requires: ["fill-extrusion-translate"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "fill-extrusion-pattern": {
            type: "resolvedImage",
            transition: true,
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "cross-faded-data-driven"
          },
          "fill-extrusion-height": {
            type: "number",
            default: 0,
            minimum: 0,
            units: "meters",
            transition: true,
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "fill-extrusion-base": {
            type: "number",
            default: 0,
            minimum: 0,
            units: "meters",
            transition: true,
            requires: ["fill-extrusion-height"],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "fill-extrusion-vertical-gradient": {
            type: "boolean",
            default: true,
            transition: false,
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          }
        },
        paint_line: {
          "line-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: true,
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "line-color": {
            type: "color",
            default: "#000000",
            transition: true,
            requires: [{ "!": "line-pattern" }],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "line-translate": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            transition: true,
            units: "pixels",
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "line-translate-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            requires: ["line-translate"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "line-width": {
            type: "number",
            default: 1,
            minimum: 0,
            transition: true,
            units: "pixels",
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "line-gap-width": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: true,
            units: "pixels",
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "line-offset": {
            type: "number",
            default: 0,
            transition: true,
            units: "pixels",
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "line-blur": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: true,
            units: "pixels",
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "line-dasharray": {
            type: "array",
            value: "number",
            minimum: 0,
            transition: true,
            units: "line widths",
            requires: [{ "!": "line-pattern" }],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "cross-faded"
          },
          "line-pattern": {
            type: "resolvedImage",
            transition: true,
            expression: { interpolated: false, parameters: ["zoom", "feature"] },
            "property-type": "cross-faded-data-driven"
          },
          "line-gradient": {
            type: "color",
            transition: false,
            requires: [
              { "!": "line-dasharray" },
              { "!": "line-pattern" },
              { source: "geojson", has: { lineMetrics: true } }
            ],
            expression: { interpolated: true, parameters: ["line-progress"] },
            "property-type": "color-ramp"
          }
        },
        paint_circle: {
          "circle-radius": {
            type: "number",
            default: 5,
            minimum: 0,
            transition: true,
            units: "pixels",
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "circle-color": {
            type: "color",
            default: "#000000",
            transition: true,
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "circle-blur": {
            type: "number",
            default: 0,
            transition: true,
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "circle-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: true,
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "circle-translate": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            transition: true,
            units: "pixels",
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "circle-translate-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            requires: ["circle-translate"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "circle-pitch-scale": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "circle-pitch-alignment": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "viewport",
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "circle-stroke-width": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: true,
            units: "pixels",
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "circle-stroke-color": {
            type: "color",
            default: "#000000",
            transition: true,
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "circle-stroke-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: true,
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          }
        },
        paint_heatmap: {
          "heatmap-radius": {
            type: "number",
            default: 30,
            minimum: 1,
            transition: true,
            units: "pixels",
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "heatmap-weight": {
            type: "number",
            default: 1,
            minimum: 0,
            transition: false,
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "heatmap-intensity": {
            type: "number",
            default: 1,
            minimum: 0,
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "heatmap-color": {
            type: "color",
            default: [
              "interpolate",
              ["linear"],
              ["heatmap-density"],
              0,
              "rgba(0, 0, 255, 0)",
              0.1,
              "royalblue",
              0.3,
              "cyan",
              0.5,
              "lime",
              0.7,
              "yellow",
              1,
              "red"
            ],
            transition: false,
            expression: { interpolated: true, parameters: ["heatmap-density"] },
            "property-type": "color-ramp"
          },
          "heatmap-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          }
        },
        paint_symbol: {
          "icon-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: true,
            requires: ["icon-image"],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "icon-color": {
            type: "color",
            default: "#000000",
            transition: true,
            requires: ["icon-image"],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "icon-halo-color": {
            type: "color",
            default: "rgba(0, 0, 0, 0)",
            transition: true,
            requires: ["icon-image"],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "icon-halo-width": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: true,
            units: "pixels",
            requires: ["icon-image"],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "icon-halo-blur": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: true,
            units: "pixels",
            requires: ["icon-image"],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "icon-translate": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            transition: true,
            units: "pixels",
            requires: ["icon-image"],
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "icon-translate-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            requires: ["icon-image", "icon-translate"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: true,
            requires: ["text-field"],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "text-color": {
            type: "color",
            default: "#000000",
            transition: true,
            overridable: true,
            requires: ["text-field"],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "text-halo-color": {
            type: "color",
            default: "rgba(0, 0, 0, 0)",
            transition: true,
            requires: ["text-field"],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "text-halo-width": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: true,
            units: "pixels",
            requires: ["text-field"],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "text-halo-blur": {
            type: "number",
            default: 0,
            minimum: 0,
            transition: true,
            units: "pixels",
            requires: ["text-field"],
            expression: {
              interpolated: true,
              parameters: ["zoom", "feature", "feature-state"]
            },
            "property-type": "data-driven"
          },
          "text-translate": {
            type: "array",
            value: "number",
            length: 2,
            default: [0, 0],
            transition: true,
            units: "pixels",
            requires: ["text-field"],
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "text-translate-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "map",
            requires: ["text-field", "text-translate"],
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          }
        },
        paint_raster: {
          "raster-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "raster-hue-rotate": {
            type: "number",
            default: 0,
            period: 360,
            transition: true,
            units: "degrees",
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "raster-brightness-min": {
            type: "number",
            default: 0,
            minimum: 0,
            maximum: 1,
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "raster-brightness-max": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "raster-saturation": {
            type: "number",
            default: 0,
            minimum: -1,
            maximum: 1,
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "raster-contrast": {
            type: "number",
            default: 0,
            minimum: -1,
            maximum: 1,
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "raster-resampling": {
            type: "enum",
            values: { linear: {}, nearest: {} },
            default: "linear",
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "raster-fade-duration": {
            type: "number",
            default: 300,
            minimum: 0,
            transition: false,
            units: "milliseconds",
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          }
        },
        paint_hillshade: {
          "hillshade-illumination-direction": {
            type: "number",
            default: 335,
            minimum: 0,
            maximum: 359,
            transition: false,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "hillshade-illumination-anchor": {
            type: "enum",
            values: { map: {}, viewport: {} },
            default: "viewport",
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "hillshade-exaggeration": {
            type: "number",
            default: 0.5,
            minimum: 0,
            maximum: 1,
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "hillshade-shadow-color": {
            type: "color",
            default: "#000000",
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "hillshade-highlight-color": {
            type: "color",
            default: "#FFFFFF",
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "hillshade-accent-color": {
            type: "color",
            default: "#000000",
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          }
        },
        paint_background: {
          "background-color": {
            type: "color",
            default: "#000000",
            transition: true,
            requires: [{ "!": "background-pattern" }],
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          },
          "background-pattern": {
            type: "resolvedImage",
            transition: true,
            expression: { interpolated: false, parameters: ["zoom"] },
            "property-type": "cross-faded"
          },
          "background-opacity": {
            type: "number",
            default: 1,
            minimum: 0,
            maximum: 1,
            transition: true,
            expression: { interpolated: true, parameters: ["zoom"] },
            "property-type": "data-constant"
          }
        },
        transition: {
          duration: {
            type: "number",
            default: 300,
            minimum: 0,
            units: "milliseconds"
          },
          delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" }
        },
        "property-type": {
          "data-driven": { type: "property-type" },
          "cross-faded": { type: "property-type" },
          "cross-faded-data-driven": { type: "property-type" },
          "color-ramp": { type: "property-type" },
          "data-constant": { type: "property-type" },
          constant: { type: "property-type" }
        },
        promoteId: { "*": { type: "string" } }
      };
      const K = [
        "type",
        "source",
        "source-layer",
        "minzoom",
        "maxzoom",
        "filter",
        "layout"
      ];
      function X(t2, e2) {
        const r2 = {};
        for (const e3 in t2)
          e3 !== "ref" && (r2[e3] = t2[e3]);
        return K.forEach((t3) => {
          t3 in e2 && (r2[t3] = e2[t3]);
        }), r2;
      }
      function H(t2, e2) {
        if (Array.isArray(t2)) {
          if (!Array.isArray(e2) || t2.length !== e2.length)
            return false;
          for (let r2 = 0;r2 < t2.length; r2++)
            if (!H(t2[r2], e2[r2]))
              return false;
          return true;
        }
        if (typeof t2 == "object" && t2 !== null && e2 !== null) {
          if (typeof e2 != "object")
            return false;
          if (Object.keys(t2).length !== Object.keys(e2).length)
            return false;
          for (const r2 in t2)
            if (!H(t2[r2], e2[r2]))
              return false;
          return true;
        }
        return t2 === e2;
      }
      function Y(t2, e2) {
        t2.push(e2);
      }
      function J(t2, e2, r2) {
        Y(r2, { command: "addSource", args: [t2, e2[t2]] });
      }
      function W(t2, e2, r2) {
        Y(e2, { command: "removeSource", args: [t2] }), r2[t2] = true;
      }
      function Q(t2, e2, r2, n2) {
        W(t2, r2, n2), J(t2, e2, r2);
      }
      function tt(t2, e2, r2) {
        let n2;
        for (n2 in t2[r2])
          if (Object.prototype.hasOwnProperty.call(t2[r2], n2) && n2 !== "data" && !H(t2[r2][n2], e2[r2][n2]))
            return false;
        for (n2 in e2[r2])
          if (Object.prototype.hasOwnProperty.call(e2[r2], n2) && n2 !== "data" && !H(t2[r2][n2], e2[r2][n2]))
            return false;
        return true;
      }
      function et(t2, e2, r2, n2, i2, s2) {
        t2 = t2 || {}, e2 = e2 || {};
        for (const a2 in t2)
          Object.prototype.hasOwnProperty.call(t2, a2) && (H(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
        for (const a2 in e2)
          Object.prototype.hasOwnProperty.call(e2, a2) && !Object.prototype.hasOwnProperty.call(t2, a2) && (H(t2[a2], e2[a2]) || r2.push({ command: s2, args: [n2, a2, e2[a2], i2] }));
      }
      function rt(t2) {
        return t2.id;
      }
      function nt(t2, e2) {
        return t2[e2.id] = e2, t2;
      }

      class it {
        constructor(t2, e2, r2, n2) {
          this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), e2 != null && e2.__line__ && (this.line = e2.__line__);
        }
      }
      function st(t2, ...e2) {
        for (const r2 of e2)
          for (const e3 in r2)
            t2[e3] = r2[e3];
        return t2;
      }

      class at extends Error {
        constructor(t2, e2) {
          super(e2), this.message = e2, this.key = t2;
        }
      }

      class ot {
        constructor(t2, e2 = []) {
          this.parent = t2, this.bindings = {};
          for (const [t3, r2] of e2)
            this.bindings[t3] = r2;
        }
        concat(t2) {
          return new ot(this, t2);
        }
        get(t2) {
          if (this.bindings[t2])
            return this.bindings[t2];
          if (this.parent)
            return this.parent.get(t2);
          throw new Error(`${t2} not found in scope.`);
        }
        has(t2) {
          return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
        }
      }
      const lt = { kind: "null" }, ut = { kind: "number" }, ct = { kind: "string" }, ht = { kind: "boolean" }, pt = { kind: "color" }, ft = { kind: "object" }, dt = { kind: "value" }, yt = { kind: "collator" }, mt = { kind: "formatted" }, gt = { kind: "padding" }, xt = { kind: "resolvedImage" }, vt = { kind: "variableAnchorOffsetCollection" };
      function bt(t2, e2) {
        return { kind: "array", itemType: t2, N: e2 };
      }
      function wt(t2) {
        if (t2.kind === "array") {
          const e2 = wt(t2.itemType);
          return typeof t2.N == "number" ? `array<${e2}, ${t2.N}>` : t2.itemType.kind === "value" ? "array" : `array<${e2}>`;
        }
        return t2.kind;
      }
      const _t = [lt, ut, ct, ht, pt, mt, ft, bt(dt), gt, xt, vt];
      function At(t2, e2) {
        if (e2.kind === "error")
          return null;
        if (t2.kind === "array") {
          if (e2.kind === "array" && (e2.N === 0 && e2.itemType.kind === "value" || !At(t2.itemType, e2.itemType)) && (typeof t2.N != "number" || t2.N === e2.N))
            return null;
        } else {
          if (t2.kind === e2.kind)
            return null;
          if (t2.kind === "value") {
            for (const t3 of _t)
              if (!At(t3, e2))
                return null;
          }
        }
        return `Expected ${wt(t2)} but found ${wt(e2)} instead.`;
      }
      function St(t2, e2) {
        return e2.some((e3) => e3.kind === t2.kind);
      }
      function kt(t2, e2) {
        return e2.some((e3) => e3 === "null" ? t2 === null : e3 === "array" ? Array.isArray(t2) : e3 === "object" ? t2 && !Array.isArray(t2) && typeof t2 == "object" : e3 === typeof t2);
      }
      function Mt(t2, e2) {
        return t2.kind === "array" && e2.kind === "array" ? t2.itemType.kind === e2.itemType.kind && typeof t2.N == "number" : t2.kind === e2.kind;
      }
      const It = 0.96422, zt = 0.82521, Pt = 4 / 29, Ct = 6 / 29, Bt = 3 * Ct * Ct, Vt = Ct * Ct * Ct, Et = Math.PI / 180, Ft = 180 / Math.PI;
      function Tt(t2) {
        return (t2 %= 360) < 0 && (t2 += 360), t2;
      }
      function $t([t2, e2, r2, n2]) {
        let i2, s2;
        const a2 = Dt((0.2225045 * (t2 = Lt(t2)) + 0.7168786 * (e2 = Lt(e2)) + 0.0606169 * (r2 = Lt(r2))) / 1);
        t2 === e2 && e2 === r2 ? i2 = s2 = a2 : (i2 = Dt((0.4360747 * t2 + 0.3850649 * e2 + 0.1430804 * r2) / It), s2 = Dt((0.0139322 * t2 + 0.0971045 * e2 + 0.7141733 * r2) / zt));
        const o2 = 116 * a2 - 16;
        return [o2 < 0 ? 0 : o2, 500 * (i2 - a2), 200 * (a2 - s2), n2];
      }
      function Lt(t2) {
        return t2 <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
      }
      function Dt(t2) {
        return t2 > Vt ? Math.pow(t2, 1 / 3) : t2 / Bt + Pt;
      }
      function Ot([t2, e2, r2, n2]) {
        let i2 = (t2 + 16) / 116, s2 = isNaN(e2) ? i2 : i2 + e2 / 500, a2 = isNaN(r2) ? i2 : i2 - r2 / 200;
        return i2 = 1 * Rt(i2), s2 = It * Rt(s2), a2 = zt * Rt(a2), [
          jt(3.1338561 * s2 - 1.6168667 * i2 - 0.4906146 * a2),
          jt(-0.9787684 * s2 + 1.9161415 * i2 + 0.033454 * a2),
          jt(0.0719453 * s2 - 0.2289914 * i2 + 1.4052427 * a2),
          n2
        ];
      }
      function jt(t2) {
        return (t2 = t2 <= 0.00304 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055) < 0 ? 0 : t2 > 1 ? 1 : t2;
      }
      function Rt(t2) {
        return t2 > Ct ? t2 * t2 * t2 : Bt * (t2 - Pt);
      }
      function Ut(t2) {
        return parseInt(t2.padEnd(2, t2), 16) / 255;
      }
      function qt(t2, e2) {
        return Nt(e2 ? t2 / 100 : t2, 0, 1);
      }
      function Nt(t2, e2, r2) {
        return Math.min(Math.max(e2, t2), r2);
      }
      function Zt(t2) {
        return !t2.some(Number.isNaN);
      }
      const Gt = {
        aliceblue: [240, 248, 255],
        antiquewhite: [250, 235, 215],
        aqua: [0, 255, 255],
        aquamarine: [127, 255, 212],
        azure: [240, 255, 255],
        beige: [245, 245, 220],
        bisque: [255, 228, 196],
        black: [0, 0, 0],
        blanchedalmond: [255, 235, 205],
        blue: [0, 0, 255],
        blueviolet: [138, 43, 226],
        brown: [165, 42, 42],
        burlywood: [222, 184, 135],
        cadetblue: [95, 158, 160],
        chartreuse: [127, 255, 0],
        chocolate: [210, 105, 30],
        coral: [255, 127, 80],
        cornflowerblue: [100, 149, 237],
        cornsilk: [255, 248, 220],
        crimson: [220, 20, 60],
        cyan: [0, 255, 255],
        darkblue: [0, 0, 139],
        darkcyan: [0, 139, 139],
        darkgoldenrod: [184, 134, 11],
        darkgray: [169, 169, 169],
        darkgreen: [0, 100, 0],
        darkgrey: [169, 169, 169],
        darkkhaki: [189, 183, 107],
        darkmagenta: [139, 0, 139],
        darkolivegreen: [85, 107, 47],
        darkorange: [255, 140, 0],
        darkorchid: [153, 50, 204],
        darkred: [139, 0, 0],
        darksalmon: [233, 150, 122],
        darkseagreen: [143, 188, 143],
        darkslateblue: [72, 61, 139],
        darkslategray: [47, 79, 79],
        darkslategrey: [47, 79, 79],
        darkturquoise: [0, 206, 209],
        darkviolet: [148, 0, 211],
        deeppink: [255, 20, 147],
        deepskyblue: [0, 191, 255],
        dimgray: [105, 105, 105],
        dimgrey: [105, 105, 105],
        dodgerblue: [30, 144, 255],
        firebrick: [178, 34, 34],
        floralwhite: [255, 250, 240],
        forestgreen: [34, 139, 34],
        fuchsia: [255, 0, 255],
        gainsboro: [220, 220, 220],
        ghostwhite: [248, 248, 255],
        gold: [255, 215, 0],
        goldenrod: [218, 165, 32],
        gray: [128, 128, 128],
        green: [0, 128, 0],
        greenyellow: [173, 255, 47],
        grey: [128, 128, 128],
        honeydew: [240, 255, 240],
        hotpink: [255, 105, 180],
        indianred: [205, 92, 92],
        indigo: [75, 0, 130],
        ivory: [255, 255, 240],
        khaki: [240, 230, 140],
        lavender: [230, 230, 250],
        lavenderblush: [255, 240, 245],
        lawngreen: [124, 252, 0],
        lemonchiffon: [255, 250, 205],
        lightblue: [173, 216, 230],
        lightcoral: [240, 128, 128],
        lightcyan: [224, 255, 255],
        lightgoldenrodyellow: [250, 250, 210],
        lightgray: [211, 211, 211],
        lightgreen: [144, 238, 144],
        lightgrey: [211, 211, 211],
        lightpink: [255, 182, 193],
        lightsalmon: [255, 160, 122],
        lightseagreen: [32, 178, 170],
        lightskyblue: [135, 206, 250],
        lightslategray: [119, 136, 153],
        lightslategrey: [119, 136, 153],
        lightsteelblue: [176, 196, 222],
        lightyellow: [255, 255, 224],
        lime: [0, 255, 0],
        limegreen: [50, 205, 50],
        linen: [250, 240, 230],
        magenta: [255, 0, 255],
        maroon: [128, 0, 0],
        mediumaquamarine: [102, 205, 170],
        mediumblue: [0, 0, 205],
        mediumorchid: [186, 85, 211],
        mediumpurple: [147, 112, 219],
        mediumseagreen: [60, 179, 113],
        mediumslateblue: [123, 104, 238],
        mediumspringgreen: [0, 250, 154],
        mediumturquoise: [72, 209, 204],
        mediumvioletred: [199, 21, 133],
        midnightblue: [25, 25, 112],
        mintcream: [245, 255, 250],
        mistyrose: [255, 228, 225],
        moccasin: [255, 228, 181],
        navajowhite: [255, 222, 173],
        navy: [0, 0, 128],
        oldlace: [253, 245, 230],
        olive: [128, 128, 0],
        olivedrab: [107, 142, 35],
        orange: [255, 165, 0],
        orangered: [255, 69, 0],
        orchid: [218, 112, 214],
        palegoldenrod: [238, 232, 170],
        palegreen: [152, 251, 152],
        paleturquoise: [175, 238, 238],
        palevioletred: [219, 112, 147],
        papayawhip: [255, 239, 213],
        peachpuff: [255, 218, 185],
        peru: [205, 133, 63],
        pink: [255, 192, 203],
        plum: [221, 160, 221],
        powderblue: [176, 224, 230],
        purple: [128, 0, 128],
        rebeccapurple: [102, 51, 153],
        red: [255, 0, 0],
        rosybrown: [188, 143, 143],
        royalblue: [65, 105, 225],
        saddlebrown: [139, 69, 19],
        salmon: [250, 128, 114],
        sandybrown: [244, 164, 96],
        seagreen: [46, 139, 87],
        seashell: [255, 245, 238],
        sienna: [160, 82, 45],
        silver: [192, 192, 192],
        skyblue: [135, 206, 235],
        slateblue: [106, 90, 205],
        slategray: [112, 128, 144],
        slategrey: [112, 128, 144],
        snow: [255, 250, 250],
        springgreen: [0, 255, 127],
        steelblue: [70, 130, 180],
        tan: [210, 180, 140],
        teal: [0, 128, 128],
        thistle: [216, 191, 216],
        tomato: [255, 99, 71],
        turquoise: [64, 224, 208],
        violet: [238, 130, 238],
        wheat: [245, 222, 179],
        white: [255, 255, 255],
        whitesmoke: [245, 245, 245],
        yellow: [255, 255, 0],
        yellowgreen: [154, 205, 50]
      };

      class Kt {
        constructor(t2, e2, r2, n2 = 1, i2 = true) {
          this.r = t2, this.g = e2, this.b = r2, this.a = n2, i2 || (this.r *= n2, this.g *= n2, this.b *= n2, n2 || this.overwriteGetter("rgb", [t2, e2, r2, n2]));
        }
        static parse(t2) {
          if (t2 instanceof Kt)
            return t2;
          if (typeof t2 != "string")
            return;
          const e2 = function(t3) {
            if ((t3 = t3.toLowerCase().trim()) === "transparent")
              return [0, 0, 0, 0];
            const e3 = Gt[t3];
            if (e3) {
              const [t4, r3, n2] = e3;
              return [t4 / 255, r3 / 255, n2 / 255, 1];
            }
            if (t3.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t3)) {
              const e4 = t3.length < 6 ? 1 : 2;
              let r3 = 1;
              return [
                Ut(t3.slice(r3, r3 += e4)),
                Ut(t3.slice(r3, r3 += e4)),
                Ut(t3.slice(r3, r3 += e4)),
                Ut(t3.slice(r3, r3 + e4) || "ff")
              ];
            }
            if (t3.startsWith("rgb")) {
              const e4 = t3.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (e4) {
                const [t4, r3, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2] = e4, f2 = [i2 || " ", o2 || " ", c2].join("");
                if (f2 === "  " || f2 === "  /" || f2 === ",," || f2 === ",,,") {
                  const t5 = [n2, a2, u2].join(""), e5 = t5 === "%%%" ? 100 : t5 === "" ? 255 : 0;
                  if (e5) {
                    const t6 = [
                      Nt(+r3 / e5, 0, 1),
                      Nt(+s2 / e5, 0, 1),
                      Nt(+l2 / e5, 0, 1),
                      h2 ? qt(+h2, p2) : 1
                    ];
                    if (Zt(t6))
                      return t6;
                  }
                }
                return;
              }
            }
            const r2 = t3.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (r2) {
              const [t4, e4, n2, i2, s2, a2, o2, l2, u2] = r2, c2 = [n2 || " ", s2 || " ", o2].join("");
              if (c2 === "  " || c2 === "  /" || c2 === ",," || c2 === ",,,") {
                const t5 = [+e4, Nt(+i2, 0, 100), Nt(+a2, 0, 100), l2 ? qt(+l2, u2) : 1];
                if (Zt(t5))
                  return function([t6, e5, r3, n3]) {
                    function i3(n4) {
                      const i4 = (n4 + t6 / 30) % 12, s3 = e5 * Math.min(r3, 1 - r3);
                      return r3 - s3 * Math.max(-1, Math.min(i4 - 3, 9 - i4, 1));
                    }
                    return t6 = Tt(t6), e5 /= 100, r3 /= 100, [i3(0), i3(8), i3(4), n3];
                  }(t5);
              }
            }
          }(t2);
          return e2 ? new Kt(...e2, false) : undefined;
        }
        get rgb() {
          const { r: t2, g: e2, b: r2, a: n2 } = this, i2 = n2 || 1 / 0;
          return this.overwriteGetter("rgb", [t2 / i2, e2 / i2, r2 / i2, n2]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(t2) {
            const [e2, r2, n2, i2] = $t(t2), s2 = Math.sqrt(r2 * r2 + n2 * n2);
            return [Math.round(1e4 * s2) ? Tt(Math.atan2(n2, r2) * Ft) : NaN, s2, e2, i2];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", $t(this.rgb));
        }
        overwriteGetter(t2, e2) {
          return Object.defineProperty(this, t2, { value: e2 }), e2;
        }
        toString() {
          const [t2, e2, r2, n2] = this.rgb;
          return `rgba(${[t2, e2, r2].map((t3) => Math.round(255 * t3)).join(",")},${n2})`;
        }
      }
      Kt.black = new Kt(0, 0, 0, 1), Kt.white = new Kt(1, 1, 1, 1), Kt.transparent = new Kt(0, 0, 0, 0), Kt.red = new Kt(1, 0, 0, 1);

      class Xt {
        constructor(t2, e2, r2) {
          this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], {
            sensitivity: this.sensitivity,
            usage: "search"
          });
        }
        compare(t2, e2) {
          return this.collator.compare(t2, e2);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }

      class Ht {
        constructor(t2, e2, r2, n2, i2) {
          this.text = t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
        }
      }

      class Yt {
        constructor(t2) {
          this.sections = t2;
        }
        static fromString(t2) {
          return new Yt([new Ht(t2, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((t2) => t2.text.length !== 0 || t2.image && t2.image.name.length !== 0);
        }
        static factory(t2) {
          return t2 instanceof Yt ? t2 : Yt.fromString(t2);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((t2) => t2.text).join("");
        }
      }

      class Jt {
        constructor(t2) {
          this.values = t2.slice();
        }
        static parse(t2) {
          if (t2 instanceof Jt)
            return t2;
          if (typeof t2 == "number")
            return new Jt([t2, t2, t2, t2]);
          if (Array.isArray(t2) && !(t2.length < 1 || t2.length > 4)) {
            for (const e2 of t2)
              if (typeof e2 != "number")
                return;
            switch (t2.length) {
              case 1:
                t2 = [t2[0], t2[0], t2[0], t2[0]];
                break;
              case 2:
                t2 = [t2[0], t2[1], t2[0], t2[1]];
                break;
              case 3:
                t2 = [t2[0], t2[1], t2[2], t2[1]];
            }
            return new Jt(t2);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }
      const Wt = new Set([
        "center",
        "left",
        "right",
        "top",
        "bottom",
        "top-left",
        "top-right",
        "bottom-left",
        "bottom-right"
      ]);

      class Qt {
        constructor(t2) {
          this.values = t2.slice();
        }
        static parse(t2) {
          if (t2 instanceof Qt)
            return t2;
          if (Array.isArray(t2) && !(t2.length < 1) && t2.length % 2 == 0) {
            for (let e2 = 0;e2 < t2.length; e2 += 2) {
              const r2 = t2[e2], n2 = t2[e2 + 1];
              if (typeof r2 != "string" || !Wt.has(r2))
                return;
              if (!Array.isArray(n2) || n2.length !== 2 || typeof n2[0] != "number" || typeof n2[1] != "number")
                return;
            }
            return new Qt(t2);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
      }

      class te {
        constructor(t2) {
          this.name = t2.name, this.available = t2.available;
        }
        toString() {
          return this.name;
        }
        static fromString(t2) {
          return t2 ? new te({ name: t2, available: false }) : null;
        }
      }
      function ee(t2, e2, r2, n2) {
        return typeof t2 == "number" && t2 >= 0 && t2 <= 255 && typeof e2 == "number" && e2 >= 0 && e2 <= 255 && typeof r2 == "number" && r2 >= 0 && r2 <= 255 ? n2 === undefined || typeof n2 == "number" && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n2 == "number" ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function re(t2) {
        if (t2 === null || typeof t2 == "string" || typeof t2 == "boolean" || typeof t2 == "number" || t2 instanceof Kt || t2 instanceof Xt || t2 instanceof Yt || t2 instanceof Jt || t2 instanceof Qt || t2 instanceof te)
          return true;
        if (Array.isArray(t2)) {
          for (const e2 of t2)
            if (!re(e2))
              return false;
          return true;
        }
        if (typeof t2 == "object") {
          for (const e2 in t2)
            if (!re(t2[e2]))
              return false;
          return true;
        }
        return false;
      }
      function ne(t2) {
        if (t2 === null)
          return lt;
        if (typeof t2 == "string")
          return ct;
        if (typeof t2 == "boolean")
          return ht;
        if (typeof t2 == "number")
          return ut;
        if (t2 instanceof Kt)
          return pt;
        if (t2 instanceof Xt)
          return yt;
        if (t2 instanceof Yt)
          return mt;
        if (t2 instanceof Jt)
          return gt;
        if (t2 instanceof Qt)
          return vt;
        if (t2 instanceof te)
          return xt;
        if (Array.isArray(t2)) {
          const e2 = t2.length;
          let r2;
          for (const e3 of t2) {
            const t3 = ne(e3);
            if (r2) {
              if (r2 === t3)
                continue;
              r2 = dt;
              break;
            }
            r2 = t3;
          }
          return bt(r2 || dt, e2);
        }
        return ft;
      }
      function ie(t2) {
        const e2 = typeof t2;
        return t2 === null ? "" : e2 === "string" || e2 === "number" || e2 === "boolean" ? String(t2) : t2 instanceof Kt || t2 instanceof Yt || t2 instanceof Jt || t2 instanceof Qt || t2 instanceof te ? t2.toString() : JSON.stringify(t2);
      }

      class se {
        constructor(t2, e2) {
          this.type = t2, this.value = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (!re(t2[1]))
            return e2.error("invalid value");
          const r2 = t2[1];
          let n2 = ne(r2);
          const i2 = e2.expectedType;
          return n2.kind !== "array" || n2.N !== 0 || !i2 || i2.kind !== "array" || typeof i2.N == "number" && i2.N !== 0 || (n2 = i2), new se(n2, r2);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }

      class ae {
        constructor(t2) {
          this.name = "ExpressionEvaluationError", this.message = t2;
        }
        toJSON() {
          return this.message;
        }
      }
      const oe = { string: ct, number: ut, boolean: ht, object: ft };

      class le {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          let r2, n2 = 1;
          const i2 = t2[0];
          if (i2 === "array") {
            let i3, s3;
            if (t2.length > 2) {
              const r3 = t2[1];
              if (typeof r3 != "string" || !(r3 in oe) || r3 === "object")
                return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
              i3 = oe[r3], n2++;
            } else
              i3 = dt;
            if (t2.length > 3) {
              if (t2[2] !== null && (typeof t2[2] != "number" || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                return e2.error('The length argument to "array" must be a positive integer literal', 2);
              s3 = t2[2], n2++;
            }
            r2 = bt(i3, s3);
          } else {
            if (!oe[i2])
              throw new Error(`Types doesn't contain name = ${i2}`);
            r2 = oe[i2];
          }
          const s2 = [];
          for (;n2 < t2.length; n2++) {
            const r3 = e2.parse(t2[n2], n2, dt);
            if (!r3)
              return null;
            s2.push(r3);
          }
          return new le(r2, s2);
        }
        evaluate(t2) {
          for (let e2 = 0;e2 < this.args.length; e2++) {
            const r2 = this.args[e2].evaluate(t2);
            if (!At(this.type, ne(r2)))
              return r2;
            if (e2 === this.args.length - 1)
              throw new ae(`Expected value to be of type ${wt(this.type)}, but found ${wt(ne(r2))} instead.`);
          }
          throw new Error;
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
      }
      const ue = {
        "to-boolean": ht,
        "to-color": pt,
        "to-number": ut,
        "to-string": ct
      };

      class ce {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          const r2 = t2[0];
          if (!ue[r2])
            throw new Error(`Can't parse ${r2} as it is not part of the known types`);
          if ((r2 === "to-boolean" || r2 === "to-string") && t2.length !== 2)
            return e2.error("Expected one argument.");
          const n2 = ue[r2], i2 = [];
          for (let r3 = 1;r3 < t2.length; r3++) {
            const n3 = e2.parse(t2[r3], r3, dt);
            if (!n3)
              return null;
            i2.push(n3);
          }
          return new ce(n2, i2);
        }
        evaluate(t2) {
          switch (this.type.kind) {
            case "boolean":
              return Boolean(this.args[0].evaluate(t2));
            case "color": {
              let e2, r2;
              for (const n2 of this.args) {
                if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof Kt)
                  return e2;
                if (typeof e2 == "string") {
                  const r3 = t2.parseColor(e2);
                  if (r3)
                    return r3;
                } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : ee(e2[0], e2[1], e2[2], e2[3]), !r2))
                  return new Kt(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
              }
              throw new ae(r2 || `Could not parse color from value '${typeof e2 == "string" ? e2 : JSON.stringify(e2)}'`);
            }
            case "padding": {
              let e2;
              for (const r2 of this.args) {
                e2 = r2.evaluate(t2);
                const n2 = Jt.parse(e2);
                if (n2)
                  return n2;
              }
              throw new ae(`Could not parse padding from value '${typeof e2 == "string" ? e2 : JSON.stringify(e2)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let e2;
              for (const r2 of this.args) {
                e2 = r2.evaluate(t2);
                const n2 = Qt.parse(e2);
                if (n2)
                  return n2;
              }
              throw new ae(`Could not parse variableAnchorOffsetCollection from value '${typeof e2 == "string" ? e2 : JSON.stringify(e2)}'`);
            }
            case "number": {
              let e2 = null;
              for (const r2 of this.args) {
                if (e2 = r2.evaluate(t2), e2 === null)
                  return 0;
                const n2 = Number(e2);
                if (!isNaN(n2))
                  return n2;
              }
              throw new ae(`Could not convert ${JSON.stringify(e2)} to number.`);
            }
            case "formatted":
              return Yt.fromString(ie(this.args[0].evaluate(t2)));
            case "resolvedImage":
              return te.fromString(ie(this.args[0].evaluate(t2)));
            default:
              return ie(this.args[0].evaluate(t2));
          }
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
      }
      const he = ["Unknown", "Point", "LineString", "Polygon"];

      class pe {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? he[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(t2) {
          let e2 = this._parseColorCache[t2];
          return e2 || (e2 = this._parseColorCache[t2] = Kt.parse(t2)), e2;
        }
      }

      class fe {
        constructor(t2, e2, r2 = [], n2, i2 = new ot, s2 = []) {
          this.registry = t2, this.path = r2, this.key = r2.map((t3) => `[${t3}]`).join(""), this.scope = i2, this.errors = s2, this.expectedType = n2, this._isConstant = e2;
        }
        parse(t2, e2, r2, n2, i2 = {}) {
          return e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
        }
        _parse(t2, e2) {
          function r2(t3, e3, r3) {
            return r3 === "assert" ? new le(e3, [t3]) : r3 === "coerce" ? new ce(e3, [t3]) : t3;
          }
          if (t2 !== null && typeof t2 != "string" && typeof t2 != "boolean" && typeof t2 != "number" || (t2 = ["literal", t2]), Array.isArray(t2)) {
            if (t2.length === 0)
              return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const n2 = t2[0];
            if (typeof n2 != "string")
              return this.error(`Expression name must be a string, but found ${typeof n2} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const i2 = this.registry[n2];
            if (i2) {
              let n3 = i2.parse(t2, this);
              if (!n3)
                return null;
              if (this.expectedType) {
                const t3 = this.expectedType, i3 = n3.type;
                if (t3.kind !== "string" && t3.kind !== "number" && t3.kind !== "boolean" && t3.kind !== "object" && t3.kind !== "array" || i3.kind !== "value")
                  if (t3.kind !== "color" && t3.kind !== "formatted" && t3.kind !== "resolvedImage" || i3.kind !== "value" && i3.kind !== "string")
                    if (t3.kind !== "padding" || i3.kind !== "value" && i3.kind !== "number" && i3.kind !== "array")
                      if (t3.kind !== "variableAnchorOffsetCollection" || i3.kind !== "value" && i3.kind !== "array") {
                        if (this.checkSubtype(t3, i3))
                          return null;
                      } else
                        n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                    else
                      n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                  else
                    n3 = r2(n3, t3, e2.typeAnnotation || "coerce");
                else
                  n3 = r2(n3, t3, e2.typeAnnotation || "assert");
              }
              if (!(n3 instanceof se) && n3.type.kind !== "resolvedImage" && this._isConstant(n3)) {
                const t3 = new pe;
                try {
                  n3 = new se(n3.type, n3.evaluate(t3));
                } catch (t4) {
                  return this.error(t4.message), null;
                }
              }
              return n3;
            }
            return this.error(`Unknown expression "${n2}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(t2 === undefined ? "'undefined' value invalid. Use null instead." : typeof t2 == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
        }
        concat(t2, e2, r2) {
          const n2 = typeof t2 == "number" ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
          return new fe(this.registry, this._isConstant, n2, e2 || null, i2, this.errors);
        }
        error(t2, ...e2) {
          const r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
          this.errors.push(new at(r2, t2));
        }
        checkSubtype(t2, e2) {
          const r2 = At(t2, e2);
          return r2 && this.error(r2), r2;
        }
      }

      class de {
        constructor(t2, e2) {
          this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
        }
        evaluate(t2) {
          return this.result.evaluate(t2);
        }
        eachChild(t2) {
          for (const e2 of this.bindings)
            t2(e2[1]);
          t2(this.result);
        }
        static parse(t2, e2) {
          if (t2.length < 4)
            return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
          const r2 = [];
          for (let n3 = 1;n3 < t2.length - 1; n3 += 2) {
            const i2 = t2[n3];
            if (typeof i2 != "string")
              return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
            if (/[^a-zA-Z0-9_]/.test(i2))
              return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
            const s2 = e2.parse(t2[n3 + 1], n3 + 1);
            if (!s2)
              return null;
            r2.push([i2, s2]);
          }
          const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
          return n2 ? new de(r2, n2) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }

      class ye {
        constructor(t2, e2) {
          this.type = e2.type, this.name = t2, this.boundExpression = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2 || typeof t2[1] != "string")
            return e2.error("'var' expression requires exactly one string literal argument.");
          const r2 = t2[1];
          return e2.scope.has(r2) ? new ye(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(t2) {
          return this.boundExpression.evaluate(t2);
        }
        eachChild() {
        }
        outputDefined() {
          return false;
        }
      }

      class me {
        constructor(t2, e2, r2) {
          this.type = t2, this.index = e2, this.input = r2;
        }
        static parse(t2, e2) {
          if (t2.length !== 3)
            return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, ut), n2 = e2.parse(t2[2], 2, bt(e2.expectedType || dt));
          return r2 && n2 ? new me(n2.type.itemType, r2, n2) : null;
        }
        evaluate(t2) {
          const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
          if (e2 < 0)
            throw new ae(`Array index out of bounds: ${e2} < 0.`);
          if (e2 >= r2.length)
            throw new ae(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
          if (e2 !== Math.floor(e2))
            throw new ae(`Array index must be an integer, but found ${e2} instead.`);
          return r2[e2];
        }
        eachChild(t2) {
          t2(this.index), t2(this.input);
        }
        outputDefined() {
          return false;
        }
      }

      class ge {
        constructor(t2, e2) {
          this.type = ht, this.needle = t2, this.haystack = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 3)
            return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, dt), n2 = e2.parse(t2[2], 2, dt);
          return r2 && n2 ? St(r2.type, [ht, ct, ut, lt, dt]) ? new ge(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${wt(r2.type)} instead`) : null;
        }
        evaluate(t2) {
          const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
          if (!r2)
            return false;
          if (!kt(e2, ["boolean", "string", "number", "null"]))
            throw new ae(`Expected first argument to be of type boolean, string, number or null, but found ${wt(ne(e2))} instead.`);
          if (!kt(r2, ["string", "array"]))
            throw new ae(`Expected second argument to be of type array or string, but found ${wt(ne(r2))} instead.`);
          return r2.indexOf(e2) >= 0;
        }
        eachChild(t2) {
          t2(this.needle), t2(this.haystack);
        }
        outputDefined() {
          return true;
        }
      }

      class xe {
        constructor(t2, e2, r2) {
          this.type = ut, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
        }
        static parse(t2, e2) {
          if (t2.length <= 2 || t2.length >= 5)
            return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, dt), n2 = e2.parse(t2[2], 2, dt);
          if (!r2 || !n2)
            return null;
          if (!St(r2.type, [ht, ct, ut, lt, dt]))
            return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${wt(r2.type)} instead`);
          if (t2.length === 4) {
            const i2 = e2.parse(t2[3], 3, ut);
            return i2 ? new xe(r2, n2, i2) : null;
          }
          return new xe(r2, n2);
        }
        evaluate(t2) {
          const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
          if (!kt(e2, ["boolean", "string", "number", "null"]))
            throw new ae(`Expected first argument to be of type boolean, string, number or null, but found ${wt(ne(e2))} instead.`);
          let n2;
          if (this.fromIndex && (n2 = this.fromIndex.evaluate(t2)), kt(r2, ["string"])) {
            const t3 = r2.indexOf(e2, n2);
            return t3 === -1 ? -1 : [...r2.slice(0, t3)].length;
          }
          if (kt(r2, ["array"]))
            return r2.indexOf(e2, n2);
          throw new ae(`Expected second argument to be of type array or string, but found ${wt(ne(r2))} instead.`);
        }
        eachChild(t2) {
          t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
        }
        outputDefined() {
          return false;
        }
      }

      class ve {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
        }
        static parse(t2, e2) {
          if (t2.length < 5)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if (t2.length % 2 != 1)
            return e2.error("Expected an even number of arguments.");
          let r2, n2;
          e2.expectedType && e2.expectedType.kind !== "value" && (n2 = e2.expectedType);
          const i2 = {}, s2 = [];
          for (let a3 = 2;a3 < t2.length - 1; a3 += 2) {
            let o3 = t2[a3];
            const l2 = t2[a3 + 1];
            Array.isArray(o3) || (o3 = [o3]);
            const u2 = e2.concat(a3);
            if (o3.length === 0)
              return u2.error("Expected at least one branch label.");
            for (const t3 of o3) {
              if (typeof t3 != "number" && typeof t3 != "string")
                return u2.error("Branch labels must be numbers or strings.");
              if (typeof t3 == "number" && Math.abs(t3) > Number.MAX_SAFE_INTEGER)
                return u2.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof t3 == "number" && Math.floor(t3) !== t3)
                return u2.error("Numeric branch labels must be integer values.");
              if (r2) {
                if (u2.checkSubtype(r2, ne(t3)))
                  return null;
              } else
                r2 = ne(t3);
              if (i2[String(t3)] !== undefined)
                return u2.error("Branch labels must be unique.");
              i2[String(t3)] = s2.length;
            }
            const c2 = e2.parse(l2, a3, n2);
            if (!c2)
              return null;
            n2 = n2 || c2.type, s2.push(c2);
          }
          const a2 = e2.parse(t2[1], 1, dt);
          if (!a2)
            return null;
          const o2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
          return o2 ? a2.type.kind !== "value" && e2.concat(1).checkSubtype(r2, a2.type) ? null : new ve(r2, n2, a2, i2, s2, o2) : null;
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2);
          return (ne(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
        }
        eachChild(t2) {
          t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
        }
      }

      class be {
        constructor(t2, e2, r2) {
          this.type = t2, this.branches = e2, this.otherwise = r2;
        }
        static parse(t2, e2) {
          if (t2.length < 4)
            return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
          if (t2.length % 2 != 0)
            return e2.error("Expected an odd number of arguments.");
          let r2;
          e2.expectedType && e2.expectedType.kind !== "value" && (r2 = e2.expectedType);
          const n2 = [];
          for (let i3 = 1;i3 < t2.length - 1; i3 += 2) {
            const s2 = e2.parse(t2[i3], i3, ht);
            if (!s2)
              return null;
            const a2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
            if (!a2)
              return null;
            n2.push([s2, a2]), r2 = r2 || a2.type;
          }
          const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
          if (!i2)
            return null;
          if (!r2)
            throw new Error("Can't infer output type");
          return new be(r2, n2, i2);
        }
        evaluate(t2) {
          for (const [e2, r2] of this.branches)
            if (e2.evaluate(t2))
              return r2.evaluate(t2);
          return this.otherwise.evaluate(t2);
        }
        eachChild(t2) {
          for (const [e2, r2] of this.branches)
            t2(e2), t2(r2);
          t2(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
        }
      }

      class we {
        constructor(t2, e2, r2, n2) {
          this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
        }
        static parse(t2, e2) {
          if (t2.length <= 2 || t2.length >= 5)
            return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1, dt), n2 = e2.parse(t2[2], 2, ut);
          if (!r2 || !n2)
            return null;
          if (!St(r2.type, [bt(dt), ct, dt]))
            return e2.error(`Expected first argument to be of type array or string, but found ${wt(r2.type)} instead`);
          if (t2.length === 4) {
            const i2 = e2.parse(t2[3], 3, ut);
            return i2 ? new we(r2.type, r2, n2, i2) : null;
          }
          return new we(r2.type, r2, n2);
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
          let n2;
          if (this.endIndex && (n2 = this.endIndex.evaluate(t2)), kt(e2, ["string"]))
            return [...e2].slice(r2, n2).join("");
          if (kt(e2, ["array"]))
            return e2.slice(r2, n2);
          throw new ae(`Expected first argument to be of type array or string, but found ${wt(ne(e2))} instead.`);
        }
        eachChild(t2) {
          t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
        }
        outputDefined() {
          return false;
        }
      }
      function _e(t2, e2) {
        const r2 = t2.length - 1;
        let n2, i2, s2 = 0, a2 = r2, o2 = 0;
        for (;s2 <= a2; )
          if (o2 = Math.floor((s2 + a2) / 2), n2 = t2[o2], i2 = t2[o2 + 1], n2 <= e2) {
            if (o2 === r2 || e2 < i2)
              return o2;
            s2 = o2 + 1;
          } else {
            if (!(n2 > e2))
              throw new ae("Input is not a number.");
            a2 = o2 - 1;
          }
        return 0;
      }

      class Ae {
        constructor(t2, e2, r2) {
          this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
          for (const [t3, e3] of r2)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static parse(t2, e2) {
          if (t2.length - 1 < 4)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if ((t2.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          const r2 = e2.parse(t2[1], 1, ut);
          if (!r2)
            return null;
          const n2 = [];
          let i2 = null;
          e2.expectedType && e2.expectedType.kind !== "value" && (i2 = e2.expectedType);
          for (let r3 = 1;r3 < t2.length; r3 += 2) {
            const s2 = r3 === 1 ? -1 / 0 : t2[r3], a2 = t2[r3 + 1], o2 = r3, l2 = r3 + 1;
            if (typeof s2 != "number")
              return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o2);
            if (n2.length && n2[n2.length - 1][0] >= s2)
              return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o2);
            const u2 = e2.parse(a2, l2, i2);
            if (!u2)
              return null;
            i2 = i2 || u2.type, n2.push([s2, u2]);
          }
          return new Ae(i2, r2, n2);
        }
        evaluate(t2) {
          const e2 = this.labels, r2 = this.outputs;
          if (e2.length === 1)
            return r2[0].evaluate(t2);
          const n2 = this.input.evaluate(t2);
          if (n2 <= e2[0])
            return r2[0].evaluate(t2);
          const i2 = e2.length;
          return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[_e(e2, n2)].evaluate(t2);
        }
        eachChild(t2) {
          t2(this.input);
          for (const e2 of this.outputs)
            t2(e2);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined());
        }
      }
      function Se(t2) {
        return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
      }
      var ke = Me;
      function Me(t2, e2, r2, n2) {
        this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = e2, this.p2x = r2, this.p2y = n2;
      }
      Me.prototype = {
        sampleCurveX: function(t2) {
          return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
        },
        sampleCurveY: function(t2) {
          return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
        },
        sampleCurveDerivativeX: function(t2) {
          return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
        },
        solveCurveX: function(t2, e2) {
          if (e2 === undefined && (e2 = 0.000001), t2 < 0)
            return 0;
          if (t2 > 1)
            return 1;
          for (var r2 = t2, n2 = 0;n2 < 8; n2++) {
            var i2 = this.sampleCurveX(r2) - t2;
            if (Math.abs(i2) < e2)
              return r2;
            var s2 = this.sampleCurveDerivativeX(r2);
            if (Math.abs(s2) < 0.000001)
              break;
            r2 -= i2 / s2;
          }
          var a2 = 0, o2 = 1;
          for (r2 = t2, n2 = 0;n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t2) < e2)); n2++)
            t2 > i2 ? a2 = r2 : o2 = r2, r2 = 0.5 * (o2 - a2) + a2;
          return r2;
        },
        solve: function(t2, e2) {
          return this.sampleCurveY(this.solveCurveX(t2, e2));
        }
      };
      var Ie = Se(ke);
      function ze(t2, e2, r2) {
        return t2 + r2 * (e2 - t2);
      }
      function Pe(t2, e2, r2) {
        return t2.map((t3, n2) => ze(t3, e2[n2], r2));
      }
      const Ce = {
        number: ze,
        color: function(t2, e2, r2, n2 = "rgb") {
          switch (n2) {
            case "rgb": {
              const [n3, i2, s2, a2] = Pe(t2.rgb, e2.rgb, r2);
              return new Kt(n3, i2, s2, a2, false);
            }
            case "hcl": {
              const [n3, i2, s2, a2] = t2.hcl, [o2, l2, u2, c2] = e2.hcl;
              let h2, p2;
              if (isNaN(n3) || isNaN(o2))
                isNaN(n3) ? isNaN(o2) ? h2 = NaN : (h2 = o2, s2 !== 1 && s2 !== 0 || (p2 = l2)) : (h2 = n3, u2 !== 1 && u2 !== 0 || (p2 = i2));
              else {
                let t3 = o2 - n3;
                o2 > n3 && t3 > 180 ? t3 -= 360 : o2 < n3 && n3 - o2 > 180 && (t3 += 360), h2 = n3 + r2 * t3;
              }
              const [f2, d2, y2, m2] = function([t3, e3, r3, n4]) {
                return t3 = isNaN(t3) ? 0 : t3 * Et, Ot([r3, Math.cos(t3) * e3, Math.sin(t3) * e3, n4]);
              }([h2, p2 != null ? p2 : ze(i2, l2, r2), ze(s2, u2, r2), ze(a2, c2, r2)]);
              return new Kt(f2, d2, y2, m2, false);
            }
            case "lab": {
              const [n3, i2, s2, a2] = Ot(Pe(t2.lab, e2.lab, r2));
              return new Kt(n3, i2, s2, a2, false);
            }
          }
        },
        array: Pe,
        padding: function(t2, e2, r2) {
          return new Jt(Pe(t2.values, e2.values, r2));
        },
        variableAnchorOffsetCollection: function(t2, e2, r2) {
          const n2 = t2.values, i2 = e2.values;
          if (n2.length !== i2.length)
            throw new ae(`Cannot interpolate values of different length. from: ${t2.toString()}, to: ${e2.toString()}`);
          const s2 = [];
          for (let t3 = 0;t3 < n2.length; t3 += 2) {
            if (n2[t3] !== i2[t3])
              throw new ae(`Cannot interpolate values containing mismatched anchors. from[${t3}]: ${n2[t3]}, to[${t3}]: ${i2[t3]}`);
            s2.push(n2[t3]);
            const [e3, a2] = n2[t3 + 1], [o2, l2] = i2[t3 + 1];
            s2.push([ze(e3, o2, r2), ze(a2, l2, r2)]);
          }
          return new Qt(s2);
        }
      };

      class Be {
        constructor(t2, e2, r2, n2, i2) {
          this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
          for (const [t3, e3] of i2)
            this.labels.push(t3), this.outputs.push(e3);
        }
        static interpolationFactor(t2, e2, r2, n2) {
          let i2 = 0;
          if (t2.name === "exponential")
            i2 = Ve(e2, t2.base, r2, n2);
          else if (t2.name === "linear")
            i2 = Ve(e2, 1, r2, n2);
          else if (t2.name === "cubic-bezier") {
            const s2 = t2.controlPoints;
            i2 = new Ie(s2[0], s2[1], s2[2], s2[3]).solve(Ve(e2, 1, r2, n2));
          }
          return i2;
        }
        static parse(t2, e2) {
          let [r2, n2, i2, ...s2] = t2;
          if (!Array.isArray(n2) || n2.length === 0)
            return e2.error("Expected an interpolation type expression.", 1);
          if (n2[0] === "linear")
            n2 = { name: "linear" };
          else if (n2[0] === "exponential") {
            const t3 = n2[1];
            if (typeof t3 != "number")
              return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
            n2 = { name: "exponential", base: t3 };
          } else {
            if (n2[0] !== "cubic-bezier")
              return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
            {
              const t3 = n2.slice(1);
              if (t3.length !== 4 || t3.some((t4) => typeof t4 != "number" || t4 < 0 || t4 > 1))
                return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              n2 = { name: "cubic-bezier", controlPoints: t3 };
            }
          }
          if (t2.length - 1 < 4)
            return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
          if ((t2.length - 1) % 2 != 0)
            return e2.error("Expected an even number of arguments.");
          if (i2 = e2.parse(i2, 2, ut), !i2)
            return null;
          const a2 = [];
          let o2 = null;
          r2 === "interpolate-hcl" || r2 === "interpolate-lab" ? o2 = pt : e2.expectedType && e2.expectedType.kind !== "value" && (o2 = e2.expectedType);
          for (let t3 = 0;t3 < s2.length; t3 += 2) {
            const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
            if (typeof r3 != "number")
              return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
            if (a2.length && a2[a2.length - 1][0] >= r3)
              return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
            const u2 = e2.parse(n3, l2, o2);
            if (!u2)
              return null;
            o2 = o2 || u2.type, a2.push([r3, u2]);
          }
          return Mt(o2, ut) || Mt(o2, pt) || Mt(o2, gt) || Mt(o2, vt) || Mt(o2, bt(ut)) ? new Be(o2, r2, n2, i2, a2) : e2.error(`Type ${wt(o2)} is not interpolatable.`);
        }
        evaluate(t2) {
          const e2 = this.labels, r2 = this.outputs;
          if (e2.length === 1)
            return r2[0].evaluate(t2);
          const n2 = this.input.evaluate(t2);
          if (n2 <= e2[0])
            return r2[0].evaluate(t2);
          const i2 = e2.length;
          if (n2 >= e2[i2 - 1])
            return r2[i2 - 1].evaluate(t2);
          const s2 = _e(e2, n2), a2 = Be.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), o2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
          switch (this.operator) {
            case "interpolate":
              return Ce[this.type.kind](o2, l2, a2);
            case "interpolate-hcl":
              return Ce.color(o2, l2, a2, "hcl");
            case "interpolate-lab":
              return Ce.color(o2, l2, a2, "lab");
          }
        }
        eachChild(t2) {
          t2(this.input);
          for (const e2 of this.outputs)
            t2(e2);
        }
        outputDefined() {
          return this.outputs.every((t2) => t2.outputDefined());
        }
      }
      function Ve(t2, e2, r2, n2) {
        const i2 = n2 - r2, s2 = t2 - r2;
        return i2 === 0 ? 0 : e2 === 1 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
      }

      class Ee {
        constructor(t2, e2) {
          this.type = t2, this.args = e2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expectected at least one argument.");
          let r2 = null;
          const n2 = e2.expectedType;
          n2 && n2.kind !== "value" && (r2 = n2);
          const i2 = [];
          for (const n3 of t2.slice(1)) {
            const t3 = e2.parse(n3, 1 + i2.length, r2, undefined, { typeAnnotation: "omit" });
            if (!t3)
              return null;
            r2 = r2 || t3.type, i2.push(t3);
          }
          if (!r2)
            throw new Error("No output type");
          const s2 = n2 && i2.some((t3) => At(n2, t3.type));
          return new Ee(s2 ? dt : r2, i2);
        }
        evaluate(t2) {
          let e2, r2 = null, n2 = 0;
          for (const i2 of this.args)
            if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof te && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), r2 !== null)
              break;
          return r2;
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return this.args.every((t2) => t2.outputDefined());
        }
      }
      function Fe(t2, e2) {
        return t2 === "==" || t2 === "!=" ? e2.kind === "boolean" || e2.kind === "string" || e2.kind === "number" || e2.kind === "null" || e2.kind === "value" : e2.kind === "string" || e2.kind === "number" || e2.kind === "value";
      }
      function Te(t2, e2, r2, n2) {
        return n2.compare(e2, r2) === 0;
      }
      function $e(t2, e2, r2) {
        const n2 = t2 !== "==" && t2 !== "!=";
        return class i2 {
          constructor(t3, e3, r3) {
            this.type = ht, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = t3.type.kind === "value" || e3.type.kind === "value";
          }
          static parse(t3, e3) {
            if (t3.length !== 3 && t3.length !== 4)
              return e3.error("Expected two or three arguments.");
            const r3 = t3[0];
            let s2 = e3.parse(t3[1], 1, dt);
            if (!s2)
              return null;
            if (!Fe(r3, s2.type))
              return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${wt(s2.type)}'.`);
            let a2 = e3.parse(t3[2], 2, dt);
            if (!a2)
              return null;
            if (!Fe(r3, a2.type))
              return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${wt(a2.type)}'.`);
            if (s2.type.kind !== a2.type.kind && s2.type.kind !== "value" && a2.type.kind !== "value")
              return e3.error(`Cannot compare types '${wt(s2.type)}' and '${wt(a2.type)}'.`);
            n2 && (s2.type.kind === "value" && a2.type.kind !== "value" ? s2 = new le(a2.type, [s2]) : s2.type.kind !== "value" && a2.type.kind === "value" && (a2 = new le(s2.type, [a2])));
            let o2 = null;
            if (t3.length === 4) {
              if (s2.type.kind !== "string" && a2.type.kind !== "string" && s2.type.kind !== "value" && a2.type.kind !== "value")
                return e3.error("Cannot use collator to compare non-string types.");
              if (o2 = e3.parse(t3[3], 3, yt), !o2)
                return null;
            }
            return new i2(s2, a2, o2);
          }
          evaluate(i3) {
            const s2 = this.lhs.evaluate(i3), a2 = this.rhs.evaluate(i3);
            if (n2 && this.hasUntypedArgument) {
              const e3 = ne(s2), r3 = ne(a2);
              if (e3.kind !== r3.kind || e3.kind !== "string" && e3.kind !== "number")
                throw new ae(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
            }
            if (this.collator && !n2 && this.hasUntypedArgument) {
              const t3 = ne(s2), r3 = ne(a2);
              if (t3.kind !== "string" || r3.kind !== "string")
                return e2(i3, s2, a2);
            }
            return this.collator ? r2(i3, s2, a2, this.collator.evaluate(i3)) : e2(i3, s2, a2);
          }
          eachChild(t3) {
            t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
          }
          outputDefined() {
            return true;
          }
        };
      }
      const Le = $e("==", function(t2, e2, r2) {
        return e2 === r2;
      }, Te), De = $e("!=", function(t2, e2, r2) {
        return e2 !== r2;
      }, function(t2, e2, r2, n2) {
        return !Te(0, e2, r2, n2);
      }), Oe = $e("<", function(t2, e2, r2) {
        return e2 < r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) < 0;
      }), je = $e(">", function(t2, e2, r2) {
        return e2 > r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) > 0;
      }), Re = $e("<=", function(t2, e2, r2) {
        return e2 <= r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) <= 0;
      }), Ue = $e(">=", function(t2, e2, r2) {
        return e2 >= r2;
      }, function(t2, e2, r2, n2) {
        return n2.compare(e2, r2) >= 0;
      });

      class qe {
        constructor(t2, e2, r2) {
          this.type = yt, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error("Expected one argument.");
          const r2 = t2[1];
          if (typeof r2 != "object" || Array.isArray(r2))
            return e2.error("Collator options argument must be an object.");
          const n2 = e2.parse(r2["case-sensitive"] !== undefined && r2["case-sensitive"], 1, ht);
          if (!n2)
            return null;
          const i2 = e2.parse(r2["diacritic-sensitive"] !== undefined && r2["diacritic-sensitive"], 1, ht);
          if (!i2)
            return null;
          let s2 = null;
          return r2.locale && (s2 = e2.parse(r2.locale, 1, ct), !s2) ? null : new qe(n2, i2, s2);
        }
        evaluate(t2) {
          return new Xt(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
        }
        eachChild(t2) {
          t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
        }
        outputDefined() {
          return false;
        }
      }

      class Ne {
        constructor(t2, e2, r2, n2, i2) {
          this.type = ct, this.number = t2, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
        }
        static parse(t2, e2) {
          if (t2.length !== 3)
            return e2.error("Expected two arguments.");
          const r2 = e2.parse(t2[1], 1, ut);
          if (!r2)
            return null;
          const n2 = t2[2];
          if (typeof n2 != "object" || Array.isArray(n2))
            return e2.error("NumberFormat options argument must be an object.");
          let i2 = null;
          if (n2.locale && (i2 = e2.parse(n2.locale, 1, ct), !i2))
            return null;
          let s2 = null;
          if (n2.currency && (s2 = e2.parse(n2.currency, 1, ct), !s2))
            return null;
          let a2 = null;
          if (n2["min-fraction-digits"] && (a2 = e2.parse(n2["min-fraction-digits"], 1, ut), !a2))
            return null;
          let o2 = null;
          return n2["max-fraction-digits"] && (o2 = e2.parse(n2["max-fraction-digits"], 1, ut), !o2) ? null : new Ne(r2, i2, s2, a2, o2);
        }
        evaluate(t2) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], {
            style: this.currency ? "currency" : "decimal",
            currency: this.currency ? this.currency.evaluate(t2) : undefined,
            minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : undefined,
            maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : undefined
          }).format(this.number.evaluate(t2));
        }
        eachChild(t2) {
          t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
        }
        outputDefined() {
          return false;
        }
      }

      class Ze {
        constructor(t2) {
          this.type = mt, this.sections = t2;
        }
        static parse(t2, e2) {
          if (t2.length < 2)
            return e2.error("Expected at least one argument.");
          const r2 = t2[1];
          if (!Array.isArray(r2) && typeof r2 == "object")
            return e2.error("First argument must be an image or text section.");
          const n2 = [];
          let i2 = false;
          for (let r3 = 1;r3 <= t2.length - 1; ++r3) {
            const s2 = t2[r3];
            if (i2 && typeof s2 == "object" && !Array.isArray(s2)) {
              i2 = false;
              let t3 = null;
              if (s2["font-scale"] && (t3 = e2.parse(s2["font-scale"], 1, ut), !t3))
                return null;
              let r4 = null;
              if (s2["text-font"] && (r4 = e2.parse(s2["text-font"], 1, bt(ct)), !r4))
                return null;
              let a2 = null;
              if (s2["text-color"] && (a2 = e2.parse(s2["text-color"], 1, pt), !a2))
                return null;
              const o2 = n2[n2.length - 1];
              o2.scale = t3, o2.font = r4, o2.textColor = a2;
            } else {
              const s3 = e2.parse(t2[r3], 1, dt);
              if (!s3)
                return null;
              const a2 = s3.type.kind;
              if (a2 !== "string" && a2 !== "value" && a2 !== "null" && a2 !== "resolvedImage")
                return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
            }
          }
          return new Ze(n2);
        }
        evaluate(t2) {
          return new Yt(this.sections.map((e2) => {
            const r2 = e2.content.evaluate(t2);
            return ne(r2) === xt ? new Ht("", r2, null, null, null) : new Ht(ie(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
          }));
        }
        eachChild(t2) {
          for (const e2 of this.sections)
            t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
        }
        outputDefined() {
          return false;
        }
      }

      class Ge {
        constructor(t2) {
          this.type = xt, this.input = t2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error("Expected two arguments.");
          const r2 = e2.parse(t2[1], 1, ct);
          return r2 ? new Ge(r2) : e2.error("No image name provided.");
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2), r2 = te.fromString(e2);
          return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
        }
        eachChild(t2) {
          t2(this.input);
        }
        outputDefined() {
          return false;
        }
      }

      class Ke {
        constructor(t2) {
          this.type = ut, this.input = t2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
          const r2 = e2.parse(t2[1], 1);
          return r2 ? r2.type.kind !== "array" && r2.type.kind !== "string" && r2.type.kind !== "value" ? e2.error(`Expected argument of type string or array, but found ${wt(r2.type)} instead.`) : new Ke(r2) : null;
        }
        evaluate(t2) {
          const e2 = this.input.evaluate(t2);
          if (typeof e2 == "string")
            return [...e2].length;
          if (Array.isArray(e2))
            return e2.length;
          throw new ae(`Expected value to be of type string or array, but found ${wt(ne(e2))} instead.`);
        }
        eachChild(t2) {
          t2(this.input);
        }
        outputDefined() {
          return false;
        }
      }
      const Xe = 8192;
      function He(t2, e2) {
        const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
        return [Math.round(r2 * i2 * Xe), Math.round(n2 * i2 * Xe)];
      }
      function Ye(t2, e2) {
        const r2 = Math.pow(2, e2.z);
        return [
          (i2 = (t2[0] / Xe + e2.x) / r2, 360 * i2 - 180),
          (n2 = (t2[1] / Xe + e2.y) / r2, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * n2) * Math.PI / 180)) - 90)
        ];
        var n2, i2;
      }
      function Je(t2, e2) {
        t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
      }
      function We(t2, e2) {
        return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
      }
      function Qe(t2, e2, r2) {
        const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], a2 = t2[1] - r2[1];
        return n2 * a2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * a2 <= 0;
      }
      function tr(t2, e2, r2, n2) {
        return (i2 = [n2[0] - r2[0], n2[1] - r2[1]])[0] * (s2 = [e2[0] - t2[0], e2[1] - t2[1]])[1] - i2[1] * s2[0] != 0 && !(!ar(t2, e2, r2, n2) || !ar(r2, n2, t2, e2));
        var i2, s2;
      }
      function er(t2, e2, r2) {
        for (const n2 of r2)
          for (let r3 = 0;r3 < n2.length - 1; ++r3)
            if (tr(t2, e2, n2[r3], n2[r3 + 1]))
              return true;
        return false;
      }
      function rr(t2, e2, r2 = false) {
        let n2 = false;
        for (const o2 of e2)
          for (let e3 = 0;e3 < o2.length - 1; e3++) {
            if (Qe(t2, o2[e3], o2[e3 + 1]))
              return r2;
            (s2 = o2[e3])[1] > (i2 = t2)[1] != (a2 = o2[e3 + 1])[1] > i2[1] && i2[0] < (a2[0] - s2[0]) * (i2[1] - s2[1]) / (a2[1] - s2[1]) + s2[0] && (n2 = !n2);
          }
        var i2, s2, a2;
        return n2;
      }
      function nr(t2, e2) {
        for (const r2 of e2)
          if (rr(t2, r2))
            return true;
        return false;
      }
      function ir(t2, e2) {
        for (const r2 of t2)
          if (!rr(r2, e2))
            return false;
        for (let r2 = 0;r2 < t2.length - 1; ++r2)
          if (er(t2[r2], t2[r2 + 1], e2))
            return false;
        return true;
      }
      function sr(t2, e2) {
        for (const r2 of e2)
          if (ir(t2, r2))
            return true;
        return false;
      }
      function ar(t2, e2, r2, n2) {
        const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], a2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), o2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
        return a2 > 0 && o2 < 0 || a2 < 0 && o2 > 0;
      }
      function or(t2, e2, r2) {
        const n2 = [];
        for (let i2 = 0;i2 < t2.length; i2++) {
          const s2 = [];
          for (let n3 = 0;n3 < t2[i2].length; n3++) {
            const a2 = He(t2[i2][n3], r2);
            Je(e2, a2), s2.push(a2);
          }
          n2.push(s2);
        }
        return n2;
      }
      function lr(t2, e2, r2) {
        const n2 = [];
        for (let i2 = 0;i2 < t2.length; i2++) {
          const s2 = or(t2[i2], e2, r2);
          n2.push(s2);
        }
        return n2;
      }
      function ur(t2, e2, r2, n2) {
        if (t2[0] < r2[0] || t2[0] > r2[2]) {
          const e3 = 0.5 * n2;
          let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
          i2 === 0 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
        }
        Je(e2, t2);
      }
      function cr(t2, e2, r2, n2) {
        const i2 = Math.pow(2, n2.z) * Xe, s2 = [n2.x * Xe, n2.y * Xe], a2 = [];
        for (const n3 of t2)
          for (const t3 of n3) {
            const n4 = [t3.x + s2[0], t3.y + s2[1]];
            ur(n4, e2, r2, i2), a2.push(n4);
          }
        return a2;
      }
      function hr(t2, e2, r2, n2) {
        const i2 = Math.pow(2, n2.z) * Xe, s2 = [n2.x * Xe, n2.y * Xe], a2 = [];
        for (const r3 of t2) {
          const t3 = [];
          for (const n3 of r3) {
            const r4 = [n3.x + s2[0], n3.y + s2[1]];
            Je(e2, r4), t3.push(r4);
          }
          a2.push(t3);
        }
        if (e2[2] - e2[0] <= i2 / 2) {
          (o2 = e2)[0] = o2[1] = 1 / 0, o2[2] = o2[3] = -1 / 0;
          for (const t3 of a2)
            for (const n3 of t3)
              ur(n3, e2, r2, i2);
        }
        var o2;
        return a2;
      }

      class pr {
        constructor(t2, e2) {
          this.type = ht, this.geojson = t2, this.geometries = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (re(t2[1])) {
            const e3 = t2[1];
            if (e3.type === "FeatureCollection") {
              const t3 = [];
              for (const r2 of e3.features) {
                const { type: e4, coordinates: n2 } = r2.geometry;
                e4 === "Polygon" && t3.push(n2), e4 === "MultiPolygon" && t3.push(...n2);
              }
              if (t3.length)
                return new pr(e3, { type: "MultiPolygon", coordinates: t3 });
            } else if (e3.type === "Feature") {
              const t3 = e3.geometry.type;
              if (t3 === "Polygon" || t3 === "MultiPolygon")
                return new pr(e3, e3.geometry);
            } else if (e3.type === "Polygon" || e3.type === "MultiPolygon")
              return new pr(e3, e3);
          }
          return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t2) {
          if (t2.geometry() != null && t2.canonicalID() != null) {
            if (t2.geometryType() === "Point")
              return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (e2.type === "Polygon") {
                  const s2 = or(e2.coordinates, n2, i2), a2 = cr(t3.geometry(), r2, n2, i2);
                  if (!We(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!rr(t4, s2))
                      return false;
                }
                if (e2.type === "MultiPolygon") {
                  const s2 = lr(e2.coordinates, n2, i2), a2 = cr(t3.geometry(), r2, n2, i2);
                  if (!We(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!nr(t4, s2))
                      return false;
                }
                return true;
              }(t2, this.geometries);
            if (t2.geometryType() === "LineString")
              return function(t3, e2) {
                const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                if (e2.type === "Polygon") {
                  const s2 = or(e2.coordinates, n2, i2), a2 = hr(t3.geometry(), r2, n2, i2);
                  if (!We(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!ir(t4, s2))
                      return false;
                }
                if (e2.type === "MultiPolygon") {
                  const s2 = lr(e2.coordinates, n2, i2), a2 = hr(t3.geometry(), r2, n2, i2);
                  if (!We(r2, n2))
                    return false;
                  for (const t4 of a2)
                    if (!sr(t4, s2))
                      return false;
                }
                return true;
              }(t2, this.geometries);
          }
          return false;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }
      let fr = class {
        constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
          if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
            for (let t3 = (this.length >> 1) - 1;t3 >= 0; t3--)
              this._down(t3);
        }
        push(t2) {
          this.data.push(t2), this._up(this.length++);
        }
        pop() {
          if (this.length === 0)
            return;
          const t2 = this.data[0], e2 = this.data.pop();
          return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
        }
        peek() {
          return this.data[0];
        }
        _up(t2) {
          const { data: e2, compare: r2 } = this, n2 = e2[t2];
          for (;t2 > 0; ) {
            const i2 = t2 - 1 >> 1, s2 = e2[i2];
            if (r2(n2, s2) >= 0)
              break;
            e2[t2] = s2, t2 = i2;
          }
          e2[t2] = n2;
        }
        _down(t2) {
          const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
          for (;t2 < n2; ) {
            let n3 = 1 + (t2 << 1);
            const s2 = n3 + 1;
            if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0)
              break;
            e2[t2] = e2[n3], t2 = n3;
          }
          e2[t2] = i2;
        }
      };
      function dr(t2, e2, r2, n2, i2) {
        yr(t2, e2, r2, n2 || t2.length - 1, i2 || gr);
      }
      function yr(t2, e2, r2, n2, i2) {
        for (;n2 > r2; ) {
          if (n2 - r2 > 600) {
            var s2 = n2 - r2 + 1, a2 = e2 - r2 + 1, o2 = Math.log(s2), l2 = 0.5 * Math.exp(2 * o2 / 3), u2 = 0.5 * Math.sqrt(o2 * l2 * (s2 - l2) / s2) * (a2 - s2 / 2 < 0 ? -1 : 1);
            yr(t2, e2, Math.max(r2, Math.floor(e2 - a2 * l2 / s2 + u2)), Math.min(n2, Math.floor(e2 + (s2 - a2) * l2 / s2 + u2)), i2);
          }
          var c2 = t2[e2], h2 = r2, p2 = n2;
          for (mr(t2, r2, e2), i2(t2[n2], c2) > 0 && mr(t2, r2, n2);h2 < p2; ) {
            for (mr(t2, h2, p2), h2++, p2--;i2(t2[h2], c2) < 0; )
              h2++;
            for (;i2(t2[p2], c2) > 0; )
              p2--;
          }
          i2(t2[r2], c2) === 0 ? mr(t2, r2, p2) : mr(t2, ++p2, n2), p2 <= e2 && (r2 = p2 + 1), e2 <= p2 && (n2 = p2 - 1);
        }
      }
      function mr(t2, e2, r2) {
        var n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      function gr(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function xr(t2, e2) {
        if (t2.length <= 1)
          return [t2];
        const r2 = [];
        let n2, i2;
        for (const e3 of t2) {
          const t3 = br(e3);
          t3 !== 0 && (e3.area = Math.abs(t3), i2 === undefined && (i2 = t3 < 0), i2 === t3 < 0 ? (n2 && r2.push(n2), n2 = [e3]) : n2.push(e3));
        }
        if (n2 && r2.push(n2), e2 > 1)
          for (let t3 = 0;t3 < r2.length; t3++)
            r2[t3].length <= e2 || (dr(r2[t3], e2, 1, r2[t3].length - 1, vr), r2[t3] = r2[t3].slice(0, e2));
        return r2;
      }
      function vr(t2, e2) {
        return e2.area - t2.area;
      }
      function br(t2) {
        let e2 = 0;
        for (let r2, n2, i2 = 0, s2 = t2.length, a2 = s2 - 1;i2 < s2; a2 = i2++)
          r2 = t2[i2], n2 = t2[a2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
        return e2;
      }
      const wr = 1 / 298.257223563, _r = wr * (2 - wr), Ar = Math.PI / 180;

      class Sr {
        constructor(t2) {
          const e2 = 6378.137 * Ar * 1000, r2 = Math.cos(t2 * Ar), n2 = 1 / (1 - _r * (1 - r2 * r2)), i2 = Math.sqrt(n2);
          this.kx = e2 * i2 * r2, this.ky = e2 * i2 * n2 * (1 - _r);
        }
        distance(t2, e2) {
          const r2 = this.wrap(t2[0] - e2[0]) * this.kx, n2 = (t2[1] - e2[1]) * this.ky;
          return Math.sqrt(r2 * r2 + n2 * n2);
        }
        pointOnLine(t2, e2) {
          let r2, n2, i2, s2, a2 = 1 / 0;
          for (let o2 = 0;o2 < t2.length - 1; o2++) {
            let l2 = t2[o2][0], u2 = t2[o2][1], c2 = this.wrap(t2[o2 + 1][0] - l2) * this.kx, h2 = (t2[o2 + 1][1] - u2) * this.ky, p2 = 0;
            c2 === 0 && h2 === 0 || (p2 = (this.wrap(e2[0] - l2) * this.kx * c2 + (e2[1] - u2) * this.ky * h2) / (c2 * c2 + h2 * h2), p2 > 1 ? (l2 = t2[o2 + 1][0], u2 = t2[o2 + 1][1]) : p2 > 0 && (l2 += c2 / this.kx * p2, u2 += h2 / this.ky * p2)), c2 = this.wrap(e2[0] - l2) * this.kx, h2 = (e2[1] - u2) * this.ky;
            const f2 = c2 * c2 + h2 * h2;
            f2 < a2 && (a2 = f2, r2 = l2, n2 = u2, i2 = o2, s2 = p2);
          }
          return { point: [r2, n2], index: i2, t: Math.max(0, Math.min(1, s2)) };
        }
        wrap(t2) {
          for (;t2 < -180; )
            t2 += 360;
          for (;t2 > 180; )
            t2 -= 360;
          return t2;
        }
      }
      function kr(t2, e2) {
        return e2[0] - t2[0];
      }
      function Mr(t2) {
        return t2[1] - t2[0] + 1;
      }
      function Ir(t2, e2) {
        return t2[1] >= t2[0] && t2[1] < e2;
      }
      function zr(t2, e2) {
        if (t2[0] > t2[1])
          return [null, null];
        const r2 = Mr(t2);
        if (e2) {
          if (r2 === 2)
            return [t2, null];
          const e3 = Math.floor(r2 / 2);
          return [
            [t2[0], t2[0] + e3],
            [t2[0] + e3, t2[1]]
          ];
        }
        if (r2 === 1)
          return [t2, null];
        const n2 = Math.floor(r2 / 2) - 1;
        return [
          [t2[0], t2[0] + n2],
          [t2[0] + n2 + 1, t2[1]]
        ];
      }
      function Pr(t2, e2) {
        if (!Ir(e2, t2.length))
          return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let n2 = e2[0];n2 <= e2[1]; ++n2)
          Je(r2, t2[n2]);
        return r2;
      }
      function Cr(t2) {
        const e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const r2 of t2)
          for (const t3 of r2)
            Je(e2, t3);
        return e2;
      }
      function Br(t2) {
        return t2[0] !== -1 / 0 && t2[1] !== -1 / 0 && t2[2] !== 1 / 0 && t2[3] !== 1 / 0;
      }
      function Vr(t2, e2, r2) {
        if (!Br(t2) || !Br(e2))
          return NaN;
        let n2 = 0, i2 = 0;
        return t2[2] < e2[0] && (n2 = e2[0] - t2[2]), t2[0] > e2[2] && (n2 = t2[0] - e2[2]), t2[1] > e2[3] && (i2 = t2[1] - e2[3]), t2[3] < e2[1] && (i2 = e2[1] - t2[3]), r2.distance([0, 0], [n2, i2]);
      }
      function Er(t2, e2, r2) {
        const n2 = r2.pointOnLine(e2, t2);
        return r2.distance(t2, n2.point);
      }
      function Fr(t2, e2, r2, n2, i2) {
        const s2 = Math.min(Er(t2, [r2, n2], i2), Er(e2, [r2, n2], i2)), a2 = Math.min(Er(r2, [t2, e2], i2), Er(n2, [t2, e2], i2));
        return Math.min(s2, a2);
      }
      function Tr(t2, e2, r2, n2, i2) {
        if (!Ir(e2, t2.length) || !Ir(n2, r2.length))
          return 1 / 0;
        let s2 = 1 / 0;
        for (let a2 = e2[0];a2 < e2[1]; ++a2) {
          const e3 = t2[a2], o2 = t2[a2 + 1];
          for (let t3 = n2[0];t3 < n2[1]; ++t3) {
            const n3 = r2[t3], a3 = r2[t3 + 1];
            if (tr(e3, o2, n3, a3))
              return 0;
            s2 = Math.min(s2, Fr(e3, o2, n3, a3, i2));
          }
        }
        return s2;
      }
      function $r(t2, e2, r2, n2, i2) {
        if (!Ir(e2, t2.length) || !Ir(n2, r2.length))
          return NaN;
        let s2 = 1 / 0;
        for (let a2 = e2[0];a2 <= e2[1]; ++a2)
          for (let e3 = n2[0];e3 <= n2[1]; ++e3)
            if (s2 = Math.min(s2, i2.distance(t2[a2], r2[e3])), s2 === 0)
              return s2;
        return s2;
      }
      function Lr(t2, e2, r2) {
        if (rr(t2, e2, true))
          return 0;
        let n2 = 1 / 0;
        for (const i2 of e2) {
          const e3 = i2[0], s2 = i2[i2.length - 1];
          if (e3 !== s2 && (n2 = Math.min(n2, Er(t2, [s2, e3], r2)), n2 === 0))
            return n2;
          const a2 = r2.pointOnLine(i2, t2);
          if (n2 = Math.min(n2, r2.distance(t2, a2.point)), n2 === 0)
            return n2;
        }
        return n2;
      }
      function Dr(t2, e2, r2, n2) {
        if (!Ir(e2, t2.length))
          return NaN;
        for (let n3 = e2[0];n3 <= e2[1]; ++n3)
          if (rr(t2[n3], r2, true))
            return 0;
        let i2 = 1 / 0;
        for (let s2 = e2[0];s2 < e2[1]; ++s2) {
          const e3 = t2[s2], a2 = t2[s2 + 1];
          for (const t3 of r2)
            for (let r3 = 0, s3 = t3.length, o2 = s3 - 1;r3 < s3; o2 = r3++) {
              const s4 = t3[o2], l2 = t3[r3];
              if (tr(e3, a2, s4, l2))
                return 0;
              i2 = Math.min(i2, Fr(e3, a2, s4, l2, n2));
            }
        }
        return i2;
      }
      function Or(t2, e2) {
        for (const r2 of t2)
          for (const t3 of r2)
            if (rr(t3, e2, true))
              return true;
        return false;
      }
      function jr(t2, e2, r2, n2 = 1 / 0) {
        const i2 = Cr(t2), s2 = Cr(e2);
        if (n2 !== 1 / 0 && Vr(i2, s2, r2) >= n2)
          return n2;
        if (We(i2, s2)) {
          if (Or(t2, e2))
            return 0;
        } else if (Or(e2, t2))
          return 0;
        let a2 = 1 / 0;
        for (const n3 of t2)
          for (let t3 = 0, i3 = n3.length, s3 = i3 - 1;t3 < i3; s3 = t3++) {
            const i4 = n3[s3], o2 = n3[t3];
            for (const t4 of e2)
              for (let e3 = 0, n4 = t4.length, s4 = n4 - 1;e3 < n4; s4 = e3++) {
                const n5 = t4[s4], l2 = t4[e3];
                if (tr(i4, o2, n5, l2))
                  return 0;
                a2 = Math.min(a2, Fr(i4, o2, n5, l2, r2));
              }
          }
        return a2;
      }
      function Rr(t2, e2, r2, n2, i2, s2) {
        if (!s2)
          return;
        const a2 = Vr(Pr(n2, s2), i2, r2);
        a2 < e2 && t2.push([a2, s2, [0, 0]]);
      }
      function Ur(t2, e2, r2, n2, i2, s2, a2) {
        if (!s2 || !a2)
          return;
        const o2 = Vr(Pr(n2, s2), Pr(i2, a2), r2);
        o2 < e2 && t2.push([o2, s2, a2]);
      }
      function qr(t2, e2, r2, n2, i2 = 1 / 0) {
        let s2 = Math.min(n2.distance(t2[0], r2[0][0]), i2);
        if (s2 === 0)
          return s2;
        const a2 = new fr([[0, [0, t2.length - 1], [0, 0]]], kr), o2 = Cr(r2);
        for (;a2.length > 0; ) {
          const i3 = a2.pop();
          if (i3[0] >= s2)
            continue;
          const l2 = i3[1], u2 = e2 ? 50 : 100;
          if (Mr(l2) <= u2) {
            if (!Ir(l2, t2.length))
              return NaN;
            if (e2) {
              const e3 = Dr(t2, l2, r2, n2);
              if (isNaN(e3) || e3 === 0)
                return e3;
              s2 = Math.min(s2, e3);
            } else
              for (let e3 = l2[0];e3 <= l2[1]; ++e3) {
                const i4 = Lr(t2[e3], r2, n2);
                if (s2 = Math.min(s2, i4), s2 === 0)
                  return 0;
              }
          } else {
            const r3 = zr(l2, e2);
            Rr(a2, s2, n2, t2, o2, r3[0]), Rr(a2, s2, n2, t2, o2, r3[1]);
          }
        }
        return s2;
      }
      function Nr(t2, e2, r2, n2, i2, s2 = 1 / 0) {
        let a2 = Math.min(s2, i2.distance(t2[0], r2[0]));
        if (a2 === 0)
          return a2;
        const o2 = new fr([[0, [0, t2.length - 1], [0, r2.length - 1]]], kr);
        for (;o2.length > 0; ) {
          const s3 = o2.pop();
          if (s3[0] >= a2)
            continue;
          const l2 = s3[1], u2 = s3[2], c2 = e2 ? 50 : 100, h2 = n2 ? 50 : 100;
          if (Mr(l2) <= c2 && Mr(u2) <= h2) {
            if (!Ir(l2, t2.length) && Ir(u2, r2.length))
              return NaN;
            let s4;
            if (e2 && n2)
              s4 = Tr(t2, l2, r2, u2, i2), a2 = Math.min(a2, s4);
            else if (e2 && !n2) {
              const e3 = t2.slice(l2[0], l2[1] + 1);
              for (let t3 = u2[0];t3 <= u2[1]; ++t3)
                if (s4 = Er(r2[t3], e3, i2), a2 = Math.min(a2, s4), a2 === 0)
                  return a2;
            } else if (!e2 && n2) {
              const e3 = r2.slice(u2[0], u2[1] + 1);
              for (let r3 = l2[0];r3 <= l2[1]; ++r3)
                if (s4 = Er(t2[r3], e3, i2), a2 = Math.min(a2, s4), a2 === 0)
                  return a2;
            } else
              s4 = $r(t2, l2, r2, u2, i2), a2 = Math.min(a2, s4);
          } else {
            const s4 = zr(l2, e2), c3 = zr(u2, n2);
            Ur(o2, a2, i2, t2, r2, s4[0], c3[0]), Ur(o2, a2, i2, t2, r2, s4[0], c3[1]), Ur(o2, a2, i2, t2, r2, s4[1], c3[0]), Ur(o2, a2, i2, t2, r2, s4[1], c3[1]);
          }
        }
        return a2;
      }
      function Zr(t2) {
        return t2.type === "MultiPolygon" ? t2.coordinates.map((t3) => ({ type: "Polygon", coordinates: t3 })) : t2.type === "MultiLineString" ? t2.coordinates.map((t3) => ({ type: "LineString", coordinates: t3 })) : t2.type === "MultiPoint" ? t2.coordinates.map((t3) => ({ type: "Point", coordinates: t3 })) : [t2];
      }

      class Gr {
        constructor(t2, e2) {
          this.type = ut, this.geojson = t2, this.geometries = e2;
        }
        static parse(t2, e2) {
          if (t2.length !== 2)
            return e2.error(`'distance' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
          if (re(t2[1])) {
            const e3 = t2[1];
            if (e3.type === "FeatureCollection")
              return new Gr(e3, e3.features.map((t3) => Zr(t3.geometry)).flat());
            if (e3.type === "Feature")
              return new Gr(e3, Zr(e3.geometry));
            if ("type" in e3 && "coordinates" in e3)
              return new Gr(e3, Zr(e3));
          }
          return e2.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t2) {
          if (t2.geometry() != null && t2.canonicalID() != null) {
            if (t2.geometryType() === "Point")
              return function(t3, e2) {
                const r2 = t3.geometry(), n2 = r2.flat().map((e3) => Ye([e3.x, e3.y], t3.canonical));
                if (r2.length === 0)
                  return NaN;
                const i2 = new Sr(n2[0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2) {
                  switch (t4.type) {
                    case "Point":
                      s2 = Math.min(s2, Nr(n2, false, [t4.coordinates], false, i2, s2));
                      break;
                    case "LineString":
                      s2 = Math.min(s2, Nr(n2, false, t4.coordinates, true, i2, s2));
                      break;
                    case "Polygon":
                      s2 = Math.min(s2, qr(n2, false, t4.coordinates, i2, s2));
                  }
                  if (s2 === 0)
                    return s2;
                }
                return s2;
              }(t2, this.geometries);
            if (t2.geometryType() === "LineString")
              return function(t3, e2) {
                const r2 = t3.geometry(), n2 = r2.flat().map((e3) => Ye([e3.x, e3.y], t3.canonical));
                if (r2.length === 0)
                  return NaN;
                const i2 = new Sr(n2[0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2) {
                  switch (t4.type) {
                    case "Point":
                      s2 = Math.min(s2, Nr(n2, true, [t4.coordinates], false, i2, s2));
                      break;
                    case "LineString":
                      s2 = Math.min(s2, Nr(n2, true, t4.coordinates, true, i2, s2));
                      break;
                    case "Polygon":
                      s2 = Math.min(s2, qr(n2, true, t4.coordinates, i2, s2));
                  }
                  if (s2 === 0)
                    return s2;
                }
                return s2;
              }(t2, this.geometries);
            if (t2.geometryType() === "Polygon")
              return function(t3, e2) {
                const r2 = t3.geometry();
                if (r2.length === 0 || r2[0].length === 0)
                  return NaN;
                const n2 = xr(r2, 0).map((e3) => e3.map((e4) => e4.map((e5) => Ye([e5.x, e5.y], t3.canonical)))), i2 = new Sr(n2[0][0][0][1]);
                let s2 = 1 / 0;
                for (const t4 of e2)
                  for (const e3 of n2) {
                    switch (t4.type) {
                      case "Point":
                        s2 = Math.min(s2, qr([t4.coordinates], false, e3, i2, s2));
                        break;
                      case "LineString":
                        s2 = Math.min(s2, qr(t4.coordinates, true, e3, i2, s2));
                        break;
                      case "Polygon":
                        s2 = Math.min(s2, jr(e3, t4.coordinates, i2, s2));
                    }
                    if (s2 === 0)
                      return s2;
                  }
                return s2;
              }(t2, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return true;
        }
      }
      const Kr = {
        "==": Le,
        "!=": De,
        ">": je,
        "<": Oe,
        ">=": Ue,
        "<=": Re,
        array: le,
        at: me,
        boolean: le,
        case: be,
        coalesce: Ee,
        collator: qe,
        format: Ze,
        image: Ge,
        in: ge,
        "index-of": xe,
        interpolate: Be,
        "interpolate-hcl": Be,
        "interpolate-lab": Be,
        length: Ke,
        let: de,
        literal: se,
        match: ve,
        number: le,
        "number-format": Ne,
        object: le,
        slice: we,
        step: Ae,
        string: le,
        "to-boolean": ce,
        "to-color": ce,
        "to-number": ce,
        "to-string": ce,
        var: ye,
        within: pr,
        distance: Gr
      };

      class Xr {
        constructor(t2, e2, r2, n2) {
          this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
        }
        evaluate(t2) {
          return this._evaluate(t2, this.args);
        }
        eachChild(t2) {
          this.args.forEach(t2);
        }
        outputDefined() {
          return false;
        }
        static parse(t2, e2) {
          const r2 = t2[0], n2 = Xr.definitions[r2];
          if (!n2)
            return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, a2 = s2.filter(([e3]) => !Array.isArray(e3) || e3.length === t2.length - 1);
          let o2 = null;
          for (const [n3, s3] of a2) {
            o2 = new fe(e2.registry, Qr, e2.path, null, e2.scope);
            const a3 = [];
            let l2 = false;
            for (let e3 = 1;e3 < t2.length; e3++) {
              const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, s4 = o2.parse(r3, 1 + a3.length, i3);
              if (!s4) {
                l2 = true;
                break;
              }
              a3.push(s4);
            }
            if (!l2)
              if (Array.isArray(n3) && n3.length !== a3.length)
                o2.error(`Expected ${n3.length} arguments, but found ${a3.length} instead.`);
              else {
                for (let t3 = 0;t3 < a3.length; t3++) {
                  const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = a3[t3];
                  o2.concat(t3 + 1).checkSubtype(e3, r3.type);
                }
                if (o2.errors.length === 0)
                  return new Xr(r2, i2, s3, a3);
              }
          }
          if (a2.length === 1)
            e2.errors.push(...o2.errors);
          else {
            const r3 = (a2.length ? a2 : s2).map(([t3]) => {
              return e3 = t3, Array.isArray(e3) ? `(${e3.map(wt).join(", ")})` : `(${wt(e3.type)}...)`;
              var e3;
            }).join(" | "), n3 = [];
            for (let r4 = 1;r4 < t2.length; r4++) {
              const i3 = e2.parse(t2[r4], 1 + n3.length);
              if (!i3)
                return null;
              n3.push(wt(i3.type));
            }
            e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
          }
          return null;
        }
        static register(t2, e2) {
          Xr.definitions = e2;
          for (const r2 in e2)
            t2[r2] = Xr;
        }
      }
      function Hr(t2, [e2, r2, n2, i2]) {
        e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
        const s2 = i2 ? i2.evaluate(t2) : 1, a2 = ee(e2, r2, n2, s2);
        if (a2)
          throw new ae(a2);
        return new Kt(e2 / 255, r2 / 255, n2 / 255, s2, false);
      }
      function Yr(t2, e2) {
        return t2 in e2;
      }
      function Jr(t2, e2) {
        const r2 = e2[t2];
        return r2 === undefined ? null : r2;
      }
      function Wr(t2) {
        return { type: t2 };
      }
      function Qr(t2) {
        if (t2 instanceof ye)
          return Qr(t2.boundExpression);
        if (t2 instanceof Xr && t2.name === "error")
          return false;
        if (t2 instanceof qe)
          return false;
        if (t2 instanceof pr)
          return false;
        if (t2 instanceof Gr)
          return false;
        const e2 = t2 instanceof ce || t2 instanceof le;
        let r2 = true;
        return t2.eachChild((t3) => {
          r2 = e2 ? r2 && Qr(t3) : r2 && t3 instanceof se;
        }), !!r2 && tn(t2) && rn(t2, [
          "zoom",
          "heatmap-density",
          "line-progress",
          "accumulated",
          "is-supported-script"
        ]);
      }
      function tn(t2) {
        if (t2 instanceof Xr) {
          if (t2.name === "get" && t2.args.length === 1)
            return false;
          if (t2.name === "feature-state")
            return false;
          if (t2.name === "has" && t2.args.length === 1)
            return false;
          if (t2.name === "properties" || t2.name === "geometry-type" || t2.name === "id")
            return false;
          if (/^filter-/.test(t2.name))
            return false;
        }
        if (t2 instanceof pr)
          return false;
        if (t2 instanceof Gr)
          return false;
        let e2 = true;
        return t2.eachChild((t3) => {
          e2 && !tn(t3) && (e2 = false);
        }), e2;
      }
      function en(t2) {
        if (t2 instanceof Xr && t2.name === "feature-state")
          return false;
        let e2 = true;
        return t2.eachChild((t3) => {
          e2 && !en(t3) && (e2 = false);
        }), e2;
      }
      function rn(t2, e2) {
        if (t2 instanceof Xr && e2.indexOf(t2.name) >= 0)
          return false;
        let r2 = true;
        return t2.eachChild((t3) => {
          r2 && !rn(t3, e2) && (r2 = false);
        }), r2;
      }
      function nn(t2) {
        return { result: "success", value: t2 };
      }
      function sn(t2) {
        return { result: "error", value: t2 };
      }
      function an(t2) {
        return t2["property-type"] === "data-driven" || t2["property-type"] === "cross-faded-data-driven";
      }
      function on(t2) {
        return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
      }
      function ln(t2) {
        return !!t2.expression && t2.expression.interpolated;
      }
      function un(t2) {
        return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : t2 === null ? "null" : typeof t2;
      }
      function cn(t2) {
        return typeof t2 == "object" && t2 !== null && !Array.isArray(t2);
      }
      function hn(t2) {
        return t2;
      }
      function pn(t2, e2) {
        const r2 = e2.type === "color", n2 = t2.stops && typeof t2.stops[0][0] == "object", i2 = n2 || !(n2 || t2.property !== undefined), s2 = t2.type || (ln(e2) ? "exponential" : "interval");
        if (r2 || e2.type === "padding") {
          const n3 = r2 ? Kt.parse : Jt.parse;
          (t2 = st({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], n3(t3[1])])), t2.default = n3(t2.default ? t2.default : e2.default);
        }
        if (t2.colorSpace && (a2 = t2.colorSpace) !== "rgb" && a2 !== "hcl" && a2 !== "lab")
          throw new Error(`Unknown color space: "${t2.colorSpace}"`);
        var a2;
        let o2, l2, u2;
        if (s2 === "exponential")
          o2 = mn;
        else if (s2 === "interval")
          o2 = yn;
        else if (s2 === "categorical") {
          o2 = dn, l2 = Object.create(null);
          for (const e3 of t2.stops)
            l2[e3[0]] = e3[1];
          u2 = typeof t2.stops[0][0];
        } else {
          if (s2 !== "identity")
            throw new Error(`Unknown function type "${s2}"`);
          o2 = gn;
        }
        if (n2) {
          const r3 = {}, n3 = [];
          for (let e3 = 0;e3 < t2.stops.length; e3++) {
            const i4 = t2.stops[e3], s4 = i4[0].zoom;
            r3[s4] === undefined && (r3[s4] = {
              zoom: s4,
              type: t2.type,
              property: t2.property,
              default: t2.default,
              stops: []
            }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
          }
          const i3 = [];
          for (const t3 of n3)
            i3.push([r3[t3].zoom, pn(r3[t3], e2)]);
          const s3 = { name: "linear" };
          return {
            kind: "composite",
            interpolationType: s3,
            interpolationFactor: Be.interpolationFactor.bind(undefined, s3),
            zoomStops: i3.map((t3) => t3[0]),
            evaluate: ({ zoom: r4 }, n4) => mn({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4)
          };
        }
        if (i2) {
          const r3 = s2 === "exponential" ? { name: "exponential", base: t2.base !== undefined ? t2.base : 1 } : null;
          return {
            kind: "camera",
            interpolationType: r3,
            interpolationFactor: Be.interpolationFactor.bind(undefined, r3),
            zoomStops: t2.stops.map((t3) => t3[0]),
            evaluate: ({ zoom: r4 }) => o2(t2, e2, r4, l2, u2)
          };
        }
        return {
          kind: "source",
          evaluate(r3, n3) {
            const i3 = n3 && n3.properties ? n3.properties[t2.property] : undefined;
            return i3 === undefined ? fn(t2.default, e2.default) : o2(t2, e2, i3, l2, u2);
          }
        };
      }
      function fn(t2, e2, r2) {
        return t2 !== undefined ? t2 : e2 !== undefined ? e2 : r2 !== undefined ? r2 : undefined;
      }
      function dn(t2, e2, r2, n2, i2) {
        return fn(typeof r2 === i2 ? n2[r2] : undefined, t2.default, e2.default);
      }
      function yn(t2, e2, r2) {
        if (un(r2) !== "number")
          return fn(t2.default, e2.default);
        const n2 = t2.stops.length;
        if (n2 === 1)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[n2 - 1][0])
          return t2.stops[n2 - 1][1];
        const i2 = _e(t2.stops.map((t3) => t3[0]), r2);
        return t2.stops[i2][1];
      }
      function mn(t2, e2, r2) {
        const n2 = t2.base !== undefined ? t2.base : 1;
        if (un(r2) !== "number")
          return fn(t2.default, e2.default);
        const i2 = t2.stops.length;
        if (i2 === 1)
          return t2.stops[0][1];
        if (r2 <= t2.stops[0][0])
          return t2.stops[0][1];
        if (r2 >= t2.stops[i2 - 1][0])
          return t2.stops[i2 - 1][1];
        const s2 = _e(t2.stops.map((t3) => t3[0]), r2), a2 = function(t3, e3, r3, n3) {
          const i3 = n3 - r3, s3 = t3 - r3;
          return i3 === 0 ? 0 : e3 === 1 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
        }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), o2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1], u2 = Ce[e2.type] || hn;
        return typeof o2.evaluate == "function" ? {
          evaluate(...e3) {
            const r3 = o2.evaluate.apply(undefined, e3), n3 = l2.evaluate.apply(undefined, e3);
            if (r3 !== undefined && n3 !== undefined)
              return u2(r3, n3, a2, t2.colorSpace);
          }
        } : u2(o2, l2, a2, t2.colorSpace);
      }
      function gn(t2, e2, r2) {
        switch (e2.type) {
          case "color":
            r2 = Kt.parse(r2);
            break;
          case "formatted":
            r2 = Yt.fromString(r2.toString());
            break;
          case "resolvedImage":
            r2 = te.fromString(r2.toString());
            break;
          case "padding":
            r2 = Jt.parse(r2);
            break;
          default:
            un(r2) === e2.type || e2.type === "enum" && e2.values[r2] || (r2 = undefined);
        }
        return fn(r2, t2.default, e2.default);
      }
      Xr.register(Kr, {
        error: [
          { kind: "error" },
          [ct],
          (t2, [e2]) => {
            throw new ae(e2.evaluate(t2));
          }
        ],
        typeof: [ct, [dt], (t2, [e2]) => wt(ne(e2.evaluate(t2)))],
        "to-rgba": [
          bt(ut, 4),
          [pt],
          (t2, [e2]) => {
            const [r2, n2, i2, s2] = e2.evaluate(t2).rgb;
            return [255 * r2, 255 * n2, 255 * i2, s2];
          }
        ],
        rgb: [pt, [ut, ut, ut], Hr],
        rgba: [pt, [ut, ut, ut, ut], Hr],
        has: {
          type: ht,
          overloads: [
            [[ct], (t2, [e2]) => Yr(e2.evaluate(t2), t2.properties())],
            [[ct, ft], (t2, [e2, r2]) => Yr(e2.evaluate(t2), r2.evaluate(t2))]
          ]
        },
        get: {
          type: dt,
          overloads: [
            [[ct], (t2, [e2]) => Jr(e2.evaluate(t2), t2.properties())],
            [[ct, ft], (t2, [e2, r2]) => Jr(e2.evaluate(t2), r2.evaluate(t2))]
          ]
        },
        "feature-state": [
          dt,
          [ct],
          (t2, [e2]) => Jr(e2.evaluate(t2), t2.featureState || {})
        ],
        properties: [ft, [], (t2) => t2.properties()],
        "geometry-type": [ct, [], (t2) => t2.geometryType()],
        id: [dt, [], (t2) => t2.id()],
        zoom: [ut, [], (t2) => t2.globals.zoom],
        "heatmap-density": [ut, [], (t2) => t2.globals.heatmapDensity || 0],
        "line-progress": [ut, [], (t2) => t2.globals.lineProgress || 0],
        accumulated: [
          dt,
          [],
          (t2) => t2.globals.accumulated === undefined ? null : t2.globals.accumulated
        ],
        "+": [
          ut,
          Wr(ut),
          (t2, e2) => {
            let r2 = 0;
            for (const n2 of e2)
              r2 += n2.evaluate(t2);
            return r2;
          }
        ],
        "*": [
          ut,
          Wr(ut),
          (t2, e2) => {
            let r2 = 1;
            for (const n2 of e2)
              r2 *= n2.evaluate(t2);
            return r2;
          }
        ],
        "-": {
          type: ut,
          overloads: [
            [[ut, ut], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)],
            [[ut], (t2, [e2]) => -e2.evaluate(t2)]
          ]
        },
        "/": [ut, [ut, ut], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)],
        "%": [ut, [ut, ut], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)],
        ln2: [ut, [], () => Math.LN2],
        pi: [ut, [], () => Math.PI],
        e: [ut, [], () => Math.E],
        "^": [ut, [ut, ut], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))],
        sqrt: [ut, [ut], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))],
        log10: [ut, [ut], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10],
        ln: [ut, [ut], (t2, [e2]) => Math.log(e2.evaluate(t2))],
        log2: [ut, [ut], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2],
        sin: [ut, [ut], (t2, [e2]) => Math.sin(e2.evaluate(t2))],
        cos: [ut, [ut], (t2, [e2]) => Math.cos(e2.evaluate(t2))],
        tan: [ut, [ut], (t2, [e2]) => Math.tan(e2.evaluate(t2))],
        asin: [ut, [ut], (t2, [e2]) => Math.asin(e2.evaluate(t2))],
        acos: [ut, [ut], (t2, [e2]) => Math.acos(e2.evaluate(t2))],
        atan: [ut, [ut], (t2, [e2]) => Math.atan(e2.evaluate(t2))],
        min: [ut, Wr(ut), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))],
        max: [ut, Wr(ut), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))],
        abs: [ut, [ut], (t2, [e2]) => Math.abs(e2.evaluate(t2))],
        round: [
          ut,
          [ut],
          (t2, [e2]) => {
            const r2 = e2.evaluate(t2);
            return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
          }
        ],
        floor: [ut, [ut], (t2, [e2]) => Math.floor(e2.evaluate(t2))],
        ceil: [ut, [ut], (t2, [e2]) => Math.ceil(e2.evaluate(t2))],
        "filter-==": [
          ht,
          [ct, dt],
          (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value
        ],
        "filter-id-==": [ht, [dt], (t2, [e2]) => t2.id() === e2.value],
        "filter-type-==": [ht, [ct], (t2, [e2]) => t2.geometryType() === e2.value],
        "filter-<": [
          ht,
          [ct, dt],
          (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 < i2;
          }
        ],
        "filter-id-<": [
          ht,
          [dt],
          (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 < n2;
          }
        ],
        "filter->": [
          ht,
          [ct, dt],
          (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 > i2;
          }
        ],
        "filter-id->": [
          ht,
          [dt],
          (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 > n2;
          }
        ],
        "filter-<=": [
          ht,
          [ct, dt],
          (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 <= i2;
          }
        ],
        "filter-id-<=": [
          ht,
          [dt],
          (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 <= n2;
          }
        ],
        "filter->=": [
          ht,
          [ct, dt],
          (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 >= i2;
          }
        ],
        "filter-id->=": [
          ht,
          [dt],
          (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 >= n2;
          }
        ],
        "filter-has": [ht, [dt], (t2, [e2]) => (e2.value in t2.properties())],
        "filter-has-id": [ht, [], (t2) => t2.id() !== null && t2.id() !== undefined],
        "filter-type-in": [
          ht,
          [bt(ct)],
          (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0
        ],
        "filter-id-in": [ht, [bt(dt)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0],
        "filter-in-small": [
          ht,
          [ct, bt(dt)],
          (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0
        ],
        "filter-in-large": [
          ht,
          [ct, bt(dt)],
          (t2, [e2, r2]) => function(t3, e3, r3, n2) {
            for (;r3 <= n2; ) {
              const i2 = r3 + n2 >> 1;
              if (e3[i2] === t3)
                return true;
              e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
            }
            return false;
          }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)
        ],
        all: {
          type: ht,
          overloads: [
            [[ht, ht], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)],
            [
              Wr(ht),
              (t2, e2) => {
                for (const r2 of e2)
                  if (!r2.evaluate(t2))
                    return false;
                return true;
              }
            ]
          ]
        },
        any: {
          type: ht,
          overloads: [
            [[ht, ht], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)],
            [
              Wr(ht),
              (t2, e2) => {
                for (const r2 of e2)
                  if (r2.evaluate(t2))
                    return true;
                return false;
              }
            ]
          ]
        },
        "!": [ht, [ht], (t2, [e2]) => !e2.evaluate(t2)],
        "is-supported-script": [
          ht,
          [ct],
          (t2, [e2]) => {
            const r2 = t2.globals && t2.globals.isSupportedScript;
            return !r2 || r2(e2.evaluate(t2));
          }
        ],
        upcase: [ct, [ct], (t2, [e2]) => e2.evaluate(t2).toUpperCase()],
        downcase: [ct, [ct], (t2, [e2]) => e2.evaluate(t2).toLowerCase()],
        concat: [ct, Wr(dt), (t2, e2) => e2.map((e3) => ie(e3.evaluate(t2))).join("")],
        "resolved-locale": [ct, [yt], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()]
      });

      class xn {
        constructor(t2, e2) {
          var r2;
          this.expression = t2, this._warningHistory = {}, this._evaluator = new pe, this._defaultValue = e2 ? (r2 = e2).type === "color" && cn(r2.default) ? new Kt(0, 0, 0, 0) : r2.type === "color" ? Kt.parse(r2.default) || null : r2.type === "padding" ? Jt.parse(r2.default) || null : r2.type === "variableAnchorOffsetCollection" ? Qt.parse(r2.default) || null : r2.default === undefined ? null : r2.default : null, this._enumValues = e2 && e2.type === "enum" ? e2.values : null;
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this.expression.evaluate(this._evaluator);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null;
          try {
            const t3 = this.expression.evaluate(this._evaluator);
            if (t3 == null || typeof t3 == "number" && t3 != t3)
              return this._defaultValue;
            if (this._enumValues && !(t3 in this._enumValues))
              throw new ae(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
            return t3;
          } catch (t3) {
            return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, typeof console != "undefined" && console.warn(t3.message)), this._defaultValue;
          }
        }
      }
      function vn(t2) {
        return Array.isArray(t2) && t2.length > 0 && typeof t2[0] == "string" && t2[0] in Kr;
      }
      function bn(t2, e2) {
        const r2 = new fe(Kr, Qr, [], e2 ? function(t3) {
          const e3 = {
            color: pt,
            string: ct,
            number: ut,
            enum: ct,
            boolean: ht,
            formatted: mt,
            padding: gt,
            resolvedImage: xt,
            variableAnchorOffsetCollection: vt
          };
          return t3.type === "array" ? bt(e3[t3.value] || dt, t3.length) : e3[t3.type];
        }(e2) : undefined), n2 = r2.parse(t2, undefined, undefined, undefined, e2 && e2.type === "string" ? { typeAnnotation: "coerce" } : undefined);
        return n2 ? nn(new xn(n2, e2)) : sn(r2.errors);
      }

      class wn {
        constructor(t2, e2) {
          this.kind = t2, this._styleExpression = e2, this.isStateDependent = t2 !== "constant" && !en(e2.expression);
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
        }
      }

      class _n {
        constructor(t2, e2, r2, n2) {
          this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = t2 !== "camera" && !en(e2.expression), this.interpolationType = n2;
        }
        evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
        }
        interpolationFactor(t2, e2, r2) {
          return this.interpolationType ? Be.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
        }
      }
      function An(t2, e2) {
        const r2 = bn(t2, e2);
        if (r2.result === "error")
          return r2;
        const n2 = r2.value.expression, i2 = tn(n2);
        if (!i2 && !an(e2))
          return sn([new at("", "data expressions not supported")]);
        const s2 = rn(n2, ["zoom"]);
        if (!s2 && !on(e2))
          return sn([new at("", "zoom expressions not supported")]);
        const a2 = kn(n2);
        return a2 || s2 ? a2 instanceof at ? sn([a2]) : a2 instanceof Be && !ln(e2) ? sn([
          new at("", '"interpolate" expressions cannot be used with this property')
        ]) : nn(a2 ? new _n(i2 ? "camera" : "composite", r2.value, a2.labels, a2 instanceof Be ? a2.interpolation : undefined) : new wn(i2 ? "constant" : "source", r2.value)) : sn([
          new at("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')
        ]);
      }

      class Sn {
        constructor(t2, e2) {
          this._parameters = t2, this._specification = e2, st(this, pn(this._parameters, this._specification));
        }
        static deserialize(t2) {
          return new Sn(t2._parameters, t2._specification);
        }
        static serialize(t2) {
          return { _parameters: t2._parameters, _specification: t2._specification };
        }
      }
      function kn(t2) {
        let e2 = null;
        if (t2 instanceof de)
          e2 = kn(t2.result);
        else if (t2 instanceof Ee) {
          for (const r2 of t2.args)
            if (e2 = kn(r2), e2)
              break;
        } else
          (t2 instanceof Ae || t2 instanceof Be) && t2.input instanceof Xr && t2.input.name === "zoom" && (e2 = t2);
        return e2 instanceof at || t2.eachChild((t3) => {
          const r2 = kn(t3);
          r2 instanceof at ? e2 = r2 : !e2 && r2 ? e2 = new at("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e2 && r2 && e2 !== r2 && (e2 = new at("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), e2;
      }
      function Mn(t2) {
        if (t2 === true || t2 === false)
          return true;
        if (!Array.isArray(t2) || t2.length === 0)
          return false;
        switch (t2[0]) {
          case "has":
            return t2.length >= 2 && t2[1] !== "$id" && t2[1] !== "$type";
          case "in":
            return t2.length >= 3 && (typeof t2[1] != "string" || Array.isArray(t2[2]));
          case "!in":
          case "!has":
          case "none":
            return false;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return t2.length !== 3 || Array.isArray(t2[1]) || Array.isArray(t2[2]);
          case "any":
          case "all":
            for (const e2 of t2.slice(1))
              if (!Mn(e2) && typeof e2 != "boolean")
                return false;
            return true;
          default:
            return true;
        }
      }
      const In = {
        type: "boolean",
        default: false,
        transition: false,
        "property-type": "data-driven",
        expression: { interpolated: false, parameters: ["zoom", "feature"] }
      };
      function zn(t2) {
        if (t2 == null)
          return { filter: () => true, needGeometry: false };
        Mn(t2) || (t2 = Bn(t2));
        const e2 = bn(t2, In);
        if (e2.result === "error")
          throw new Error(e2.value.map((t3) => `${t3.key}: ${t3.message}`).join(", "));
        return {
          filter: (t3, r2, n2) => e2.value.evaluate(t3, r2, {}, n2),
          needGeometry: Cn(t2)
        };
      }
      function Pn(t2, e2) {
        return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
      }
      function Cn(t2) {
        if (!Array.isArray(t2))
          return false;
        if (t2[0] === "within" || t2[0] === "distance")
          return true;
        for (let e2 = 1;e2 < t2.length; e2++)
          if (Cn(t2[e2]))
            return true;
        return false;
      }
      function Bn(t2) {
        if (!t2)
          return true;
        const e2 = t2[0];
        return t2.length <= 1 ? e2 !== "any" : e2 === "==" ? Vn(t2[1], t2[2], "==") : e2 === "!=" ? Tn(Vn(t2[1], t2[2], "==")) : e2 === "<" || e2 === ">" || e2 === "<=" || e2 === ">=" ? Vn(t2[1], t2[2], e2) : e2 === "any" ? (r2 = t2.slice(1), ["any"].concat(r2.map(Bn))) : e2 === "all" ? ["all"].concat(t2.slice(1).map(Bn)) : e2 === "none" ? ["all"].concat(t2.slice(1).map(Bn).map(Tn)) : e2 === "in" ? En(t2[1], t2.slice(2)) : e2 === "!in" ? Tn(En(t2[1], t2.slice(2))) : e2 === "has" ? Fn(t2[1]) : e2 !== "!has" || Tn(Fn(t2[1]));
        var r2;
      }
      function Vn(t2, e2, r2) {
        switch (t2) {
          case "$type":
            return [`filter-type-${r2}`, e2];
          case "$id":
            return [`filter-id-${r2}`, e2];
          default:
            return [`filter-${r2}`, t2, e2];
        }
      }
      function En(t2, e2) {
        if (e2.length === 0)
          return false;
        switch (t2) {
          case "$type":
            return ["filter-type-in", ["literal", e2]];
          case "$id":
            return ["filter-id-in", ["literal", e2]];
          default:
            return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(Pn)]] : ["filter-in-small", t2, ["literal", e2]];
        }
      }
      function Fn(t2) {
        switch (t2) {
          case "$type":
            return true;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", t2];
        }
      }
      function Tn(t2) {
        return ["!", t2];
      }
      function $n(t2) {
        const e2 = typeof t2;
        if (e2 === "number" || e2 === "boolean" || e2 === "string" || t2 == null)
          return JSON.stringify(t2);
        if (Array.isArray(t2)) {
          let e3 = "[";
          for (const r3 of t2)
            e3 += `${$n(r3)},`;
          return `${e3}]`;
        }
        const r2 = Object.keys(t2).sort();
        let n2 = "{";
        for (let e3 = 0;e3 < r2.length; e3++)
          n2 += `${JSON.stringify(r2[e3])}:${$n(t2[r2[e3]])},`;
        return `${n2}}`;
      }
      function Ln(t2) {
        let e2 = "";
        for (const r2 of K)
          e2 += `/${$n(t2[r2])}`;
        return e2;
      }
      function Dn(t2) {
        const e2 = t2.value;
        return e2 ? [new it(t2.key, e2, "constants have been deprecated as of v8")] : [];
      }
      function On(t2) {
        return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
      }
      function jn(t2) {
        if (Array.isArray(t2))
          return t2.map(jn);
        if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
          const e2 = {};
          for (const r2 in t2)
            e2[r2] = jn(t2[r2]);
          return e2;
        }
        return On(t2);
      }
      function Rn(t2) {
        const { key: e2, value: r2 } = t2, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, s2 = t2.style, a2 = t2.styleSpec, o2 = t2.validateSpec;
        let l2 = [];
        const u2 = un(r2);
        if (u2 !== "object")
          return [new it(e2, r2, `object expected, ${u2} found`)];
        for (const t3 in r2) {
          const u3 = t3.split(".")[0], c2 = n2[u3] || n2["*"];
          let h2;
          if (i2[u3])
            h2 = i2[u3];
          else if (n2[u3])
            h2 = o2;
          else if (i2["*"])
            h2 = i2["*"];
          else {
            if (!n2["*"]) {
              l2.push(new it(e2, r2[t3], `unknown property "${t3}"`));
              continue;
            }
            h2 = o2;
          }
          l2 = l2.concat(h2({
            key: (e2 ? `${e2}.` : e2) + t3,
            value: r2[t3],
            valueSpec: c2,
            style: s2,
            styleSpec: a2,
            object: r2,
            objectKey: t3,
            validateSpec: o2
          }, r2));
        }
        for (const t3 in n2)
          i2[t3] || n2[t3].required && n2[t3].default === undefined && r2[t3] === undefined && l2.push(new it(e2, r2, `missing required property "${t3}"`));
        return l2;
      }
      function Un(t2) {
        const { value: e2, valueSpec: r2, style: n2, styleSpec: i2, key: s2 } = t2, a2 = t2.arrayElementValidator || t2.validateSpec;
        if (un(e2) !== "array")
          return [new it(s2, e2, `array expected, ${un(e2)} found`)];
        if (r2.length && e2.length !== r2.length)
          return [
            new it(s2, e2, `array length ${r2.length} expected, length ${e2.length} found`)
          ];
        if (r2["min-length"] && e2.length < r2["min-length"])
          return [
            new it(s2, e2, `array length at least ${r2["min-length"]} expected, length ${e2.length} found`)
          ];
        let o2 = { type: r2.value, values: r2.values };
        i2.$version < 7 && (o2.function = r2.function), un(r2.value) === "object" && (o2 = r2.value);
        let l2 = [];
        for (let r3 = 0;r3 < e2.length; r3++)
          l2 = l2.concat(a2({
            array: e2,
            arrayIndex: r3,
            value: e2[r3],
            valueSpec: o2,
            validateSpec: t2.validateSpec,
            style: n2,
            styleSpec: i2,
            key: `${s2}[${r3}]`
          }));
        return l2;
      }
      function qn(t2) {
        const { key: e2, value: r2, valueSpec: n2 } = t2;
        let i2 = un(r2);
        return i2 === "number" && r2 != r2 && (i2 = "NaN"), i2 !== "number" ? [new it(e2, r2, `number expected, ${i2} found`)] : ("minimum" in n2) && r2 < n2.minimum ? [new it(e2, r2, `${r2} is less than the minimum value ${n2.minimum}`)] : ("maximum" in n2) && r2 > n2.maximum ? [new it(e2, r2, `${r2} is greater than the maximum value ${n2.maximum}`)] : [];
      }
      function Nn(t2) {
        const e2 = t2.valueSpec, r2 = On(t2.value.type);
        let n2, i2, s2, a2 = {};
        const o2 = r2 !== "categorical" && t2.value.property === undefined, l2 = !o2, u2 = un(t2.value.stops) === "array" && un(t2.value.stops[0]) === "array" && un(t2.value.stops[0][0]) === "object", c2 = Rn({
          key: t2.key,
          value: t2.value,
          valueSpec: t2.styleSpec.function,
          validateSpec: t2.validateSpec,
          style: t2.style,
          styleSpec: t2.styleSpec,
          objectElementValidators: {
            stops: function(t3) {
              if (r2 === "identity")
                return [
                  new it(t3.key, t3.value, 'identity function may not have a "stops" property')
                ];
              let e3 = [];
              const n3 = t3.value;
              return e3 = e3.concat(Un({
                key: t3.key,
                value: n3,
                valueSpec: t3.valueSpec,
                validateSpec: t3.validateSpec,
                style: t3.style,
                styleSpec: t3.styleSpec,
                arrayElementValidator: h2
              })), un(n3) === "array" && n3.length === 0 && e3.push(new it(t3.key, n3, "array must have at least one stop")), e3;
            },
            default: function(t3) {
              return t3.validateSpec({
                key: t3.key,
                value: t3.value,
                valueSpec: e2,
                validateSpec: t3.validateSpec,
                style: t3.style,
                styleSpec: t3.styleSpec
              });
            }
          }
        });
        return r2 === "identity" && o2 && c2.push(new it(t2.key, t2.value, 'missing required property "property"')), r2 === "identity" || t2.value.stops || c2.push(new it(t2.key, t2.value, 'missing required property "stops"')), r2 === "exponential" && t2.valueSpec.expression && !ln(t2.valueSpec) && c2.push(new it(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (l2 && !an(t2.valueSpec) ? c2.push(new it(t2.key, t2.value, "property functions not supported")) : o2 && !on(t2.valueSpec) && c2.push(new it(t2.key, t2.value, "zoom functions not supported"))), r2 !== "categorical" && !u2 || t2.value.property !== undefined || c2.push(new it(t2.key, t2.value, '"property" property is required')), c2;
        function h2(t3) {
          let r3 = [];
          const { value: n3, key: o3 } = t3;
          if (un(n3) !== "array")
            return [new it(o3, n3, `array expected, ${un(n3)} found`)];
          if (n3.length !== 2)
            return [new it(o3, n3, `array length 2 expected, length ${n3.length} found`)];
          if (u2) {
            if (un(n3[0]) !== "object")
              return [new it(o3, n3, `object expected, ${un(n3[0])} found`)];
            if (n3[0].zoom === undefined)
              return [new it(o3, n3, "object stop key must have zoom")];
            if (n3[0].value === undefined)
              return [new it(o3, n3, "object stop key must have value")];
            if (s2 && s2 > On(n3[0].zoom))
              return [
                new it(o3, n3[0].zoom, "stop zoom values must appear in ascending order")
              ];
            On(n3[0].zoom) !== s2 && (s2 = On(n3[0].zoom), i2 = undefined, a2 = {}), r3 = r3.concat(Rn({
              key: `${o3}[0]`,
              value: n3[0],
              valueSpec: { zoom: {} },
              validateSpec: t3.validateSpec,
              style: t3.style,
              styleSpec: t3.styleSpec,
              objectElementValidators: { zoom: qn, value: p2 }
            }));
          } else
            r3 = r3.concat(p2({
              key: `${o3}[0]`,
              value: n3[0],
              valueSpec: {},
              validateSpec: t3.validateSpec,
              style: t3.style,
              styleSpec: t3.styleSpec
            }, n3));
          return vn(jn(n3[1])) ? r3.concat([
            new it(`${o3}[1]`, n3[1], "expressions are not allowed in function stops.")
          ]) : r3.concat(t3.validateSpec({
            key: `${o3}[1]`,
            value: n3[1],
            valueSpec: e2,
            validateSpec: t3.validateSpec,
            style: t3.style,
            styleSpec: t3.styleSpec
          }));
        }
        function p2(t3, s3) {
          const o3 = un(t3.value), l3 = On(t3.value), u3 = t3.value !== null ? t3.value : s3;
          if (n2) {
            if (o3 !== n2)
              return [
                new it(t3.key, u3, `${o3} stop domain type must match previous stop domain type ${n2}`)
              ];
          } else
            n2 = o3;
          if (o3 !== "number" && o3 !== "string" && o3 !== "boolean")
            return [
              new it(t3.key, u3, "stop domain value must be a number, string, or boolean")
            ];
          if (o3 !== "number" && r2 !== "categorical") {
            let n3 = `number expected, ${o3} found`;
            return an(e2) && r2 === undefined && (n3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new it(t3.key, u3, n3)];
          }
          return r2 !== "categorical" || o3 !== "number" || isFinite(l3) && Math.floor(l3) === l3 ? r2 !== "categorical" && o3 === "number" && i2 !== undefined && l3 < i2 ? [new it(t3.key, u3, "stop domain values must appear in ascending order")] : (i2 = l3, r2 === "categorical" && (l3 in a2) ? [new it(t3.key, u3, "stop domain values must be unique")] : (a2[l3] = true, [])) : [new it(t3.key, u3, `integer expected, found ${l3}`)];
        }
      }
      function Zn(t2) {
        const e2 = (t2.expressionContext === "property" ? An : bn)(jn(t2.value), t2.valueSpec);
        if (e2.result === "error")
          return e2.value.map((e3) => new it(`${t2.key}${e3.key}`, t2.value, e3.message));
        const r2 = e2.value.expression || e2.value._styleExpression.expression;
        if (t2.expressionContext === "property" && t2.propertyKey === "text-font" && !r2.outputDefined())
          return [
            new it(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)
          ];
        if (t2.expressionContext === "property" && t2.propertyType === "layout" && !en(r2))
          return [
            new it(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')
          ];
        if (t2.expressionContext === "filter" && !en(r2))
          return [
            new it(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')
          ];
        if (t2.expressionContext && t2.expressionContext.indexOf("cluster") === 0) {
          if (!rn(r2, ["zoom", "feature-state"]))
            return [
              new it(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')
            ];
          if (t2.expressionContext === "cluster-initial" && !tn(r2))
            return [
              new it(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")
            ];
        }
        return [];
      }
      function Gn(t2) {
        const { key: e2, value: r2, valueSpec: n2 } = t2, i2 = [];
        return Array.isArray(n2.values) ? n2.values.indexOf(On(r2)) === -1 && i2.push(new it(e2, r2, `expected one of [${n2.values.join(", ")}], ${JSON.stringify(r2)} found`)) : Object.keys(n2.values).indexOf(On(r2)) === -1 && i2.push(new it(e2, r2, `expected one of [${Object.keys(n2.values).join(", ")}], ${JSON.stringify(r2)} found`)), i2;
      }
      function Kn(t2) {
        return Mn(jn(t2.value)) ? Zn(st({}, t2, {
          expressionContext: "filter",
          valueSpec: { value: "boolean" }
        })) : Xn(t2);
      }
      function Xn(t2) {
        const { value: e2, key: r2 } = t2;
        if (un(e2) !== "array")
          return [new it(r2, e2, `array expected, ${un(e2)} found`)];
        const n2 = t2.styleSpec;
        let i2, s2 = [];
        if (e2.length < 1)
          return [new it(r2, e2, "filter array must have at least 1 element")];
        switch (s2 = s2.concat(Gn({
          key: `${r2}[0]`,
          value: e2[0],
          valueSpec: n2.filter_operator,
          style: t2.style,
          styleSpec: t2.styleSpec
        })), On(e2[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            e2.length >= 2 && On(e2[1]) === "$type" && s2.push(new it(r2, e2, `"$type" cannot be use with operator "${e2[0]}"`));
          case "==":
          case "!=":
            e2.length !== 3 && s2.push(new it(r2, e2, `filter array for operator "${e2[0]}" must have 3 elements`));
          case "in":
          case "!in":
            e2.length >= 2 && (i2 = un(e2[1]), i2 !== "string" && s2.push(new it(`${r2}[1]`, e2[1], `string expected, ${i2} found`)));
            for (let a2 = 2;a2 < e2.length; a2++)
              i2 = un(e2[a2]), On(e2[1]) === "$type" ? s2 = s2.concat(Gn({
                key: `${r2}[${a2}]`,
                value: e2[a2],
                valueSpec: n2.geometry_type,
                style: t2.style,
                styleSpec: t2.styleSpec
              })) : i2 !== "string" && i2 !== "number" && i2 !== "boolean" && s2.push(new it(`${r2}[${a2}]`, e2[a2], `string, number, or boolean expected, ${i2} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let n3 = 1;n3 < e2.length; n3++)
              s2 = s2.concat(Xn({
                key: `${r2}[${n3}]`,
                value: e2[n3],
                style: t2.style,
                styleSpec: t2.styleSpec
              }));
            break;
          case "has":
          case "!has":
            i2 = un(e2[1]), e2.length !== 2 ? s2.push(new it(r2, e2, `filter array for "${e2[0]}" operator must have 2 elements`)) : i2 !== "string" && s2.push(new it(`${r2}[1]`, e2[1], `string expected, ${i2} found`));
        }
        return s2;
      }
      function Hn(t2, e2) {
        const { key: r2, validateSpec: n2, style: i2, styleSpec: s2, value: a2, objectKey: o2 } = t2, l2 = s2[`${e2}_${t2.layerType}`];
        if (!l2)
          return [];
        const u2 = o2.match(/^(.*)-transition$/);
        if (e2 === "paint" && u2 && l2[u2[1]] && l2[u2[1]].transition)
          return n2({
            key: r2,
            value: a2,
            valueSpec: s2.transition,
            style: i2,
            styleSpec: s2
          });
        const c2 = t2.valueSpec || l2[o2];
        if (!c2)
          return [new it(r2, a2, `unknown property "${o2}"`)];
        let h2;
        if (un(a2) === "string" && an(c2) && !c2.tokens && (h2 = /^{([^}]+)}$/.exec(a2)))
          return [
            new it(r2, a2, `"${o2}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h2[1])} }\`.`)
          ];
        const p2 = [];
        return t2.layerType === "symbol" && (o2 === "text-field" && i2 && !i2.glyphs && p2.push(new it(r2, a2, 'use of "text-field" requires a style "glyphs" property')), o2 === "text-font" && cn(jn(a2)) && On(a2.type) === "identity" && p2.push(new it(r2, a2, '"text-font" does not support identity functions'))), p2.concat(n2({
          key: t2.key,
          value: a2,
          valueSpec: c2,
          style: i2,
          styleSpec: s2,
          expressionContext: "property",
          propertyType: e2,
          propertyKey: o2
        }));
      }
      function Yn(t2) {
        return Hn(t2, "paint");
      }
      function Jn(t2) {
        return Hn(t2, "layout");
      }
      function Wn(t2) {
        let e2 = [];
        const { value: r2, key: n2, style: i2, styleSpec: s2 } = t2;
        r2.type || r2.ref || e2.push(new it(n2, r2, 'either "type" or "ref" is required'));
        let a2 = On(r2.type);
        const o2 = On(r2.ref);
        if (r2.id) {
          const s3 = On(r2.id);
          for (let a3 = 0;a3 < t2.arrayIndex; a3++) {
            const t3 = i2.layers[a3];
            On(t3.id) === s3 && e2.push(new it(n2, r2.id, `duplicate layer id "${r2.id}", previously used at line ${t3.id.__line__}`));
          }
        }
        if ("ref" in r2) {
          let t3;
          ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
            t4 in r2 && e2.push(new it(n2, r2[t4], `"${t4}" is prohibited for ref layers`));
          }), i2.layers.forEach((e3) => {
            On(e3.id) === o2 && (t3 = e3);
          }), t3 ? t3.ref ? e2.push(new it(n2, r2.ref, "ref cannot reference another ref layer")) : a2 = On(t3.type) : e2.push(new it(n2, r2.ref, `ref layer "${o2}" not found`));
        } else if (a2 !== "background")
          if (r2.source) {
            const t3 = i2.sources && i2.sources[r2.source], s3 = t3 && On(t3.type);
            t3 ? s3 === "vector" && a2 === "raster" ? e2.push(new it(n2, r2.source, `layer "${r2.id}" requires a raster source`)) : s3 !== "raster-dem" && a2 === "hillshade" ? e2.push(new it(n2, r2.source, `layer "${r2.id}" requires a raster-dem source`)) : s3 === "raster" && a2 !== "raster" ? e2.push(new it(n2, r2.source, `layer "${r2.id}" requires a vector source`)) : s3 !== "vector" || r2["source-layer"] ? s3 === "raster-dem" && a2 !== "hillshade" ? e2.push(new it(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : a2 !== "line" || !r2.paint || !r2.paint["line-gradient"] || s3 === "geojson" && t3.lineMetrics || e2.push(new it(n2, r2, `layer "${r2.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e2.push(new it(n2, r2, `layer "${r2.id}" must specify a "source-layer"`)) : e2.push(new it(n2, r2.source, `source "${r2.source}" not found`));
          } else
            e2.push(new it(n2, r2, 'missing required property "source"'));
        return e2 = e2.concat(Rn({
          key: n2,
          value: r2,
          valueSpec: s2.layer,
          style: t2.style,
          styleSpec: t2.styleSpec,
          validateSpec: t2.validateSpec,
          objectElementValidators: {
            "*": () => [],
            type: () => t2.validateSpec({
              key: `${n2}.type`,
              value: r2.type,
              valueSpec: s2.layer.type,
              style: t2.style,
              styleSpec: t2.styleSpec,
              validateSpec: t2.validateSpec,
              object: r2,
              objectKey: "type"
            }),
            filter: Kn,
            layout: (t3) => Rn({
              layer: r2,
              key: t3.key,
              value: t3.value,
              style: t3.style,
              styleSpec: t3.styleSpec,
              validateSpec: t3.validateSpec,
              objectElementValidators: { "*": (t4) => Jn(st({ layerType: a2 }, t4)) }
            }),
            paint: (t3) => Rn({
              layer: r2,
              key: t3.key,
              value: t3.value,
              style: t3.style,
              styleSpec: t3.styleSpec,
              validateSpec: t3.validateSpec,
              objectElementValidators: { "*": (t4) => Yn(st({ layerType: a2 }, t4)) }
            })
          }
        })), e2;
      }
      function Qn(t2) {
        const { value: e2, key: r2 } = t2, n2 = un(e2);
        return n2 !== "string" ? [new it(r2, e2, `string expected, ${n2} found`)] : [];
      }
      const ti = {
        promoteId: function({ key: t2, value: e2 }) {
          if (un(e2) === "string")
            return Qn({ key: t2, value: e2 });
          {
            const r2 = [];
            for (const n2 in e2)
              r2.push(...Qn({ key: `${t2}.${n2}`, value: e2[n2] }));
            return r2;
          }
        }
      };
      function ei(t2) {
        const { value: e2, key: r2, styleSpec: n2, style: i2, validateSpec: s2 } = t2;
        if (!e2.type)
          return [new it(r2, e2, '"type" is required')];
        const a2 = On(e2.type);
        let o2;
        switch (a2) {
          case "vector":
          case "raster":
            return o2 = Rn({
              key: r2,
              value: e2,
              valueSpec: n2[`source_${a2.replace("-", "_")}`],
              style: t2.style,
              styleSpec: n2,
              objectElementValidators: ti,
              validateSpec: s2
            }), o2;
          case "raster-dem":
            return o2 = function(t3) {
              var e3;
              const r3 = (e3 = t3.sourceName) !== null && e3 !== undefined ? e3 : "", n3 = t3.value, i3 = t3.styleSpec, s3 = i3.source_raster_dem, a3 = t3.style;
              let o3 = [];
              const l2 = un(n3);
              if (n3 === undefined)
                return o3;
              if (l2 !== "object")
                return o3.push(new it("source_raster_dem", n3, `object expected, ${l2} found`)), o3;
              const u2 = On(n3.encoding) === "custom", c2 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h2 = t3.value.encoding ? `"${t3.value.encoding}"` : "Default";
              for (const e4 in n3)
                !u2 && c2.includes(e4) ? o3.push(new it(e4, n3[e4], `In "${r3}": "${e4}" is only valid when "encoding" is set to "custom". ${h2} encoding found`)) : s3[e4] ? o3 = o3.concat(t3.validateSpec({
                  key: e4,
                  value: n3[e4],
                  valueSpec: s3[e4],
                  validateSpec: t3.validateSpec,
                  style: a3,
                  styleSpec: i3
                })) : o3.push(new it(e4, n3[e4], `unknown property "${e4}"`));
              return o3;
            }({
              sourceName: r2,
              value: e2,
              style: t2.style,
              styleSpec: n2,
              validateSpec: s2
            }), o2;
          case "geojson":
            if (o2 = Rn({
              key: r2,
              value: e2,
              valueSpec: n2.source_geojson,
              style: i2,
              styleSpec: n2,
              validateSpec: s2,
              objectElementValidators: ti
            }), e2.cluster)
              for (const t3 in e2.clusterProperties) {
                const [n3, i3] = e2.clusterProperties[t3], a3 = typeof n3 == "string" ? [n3, ["accumulated"], ["get", t3]] : n3;
                o2.push(...Zn({
                  key: `${r2}.${t3}.map`,
                  value: i3,
                  validateSpec: s2,
                  expressionContext: "cluster-map"
                })), o2.push(...Zn({
                  key: `${r2}.${t3}.reduce`,
                  value: a3,
                  validateSpec: s2,
                  expressionContext: "cluster-reduce"
                }));
              }
            return o2;
          case "video":
            return Rn({
              key: r2,
              value: e2,
              valueSpec: n2.source_video,
              style: i2,
              validateSpec: s2,
              styleSpec: n2
            });
          case "image":
            return Rn({
              key: r2,
              value: e2,
              valueSpec: n2.source_image,
              style: i2,
              validateSpec: s2,
              styleSpec: n2
            });
          case "canvas":
            return [
              new it(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")
            ];
          default:
            return Gn({
              key: `${r2}.type`,
              value: e2.type,
              valueSpec: {
                values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
              },
              style: i2,
              validateSpec: s2,
              styleSpec: n2
            });
        }
      }
      function ri(t2) {
        const { value: e2, styleSpec: r2 } = t2, n2 = r2.light, i2 = t2.style;
        let s2 = [];
        const a2 = un(e2);
        if (e2 === undefined)
          return s2;
        if (a2 !== "object")
          return s2 = s2.concat([new it("light", e2, `object expected, ${a2} found`)]), s2;
        for (const a3 in e2) {
          const o2 = a3.match(/^(.*)-transition$/);
          s2 = s2.concat(o2 && n2[o2[1]] && n2[o2[1]].transition ? t2.validateSpec({
            key: a3,
            value: e2[a3],
            valueSpec: r2.transition,
            validateSpec: t2.validateSpec,
            style: i2,
            styleSpec: r2
          }) : n2[a3] ? t2.validateSpec({
            key: a3,
            value: e2[a3],
            valueSpec: n2[a3],
            validateSpec: t2.validateSpec,
            style: i2,
            styleSpec: r2
          }) : [new it(a3, e2[a3], `unknown property "${a3}"`)]);
        }
        return s2;
      }
      function ni(t2) {
        const { value: e2, styleSpec: r2 } = t2, n2 = r2.sky, i2 = t2.style, s2 = un(e2);
        if (e2 === undefined)
          return [];
        if (s2 !== "object")
          return [new it("sky", e2, `object expected, ${s2} found`)];
        let a2 = [];
        for (const s3 in e2)
          a2 = a2.concat(n2[s3] ? t2.validateSpec({
            key: s3,
            value: e2[s3],
            valueSpec: n2[s3],
            style: i2,
            styleSpec: r2
          }) : [new it(s3, e2[s3], `unknown property "${s3}"`)]);
        return a2;
      }
      function ii(t2) {
        const { value: e2, styleSpec: r2 } = t2, n2 = r2.terrain, i2 = t2.style;
        let s2 = [];
        const a2 = un(e2);
        if (e2 === undefined)
          return s2;
        if (a2 !== "object")
          return s2 = s2.concat([new it("terrain", e2, `object expected, ${a2} found`)]), s2;
        for (const a3 in e2)
          s2 = s2.concat(n2[a3] ? t2.validateSpec({
            key: a3,
            value: e2[a3],
            valueSpec: n2[a3],
            validateSpec: t2.validateSpec,
            style: i2,
            styleSpec: r2
          }) : [new it(a3, e2[a3], `unknown property "${a3}"`)]);
        return s2;
      }
      function si(t2) {
        let e2 = [];
        const { value: r2, key: n2 } = t2;
        if (Array.isArray(r2)) {
          const i2 = [], s2 = [];
          for (const a2 in r2)
            r2[a2].id && i2.includes(r2[a2].id) && e2.push(new it(n2, r2, `all the sprites' ids must be unique, but ${r2[a2].id} is duplicated`)), i2.push(r2[a2].id), r2[a2].url && s2.includes(r2[a2].url) && e2.push(new it(n2, r2, `all the sprites' URLs must be unique, but ${r2[a2].url} is duplicated`)), s2.push(r2[a2].url), e2 = e2.concat(Rn({
              key: `${n2}[${a2}]`,
              value: r2[a2],
              valueSpec: {
                id: { type: "string", required: true },
                url: { type: "string", required: true }
              },
              validateSpec: t2.validateSpec
            }));
          return e2;
        }
        return Qn({ key: n2, value: r2 });
      }
      const ai = {
        "*": () => [],
        array: Un,
        boolean: function(t2) {
          const { value: e2, key: r2 } = t2, n2 = un(e2);
          return n2 !== "boolean" ? [new it(r2, e2, `boolean expected, ${n2} found`)] : [];
        },
        number: qn,
        color: function(t2) {
          const { key: e2, value: r2 } = t2, n2 = un(r2);
          return n2 !== "string" ? [new it(e2, r2, `color expected, ${n2} found`)] : Kt.parse(String(r2)) ? [] : [new it(e2, r2, `color expected, "${r2}" found`)];
        },
        constants: Dn,
        enum: Gn,
        filter: Kn,
        function: Nn,
        layer: Wn,
        object: Rn,
        source: ei,
        light: ri,
        sky: ni,
        terrain: ii,
        projection: function(t2) {
          const { value: e2, styleSpec: r2 } = t2, n2 = r2.projection, i2 = t2.style, s2 = un(e2);
          if (e2 === undefined)
            return [];
          if (s2 !== "object")
            return [new it("projection", e2, `object expected, ${s2} found`)];
          let a2 = [];
          for (const s3 in e2)
            a2 = a2.concat(n2[s3] ? t2.validateSpec({
              key: s3,
              value: e2[s3],
              valueSpec: n2[s3],
              style: i2,
              styleSpec: r2
            }) : [new it(s3, e2[s3], `unknown property "${s3}"`)]);
          return a2;
        },
        string: Qn,
        formatted: function(t2) {
          return Qn(t2).length === 0 ? [] : Zn(t2);
        },
        resolvedImage: function(t2) {
          return Qn(t2).length === 0 ? [] : Zn(t2);
        },
        padding: function(t2) {
          const { key: e2, value: r2 } = t2;
          if (un(r2) === "array") {
            if (r2.length < 1 || r2.length > 4)
              return [
                new it(e2, r2, `padding requires 1 to 4 values; ${r2.length} values found`)
              ];
            const n2 = { type: "number" };
            let i2 = [];
            for (let s2 = 0;s2 < r2.length; s2++)
              i2 = i2.concat(t2.validateSpec({
                key: `${e2}[${s2}]`,
                value: r2[s2],
                validateSpec: t2.validateSpec,
                valueSpec: n2
              }));
            return i2;
          }
          return qn({ key: e2, value: r2, valueSpec: {} });
        },
        variableAnchorOffsetCollection: function(t2) {
          const { key: e2, value: r2 } = t2, n2 = un(r2), i2 = t2.styleSpec;
          if (n2 !== "array" || r2.length < 1 || r2.length % 2 != 0)
            return [
              new it(e2, r2, "variableAnchorOffsetCollection requires a non-empty array of even length")
            ];
          let s2 = [];
          for (let n3 = 0;n3 < r2.length; n3 += 2)
            s2 = s2.concat(Gn({
              key: `${e2}[${n3}]`,
              value: r2[n3],
              valueSpec: i2.layout_symbol["text-anchor"]
            })), s2 = s2.concat(Un({
              key: `${e2}[${n3 + 1}]`,
              value: r2[n3 + 1],
              valueSpec: { length: 2, value: "number" },
              validateSpec: t2.validateSpec,
              style: t2.style,
              styleSpec: i2
            }));
          return s2;
        },
        sprite: si
      };
      function oi(t2) {
        const { value: e2, valueSpec: r2, styleSpec: n2 } = t2;
        return t2.validateSpec = oi, r2.expression && cn(On(e2)) ? Nn(t2) : r2.expression && vn(jn(e2)) ? Zn(t2) : r2.type && ai[r2.type] ? ai[r2.type](t2) : Rn(st({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
      }
      function li(t2) {
        const { value: e2, key: r2 } = t2, n2 = Qn(t2);
        return n2.length || (e2.indexOf("{fontstack}") === -1 && n2.push(new it(r2, e2, '"glyphs" url must include a "{fontstack}" token')), e2.indexOf("{range}") === -1 && n2.push(new it(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
      }
      function ui(t2, e2 = G) {
        let r2 = [];
        return r2 = r2.concat(oi({
          key: "",
          value: t2,
          valueSpec: e2.$root,
          styleSpec: e2,
          style: t2,
          validateSpec: oi,
          objectElementValidators: { glyphs: li, "*": () => [] }
        })), t2.constants && (r2 = r2.concat(Dn({
          key: "constants",
          value: t2.constants,
          style: t2,
          styleSpec: e2,
          validateSpec: oi
        }))), hi(r2);
      }
      function ci(t2) {
        return function(e2) {
          return t2({ ...e2, validateSpec: oi });
        };
      }
      function hi(t2) {
        return [].concat(t2).sort((t3, e2) => t3.line - e2.line);
      }
      function pi(t2) {
        return function(...e2) {
          return hi(t2.apply(this, e2));
        };
      }
      ui.source = pi(ci(ei)), ui.sprite = pi(ci(si)), ui.glyphs = pi(ci(li)), ui.light = pi(ci(ri)), ui.sky = pi(ci(ni)), ui.terrain = pi(ci(ii)), ui.layer = pi(ci(Wn)), ui.filter = pi(ci(Kn)), ui.paintProperty = pi(ci(Yn)), ui.layoutProperty = pi(ci(Jn));
      const fi = ui, di = fi.light, yi = fi.sky, mi = fi.paintProperty, gi = fi.layoutProperty;
      function xi(t2, e2) {
        let r2 = false;
        if (e2 && e2.length)
          for (const n2 of e2)
            t2.fire(new N(new Error(n2.message))), r2 = true;
        return r2;
      }

      class vi {
        constructor(t2, e2, r2) {
          const n2 = this.cells = [];
          if (t2 instanceof ArrayBuffer) {
            this.arrayBuffer = t2;
            const i3 = new Int32Array(this.arrayBuffer);
            t2 = i3[0], this.d = (e2 = i3[1]) + 2 * (r2 = i3[2]);
            for (let t3 = 0;t3 < this.d * this.d; t3++) {
              const e3 = i3[3 + t3], r3 = i3[3 + t3 + 1];
              n2.push(e3 === r3 ? null : i3.subarray(e3, r3));
            }
            const s2 = i3[3 + n2.length + 1];
            this.keys = i3.subarray(i3[3 + n2.length], s2), this.bboxes = i3.subarray(s2), this.insert = this._insertReadonly;
          } else {
            this.d = e2 + 2 * r2;
            for (let t3 = 0;t3 < this.d * this.d; t3++)
              n2.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
          const i2 = r2 / e2 * t2;
          this.min = -i2, this.max = t2 + i2;
        }
        insert(t2, e2, r2, n2, i2) {
          this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++, undefined, undefined), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(t2, e2, r2, n2, i2, s2) {
          this.cells[i2].push(s2);
        }
        query(t2, e2, r2, n2, i2) {
          const s2 = this.min, a2 = this.max;
          if (t2 <= s2 && e2 <= s2 && a2 <= r2 && a2 <= n2 && !i2)
            return Array.prototype.slice.call(this.keys);
          {
            const s3 = [];
            return this._forEachCell(t2, e2, r2, n2, this._queryCell, s3, {}, i2), s3;
          }
        }
        _queryCell(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = this.cells[i2];
          if (l2 !== null) {
            const i3 = this.keys, u2 = this.bboxes;
            for (let c2 = 0;c2 < l2.length; c2++) {
              const h2 = l2[c2];
              if (a2[h2] === undefined) {
                const l3 = 4 * h2;
                (o2 ? o2(u2[l3 + 0], u2[l3 + 1], u2[l3 + 2], u2[l3 + 3]) : t2 <= u2[l3 + 2] && e2 <= u2[l3 + 3] && r2 >= u2[l3 + 0] && n2 >= u2[l3 + 1]) ? (a2[h2] = true, s2.push(i3[h2])) : a2[h2] = false;
              }
            }
          }
        }
        _forEachCell(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = this._convertToCellCoord(t2), u2 = this._convertToCellCoord(e2), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2);
          for (let p2 = l2;p2 <= c2; p2++)
            for (let l3 = u2;l3 <= h2; l3++) {
              const u3 = this.d * l3 + p2;
              if ((!o2 || o2(this._convertFromCellCoord(p2), this._convertFromCellCoord(l3), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(l3 + 1))) && i2.call(this, t2, e2, r2, n2, u3, s2, a2, o2))
                return;
            }
        }
        _convertFromCellCoord(t2) {
          return (t2 - this.padding) / this.scale;
        }
        _convertToCellCoord(t2) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer)
            return this.arrayBuffer;
          const t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1;
          let r2 = 0;
          for (let t3 = 0;t3 < this.cells.length; t3++)
            r2 += this.cells[t3].length;
          const n2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
          n2[0] = this.extent, n2[1] = this.n, n2[2] = this.padding;
          let i2 = e2;
          for (let e3 = 0;e3 < t2.length; e3++) {
            const r3 = t2[e3];
            n2[3 + e3] = i2, n2.set(r3, i2), i2 += r3.length;
          }
          return n2[3 + t2.length] = i2, n2.set(this.keys, i2), i2 += this.keys.length, n2[3 + t2.length + 1] = i2, n2.set(this.bboxes, i2), i2 += this.bboxes.length, n2.buffer;
        }
        static serialize(t2, e2) {
          const r2 = t2.toArrayBuffer();
          return e2 && e2.push(r2), { buffer: r2 };
        }
        static deserialize(t2) {
          return new vi(t2.buffer);
        }
      }
      const bi = {};
      function wi(t2, e2, r2 = {}) {
        if (bi[t2])
          throw new Error(`${t2} is already registered.`);
        Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), bi[t2] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
      }
      wi("Object", Object), wi("TransferableGridIndex", vi), wi("Color", Kt), wi("Error", Error), wi("AJAXError", L), wi("ResolvedImage", te), wi("StylePropertyFunction", Sn), wi("StyleExpression", xn, { omit: ["_evaluator"] }), wi("ZoomDependentExpression", _n), wi("ZoomConstantExpression", wn), wi("CompoundExpression", Xr, { omit: ["_evaluate"] });
      for (const t2 in Kr)
        Kr[t2]._classRegistryKey || wi(`Expression_${t2}`, Kr[t2]);
      function _i(t2) {
        return t2 && typeof ArrayBuffer != "undefined" && (t2 instanceof ArrayBuffer || t2.constructor && t2.constructor.name === "ArrayBuffer");
      }
      function Ai(t2) {
        return t2.$name || t2.constructor._classRegistryKey;
      }
      function Si(t2) {
        return !function(t3) {
          if (t3 === null || typeof t3 != "object")
            return false;
          const e2 = Ai(t3);
          return !(!e2 || e2 === "Object");
        }(t2) && (t2 == null || typeof t2 == "boolean" || typeof t2 == "number" || typeof t2 == "string" || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || t2 instanceof Blob || t2 instanceof Error || _i(t2) || I(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData);
      }
      function ki(t2, e2) {
        if (Si(t2))
          return (_i(t2) || I(t2)) && e2 && e2.push(t2), ArrayBuffer.isView(t2) && e2 && e2.push(t2.buffer), t2 instanceof ImageData && e2 && e2.push(t2.data.buffer), t2;
        if (Array.isArray(t2)) {
          const r3 = [];
          for (const n3 of t2)
            r3.push(ki(n3, e2));
          return r3;
        }
        if (typeof t2 != "object")
          throw new Error("can't serialize object of type " + typeof t2);
        const r2 = Ai(t2);
        if (!r2)
          throw new Error(`can't serialize object of unregistered class ${t2.constructor.name}`);
        if (!bi[r2])
          throw new Error(`${r2} is not registered.`);
        const { klass: n2 } = bi[r2], i2 = n2.serialize ? n2.serialize(t2, e2) : {};
        if (n2.serialize) {
          if (e2 && i2 === e2[e2.length - 1])
            throw new Error("statically serialized object won't survive transfer of $name property");
        } else {
          for (const n3 in t2) {
            if (!t2.hasOwnProperty(n3))
              continue;
            if (bi[r2].omit.indexOf(n3) >= 0)
              continue;
            const s2 = t2[n3];
            i2[n3] = bi[r2].shallow.indexOf(n3) >= 0 ? s2 : ki(s2, e2);
          }
          t2 instanceof Error && (i2.message = t2.message);
        }
        if (i2.$name)
          throw new Error("$name property is reserved for worker serialization logic.");
        return r2 !== "Object" && (i2.$name = r2), i2;
      }
      function Mi(t2) {
        if (Si(t2))
          return t2;
        if (Array.isArray(t2))
          return t2.map(Mi);
        if (typeof t2 != "object")
          throw new Error("can't deserialize object of type " + typeof t2);
        const e2 = Ai(t2) || "Object";
        if (!bi[e2])
          throw new Error(`can't deserialize unregistered class ${e2}`);
        const { klass: r2 } = bi[e2];
        if (!r2)
          throw new Error(`can't deserialize unregistered class ${e2}`);
        if (r2.deserialize)
          return r2.deserialize(t2);
        const n2 = Object.create(r2.prototype);
        for (const r3 of Object.keys(t2)) {
          if (r3 === "$name")
            continue;
          const i2 = t2[r3];
          n2[r3] = bi[e2].shallow.indexOf(r3) >= 0 ? i2 : Mi(i2);
        }
        return n2;
      }

      class Ii {
        constructor() {
          this.first = true;
        }
        update(t2, e2) {
          const r2 = Math.floor(t2);
          return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
        }
      }
      const zi = {
        "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255,
        "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607,
        Khmer: (t2) => t2 >= 6016 && t2 <= 6143,
        "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303,
        "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527,
        "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591,
        "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215,
        "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279,
        "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311,
        "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471,
        "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727,
        "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983,
        "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263,
        "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287,
        "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351,
        Katakana: (t2) => t2 >= 12448 && t2 <= 12543,
        Kanbun: (t2) => t2 >= 12688 && t2 <= 12703,
        "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783,
        "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055,
        "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311,
        "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967,
        "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743,
        "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055,
        "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103,
        "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135,
        "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519
      };
      function Pi(t2) {
        for (const e2 of t2)
          if (Ti(e2.charCodeAt(0)))
            return true;
        return false;
      }
      function Ci(t2) {
        for (const e2 of t2)
          if (!Ei(e2.charCodeAt(0)))
            return false;
        return true;
      }
      function Bi(t2) {
        const e2 = t2.map((t3) => {
          try {
            return new RegExp(`\\p{sc=${t3}}`, "u").source;
          } catch (t4) {
            return null;
          }
        }).filter((t3) => t3);
        return new RegExp(e2.join("|"), "u");
      }
      const Vi = Bi(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
      function Ei(t2) {
        return !Vi.test(String.fromCodePoint(t2));
      }
      const Fi = Bi([
        "Bopo",
        "Hani",
        "Hira",
        "Kana",
        "Kits",
        "Nshu",
        "Tang",
        "Yiii"
      ]);
      function Ti(t2) {
        return !(t2 !== 746 && t2 !== 747 && (t2 < 4352 || !(zi["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || zi["CJK Compatibility"](t2) || zi["CJK Strokes"](t2) || !(!zi["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || t2 === 12336) || zi["Enclosed CJK Letters and Months"](t2) || zi["Ideographic Description Characters"](t2) || zi.Kanbun(t2) || zi.Katakana(t2) && t2 !== 12540 || !(!zi["Halfwidth and Fullwidth Forms"](t2) || t2 === 65288 || t2 === 65289 || t2 === 65293 || t2 >= 65306 && t2 <= 65310 || t2 === 65339 || t2 === 65341 || t2 === 65343 || t2 >= 65371 && t2 <= 65503 || t2 === 65507 || t2 >= 65512 && t2 <= 65519) || !(!zi["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || zi["Vertical Forms"](t2) || zi["Yijing Hexagram Symbols"](t2) || /\p{sc=Cans}/u.test(String.fromCodePoint(t2)) || /\p{sc=Hang}/u.test(String.fromCodePoint(t2)) || Fi.test(String.fromCodePoint(t2)))));
      }
      function $i(t2) {
        return !(Ti(t2) || function(t3) {
          return !!(zi["Latin-1 Supplement"](t3) && (t3 === 167 || t3 === 169 || t3 === 174 || t3 === 177 || t3 === 188 || t3 === 189 || t3 === 190 || t3 === 215 || t3 === 247) || zi["General Punctuation"](t3) && (t3 === 8214 || t3 === 8224 || t3 === 8225 || t3 === 8240 || t3 === 8241 || t3 === 8251 || t3 === 8252 || t3 === 8258 || t3 === 8263 || t3 === 8264 || t3 === 8265 || t3 === 8273) || zi["Letterlike Symbols"](t3) || zi["Number Forms"](t3) || zi["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9000 || t3 === 9003 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || t3 === 9167 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || zi["Control Pictures"](t3) && t3 !== 9251 || zi["Optical Character Recognition"](t3) || zi["Enclosed Alphanumerics"](t3) || zi["Geometric Shapes"](t3) || zi["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || zi["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || zi["CJK Symbols and Punctuation"](t3) || zi.Katakana(t3) || zi["Private Use Area"](t3) || zi["CJK Compatibility Forms"](t3) || zi["Small Form Variants"](t3) || zi["Halfwidth and Fullwidth Forms"](t3) || t3 === 8734 || t3 === 8756 || t3 === 8757 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || t3 === 65532 || t3 === 65533);
        }(t2));
      }
      const Li = Bi([
        "Adlm",
        "Arab",
        "Armi",
        "Avst",
        "Chrs",
        "Cprt",
        "Egyp",
        "Elym",
        "Gara",
        "Hatr",
        "Hebr",
        "Hung",
        "Khar",
        "Lydi",
        "Mand",
        "Mani",
        "Mend",
        "Merc",
        "Mero",
        "Narb",
        "Nbat",
        "Nkoo",
        "Orkh",
        "Palm",
        "Phli",
        "Phlp",
        "Phnx",
        "Prti",
        "Rohg",
        "Samr",
        "Sarb",
        "Sogo",
        "Syrc",
        "Thaa",
        "Todr",
        "Yezi"
      ]);
      function Di(t2) {
        return Li.test(String.fromCodePoint(t2));
      }
      function Oi(t2, e2) {
        return !(!e2 && Di(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || zi.Khmer(t2));
      }
      function ji(t2) {
        for (const e2 of t2)
          if (Di(e2.charCodeAt(0)))
            return true;
        return false;
      }
      const Ri = new class {
        constructor() {
          this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null;
        }
        setState(t2) {
          this.pluginStatus = t2.pluginStatus, this.pluginURL = t2.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(t2) {
          this.applyArabicShaping = t2.applyArabicShaping, this.processBidirectionalText = t2.processBidirectionalText, this.processStyledBidirectionalText = t2.processStyledBidirectionalText;
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getPluginURL() {
          return this.pluginURL;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
      };

      class Ui {
        constructor(t2, e2) {
          this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Ii, this.transition = {});
        }
        isSupportedScript(t2) {
          return function(t3, e2) {
            for (const r2 of t3)
              if (!Oi(r2.charCodeAt(0), e2))
                return false;
            return true;
          }(t2, Ri.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const t2 = this.zoom, e2 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
          return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
        }
      }

      class qi {
        constructor(t2, e2) {
          this.property = t2, this.value = e2, this.expression = function(t3, e3) {
            if (cn(t3))
              return new Sn(t3, e3);
            if (vn(t3)) {
              const r2 = An(t3, e3);
              if (r2.result === "error")
                throw new Error(r2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
              return r2.value;
            }
            {
              let r2 = t3;
              return e3.type === "color" && typeof t3 == "string" ? r2 = Kt.parse(t3) : e3.type !== "padding" || typeof t3 != "number" && !Array.isArray(t3) ? e3.type === "variableAnchorOffsetCollection" && Array.isArray(t3) && (r2 = Qt.parse(t3)) : r2 = Jt.parse(t3), { kind: "constant", evaluate: () => r2 };
            }
          }(e2 === undefined ? t2.specification.default : e2, t2.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(t2, e2, r2) {
          return this.property.possiblyEvaluate(this, t2, e2, r2);
        }
      }

      class Ni {
        constructor(t2) {
          this.property = t2, this.value = new qi(t2, undefined);
        }
        transitioned(t2, e2) {
          return new Gi(this.property, this.value, e2, g({}, t2.transition, this.transition), t2.now);
        }
        untransitioned() {
          return new Gi(this.property, this.value, null, {}, 0);
        }
      }

      class Zi {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
        }
        getValue(t2) {
          return w(this._values[t2].value.value);
        }
        setValue(t2, e2) {
          Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Ni(this._values[t2].property)), this._values[t2].value = new qi(this._values[t2].property, e2 === null ? undefined : w(e2));
        }
        getTransition(t2) {
          return w(this._values[t2].transition);
        }
        setTransition(t2, e2) {
          Object.prototype.hasOwnProperty.call(this._values, t2) || (this._values[t2] = new Ni(this._values[t2].property)), this._values[t2].transition = w(e2) || undefined;
        }
        serialize() {
          const t2 = {};
          for (const e2 of Object.keys(this._values)) {
            const r2 = this.getValue(e2);
            r2 !== undefined && (t2[e2] = r2);
            const n2 = this.getTransition(e2);
            n2 !== undefined && (t2[`${e2}-transition`] = n2);
          }
          return t2;
        }
        transitioned(t2, e2) {
          const r2 = new Ki(this._properties);
          for (const n2 of Object.keys(this._values))
            r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
          return r2;
        }
        untransitioned() {
          const t2 = new Ki(this._properties);
          for (const e2 of Object.keys(this._values))
            t2._values[e2] = this._values[e2].untransitioned();
          return t2;
        }
      }

      class Gi {
        constructor(t2, e2, r2, n2, i2) {
          this.property = t2, this.value = e2, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
          if (s2) {
            if (n2 > this.end)
              return this.prior = null, i2;
            if (this.value.isDataDriven())
              return this.prior = null, i2;
            if (n2 < this.begin)
              return s2.possiblyEvaluate(t2, e2, r2);
            {
              const a2 = (n2 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, function(t3) {
                if (t3 <= 0)
                  return 0;
                if (t3 >= 1)
                  return 1;
                const e3 = t3 * t3, r3 = e3 * t3;
                return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e3) + r3 - 0.75);
              }(a2));
            }
          }
          return i2;
        }
      }

      class Ki {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = new Yi(this._properties);
          for (const i2 of Object.keys(this._values))
            n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
          return n2;
        }
        hasTransition() {
          for (const t2 of Object.keys(this._values))
            if (this._values[t2].prior)
              return true;
          return false;
        }
      }

      class Xi {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
        }
        hasValue(t2) {
          return this._values[t2].value !== undefined;
        }
        getValue(t2) {
          return w(this._values[t2].value);
        }
        setValue(t2, e2) {
          this._values[t2] = new qi(this._values[t2].property, e2 === null ? undefined : w(e2));
        }
        serialize() {
          const t2 = {};
          for (const e2 of Object.keys(this._values)) {
            const r2 = this.getValue(e2);
            r2 !== undefined && (t2[e2] = r2);
          }
          return t2;
        }
        possiblyEvaluate(t2, e2, r2) {
          const n2 = new Yi(this._properties);
          for (const i2 of Object.keys(this._values))
            n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
          return n2;
        }
      }

      class Hi {
        constructor(t2, e2, r2) {
          this.property = t2, this.value = e2, this.parameters = r2;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(t2) {
          return this.value.kind === "constant" ? this.value.value : t2;
        }
        evaluate(t2, e2, r2, n2) {
          return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
        }
      }

      class Yi {
        constructor(t2) {
          this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
        }
        get(t2) {
          return this._values[t2];
        }
      }

      class Ji {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2) {
          if (t2.isDataDriven())
            throw new Error("Value should not be data driven");
          return t2.expression.evaluate(e2);
        }
        interpolate(t2, e2, r2) {
          const n2 = Ce[this.specification.type];
          return n2 ? n2(t2, e2, r2) : t2;
        }
      }

      class Wi {
        constructor(t2, e2) {
          this.specification = t2, this.overrides = e2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          return new Hi(this, t2.expression.kind === "constant" || t2.expression.kind === "camera" ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
        }
        interpolate(t2, e2, r2) {
          if (t2.value.kind !== "constant" || e2.value.kind !== "constant")
            return t2;
          if (t2.value.value === undefined || e2.value.value === undefined)
            return new Hi(this, { kind: "constant", value: undefined }, t2.parameters);
          const n2 = Ce[this.specification.type];
          if (n2) {
            const i2 = n2(t2.value.value, e2.value.value, r2);
            return new Hi(this, { kind: "constant", value: i2 }, t2.parameters);
          }
          return t2;
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          return t2.kind === "constant" ? t2.value : t2.evaluate(e2, r2, n2, i2, s2);
        }
      }

      class Qi extends Wi {
        possiblyEvaluate(t2, e2, r2, n2) {
          if (t2.value === undefined)
            return new Hi(this, { kind: "constant", value: undefined }, e2);
          if (t2.expression.kind === "constant") {
            const i2 = t2.expression.evaluate(e2, null, {}, r2, n2), s2 = t2.property.specification.type === "resolvedImage" && typeof i2 != "string" ? i2.name : i2, a2 = this._calculate(s2, s2, s2, e2);
            return new Hi(this, { kind: "constant", value: a2 }, e2);
          }
          if (t2.expression.kind === "camera") {
            const r3 = this._calculate(t2.expression.evaluate({ zoom: e2.zoom - 1 }), t2.expression.evaluate({ zoom: e2.zoom }), t2.expression.evaluate({ zoom: e2.zoom + 1 }), e2);
            return new Hi(this, { kind: "constant", value: r3 }, e2);
          }
          return new Hi(this, t2.expression, e2);
        }
        evaluate(t2, e2, r2, n2, i2, s2) {
          if (t2.kind === "source") {
            const a2 = t2.evaluate(e2, r2, n2, i2, s2);
            return this._calculate(a2, a2, a2, e2);
          }
          return t2.kind === "composite" ? this._calculate(t2.evaluate({ zoom: Math.floor(e2.zoom) - 1 }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) }, r2, n2), t2.evaluate({ zoom: Math.floor(e2.zoom) + 1 }, r2, n2), e2) : t2.value;
        }
        _calculate(t2, e2, r2, n2) {
          return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
        }
        interpolate(t2) {
          return t2;
        }
      }

      class ts {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          if (t2.value !== undefined) {
            if (t2.expression.kind === "constant") {
              const i2 = t2.expression.evaluate(e2, null, {}, r2, n2);
              return this._calculate(i2, i2, i2, e2);
            }
            return this._calculate(t2.expression.evaluate(new Ui(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new Ui(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new Ui(Math.floor(e2.zoom + 1), e2)), e2);
          }
        }
        _calculate(t2, e2, r2, n2) {
          return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
        }
        interpolate(t2) {
          return t2;
        }
      }

      class es {
        constructor(t2) {
          this.specification = t2;
        }
        possiblyEvaluate(t2, e2, r2, n2) {
          return !!t2.expression.evaluate(e2, null, {}, r2, n2);
        }
        interpolate() {
          return false;
        }
      }

      class rs {
        constructor(t2) {
          this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const e2 in t2) {
            const r2 = t2[e2];
            r2.specification.overridable && this.overridableProperties.push(e2);
            const n2 = this.defaultPropertyValues[e2] = new qi(r2, undefined), i2 = this.defaultTransitionablePropertyValues[e2] = new Ni(r2);
            this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
          }
        }
      }
      wi("DataDrivenProperty", Wi), wi("DataConstantProperty", Ji), wi("CrossFadedDataDrivenProperty", Qi), wi("CrossFadedProperty", ts), wi("ColorRampProperty", es);
      const ns = "-transition";

      class is extends Z {
        constructor(t2, e2) {
          if (super(), this.id = t2.id, this.type = t2.type, this._featureFilter = { filter: () => true, needGeometry: false }, t2.type !== "custom" && (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, t2.type !== "background" && (this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter), e2.layout && (this._unevaluatedLayout = new Xi(e2.layout)), e2.paint)) {
            this._transitionablePaint = new Zi(e2.paint);
            for (const e3 in t2.paint)
              this.setPaintProperty(e3, t2.paint[e3], { validate: false });
            for (const e3 in t2.layout)
              this.setLayoutProperty(e3, t2.layout[e3], { validate: false });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Yi(e2.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(t2) {
          return t2 === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t2);
        }
        setLayoutProperty(t2, e2, r2 = {}) {
          e2 != null && this._validate(gi, `layers.${this.id}.layout.${t2}`, t2, e2, r2) || (t2 !== "visibility" ? this._unevaluatedLayout.setValue(t2, e2) : this.visibility = e2);
        }
        getPaintProperty(t2) {
          return t2.endsWith(ns) ? this._transitionablePaint.getTransition(t2.slice(0, -11)) : this._transitionablePaint.getValue(t2);
        }
        setPaintProperty(t2, e2, r2 = {}) {
          if (e2 != null && this._validate(mi, `layers.${this.id}.paint.${t2}`, t2, e2, r2))
            return false;
          if (t2.endsWith(ns))
            return this._transitionablePaint.setTransition(t2.slice(0, -11), e2 || undefined), false;
          {
            const r3 = this._transitionablePaint._values[t2], n2 = r3.property.specification["property-type"] === "cross-faded-data-driven", i2 = r3.value.isDataDriven(), s2 = r3.value;
            this._transitionablePaint.setValue(t2, e2), this._handleSpecialPaintPropertyUpdate(t2);
            const a2 = this._transitionablePaint._values[t2].value;
            return a2.isDataDriven() || i2 || n2 || this._handleOverridablePaintPropertyUpdate(t2, s2, a2);
          }
        }
        _handleSpecialPaintPropertyUpdate(t2) {
        }
        _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
          return false;
        }
        isHidden(t2) {
          return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(t2) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t2, e2) {
          t2.getCrossfadeParameters && (this._crossfadeParameters = t2.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, undefined, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, undefined, e2);
        }
        serialize() {
          const t2 = {
            id: this.id,
            type: this.type,
            source: this.source,
            "source-layer": this.sourceLayer,
            metadata: this.metadata,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            filter: this.filter,
            layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
            paint: this._transitionablePaint && this._transitionablePaint.serialize()
          };
          return this.visibility && (t2.layout = t2.layout || {}, t2.layout.visibility = this.visibility), b(t2, (t3, e2) => !(t3 === undefined || e2 === "layout" && !Object.keys(t3).length || e2 === "paint" && !Object.keys(t3).length));
        }
        _validate(t2, e2, r2, n2, i2 = {}) {
          return (!i2 || i2.validate !== false) && xi(this, t2.call(fi, {
            key: e2,
            layerType: this.type,
            objectKey: r2,
            value: n2,
            styleSpec: G,
            style: { glyphs: true, sprite: true }
          }));
        }
        is3D() {
          return false;
        }
        isTileClipped() {
          return false;
        }
        hasOffscreenPass() {
          return false;
        }
        resize() {
        }
        isStateDependent() {
          for (const t2 in this.paint._values) {
            const e2 = this.paint.get(t2);
            if (e2 instanceof Hi && an(e2.property.specification) && (e2.value.kind === "source" || e2.value.kind === "composite") && e2.value.isStateDependent)
              return true;
          }
          return false;
        }
      }
      const ss = {
        Int8: Int8Array,
        Uint8: Uint8Array,
        Int16: Int16Array,
        Uint16: Uint16Array,
        Int32: Int32Array,
        Uint32: Uint32Array,
        Float32: Float32Array
      };

      class as {
        constructor(t2, e2) {
          this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }

      class os {
        constructor() {
          this.isTransferred = false, this.capacity = -1, this.resize(0);
        }
        static serialize(t2, e2) {
          return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
        }
        static deserialize(t2) {
          const e2 = Object.create(this.prototype);
          return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t2) {
          this.reserve(t2), this.length = t2;
        }
        reserve(t2) {
          if (t2 > this.capacity) {
            this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const e2 = this.uint8;
            this._refreshViews(), e2 && this.uint8.set(e2);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function ls(t2, e2 = 1) {
        let r2 = 0, n2 = 0;
        return {
          members: t2.map((t3) => {
            const i2 = ss[t3.type].BYTES_PER_ELEMENT, s2 = r2 = us(r2, Math.max(e2, i2)), a2 = t3.components || 1;
            return n2 = Math.max(n2, i2), r2 += i2 * a2, { name: t3.name, type: t3.type, components: a2, offset: s2 };
          }),
          size: us(r2, Math.max(n2, e2)),
          alignment: e2
        };
      }
      function us(t2, e2) {
        return Math.ceil(t2 / e2) * e2;
      }

      class cs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
        }
      }
      cs.prototype.bytesPerElement = 4, wi("StructArrayLayout2i4", cs);

      class hs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
        }
      }
      hs.prototype.bytesPerElement = 6, wi("StructArrayLayout3i6", hs);

      class ps extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
        }
      }
      ps.prototype.bytesPerElement = 8, wi("StructArrayLayout4i8", ps);

      class fs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 6 * t2;
          return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
        }
      }
      fs.prototype.bytesPerElement = 12, wi("StructArrayLayout2i4i12", fs);

      class ds extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 4 * t2, l2 = 8 * t2;
          return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.uint8[l2 + 4] = n2, this.uint8[l2 + 5] = i2, this.uint8[l2 + 6] = s2, this.uint8[l2 + 7] = a2, t2;
        }
      }
      ds.prototype.bytesPerElement = 8, wi("StructArrayLayout2i4ub8", ds);

      class ys extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
        }
      }
      ys.prototype.bytesPerElement = 8, wi("StructArrayLayout2f8", ys);

      class ms extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
          const c2 = this.length;
          return this.resize(c2 + 1), this.emplace(c2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
          const h2 = 10 * t2;
          return this.uint16[h2 + 0] = e2, this.uint16[h2 + 1] = r2, this.uint16[h2 + 2] = n2, this.uint16[h2 + 3] = i2, this.uint16[h2 + 4] = s2, this.uint16[h2 + 5] = a2, this.uint16[h2 + 6] = o2, this.uint16[h2 + 7] = l2, this.uint16[h2 + 8] = u2, this.uint16[h2 + 9] = c2, t2;
        }
      }
      ms.prototype.bytesPerElement = 20, wi("StructArrayLayout10ui20", ms);

      class gs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
          const p2 = this.length;
          return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
          const f2 = 12 * t2;
          return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = a2, this.uint16[f2 + 6] = o2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u2, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t2;
        }
      }
      gs.prototype.bytesPerElement = 24, wi("StructArrayLayout4i4ui4i24", gs);

      class xs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
        }
      }
      xs.prototype.bytesPerElement = 12, wi("StructArrayLayout3f12", xs);

      class vs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.uint32[1 * t2 + 0] = e2, t2;
        }
      }
      vs.prototype.bytesPerElement = 4, wi("StructArrayLayout1ul4", vs);

      class bs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = this.length;
          return this.resize(u2 + 1), this.emplace(u2, t2, e2, r2, n2, i2, s2, a2, o2, l2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2) {
          const c2 = 10 * t2, h2 = 5 * t2;
          return this.int16[c2 + 0] = e2, this.int16[c2 + 1] = r2, this.int16[c2 + 2] = n2, this.int16[c2 + 3] = i2, this.int16[c2 + 4] = s2, this.int16[c2 + 5] = a2, this.uint32[h2 + 3] = o2, this.uint16[c2 + 8] = l2, this.uint16[c2 + 9] = u2, t2;
        }
      }
      bs.prototype.bytesPerElement = 20, wi("StructArrayLayout6i1ul2ui20", bs);

      class ws extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 6 * t2;
          return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, this.int16[o2 + 5] = a2, t2;
        }
      }
      ws.prototype.bytesPerElement = 12, wi("StructArrayLayout2i2i2i12", ws);

      class _s extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2) {
          const s2 = this.length;
          return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
        }
        emplace(t2, e2, r2, n2, i2, s2) {
          const a2 = 4 * t2, o2 = 8 * t2;
          return this.float32[a2 + 0] = e2, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.int16[o2 + 6] = i2, this.int16[o2 + 7] = s2, t2;
        }
      }
      _s.prototype.bytesPerElement = 16, wi("StructArrayLayout2f1f2i16", _s);

      class As extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2) {
          const a2 = this.length;
          return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2) {
          const o2 = 16 * t2, l2 = 4 * t2, u2 = 8 * t2;
          return this.uint8[o2 + 0] = e2, this.uint8[o2 + 1] = r2, this.float32[l2 + 1] = n2, this.float32[l2 + 2] = i2, this.int16[u2 + 6] = s2, this.int16[u2 + 7] = a2, t2;
        }
      }
      As.prototype.bytesPerElement = 16, wi("StructArrayLayout2ub2f2i16", As);

      class Ss extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
        }
      }
      Ss.prototype.bytesPerElement = 6, wi("StructArrayLayout3ui6", Ss);

      class ks extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2) {
          const g2 = this.length;
          return this.resize(g2 + 1), this.emplace(g2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2) {
          const x2 = 24 * t2, v2 = 12 * t2, b2 = 48 * t2;
          return this.int16[x2 + 0] = e2, this.int16[x2 + 1] = r2, this.uint16[x2 + 2] = n2, this.uint16[x2 + 3] = i2, this.uint32[v2 + 2] = s2, this.uint32[v2 + 3] = a2, this.uint32[v2 + 4] = o2, this.uint16[x2 + 10] = l2, this.uint16[x2 + 11] = u2, this.uint16[x2 + 12] = c2, this.float32[v2 + 7] = h2, this.float32[v2 + 8] = p2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = d2, this.uint8[b2 + 38] = y2, this.uint32[v2 + 10] = m2, this.int16[x2 + 22] = g2, t2;
        }
      }
      ks.prototype.bytesPerElement = 48, wi("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", ks);

      class Ms extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, M2, I2) {
          const z2 = this.length;
          return this.resize(z2 + 1), this.emplace(z2, t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, M2, I2);
        }
        emplace(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2, m2, g2, x2, v2, b2, w2, _2, A2, S2, k2, M2, I2, z2) {
          const P2 = 32 * t2, C2 = 16 * t2;
          return this.int16[P2 + 0] = e2, this.int16[P2 + 1] = r2, this.int16[P2 + 2] = n2, this.int16[P2 + 3] = i2, this.int16[P2 + 4] = s2, this.int16[P2 + 5] = a2, this.int16[P2 + 6] = o2, this.int16[P2 + 7] = l2, this.uint16[P2 + 8] = u2, this.uint16[P2 + 9] = c2, this.uint16[P2 + 10] = h2, this.uint16[P2 + 11] = p2, this.uint16[P2 + 12] = f2, this.uint16[P2 + 13] = d2, this.uint16[P2 + 14] = y2, this.uint16[P2 + 15] = m2, this.uint16[P2 + 16] = g2, this.uint16[P2 + 17] = x2, this.uint16[P2 + 18] = v2, this.uint16[P2 + 19] = b2, this.uint16[P2 + 20] = w2, this.uint16[P2 + 21] = _2, this.uint16[P2 + 22] = A2, this.uint32[C2 + 12] = S2, this.float32[C2 + 13] = k2, this.float32[C2 + 14] = M2, this.uint16[P2 + 30] = I2, this.uint16[P2 + 31] = z2, t2;
        }
      }
      Ms.prototype.bytesPerElement = 64, wi("StructArrayLayout8i15ui1ul2f2ui64", Ms);

      class Is extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.float32[1 * t2 + 0] = e2, t2;
        }
      }
      Is.prototype.bytesPerElement = 4, wi("StructArrayLayout1f4", Is);

      class zs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 3 * t2;
          return this.uint16[6 * t2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
        }
      }
      zs.prototype.bytesPerElement = 12, wi("StructArrayLayout1ui2f12", zs);

      class Ps extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2) {
          const n2 = this.length;
          return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
        }
        emplace(t2, e2, r2, n2) {
          const i2 = 4 * t2;
          return this.uint32[2 * t2 + 0] = e2, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, t2;
        }
      }
      Ps.prototype.bytesPerElement = 8, wi("StructArrayLayout1ul2ui8", Ps);

      class Cs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2) {
          const r2 = this.length;
          return this.resize(r2 + 1), this.emplace(r2, t2, e2);
        }
        emplace(t2, e2, r2) {
          const n2 = 2 * t2;
          return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
        }
      }
      Cs.prototype.bytesPerElement = 4, wi("StructArrayLayout2ui4", Cs);

      class Bs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(t2) {
          const e2 = this.length;
          return this.resize(e2 + 1), this.emplace(e2, t2);
        }
        emplace(t2, e2) {
          return this.uint16[1 * t2 + 0] = e2, t2;
        }
      }
      Bs.prototype.bytesPerElement = 2, wi("StructArrayLayout1ui2", Bs);

      class Vs extends os {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(t2, e2, r2, n2) {
          const i2 = this.length;
          return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
        }
        emplace(t2, e2, r2, n2, i2) {
          const s2 = 4 * t2;
          return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
        }
      }
      Vs.prototype.bytesPerElement = 16, wi("StructArrayLayout4f16", Vs);

      class Es extends as {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new s(this.anchorPointX, this.anchorPointY);
        }
      }
      Es.prototype.size = 20;

      class Fs extends bs {
        get(t2) {
          return new Es(this, t2);
        }
      }
      wi("CollisionBoxArray", Fs);

      class Ts extends as {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(t2) {
          this._structArray.uint8[this._pos1 + 37] = t2;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(t2) {
          this._structArray.uint8[this._pos1 + 38] = t2;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(t2) {
          this._structArray.uint32[this._pos4 + 10] = t2;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      Ts.prototype.size = 48;

      class $s extends ks {
        get(t2) {
          return new Ts(this, t2);
        }
      }
      wi("PlacedSymbolArray", $s);

      class Ls extends as {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(t2) {
          this._structArray.uint32[this._pos4 + 12] = t2;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      Ls.prototype.size = 64;

      class Ds extends Ms {
        get(t2) {
          return new Ls(this, t2);
        }
      }
      wi("SymbolInstanceArray", Ds);

      class Os extends Is {
        getoffsetX(t2) {
          return this.float32[1 * t2 + 0];
        }
      }
      wi("GlyphOffsetArray", Os);

      class js extends hs {
        getx(t2) {
          return this.int16[3 * t2 + 0];
        }
        gety(t2) {
          return this.int16[3 * t2 + 1];
        }
        gettileUnitDistanceFromAnchor(t2) {
          return this.int16[3 * t2 + 2];
        }
      }
      wi("SymbolLineVertexArray", js);

      class Rs extends as {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      Rs.prototype.size = 12;

      class Us extends zs {
        get(t2) {
          return new Rs(this, t2);
        }
      }
      wi("TextAnchorOffsetArray", Us);

      class qs extends as {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      qs.prototype.size = 8;

      class Ns extends Ps {
        get(t2) {
          return new qs(this, t2);
        }
      }
      wi("FeatureIndexArray", Ns);

      class Zs extends cs {
      }

      class Gs extends cs {
      }

      class Ks extends cs {
      }

      class Xs extends fs {
      }

      class Hs extends ds {
      }

      class Ys extends ys {
      }

      class Js extends ms {
      }

      class Ws extends gs {
      }

      class Qs extends xs {
      }

      class ta extends vs {
      }

      class ea extends ws {
      }

      class ra extends As {
      }

      class na extends Ss {
      }

      class ia extends Cs {
      }
      const sa = ls([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: aa } = sa;

      class oa {
        constructor(t2 = []) {
          this.segments = t2;
        }
        prepareSegment(t2, e2, r2, n2) {
          let i2 = this.segments[this.segments.length - 1];
          return t2 > oa.MAX_VERTEX_ARRAY_LENGTH && A(`Max vertices per segment is ${oa.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > oa.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = {
            vertexOffset: e2.length,
            primitiveOffset: r2.length,
            vertexLength: 0,
            primitiveLength: 0
          }, n2 !== undefined && (i2.sortKey = n2), this.segments.push(i2)), i2;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t2 of this.segments)
            for (const e2 in t2.vaos)
              t2.vaos[e2].destroy();
        }
        static simpleSegment(t2, e2, r2, n2) {
          return new oa([
            {
              vertexOffset: t2,
              primitiveOffset: e2,
              vertexLength: r2,
              primitiveLength: n2,
              vaos: {},
              sortKey: 0
            }
          ]);
        }
      }
      function la(t2, e2) {
        return 256 * (t2 = y(Math.floor(t2), 0, 255)) + y(Math.floor(e2), 0, 255);
      }
      oa.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, wi("SegmentVector", oa);
      const ua = ls([
        { name: "a_pattern_from", components: 4, type: "Uint16" },
        { name: "a_pattern_to", components: 4, type: "Uint16" },
        { name: "a_pixel_ratio_from", components: 1, type: "Uint16" },
        { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }
      ]);
      var ca = { exports: {} }, ha = { exports: {} };
      ha.exports = function(t2, e2) {
        var r2, n2, i2, s2, a2, o2, l2, u2;
        for (n2 = t2.length - (r2 = 3 & t2.length), i2 = e2, a2 = 3432918353, o2 = 461845907, u2 = 0;u2 < n2; )
          l2 = 255 & t2.charCodeAt(u2) | (255 & t2.charCodeAt(++u2)) << 8 | (255 & t2.charCodeAt(++u2)) << 16 | (255 & t2.charCodeAt(++u2)) << 24, ++u2, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
        switch (l2 = 0, r2) {
          case 3:
            l2 ^= (255 & t2.charCodeAt(u2 + 2)) << 16;
          case 2:
            l2 ^= (255 & t2.charCodeAt(u2 + 1)) << 8;
          case 1:
            i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t2.charCodeAt(u2))) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295;
        }
        return i2 ^= t2.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
      };
      var pa = ha.exports, fa = { exports: {} };
      fa.exports = function(t2, e2) {
        for (var r2, n2 = t2.length, i2 = e2 ^ n2, s2 = 0;n2 >= 4; )
          r2 = 1540483477 * (65535 & (r2 = 255 & t2.charCodeAt(s2) | (255 & t2.charCodeAt(++s2)) << 8 | (255 & t2.charCodeAt(++s2)) << 16 | (255 & t2.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
        switch (n2) {
          case 3:
            i2 ^= (255 & t2.charCodeAt(s2 + 2)) << 16;
          case 2:
            i2 ^= (255 & t2.charCodeAt(s2 + 1)) << 8;
          case 1:
            i2 = 1540483477 * (65535 & (i2 ^= 255 & t2.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
        }
        return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
      };
      var da = pa, ya = fa.exports;
      ca.exports = da, ca.exports.murmur3 = da, ca.exports.murmur2 = ya;
      var ma = r(ca.exports);

      class ga {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = false;
        }
        add(t2, e2, r2, n2) {
          this.ids.push(xa(t2)), this.positions.push(e2, r2, n2);
        }
        getPositions(t2) {
          if (!this.indexed)
            throw new Error("Trying to get index, but feature positions are not indexed");
          const e2 = xa(t2);
          let r2 = 0, n2 = this.ids.length - 1;
          for (;r2 < n2; ) {
            const t3 = r2 + n2 >> 1;
            this.ids[t3] >= e2 ? n2 = t3 : r2 = t3 + 1;
          }
          const i2 = [];
          for (;this.ids[r2] === e2; )
            i2.push({
              index: this.positions[3 * r2],
              start: this.positions[3 * r2 + 1],
              end: this.positions[3 * r2 + 2]
            }), r2++;
          return i2;
        }
        static serialize(t2, e2) {
          const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
          return va(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
        }
        static deserialize(t2) {
          const e2 = new ga;
          return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
        }
      }
      function xa(t2) {
        const e2 = +t2;
        return !isNaN(e2) && e2 <= Number.MAX_SAFE_INTEGER ? e2 : ma(String(t2));
      }
      function va(t2, e2, r2, n2) {
        for (;r2 < n2; ) {
          const i2 = t2[r2 + n2 >> 1];
          let s2 = r2 - 1, a2 = n2 + 1;
          for (;; ) {
            do {
              s2++;
            } while (t2[s2] < i2);
            do {
              a2--;
            } while (t2[a2] > i2);
            if (s2 >= a2)
              break;
            ba(t2, s2, a2), ba(e2, 3 * s2, 3 * a2), ba(e2, 3 * s2 + 1, 3 * a2 + 1), ba(e2, 3 * s2 + 2, 3 * a2 + 2);
          }
          a2 - r2 < n2 - a2 ? (va(t2, e2, r2, a2), r2 = a2 + 1) : (va(t2, e2, a2 + 1, n2), n2 = a2);
        }
      }
      function ba(t2, e2, r2) {
        const n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      wi("FeaturePositionMap", ga);

      class wa {
        constructor(t2, e2) {
          this.gl = t2.gl, this.location = e2;
        }
      }

      class _a extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = 0;
        }
        set(t2) {
          this.current !== t2 && (this.current = t2, this.gl.uniform1f(this.location, t2));
        }
      }

      class Aa extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = [0, 0, 0, 0];
        }
        set(t2) {
          t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] && t2[3] === this.current[3] || (this.current = t2, this.gl.uniform4f(this.location, t2[0], t2[1], t2[2], t2[3]));
        }
      }

      class Sa extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = Kt.transparent;
        }
        set(t2) {
          t2.r === this.current.r && t2.g === this.current.g && t2.b === this.current.b && t2.a === this.current.a || (this.current = t2, this.gl.uniform4f(this.location, t2.r, t2.g, t2.b, t2.a));
        }
      }
      const ka = new Float32Array(16);
      function Ma(t2) {
        return [la(255 * t2.r, 255 * t2.g), la(255 * t2.b, 255 * t2.a)];
      }

      class Ia {
        constructor(t2, e2, r2) {
          this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2;
        }
        setUniform(t2, e2, r2) {
          t2.set(r2.constantOr(this.value));
        }
        getBinding(t2, e2, r2) {
          return this.type === "color" ? new Sa(t2, e2) : new _a(t2, e2);
        }
      }

      class za {
        constructor(t2, e2) {
          this.uniformNames = e2.map((t3) => `u_${t3}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(t2, e2) {
          this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t2.tlbr;
        }
        setUniform(t2, e2, r2, n2) {
          const i2 = n2 === "u_pattern_to" ? this.patternTo : n2 === "u_pattern_from" ? this.patternFrom : n2 === "u_pixel_ratio_to" ? this.pixelRatioTo : n2 === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          i2 && t2.set(i2);
        }
        getBinding(t2, e2, r2) {
          return r2.substr(0, 9) === "u_pattern" ? new Aa(t2, e2) : new _a(t2, e2);
        }
      }

      class Pa {
        constructor(t2, e2, r2, n2) {
          this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({
            name: `a_${t3}`,
            type: "Float32",
            components: r2 === "color" ? 2 : 1,
            offset: 0
          })), this.paintVertexArray = new n2;
        }
        populatePaintArray(t2, e2, r2, n2, i2) {
          const s2 = this.paintVertexArray.length, a2 = this.expression.evaluate(new Ui(0), e2, {}, n2, [], i2);
          this.paintVertexArray.resize(t2), this._setPaintValue(s2, t2, a2);
        }
        updatePaintArray(t2, e2, r2, n2) {
          const i2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
          this._setPaintValue(t2, e2, i2);
        }
        _setPaintValue(t2, e2, r2) {
          if (this.type === "color") {
            const n2 = Ma(r2);
            for (let r3 = t2;r3 < e2; r3++)
              this.paintVertexArray.emplace(r3, n2[0], n2[1]);
          } else {
            for (let n2 = t2;n2 < e2; n2++)
              this.paintVertexArray.emplace(n2, r2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2));
          }
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }

      class Ca {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({
            name: `a_${t3}`,
            type: "Float32",
            components: r2 === "color" ? 4 : 2,
            offset: 0
          })), this.paintVertexArray = new s2;
        }
        populatePaintArray(t2, e2, r2, n2, i2) {
          const s2 = this.expression.evaluate(new Ui(this.zoom), e2, {}, n2, [], i2), a2 = this.expression.evaluate(new Ui(this.zoom + 1), e2, {}, n2, [], i2), o2 = this.paintVertexArray.length;
          this.paintVertexArray.resize(t2), this._setPaintValue(o2, t2, s2, a2);
        }
        updatePaintArray(t2, e2, r2, n2) {
          const i2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), s2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
          this._setPaintValue(t2, e2, i2, s2);
        }
        _setPaintValue(t2, e2, r2, n2) {
          if (this.type === "color") {
            const i2 = Ma(r2), s2 = Ma(n2);
            for (let r3 = t2;r3 < e2; r3++)
              this.paintVertexArray.emplace(r3, i2[0], i2[1], s2[0], s2[1]);
          } else {
            for (let i2 = t2;i2 < e2; i2++)
              this.paintVertexArray.emplace(i2, r2, n2);
            this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
          }
        }
        upload(t2) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t2, e2) {
          const r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = y(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
          t2.set(n2);
        }
        getBinding(t2, e2, r2) {
          return new _a(t2, e2);
        }
      }

      class Ba {
        constructor(t2, e2, r2, n2, i2, s2) {
          this.expression = t2, this.type = e2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = s2, this.zoomInPaintVertexArray = new i2, this.zoomOutPaintVertexArray = new i2;
        }
        populatePaintArray(t2, e2, r2) {
          const n2 = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r2);
        }
        updatePaintArray(t2, e2, r2, n2, i2) {
          this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], i2);
        }
        _setPaintValues(t2, e2, r2, n2) {
          if (!n2 || !r2)
            return;
          const { min: i2, mid: s2, max: a2 } = r2, o2 = n2[i2], l2 = n2[s2], u2 = n2[a2];
          if (o2 && l2 && u2)
            for (let r3 = t2;r3 < e2; r3++)
              this.zoomInPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], l2.pixelRatio, o2.pixelRatio), this.zoomOutPaintVertexArray.emplace(r3, l2.tl[0], l2.tl[1], l2.br[0], l2.br[1], u2.tl[0], u2.tl[1], u2.br[0], u2.br[1], l2.pixelRatio, u2.pixelRatio);
        }
        upload(t2) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, ua.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, ua.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }

      class Va {
        constructor(t2, e2, r2) {
          this.binders = {}, this._buffers = [];
          const n2 = [];
          for (const i2 in t2.paint._values) {
            if (!r2(i2))
              continue;
            const s2 = t2.paint.get(i2);
            if (!(s2 instanceof Hi && an(s2.property.specification)))
              continue;
            const a2 = Fa(i2, t2.type), o2 = s2.value, l2 = s2.property.specification.type, u2 = s2.property.useIntegerZoom, c2 = s2.property.specification["property-type"], h2 = c2 === "cross-faded" || c2 === "cross-faded-data-driven";
            if (o2.kind === "constant")
              this.binders[i2] = h2 ? new za(o2.value, a2) : new Ia(o2.value, a2, l2), n2.push(`/u_${i2}`);
            else if (o2.kind === "source" || h2) {
              const r3 = Ta(i2, l2, "source");
              this.binders[i2] = h2 ? new Ba(o2, l2, u2, e2, r3, t2.id) : new Pa(o2, a2, l2, r3), n2.push(`/a_${i2}`);
            } else {
              const t3 = Ta(i2, l2, "composite");
              this.binders[i2] = new Ca(o2, a2, l2, u2, e2, t3), n2.push(`/z_${i2}`);
            }
          }
          this.cacheKey = n2.sort().join("");
        }
        getMaxValue(t2) {
          const e2 = this.binders[t2];
          return e2 instanceof Pa || e2 instanceof Ca ? e2.maxValue : 0;
        }
        populatePaintArrays(t2, e2, r2, n2, i2) {
          for (const s2 in this.binders) {
            const a2 = this.binders[s2];
            (a2 instanceof Pa || a2 instanceof Ca || a2 instanceof Ba) && a2.populatePaintArray(t2, e2, r2, n2, i2);
          }
        }
        setConstantPatternPositions(t2, e2) {
          for (const r2 in this.binders) {
            const n2 = this.binders[r2];
            n2 instanceof za && n2.setConstantPatternPositions(t2, e2);
          }
        }
        updatePaintArrays(t2, e2, r2, n2, i2) {
          let s2 = false;
          for (const a2 in t2) {
            const o2 = e2.getPositions(a2);
            for (const e3 of o2) {
              const o3 = r2.feature(e3.index);
              for (const r3 in this.binders) {
                const l2 = this.binders[r3];
                if ((l2 instanceof Pa || l2 instanceof Ca || l2 instanceof Ba) && l2.expression.isStateDependent === true) {
                  const u2 = n2.paint.get(r3);
                  l2.expression = u2.value, l2.updatePaintArray(e3.start, e3.end, o3, t2[a2], i2), s2 = true;
                }
              }
            }
          }
          return s2;
        }
        defines() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            (r2 instanceof Ia || r2 instanceof za) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
          }
          return t2;
        }
        getBinderAttributes() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (r2 instanceof Pa || r2 instanceof Ca)
              for (let e3 = 0;e3 < r2.paintVertexAttributes.length; e3++)
                t2.push(r2.paintVertexAttributes[e3].name);
            else if (r2 instanceof Ba)
              for (let e3 = 0;e3 < ua.members.length; e3++)
                t2.push(ua.members[e3].name);
          }
          return t2;
        }
        getBinderUniforms() {
          const t2 = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (r2 instanceof Ia || r2 instanceof za || r2 instanceof Ca)
              for (const e3 of r2.uniformNames)
                t2.push(e3);
          }
          return t2;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t2, e2) {
          const r2 = [];
          for (const n2 in this.binders) {
            const i2 = this.binders[n2];
            if (i2 instanceof Ia || i2 instanceof za || i2 instanceof Ca) {
              for (const s2 of i2.uniformNames)
                if (e2[s2]) {
                  const a2 = i2.getBinding(t2, e2[s2], s2);
                  r2.push({ name: s2, property: n2, binding: a2 });
                }
            }
          }
          return r2;
        }
        setUniforms(t2, e2, r2, n2) {
          for (const { name: t3, property: i2, binding: s2 } of e2)
            this.binders[i2].setUniform(s2, n2, r2.get(i2), t3);
        }
        updatePaintBuffers(t2) {
          this._buffers = [];
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            if (t2 && r2 instanceof Ba) {
              const e3 = t2.fromScale === 2 ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
              e3 && this._buffers.push(e3);
            } else
              (r2 instanceof Pa || r2 instanceof Ca) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
          }
        }
        upload(t2) {
          for (const e2 in this.binders) {
            const r2 = this.binders[e2];
            (r2 instanceof Pa || r2 instanceof Ca || r2 instanceof Ba) && r2.upload(t2);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t2 in this.binders) {
            const e2 = this.binders[t2];
            (e2 instanceof Pa || e2 instanceof Ca || e2 instanceof Ba) && e2.destroy();
          }
        }
      }

      class Ea {
        constructor(t2, e2, r2 = () => true) {
          this.programConfigurations = {};
          for (const n2 of t2)
            this.programConfigurations[n2.id] = new Va(n2, e2, r2);
          this.needsUpload = false, this._featureMap = new ga, this._bufferOffset = 0;
        }
        populatePaintArrays(t2, e2, r2, n2, i2, s2) {
          for (const r3 in this.programConfigurations)
            this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, s2);
          e2.id !== undefined && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
        }
        updatePaintArrays(t2, e2, r2, n2) {
          for (const i2 of r2)
            this.needsUpload = this.programConfigurations[i2.id].updatePaintArrays(t2, this._featureMap, e2, i2, n2) || this.needsUpload;
        }
        get(t2) {
          return this.programConfigurations[t2];
        }
        upload(t2) {
          if (this.needsUpload) {
            for (const e2 in this.programConfigurations)
              this.programConfigurations[e2].upload(t2);
            this.needsUpload = false;
          }
        }
        destroy() {
          for (const t2 in this.programConfigurations)
            this.programConfigurations[t2].destroy();
        }
      }
      function Fa(t2, e2) {
        return {
          "text-opacity": ["opacity"],
          "icon-opacity": ["opacity"],
          "text-color": ["fill_color"],
          "icon-color": ["fill_color"],
          "text-halo-color": ["halo_color"],
          "icon-halo-color": ["halo_color"],
          "text-halo-blur": ["halo_blur"],
          "icon-halo-blur": ["halo_blur"],
          "text-halo-width": ["halo_width"],
          "icon-halo-width": ["halo_width"],
          "line-gap-width": ["gapwidth"],
          "line-pattern": [
            "pattern_to",
            "pattern_from",
            "pixel_ratio_to",
            "pixel_ratio_from"
          ],
          "fill-pattern": [
            "pattern_to",
            "pattern_from",
            "pixel_ratio_to",
            "pixel_ratio_from"
          ],
          "fill-extrusion-pattern": [
            "pattern_to",
            "pattern_from",
            "pixel_ratio_to",
            "pixel_ratio_from"
          ]
        }[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
      }
      function Ta(t2, e2, r2) {
        const n2 = {
          color: { source: ys, composite: Vs },
          number: { source: Is, composite: ys }
        }, i2 = function(t3) {
          return {
            "line-pattern": { source: Js, composite: Js },
            "fill-pattern": { source: Js, composite: Js },
            "fill-extrusion-pattern": { source: Js, composite: Js }
          }[t3];
        }(t2);
        return i2 && i2[r2] || n2[e2][r2];
      }
      wi("ConstantBinder", Ia), wi("CrossFadedConstantBinder", za), wi("SourceExpressionBinder", Pa), wi("CrossFadedCompositeBinder", Ba), wi("CompositeExpressionBinder", Ca), wi("ProgramConfiguration", Va, { omit: ["_buffers"] }), wi("ProgramConfigurationSet", Ea);
      const $a = 8192, La = Math.pow(2, 14) - 1, Da = -La - 1;
      function Oa(t2) {
        const e2 = $a / t2.extent, r2 = t2.loadGeometry();
        for (let t3 = 0;t3 < r2.length; t3++) {
          const n2 = r2[t3];
          for (let t4 = 0;t4 < n2.length; t4++) {
            const r3 = n2[t4], i2 = Math.round(r3.x * e2), s2 = Math.round(r3.y * e2);
            r3.x = y(i2, Da, La), r3.y = y(s2, Da, La), (i2 < r3.x || i2 > r3.x + 1 || s2 < r3.y || s2 > r3.y + 1) && A("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return r2;
      }
      function ja(t2, e2) {
        return {
          type: t2.type,
          id: t2.id,
          properties: t2.properties,
          geometry: e2 ? Oa(t2) : []
        };
      }
      function Ra(t2, e2, r2, n2, i2) {
        t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
      }

      class Ua {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Gs, this.indexArray = new na, this.segments = new oa, this.programConfigurations = new Ea(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          const n2 = this.layers[0], i2 = [];
          let s2 = null, a2 = false;
          n2.type === "circle" && (s2 = n2.layout.get("circle-sort-key"), a2 = !s2.isConstant());
          for (const { feature: e3, id: n3, index: o2, sourceLayerIndex: l2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u2 = ja(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new Ui(this.zoom), u2, r2))
              continue;
            const c2 = a2 ? s2.evaluate(u2, {}, r2) : undefined, h2 = {
              id: n3,
              properties: e3.properties,
              type: e3.type,
              sourceLayerIndex: l2,
              index: o2,
              geometry: t3 ? u2.geometry : Oa(e3),
              patterns: {},
              sortKey: c2
            };
            i2.push(h2);
          }
          a2 && i2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of i2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a3 } = n3, o2 = t2[s3].feature;
            this.addFeature(n3, i3, s3, r2), e2.featureIndex.insert(o2, i3, s3, a3, this.index);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, aa), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t2, e2, r2, n2) {
          for (const r3 of e2)
            for (const e3 of r3) {
              const { x: r4, y: n3 } = e3;
              if (r4 < 0 || r4 >= $a || n3 < 0 || n3 >= $a)
                continue;
              const i2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), s2 = i2.vertexLength;
              Ra(this.layoutVertexArray, r4, n3, -1, -1), Ra(this.layoutVertexArray, r4, n3, 1, -1), Ra(this.layoutVertexArray, r4, n3, 1, 1), Ra(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(s2, s2 + 1, s2 + 2), this.indexArray.emplaceBack(s2, s2 + 3, s2 + 2), i2.vertexLength += 4, i2.primitiveLength += 2;
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2);
        }
      }
      function qa(t2, e2) {
        for (let r2 = 0;r2 < t2.length; r2++)
          if (Wa(e2, t2[r2]))
            return true;
        for (let r2 = 0;r2 < e2.length; r2++)
          if (Wa(t2, e2[r2]))
            return true;
        return !!Ka(t2, e2);
      }
      function Na(t2, e2, r2) {
        return !!Wa(t2, e2) || !!Ha(e2, t2, r2);
      }
      function Za(t2, e2) {
        if (t2.length === 1)
          return Ja(e2, t2[0]);
        for (let r2 = 0;r2 < e2.length; r2++) {
          const n2 = e2[r2];
          for (let e3 = 0;e3 < n2.length; e3++)
            if (Wa(t2, n2[e3]))
              return true;
        }
        for (let r2 = 0;r2 < t2.length; r2++)
          if (Ja(e2, t2[r2]))
            return true;
        for (let r2 = 0;r2 < e2.length; r2++)
          if (Ka(t2, e2[r2]))
            return true;
        return false;
      }
      function Ga(t2, e2, r2) {
        if (t2.length > 1) {
          if (Ka(t2, e2))
            return true;
          for (let n2 = 0;n2 < e2.length; n2++)
            if (Ha(e2[n2], t2, r2))
              return true;
        }
        for (let n2 = 0;n2 < t2.length; n2++)
          if (Ha(t2[n2], e2, r2))
            return true;
        return false;
      }
      function Ka(t2, e2) {
        if (t2.length === 0 || e2.length === 0)
          return false;
        for (let r2 = 0;r2 < t2.length - 1; r2++) {
          const n2 = t2[r2], i2 = t2[r2 + 1];
          for (let t3 = 0;t3 < e2.length - 1; t3++)
            if (Xa(n2, i2, e2[t3], e2[t3 + 1]))
              return true;
        }
        return false;
      }
      function Xa(t2, e2, r2, n2) {
        return S(t2, r2, n2) !== S(e2, r2, n2) && S(t2, e2, r2) !== S(t2, e2, n2);
      }
      function Ha(t2, e2, r2) {
        const n2 = r2 * r2;
        if (e2.length === 1)
          return t2.distSqr(e2[0]) < n2;
        for (let r3 = 1;r3 < e2.length; r3++)
          if (Ya(t2, e2[r3 - 1], e2[r3]) < n2)
            return true;
        return false;
      }
      function Ya(t2, e2, r2) {
        const n2 = e2.distSqr(r2);
        if (n2 === 0)
          return t2.distSqr(e2);
        const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
        return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
      }
      function Ja(t2, e2) {
        let r2, n2, i2, s2 = false;
        for (let a2 = 0;a2 < t2.length; a2++) {
          r2 = t2[a2];
          for (let t3 = 0, a3 = r2.length - 1;t3 < r2.length; a3 = t3++)
            n2 = r2[t3], i2 = r2[a3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
        }
        return s2;
      }
      function Wa(t2, e2) {
        let r2 = false;
        for (let n2 = 0, i2 = t2.length - 1;n2 < t2.length; i2 = n2++) {
          const s2 = t2[n2], a2 = t2[i2];
          s2.y > e2.y != a2.y > e2.y && e2.x < (a2.x - s2.x) * (e2.y - s2.y) / (a2.y - s2.y) + s2.x && (r2 = !r2);
        }
        return r2;
      }
      function Qa(t2, e2, r2) {
        const n2 = r2[0], i2 = r2[2];
        if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
          return false;
        const s2 = S(t2, e2, r2[0]);
        return s2 !== S(t2, e2, r2[1]) || s2 !== S(t2, e2, r2[2]) || s2 !== S(t2, e2, r2[3]);
      }
      function to(t2, e2, r2) {
        const n2 = e2.paint.get(t2).value;
        return n2.kind === "constant" ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
      }
      function eo(t2) {
        return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
      }
      function ro(t2, e2, r2, n2, i2) {
        if (!e2[0] && !e2[1])
          return t2;
        const a2 = s.convert(e2)._mult(i2);
        r2 === "viewport" && a2._rotate(-n2);
        const o2 = [];
        for (let e3 = 0;e3 < t2.length; e3++)
          o2.push(t2[e3].sub(a2));
        return o2;
      }
      let no, io;
      wi("CircleBucket", Ua, { omit: ["layers"] });
      var so = {
        get paint() {
          return io = io || new rs({
            "circle-radius": new Wi(G.paint_circle["circle-radius"]),
            "circle-color": new Wi(G.paint_circle["circle-color"]),
            "circle-blur": new Wi(G.paint_circle["circle-blur"]),
            "circle-opacity": new Wi(G.paint_circle["circle-opacity"]),
            "circle-translate": new Ji(G.paint_circle["circle-translate"]),
            "circle-translate-anchor": new Ji(G.paint_circle["circle-translate-anchor"]),
            "circle-pitch-scale": new Ji(G.paint_circle["circle-pitch-scale"]),
            "circle-pitch-alignment": new Ji(G.paint_circle["circle-pitch-alignment"]),
            "circle-stroke-width": new Wi(G.paint_circle["circle-stroke-width"]),
            "circle-stroke-color": new Wi(G.paint_circle["circle-stroke-color"]),
            "circle-stroke-opacity": new Wi(G.paint_circle["circle-stroke-opacity"])
          });
        },
        get layout() {
          return no = no || new rs({
            "circle-sort-key": new Wi(G.layout_circle["circle-sort-key"])
          });
        }
      }, ao = 0.000001, oo = typeof Float32Array != "undefined" ? Float32Array : Array;
      function lo(t2) {
        return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }
      function uo(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], y2 = e2[12], m2 = e2[13], g2 = e2[14], x2 = e2[15], v2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
        return t2[0] = v2 * n2 + b2 * o2 + w2 * h2 + _2 * y2, t2[1] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[2] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[3] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[4] = (v2 = r2[4]) * n2 + (b2 = r2[5]) * o2 + (w2 = r2[6]) * h2 + (_2 = r2[7]) * y2, t2[5] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[6] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[7] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[8] = (v2 = r2[8]) * n2 + (b2 = r2[9]) * o2 + (w2 = r2[10]) * h2 + (_2 = r2[11]) * y2, t2[9] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[10] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[11] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2[12] = (v2 = r2[12]) * n2 + (b2 = r2[13]) * o2 + (w2 = r2[14]) * h2 + (_2 = r2[15]) * y2, t2[13] = v2 * i2 + b2 * l2 + w2 * p2 + _2 * m2, t2[14] = v2 * s2 + b2 * u2 + w2 * f2 + _2 * g2, t2[15] = v2 * a2 + b2 * c2 + w2 * d2 + _2 * x2, t2;
      }
      Math.hypot || (Math.hypot = function() {
        for (var t2 = 0, e2 = arguments.length;e2--; )
          t2 += arguments[e2] * arguments[e2];
        return Math.sqrt(t2);
      });
      var co, ho = uo;
      function po(t2, e2, r2) {
        var n2 = e2[0], i2 = e2[1], s2 = e2[2], a2 = e2[3];
        return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * a2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * a2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * a2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * a2, t2;
      }
      co = new oo(4), oo != Float32Array && (co[0] = 0, co[1] = 0, co[2] = 0, co[3] = 0);

      class fo extends is {
        constructor(t2) {
          super(t2, so);
        }
        createBucket(t2) {
          return new Ua(t2);
        }
        queryRadius(t2) {
          const e2 = t2;
          return to("circle-radius", this, e2) + to("circle-stroke-width", this, e2) + eo(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = ro(t2, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, a2), u2 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2), c2 = this.paint.get("circle-pitch-alignment") === "map", h2 = c2 ? l2 : function(t3, e3) {
            return t3.map((t4) => yo(t4, e3));
          }(l2, o2), p2 = c2 ? u2 * a2 : u2;
          for (const t3 of n2)
            for (const e3 of t3) {
              const t4 = c2 ? e3 : yo(e3, o2);
              let r3 = p2;
              const n3 = po([], [e3.x, e3.y, 0, 1], o2);
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? r3 *= n3[3] / s2.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (r3 *= s2.cameraToCenterDistance / n3[3]), Na(h2, t4, r3))
                return true;
            }
          return false;
        }
      }
      function yo(t2, e2) {
        const r2 = po([], [t2.x, t2.y, 0, 1], e2);
        return new s(r2[0] / r2[3], r2[1] / r2[3]);
      }

      class mo extends Ua {
      }
      let go;
      wi("HeatmapBucket", mo, { omit: ["layers"] });
      var xo = {
        get paint() {
          return go = go || new rs({
            "heatmap-radius": new Wi(G.paint_heatmap["heatmap-radius"]),
            "heatmap-weight": new Wi(G.paint_heatmap["heatmap-weight"]),
            "heatmap-intensity": new Ji(G.paint_heatmap["heatmap-intensity"]),
            "heatmap-color": new es(G.paint_heatmap["heatmap-color"]),
            "heatmap-opacity": new Ji(G.paint_heatmap["heatmap-opacity"])
          });
        }
      };
      function vo(t2, { width: e2, height: r2 }, n2, i2) {
        if (i2) {
          if (i2 instanceof Uint8ClampedArray)
            i2 = new Uint8Array(i2.buffer);
          else if (i2.length !== e2 * r2 * n2)
            throw new RangeError(`mismatched image size. expected: ${i2.length} but got: ${e2 * r2 * n2}`);
        } else
          i2 = new Uint8Array(e2 * r2 * n2);
        return t2.width = e2, t2.height = r2, t2.data = i2, t2;
      }
      function bo(t2, { width: e2, height: r2 }, n2) {
        if (e2 === t2.width && r2 === t2.height)
          return;
        const i2 = vo({}, { width: e2, height: r2 }, n2);
        wo(t2, i2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, e2), height: Math.min(t2.height, r2) }, n2), t2.width = e2, t2.height = r2, t2.data = i2.data;
      }
      function wo(t2, e2, r2, n2, i2, s2) {
        if (i2.width === 0 || i2.height === 0)
          return e2;
        if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
          throw new RangeError("out of range source coordinates for image copy");
        if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
          throw new RangeError("out of range destination coordinates for image copy");
        const a2 = t2.data, o2 = e2.data;
        if (a2 === o2)
          throw new Error("srcData equals dstData, so image is already copied");
        for (let l2 = 0;l2 < i2.height; l2++) {
          const u2 = ((r2.y + l2) * t2.width + r2.x) * s2, c2 = ((n2.y + l2) * e2.width + n2.x) * s2;
          for (let t3 = 0;t3 < i2.width * s2; t3++)
            o2[c2 + t3] = a2[u2 + t3];
        }
        return e2;
      }

      class _o {
        constructor(t2, e2) {
          vo(this, t2, 1, e2);
        }
        resize(t2) {
          bo(this, t2, 1);
        }
        clone() {
          return new _o({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t2, e2, r2, n2, i2) {
          wo(t2, e2, r2, n2, i2, 1);
        }
      }

      class Ao {
        constructor(t2, e2) {
          vo(this, t2, 4, e2);
        }
        resize(t2) {
          bo(this, t2, 4);
        }
        replace(t2, e2) {
          e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
        }
        clone() {
          return new Ao({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t2, e2, r2, n2, i2) {
          wo(t2, e2, r2, n2, i2, 4);
        }
      }
      function So(t2) {
        const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Ao({ width: r2, height: n2 });
        if (Math.log(r2) / Math.LN2 % 1 != 0)
          throw new Error(`width is not a power of 2 - ${r2}`);
        const s2 = (r3, n3, s3) => {
          e2[t2.evaluationKey] = s3;
          const a2 = t2.expression.evaluate(e2);
          i2.data[r3 + n3 + 0] = Math.floor(255 * a2.r / a2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * a2.g / a2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * a2.b / a2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * a2.a);
        };
        if (t2.clips)
          for (let e3 = 0, i3 = 0;e3 < n2; ++e3, i3 += 4 * r2)
            for (let n3 = 0, a2 = 0;n3 < r2; n3++, a2 += 4) {
              const o2 = n3 / (r2 - 1), { start: l2, end: u2 } = t2.clips[e3];
              s2(i3, a2, l2 * (1 - o2) + u2 * o2);
            }
        else
          for (let t3 = 0, e3 = 0;t3 < r2; t3++, e3 += 4)
            s2(0, e3, t3 / (r2 - 1));
        return i2;
      }
      wi("AlphaImage", _o), wi("RGBAImage", Ao);
      const ko = "big-fb";

      class Mo extends is {
        createBucket(t2) {
          return new mo(t2);
        }
        constructor(t2) {
          super(t2, xo), this.heatmapFbos = new Map, this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          t2 === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = So({
            expression: this._transitionablePaint._values["heatmap-color"].value.expression,
            evaluationKey: "heatmapDensity",
            image: this.colorRamp
          }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbos.has(ko) && this.heatmapFbos.delete(ko);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return false;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }
      let Io;
      var zo = {
        get paint() {
          return Io = Io || new rs({
            "hillshade-illumination-direction": new Ji(G.paint_hillshade["hillshade-illumination-direction"]),
            "hillshade-illumination-anchor": new Ji(G.paint_hillshade["hillshade-illumination-anchor"]),
            "hillshade-exaggeration": new Ji(G.paint_hillshade["hillshade-exaggeration"]),
            "hillshade-shadow-color": new Ji(G.paint_hillshade["hillshade-shadow-color"]),
            "hillshade-highlight-color": new Ji(G.paint_hillshade["hillshade-highlight-color"]),
            "hillshade-accent-color": new Ji(G.paint_hillshade["hillshade-accent-color"])
          });
        }
      };

      class Po extends is {
        constructor(t2) {
          super(t2, zo);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }
      const Co = ls([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Bo } = Co;
      function Vo(t2, e2, r2 = 2) {
        const n2 = e2 && e2.length, i2 = n2 ? e2[0] * r2 : t2.length;
        let s2 = Eo(t2, 0, i2, r2, true);
        const a2 = [];
        if (!s2 || s2.next === s2.prev)
          return a2;
        let o2, l2, u2;
        if (n2 && (s2 = function(t3, e3, r3, n3) {
          const i3 = [];
          for (let r4 = 0, s3 = e3.length;r4 < s3; r4++) {
            const a3 = Eo(t3, e3[r4] * n3, r4 < s3 - 1 ? e3[r4 + 1] * n3 : t3.length, n3, false);
            a3 === a3.next && (a3.steiner = true), i3.push(No(a3));
          }
          i3.sort(jo);
          for (let t4 = 0;t4 < i3.length; t4++)
            r3 = Ro(i3[t4], r3);
          return r3;
        }(t2, e2, s2, r2)), t2.length > 80 * r2) {
          o2 = 1 / 0, l2 = 1 / 0;
          let e3 = -1 / 0, n3 = -1 / 0;
          for (let s3 = r2;s3 < i2; s3 += r2) {
            const r3 = t2[s3], i3 = t2[s3 + 1];
            r3 < o2 && (o2 = r3), i3 < l2 && (l2 = i3), r3 > e3 && (e3 = r3), i3 > n3 && (n3 = i3);
          }
          u2 = Math.max(e3 - o2, n3 - l2), u2 = u2 !== 0 ? 32767 / u2 : 0;
        }
        return To(s2, a2, r2, o2, l2, u2, 0), a2;
      }
      function Eo(t2, e2, r2, n2, i2) {
        let s2;
        if (i2 === function(t3, e3, r3, n3) {
          let i3 = 0;
          for (let s3 = e3, a2 = r3 - n3;s3 < r3; s3 += n3)
            i3 += (t3[a2] - t3[s3]) * (t3[s3 + 1] + t3[a2 + 1]), a2 = s3;
          return i3;
        }(t2, e2, r2, n2) > 0)
          for (let i3 = e2;i3 < r2; i3 += n2)
            s2 = tl(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
        else
          for (let i3 = r2 - n2;i3 >= e2; i3 -= n2)
            s2 = tl(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
        return s2 && Xo(s2, s2.next) && (el(s2), s2 = s2.next), s2;
      }
      function Fo(t2, e2) {
        if (!t2)
          return t2;
        e2 || (e2 = t2);
        let r2, n2 = t2;
        do {
          if (r2 = false, n2.steiner || !Xo(n2, n2.next) && Ko(n2.prev, n2, n2.next) !== 0)
            n2 = n2.next;
          else {
            if (el(n2), n2 = e2 = n2.prev, n2 === n2.next)
              break;
            r2 = true;
          }
        } while (r2 || n2 !== e2);
        return e2;
      }
      function To(t2, e2, r2, n2, i2, s2, a2) {
        if (!t2)
          return;
        !a2 && s2 && function(t3, e3, r3, n3) {
          let i3 = t3;
          do {
            i3.z === 0 && (i3.z = qo(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
          } while (i3 !== t3);
          i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
            let e4, r4 = 1;
            do {
              let n4, i4 = t4;
              t4 = null;
              let s3 = null;
              for (e4 = 0;i4; ) {
                e4++;
                let a3 = i4, o3 = 0;
                for (let t5 = 0;t5 < r4 && (o3++, a3 = a3.nextZ, a3); t5++)
                  ;
                let l2 = r4;
                for (;o3 > 0 || l2 > 0 && a3; )
                  o3 !== 0 && (l2 === 0 || !a3 || i4.z <= a3.z) ? (n4 = i4, i4 = i4.nextZ, o3--) : (n4 = a3, a3 = a3.nextZ, l2--), s3 ? s3.nextZ = n4 : t4 = n4, n4.prevZ = s3, s3 = n4;
                i4 = a3;
              }
              s3.nextZ = null, r4 *= 2;
            } while (e4 > 1);
          }(i3);
        }(t2, n2, i2, s2);
        let o2 = t2;
        for (;t2.prev !== t2.next; ) {
          const { prev: l2, next: u2 } = t2;
          if (s2 ? Lo(t2, n2, i2, s2) : $o(t2))
            e2.push(l2.i, t2.i, u2.i), el(t2), t2 = u2.next, o2 = u2.next;
          else if ((t2 = u2) === o2) {
            a2 ? a2 === 1 ? To(t2 = Do(Fo(t2), e2), e2, r2, n2, i2, s2, 2) : a2 === 2 && Oo(t2, e2, r2, n2, i2, s2) : To(Fo(t2), e2, r2, n2, i2, s2, 1);
            break;
          }
        }
      }
      function $o(t2) {
        const e2 = t2.prev, r2 = t2, n2 = t2.next;
        if (Ko(e2, r2, n2) >= 0)
          return false;
        const i2 = e2.x, s2 = r2.x, a2 = n2.x, o2 = e2.y, l2 = r2.y, u2 = n2.y, c2 = i2 < s2 ? i2 < a2 ? i2 : a2 : s2 < a2 ? s2 : a2, h2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, p2 = i2 > s2 ? i2 > a2 ? i2 : a2 : s2 > a2 ? s2 : a2, f2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2;
        let d2 = n2.next;
        for (;d2 !== e2; ) {
          if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f2 && Zo(i2, o2, s2, l2, a2, u2, d2.x, d2.y) && Ko(d2.prev, d2, d2.next) >= 0)
            return false;
          d2 = d2.next;
        }
        return true;
      }
      function Lo(t2, e2, r2, n2) {
        const i2 = t2.prev, s2 = t2, a2 = t2.next;
        if (Ko(i2, s2, a2) >= 0)
          return false;
        const o2 = i2.x, l2 = s2.x, u2 = a2.x, c2 = i2.y, h2 = s2.y, p2 = a2.y, f2 = o2 < l2 ? o2 < u2 ? o2 : u2 : l2 < u2 ? l2 : u2, d2 = c2 < h2 ? c2 < p2 ? c2 : p2 : h2 < p2 ? h2 : p2, y2 = o2 > l2 ? o2 > u2 ? o2 : u2 : l2 > u2 ? l2 : u2, m2 = c2 > h2 ? c2 > p2 ? c2 : p2 : h2 > p2 ? h2 : p2, g2 = qo(f2, d2, e2, r2, n2), x2 = qo(y2, m2, e2, r2, n2);
        let { prevZ: v2, nextZ: b2 } = t2;
        for (;v2 && v2.z >= g2 && b2 && b2.z <= x2; ) {
          if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && Zo(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && Ko(v2.prev, v2, v2.next) >= 0)
            return false;
          if (v2 = v2.prevZ, b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && Zo(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && Ko(b2.prev, b2, b2.next) >= 0)
            return false;
          b2 = b2.nextZ;
        }
        for (;v2 && v2.z >= g2; ) {
          if (v2.x >= f2 && v2.x <= y2 && v2.y >= d2 && v2.y <= m2 && v2 !== i2 && v2 !== a2 && Zo(o2, c2, l2, h2, u2, p2, v2.x, v2.y) && Ko(v2.prev, v2, v2.next) >= 0)
            return false;
          v2 = v2.prevZ;
        }
        for (;b2 && b2.z <= x2; ) {
          if (b2.x >= f2 && b2.x <= y2 && b2.y >= d2 && b2.y <= m2 && b2 !== i2 && b2 !== a2 && Zo(o2, c2, l2, h2, u2, p2, b2.x, b2.y) && Ko(b2.prev, b2, b2.next) >= 0)
            return false;
          b2 = b2.nextZ;
        }
        return true;
      }
      function Do(t2, e2) {
        let r2 = t2;
        do {
          const n2 = r2.prev, i2 = r2.next.next;
          !Xo(n2, i2) && Ho(n2, r2, r2.next, i2) && Wo(n2, i2) && Wo(i2, n2) && (e2.push(n2.i, r2.i, i2.i), el(r2), el(r2.next), r2 = t2 = i2), r2 = r2.next;
        } while (r2 !== t2);
        return Fo(r2);
      }
      function Oo(t2, e2, r2, n2, i2, s2) {
        let a2 = t2;
        do {
          let t3 = a2.next.next;
          for (;t3 !== a2.prev; ) {
            if (a2.i !== t3.i && Go(a2, t3)) {
              let o2 = Qo(a2, t3);
              return a2 = Fo(a2, a2.next), o2 = Fo(o2, o2.next), To(a2, e2, r2, n2, i2, s2, 0), void To(o2, e2, r2, n2, i2, s2, 0);
            }
            t3 = t3.next;
          }
          a2 = a2.next;
        } while (a2 !== t2);
      }
      function jo(t2, e2) {
        return t2.x - e2.x;
      }
      function Ro(t2, e2) {
        const r2 = function(t3, e3) {
          let r3 = e3;
          const { x: n3, y: i2 } = t3;
          let s2, a2 = -1 / 0;
          do {
            if (i2 <= r3.y && i2 >= r3.next.y && r3.next.y !== r3.y) {
              const t4 = r3.x + (i2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
              if (t4 <= n3 && t4 > a2 && (a2 = t4, s2 = r3.x < r3.next.x ? r3 : r3.next, t4 === n3))
                return s2;
            }
            r3 = r3.next;
          } while (r3 !== e3);
          if (!s2)
            return null;
          const o2 = s2, l2 = s2.x, u2 = s2.y;
          let c2 = 1 / 0;
          r3 = s2;
          do {
            if (n3 >= r3.x && r3.x >= l2 && n3 !== r3.x && Zo(i2 < u2 ? n3 : a2, i2, l2, u2, i2 < u2 ? a2 : n3, i2, r3.x, r3.y)) {
              const e4 = Math.abs(i2 - r3.y) / (n3 - r3.x);
              Wo(r3, t3) && (e4 < c2 || e4 === c2 && (r3.x > s2.x || r3.x === s2.x && Uo(s2, r3))) && (s2 = r3, c2 = e4);
            }
            r3 = r3.next;
          } while (r3 !== o2);
          return s2;
        }(t2, e2);
        if (!r2)
          return e2;
        const n2 = Qo(r2, t2);
        return Fo(n2, n2.next), Fo(r2, r2.next);
      }
      function Uo(t2, e2) {
        return Ko(t2.prev, t2, e2.prev) < 0 && Ko(e2.next, t2, t2.next) < 0;
      }
      function qo(t2, e2, r2, n2, i2) {
        return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
      }
      function No(t2) {
        let e2 = t2, r2 = t2;
        do {
          (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
        } while (e2 !== t2);
        return r2;
      }
      function Zo(t2, e2, r2, n2, i2, s2, a2, o2) {
        return (i2 - a2) * (e2 - o2) >= (t2 - a2) * (s2 - o2) && (t2 - a2) * (n2 - o2) >= (r2 - a2) * (e2 - o2) && (r2 - a2) * (s2 - o2) >= (i2 - a2) * (n2 - o2);
      }
      function Go(t2, e2) {
        return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
          let r2 = t3;
          do {
            if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && Ho(r2, r2.next, t3, e3))
              return true;
            r2 = r2.next;
          } while (r2 !== t3);
          return false;
        }(t2, e2) && (Wo(t2, e2) && Wo(e2, t2) && function(t3, e3) {
          let r2 = t3, n2 = false;
          const i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
          do {
            r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
          } while (r2 !== t3);
          return n2;
        }(t2, e2) && (Ko(t2.prev, t2, e2.prev) || Ko(t2, e2.prev, e2)) || Xo(t2, e2) && Ko(t2.prev, t2, t2.next) > 0 && Ko(e2.prev, e2, e2.next) > 0);
      }
      function Ko(t2, e2, r2) {
        return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
      }
      function Xo(t2, e2) {
        return t2.x === e2.x && t2.y === e2.y;
      }
      function Ho(t2, e2, r2, n2) {
        const i2 = Jo(Ko(t2, e2, r2)), s2 = Jo(Ko(t2, e2, n2)), a2 = Jo(Ko(r2, n2, t2)), o2 = Jo(Ko(r2, n2, e2));
        return i2 !== s2 && a2 !== o2 || !(i2 !== 0 || !Yo(t2, r2, e2)) || !(s2 !== 0 || !Yo(t2, n2, e2)) || !(a2 !== 0 || !Yo(r2, t2, n2)) || !(o2 !== 0 || !Yo(r2, e2, n2));
      }
      function Yo(t2, e2, r2) {
        return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
      }
      function Jo(t2) {
        return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
      }
      function Wo(t2, e2) {
        return Ko(t2.prev, t2, t2.next) < 0 ? Ko(t2, e2, t2.next) >= 0 && Ko(t2, t2.prev, e2) >= 0 : Ko(t2, e2, t2.prev) < 0 || Ko(t2, t2.next, e2) < 0;
      }
      function Qo(t2, e2) {
        const r2 = rl(t2.i, t2.x, t2.y), n2 = rl(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
        return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
      }
      function tl(t2, e2, r2, n2) {
        const i2 = rl(t2, e2, r2);
        return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
      }
      function el(t2) {
        t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
      }
      function rl(t2, e2, r2) {
        return {
          i: t2,
          x: e2,
          y: r2,
          prev: null,
          next: null,
          z: 0,
          prevZ: null,
          nextZ: null,
          steiner: false
        };
      }
      function nl(t2, e2, r2) {
        const n2 = r2.patternDependencies;
        let i2 = false;
        for (const r3 of e2) {
          const e3 = r3.paint.get(`${t2}-pattern`);
          e3.isConstant() || (i2 = true);
          const s2 = e3.constantOr(null);
          s2 && (i2 = true, n2[s2.to] = true, n2[s2.from] = true);
        }
        return i2;
      }
      function il(t2, e2, r2, n2, i2) {
        const s2 = i2.patternDependencies;
        for (const a2 of e2) {
          const e3 = a2.paint.get(`${t2}-pattern`).value;
          if (e3.kind !== "constant") {
            let t3 = e3.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), o2 = e3.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), l2 = e3.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
            t3 = t3 && t3.name ? t3.name : t3, o2 = o2 && o2.name ? o2.name : o2, l2 = l2 && l2.name ? l2.name : l2, s2[t3] = true, s2[o2] = true, s2[l2] = true, r2.patterns[a2.id] = { min: t3, mid: o2, max: l2 };
          }
        }
        return r2;
      }

      class sl {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Ks, this.indexArray = new na, this.indexArray2 = new ia, this.programConfigurations = new Ea(t2.layers, t2.zoom), this.segments = new oa, this.segments2 = new oa, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          this.hasPattern = nl("fill", this.layers, e2);
          const n2 = this.layers[0].layout.get("fill-sort-key"), i2 = !n2.isConstant(), s2 = [];
          for (const { feature: a2, id: o2, index: l2, sourceLayerIndex: u2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, c2 = ja(a2, t3);
            if (!this.layers[0]._featureFilter.filter(new Ui(this.zoom), c2, r2))
              continue;
            const h2 = i2 ? n2.evaluate(c2, {}, r2, e2.availableImages) : undefined, p2 = {
              id: o2,
              properties: a2.properties,
              type: a2.type,
              sourceLayerIndex: u2,
              index: l2,
              geometry: t3 ? c2.geometry : Oa(a2),
              patterns: {},
              sortKey: h2
            };
            s2.push(p2);
          }
          i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
            if (this.hasPattern) {
              const t3 = il("fill", this.layers, n3, this.zoom, e2);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, s3, r2, {});
            e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        addFeatures(t2, e2, r2) {
          for (const t3 of this.patternFeatures)
            this.addFeature(t3, t3.geometry, t3.index, e2, r2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Bo), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(t2, e2, r2, n2, i2) {
          for (const t3 of xr(e2, 500)) {
            let e3 = 0;
            for (const r4 of t3)
              e3 += r4.length;
            const r3 = this.segments.prepareSegment(e3, this.layoutVertexArray, this.indexArray), n3 = r3.vertexLength, i3 = [], s2 = [];
            for (const e4 of t3) {
              if (e4.length === 0)
                continue;
              e4 !== t3[0] && s2.push(i3.length / 2);
              const r4 = this.segments2.prepareSegment(e4.length, this.layoutVertexArray, this.indexArray2), n4 = r4.vertexLength;
              this.layoutVertexArray.emplaceBack(e4[0].x, e4[0].y), this.indexArray2.emplaceBack(n4 + e4.length - 1, n4), i3.push(e4[0].x), i3.push(e4[0].y);
              for (let t4 = 1;t4 < e4.length; t4++)
                this.layoutVertexArray.emplaceBack(e4[t4].x, e4[t4].y), this.indexArray2.emplaceBack(n4 + t4 - 1, n4 + t4), i3.push(e4[t4].x), i3.push(e4[t4].y);
              r4.vertexLength += e4.length, r4.primitiveLength += e4.length;
            }
            const a2 = Vo(i3, s2);
            for (let t4 = 0;t4 < a2.length; t4 += 3)
              this.indexArray.emplaceBack(n3 + a2[t4], n3 + a2[t4 + 1], n3 + a2[t4 + 2]);
            r3.vertexLength += e3, r3.primitiveLength += a2.length / 3;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
        }
      }
      let al, ol;
      wi("FillBucket", sl, { omit: ["layers", "patternFeatures"] });
      var ll = {
        get paint() {
          return ol = ol || new rs({
            "fill-antialias": new Ji(G.paint_fill["fill-antialias"]),
            "fill-opacity": new Wi(G.paint_fill["fill-opacity"]),
            "fill-color": new Wi(G.paint_fill["fill-color"]),
            "fill-outline-color": new Wi(G.paint_fill["fill-outline-color"]),
            "fill-translate": new Ji(G.paint_fill["fill-translate"]),
            "fill-translate-anchor": new Ji(G.paint_fill["fill-translate-anchor"]),
            "fill-pattern": new Qi(G.paint_fill["fill-pattern"])
          });
        },
        get layout() {
          return al = al || new rs({ "fill-sort-key": new Wi(G.layout_fill["fill-sort-key"]) });
        }
      };

      class ul extends is {
        constructor(t2) {
          super(t2, ll);
        }
        recalculate(t2, e2) {
          super.recalculate(t2, e2);
          const r2 = this.paint._values["fill-outline-color"];
          r2.value.kind === "constant" && r2.value.value === undefined && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(t2) {
          return new sl(t2);
        }
        queryRadius() {
          return eo(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, s2, a2) {
          return Za(ro(t2, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, a2), n2);
        }
        isTileClipped() {
          return true;
        }
      }
      const cl = ls([
        { name: "a_pos", components: 2, type: "Int16" },
        { name: "a_normal_ed", components: 4, type: "Int16" }
      ], 4), hl = ls([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: pl } = cl;
      var fl = {}, dl = n, yl = ml;
      function ml(t2, e2, r2, n2, i2) {
        this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(gl, this, e2);
      }
      function gl(t2, e2, r2) {
        t2 == 1 ? e2.id = r2.readVarint() : t2 == 2 ? function(t3, e3) {
          for (var r3 = t3.readVarint() + t3.pos;t3.pos < r3; ) {
            var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
            e3.properties[n2] = i2;
          }
        }(r2, e2) : t2 == 3 ? e2.type = r2.readVarint() : t2 == 4 && (e2._geometry = r2.pos);
      }
      function xl(t2) {
        for (var e2, r2, n2 = 0, i2 = 0, s2 = t2.length, a2 = s2 - 1;i2 < s2; a2 = i2++)
          n2 += ((r2 = t2[a2]).x - (e2 = t2[i2]).x) * (e2.y + r2.y);
        return n2;
      }
      ml.types = ["Unknown", "Point", "LineString", "Polygon"], ml.prototype.loadGeometry = function() {
        var t2 = this._pbf;
        t2.pos = this._geometry;
        for (var e2, r2 = t2.readVarint() + t2.pos, n2 = 1, i2 = 0, s2 = 0, a2 = 0, o2 = [];t2.pos < r2; ) {
          if (i2 <= 0) {
            var l2 = t2.readVarint();
            n2 = 7 & l2, i2 = l2 >> 3;
          }
          if (i2--, n2 === 1 || n2 === 2)
            s2 += t2.readSVarint(), a2 += t2.readSVarint(), n2 === 1 && (e2 && o2.push(e2), e2 = []), e2.push(new dl(s2, a2));
          else {
            if (n2 !== 7)
              throw new Error("unknown command " + n2);
            e2 && e2.push(e2[0].clone());
          }
        }
        return e2 && o2.push(e2), o2;
      }, ml.prototype.bbox = function() {
        var t2 = this._pbf;
        t2.pos = this._geometry;
        for (var e2 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, s2 = 0, a2 = 1 / 0, o2 = -1 / 0, l2 = 1 / 0, u2 = -1 / 0;t2.pos < e2; ) {
          if (n2 <= 0) {
            var c2 = t2.readVarint();
            r2 = 7 & c2, n2 = c2 >> 3;
          }
          if (n2--, r2 === 1 || r2 === 2)
            (i2 += t2.readSVarint()) < a2 && (a2 = i2), i2 > o2 && (o2 = i2), (s2 += t2.readSVarint()) < l2 && (l2 = s2), s2 > u2 && (u2 = s2);
          else if (r2 !== 7)
            throw new Error("unknown command " + r2);
        }
        return [a2, l2, o2, u2];
      }, ml.prototype.toGeoJSON = function(t2, e2, r2) {
        var n2, i2, s2 = this.extent * Math.pow(2, r2), a2 = this.extent * t2, o2 = this.extent * e2, l2 = this.loadGeometry(), u2 = ml.types[this.type];
        function c2(t3) {
          for (var e3 = 0;e3 < t3.length; e3++) {
            var r3 = t3[e3];
            t3[e3] = [
              360 * (r3.x + a2) / s2 - 180,
              360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + o2) / s2) * Math.PI / 180)) - 90
            ];
          }
        }
        switch (this.type) {
          case 1:
            var h2 = [];
            for (n2 = 0;n2 < l2.length; n2++)
              h2[n2] = l2[n2][0];
            c2(l2 = h2);
            break;
          case 2:
            for (n2 = 0;n2 < l2.length; n2++)
              c2(l2[n2]);
            break;
          case 3:
            for (l2 = function(t3) {
              var e3 = t3.length;
              if (e3 <= 1)
                return [t3];
              for (var r3, n3, i3 = [], s3 = 0;s3 < e3; s3++) {
                var a3 = xl(t3[s3]);
                a3 !== 0 && (n3 === undefined && (n3 = a3 < 0), n3 === a3 < 0 ? (r3 && i3.push(r3), r3 = [t3[s3]]) : r3.push(t3[s3]));
              }
              return r3 && i3.push(r3), i3;
            }(l2), n2 = 0;n2 < l2.length; n2++)
              for (i2 = 0;i2 < l2[n2].length; i2++)
                c2(l2[n2][i2]);
        }
        l2.length === 1 ? l2 = l2[0] : u2 = "Multi" + u2;
        var p2 = {
          type: "Feature",
          geometry: { type: u2, coordinates: l2 },
          properties: this.properties
        };
        return "id" in this && (p2.id = this.id), p2;
      };
      var vl = yl, bl = wl;
      function wl(t2, e2) {
        this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(_l, this, e2), this.length = this._features.length;
      }
      function _l(t2, e2, r2) {
        t2 === 15 ? e2.version = r2.readVarint() : t2 === 1 ? e2.name = r2.readString() : t2 === 5 ? e2.extent = r2.readVarint() : t2 === 2 ? e2._features.push(r2.pos) : t2 === 3 ? e2._keys.push(r2.readString()) : t2 === 4 && e2._values.push(function(t3) {
          for (var e3 = null, r3 = t3.readVarint() + t3.pos;t3.pos < r3; ) {
            var n2 = t3.readVarint() >> 3;
            e3 = n2 === 1 ? t3.readString() : n2 === 2 ? t3.readFloat() : n2 === 3 ? t3.readDouble() : n2 === 4 ? t3.readVarint64() : n2 === 5 ? t3.readVarint() : n2 === 6 ? t3.readSVarint() : n2 === 7 ? t3.readBoolean() : null;
          }
          return e3;
        }(r2));
      }
      wl.prototype.feature = function(t2) {
        if (t2 < 0 || t2 >= this._features.length)
          throw new Error("feature index out of bounds");
        this._pbf.pos = this._features[t2];
        var e2 = this._pbf.readVarint() + this._pbf.pos;
        return new vl(this._pbf, e2, this.extent, this._keys, this._values);
      };
      var Al = bl;
      function Sl(t2, e2, r2) {
        if (t2 === 3) {
          var n2 = new Al(r2, r2.readVarint() + r2.pos);
          n2.length && (e2[n2.name] = n2);
        }
      }
      fl.VectorTile = function(t2, e2) {
        this.layers = t2.readFields(Sl, {}, e2);
      }, fl.VectorTileFeature = yl, fl.VectorTileLayer = bl;
      const kl = fl.VectorTileFeature.types, Ml = Math.pow(2, 13);
      function Il(t2, e2, r2, n2, i2, s2, a2, o2) {
        t2.emplaceBack(e2, r2, 2 * Math.floor(n2 * Ml) + a2, i2 * Ml * 2, s2 * Ml * 2, Math.round(o2));
      }

      class zl {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Xs, this.centroidVertexArray = new Zs, this.indexArray = new na, this.programConfigurations = new Ea(t2.layers, t2.zoom), this.segments = new oa, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          this.features = [], this.hasPattern = nl("fill-extrusion", this.layers, e2);
          for (const { feature: n2, id: i2, index: s2, sourceLayerIndex: a2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, o2 = ja(n2, t3);
            if (!this.layers[0]._featureFilter.filter(new Ui(this.zoom), o2, r2))
              continue;
            const l2 = {
              id: i2,
              sourceLayerIndex: a2,
              index: s2,
              geometry: t3 ? o2.geometry : Oa(n2),
              properties: n2.properties,
              type: n2.type,
              patterns: {}
            };
            this.hasPattern ? this.features.push(il("fill-extrusion", this.layers, l2, this.zoom, e2)) : this.addFeature(l2, l2.geometry, s2, r2, {}), e2.featureIndex.insert(n2, l2.geometry, s2, a2, this.index, true);
          }
        }
        addFeatures(t2, e2, r2) {
          for (const t3 of this.features) {
            const { geometry: n2 } = t3;
            this.addFeature(t3, n2, t3.index, e2, r2);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, pl), this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, hl.members, true), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(t2, e2, r2, n2, i2) {
          for (const r3 of xr(e2, 500)) {
            const e3 = { x: 0, y: 0, vertexCount: 0 };
            let n3 = 0;
            for (const t3 of r3)
              n3 += t3.length;
            let i3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
            for (const t3 of r3) {
              if (t3.length === 0)
                continue;
              if (Cl(t3))
                continue;
              let r4 = 0;
              for (let n4 = 0;n4 < t3.length; n4++) {
                const s3 = t3[n4];
                if (n4 >= 1) {
                  const a3 = t3[n4 - 1];
                  if (!Pl(s3, a3)) {
                    i3.vertexLength + 4 > oa.MAX_VERTEX_ARRAY_LENGTH && (i3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                    const t4 = s3.sub(a3)._perp()._unit(), n5 = a3.dist(s3);
                    r4 + n5 > 32768 && (r4 = 0), Il(this.layoutVertexArray, s3.x, s3.y, t4.x, t4.y, 0, 0, r4), Il(this.layoutVertexArray, s3.x, s3.y, t4.x, t4.y, 0, 1, r4), e3.x += 2 * s3.x, e3.y += 2 * s3.y, e3.vertexCount += 2, r4 += n5, Il(this.layoutVertexArray, a3.x, a3.y, t4.x, t4.y, 0, 0, r4), Il(this.layoutVertexArray, a3.x, a3.y, t4.x, t4.y, 0, 1, r4), e3.x += 2 * a3.x, e3.y += 2 * a3.y, e3.vertexCount += 2;
                    const o3 = i3.vertexLength;
                    this.indexArray.emplaceBack(o3, o3 + 2, o3 + 1), this.indexArray.emplaceBack(o3 + 1, o3 + 2, o3 + 3), i3.vertexLength += 4, i3.primitiveLength += 2;
                  }
                }
              }
            }
            if (i3.vertexLength + n3 > oa.MAX_VERTEX_ARRAY_LENGTH && (i3 = this.segments.prepareSegment(n3, this.layoutVertexArray, this.indexArray)), kl[t2.type] !== "Polygon")
              continue;
            const s2 = [], a2 = [], o2 = i3.vertexLength;
            for (const t3 of r3)
              if (t3.length !== 0) {
                t3 !== r3[0] && a2.push(s2.length / 2);
                for (let r4 = 0;r4 < t3.length; r4++) {
                  const n4 = t3[r4];
                  Il(this.layoutVertexArray, n4.x, n4.y, 0, 0, 1, 1, 0), e3.x += n4.x, e3.y += n4.y, e3.vertexCount += 1, s2.push(n4.x), s2.push(n4.y);
                }
              }
            const l2 = Vo(s2, a2);
            for (let t3 = 0;t3 < l2.length; t3 += 3)
              this.indexArray.emplaceBack(o2 + l2[t3], o2 + l2[t3 + 2], o2 + l2[t3 + 1]);
            i3.primitiveLength += l2.length / 3, i3.vertexLength += n3;
            for (let t3 = 0;t3 < e3.vertexCount; t3++) {
              const t4 = Math.floor(e3.x / e3.vertexCount), r4 = Math.floor(e3.y / e3.vertexCount);
              this.centroidVertexArray.emplaceBack(t4, r4);
            }
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
        }
      }
      function Pl(t2, e2) {
        return t2.x === e2.x && (t2.x < 0 || t2.x > $a) || t2.y === e2.y && (t2.y < 0 || t2.y > $a);
      }
      function Cl(t2) {
        return t2.every((t3) => t3.x < 0) || t2.every((t3) => t3.x > $a) || t2.every((t3) => t3.y < 0) || t2.every((t3) => t3.y > $a);
      }
      let Bl;
      wi("FillExtrusionBucket", zl, { omit: ["layers", "features"] });
      var Vl = {
        get paint() {
          return Bl = Bl || new rs({
            "fill-extrusion-opacity": new Ji(G["paint_fill-extrusion"]["fill-extrusion-opacity"]),
            "fill-extrusion-color": new Wi(G["paint_fill-extrusion"]["fill-extrusion-color"]),
            "fill-extrusion-translate": new Ji(G["paint_fill-extrusion"]["fill-extrusion-translate"]),
            "fill-extrusion-translate-anchor": new Ji(G["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
            "fill-extrusion-pattern": new Qi(G["paint_fill-extrusion"]["fill-extrusion-pattern"]),
            "fill-extrusion-height": new Wi(G["paint_fill-extrusion"]["fill-extrusion-height"]),
            "fill-extrusion-base": new Wi(G["paint_fill-extrusion"]["fill-extrusion-base"]),
            "fill-extrusion-vertical-gradient": new Ji(G["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
          });
        }
      };

      class El extends is {
        constructor(t2) {
          super(t2, Vl);
        }
        createBucket(t2) {
          return new zl(t2);
        }
        queryRadius() {
          return eo(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return true;
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, a2, o2, l2) {
          const u2 = ro(t2, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), a2.angle, o2), c2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), h2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), p2 = function(t3, e3, r3, n3) {
            const i3 = [];
            for (const r4 of t3) {
              const t4 = [r4.x, r4.y, 0, 1];
              po(t4, t4, e3), i3.push(new s(t4[0] / t4[3], t4[1] / t4[3]));
            }
            return i3;
          }(u2, l2), f2 = function(t3, e3, r3, n3) {
            const i3 = [], a3 = [], o3 = n3[8] * e3, l3 = n3[9] * e3, u3 = n3[10] * e3, c3 = n3[11] * e3, h3 = n3[8] * r3, p3 = n3[9] * r3, f3 = n3[10] * r3, d2 = n3[11] * r3;
            for (const e4 of t3) {
              const t4 = [], r4 = [];
              for (const i4 of e4) {
                const { x: e5, y: a4 } = i4, y2 = n3[0] * e5 + n3[4] * a4 + n3[12], m2 = n3[1] * e5 + n3[5] * a4 + n3[13], g2 = n3[2] * e5 + n3[6] * a4 + n3[14], x2 = n3[3] * e5 + n3[7] * a4 + n3[15], v2 = g2 + u3, b2 = x2 + c3, w2 = y2 + h3, _2 = m2 + p3, A2 = g2 + f3, S2 = x2 + d2, k2 = new s((y2 + o3) / b2, (m2 + l3) / b2);
                k2.z = v2 / b2, t4.push(k2);
                const M2 = new s(w2 / S2, _2 / S2);
                M2.z = A2 / S2, r4.push(M2);
              }
              i3.push(t4), a3.push(r4);
            }
            return [i3, a3];
          }(n2, h2, c2, l2);
          return function(t3, e3, r3) {
            let n3 = 1 / 0;
            Za(r3, e3) && (n3 = Tl(r3, e3[0]));
            for (let i3 = 0;i3 < e3.length; i3++) {
              const s2 = e3[i3], a3 = t3[i3];
              for (let t4 = 0;t4 < s2.length - 1; t4++) {
                const e4 = s2[t4], i4 = [e4, s2[t4 + 1], a3[t4 + 1], a3[t4], e4];
                qa(r3, i4) && (n3 = Math.min(n3, Tl(r3, i4)));
              }
            }
            return n3 !== 1 / 0 && n3;
          }(f2[0], f2[1], p2);
        }
      }
      function Fl(t2, e2) {
        return t2.x * e2.x + t2.y * e2.y;
      }
      function Tl(t2, e2) {
        if (t2.length === 1) {
          let r2 = 0;
          const n2 = e2[r2++];
          let i2;
          for (;!i2 || n2.equals(i2); )
            if (i2 = e2[r2++], !i2)
              return 1 / 0;
          for (;r2 < e2.length; r2++) {
            const s2 = e2[r2], a2 = t2[0], o2 = i2.sub(n2), l2 = s2.sub(n2), u2 = a2.sub(n2), c2 = Fl(o2, o2), h2 = Fl(o2, l2), p2 = Fl(l2, l2), f2 = Fl(u2, o2), d2 = Fl(u2, l2), y2 = c2 * p2 - h2 * h2, m2 = (p2 * f2 - h2 * d2) / y2, g2 = (c2 * d2 - h2 * f2) / y2, x2 = n2.z * (1 - m2 - g2) + i2.z * m2 + s2.z * g2;
            if (isFinite(x2))
              return x2;
          }
          return 1 / 0;
        }
        {
          let t3 = 1 / 0;
          for (const r2 of e2)
            t3 = Math.min(t3, r2.z);
          return t3;
        }
      }
      const $l = ls([
        { name: "a_pos_normal", components: 2, type: "Int16" },
        { name: "a_data", components: 4, type: "Uint8" }
      ], 4), { members: Ll } = $l, Dl = ls([
        { name: "a_uv_x", components: 1, type: "Float32" },
        { name: "a_split_index", components: 1, type: "Float32" }
      ]), { members: Ol } = Dl, jl = fl.VectorTileFeature.types, Rl = Math.cos(Math.PI / 180 * 37.5), Ul = Math.pow(2, 14) / 0.5;

      class ql {
        constructor(t2) {
          this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.id), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
            this.gradients[t3.id] = {};
          }), this.layoutVertexArray = new Hs, this.layoutVertexArray2 = new Ys, this.indexArray = new na, this.programConfigurations = new Ea(t2.layers, t2.zoom), this.segments = new oa, this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
        }
        populate(t2, e2, r2) {
          this.hasPattern = nl("line", this.layers, e2);
          const n2 = this.layers[0].layout.get("line-sort-key"), i2 = !n2.isConstant(), s2 = [];
          for (const { feature: e3, id: a2, index: o2, sourceLayerIndex: l2 } of t2) {
            const t3 = this.layers[0]._featureFilter.needGeometry, u2 = ja(e3, t3);
            if (!this.layers[0]._featureFilter.filter(new Ui(this.zoom), u2, r2))
              continue;
            const c2 = i2 ? n2.evaluate(u2, {}, r2) : undefined, h2 = {
              id: a2,
              properties: e3.properties,
              type: e3.type,
              sourceLayerIndex: l2,
              index: o2,
              geometry: t3 ? u2.geometry : Oa(e3),
              patterns: {},
              sortKey: c2
            };
            s2.push(h2);
          }
          i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
          for (const n3 of s2) {
            const { geometry: i3, index: s3, sourceLayerIndex: a2 } = n3;
            if (this.hasPattern) {
              const t3 = il("line", this.layers, n3, this.zoom, e2);
              this.patternFeatures.push(t3);
            } else
              this.addFeature(n3, i3, s3, r2, {});
            e2.featureIndex.insert(t2[s3].feature, i3, s3, a2, this.index);
          }
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
        }
        addFeatures(t2, e2, r2) {
          for (const t3 of this.patternFeatures)
            this.addFeature(t3, t3.geometry, t3.index, e2, r2);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t2) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Ol)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ll), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t2) {
          if (t2.properties && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t2.properties, "mapbox_clip_end"))
            return {
              start: +t2.properties.mapbox_clip_start,
              end: +t2.properties.mapbox_clip_end
            };
        }
        addFeature(t2, e2, r2, n2, i2) {
          const s2 = this.layers[0].layout, a2 = s2.get("line-join").evaluate(t2, {}), o2 = s2.get("line-cap"), l2 = s2.get("line-miter-limit"), u2 = s2.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(t2);
          for (const r3 of e2)
            this.addLine(r3, t2, a2, o2, l2, u2);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
        }
        addLine(t2, e2, r2, n2, i2, s2) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let e3 = 0;e3 < t2.length - 1; e3++)
              this.totalDistance += t2[e3].dist(t2[e3 + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const a2 = jl[e2.type] === "Polygon";
          let o2 = t2.length;
          for (;o2 >= 2 && t2[o2 - 1].equals(t2[o2 - 2]); )
            o2--;
          let l2 = 0;
          for (;l2 < o2 - 1 && t2[l2].equals(t2[l2 + 1]); )
            l2++;
          if (o2 < (a2 ? 3 : 2))
            return;
          r2 === "bevel" && (i2 = 1.05);
          const u2 = this.overscaling <= 16 ? 15 * $a / (512 * this.overscaling) : 0, c2 = this.segments.prepareSegment(10 * o2, this.layoutVertexArray, this.indexArray);
          let h2, p2, f2, d2, y2;
          this.e1 = this.e2 = -1, a2 && (h2 = t2[o2 - 2], y2 = t2[l2].sub(h2)._unit()._perp());
          for (let e3 = l2;e3 < o2; e3++) {
            if (f2 = e3 === o2 - 1 ? a2 ? t2[l2 + 1] : undefined : t2[e3 + 1], f2 && t2[e3].equals(f2))
              continue;
            y2 && (d2 = y2), h2 && (p2 = h2), h2 = t2[e3], y2 = f2 ? f2.sub(h2)._unit()._perp() : d2, d2 = d2 || y2;
            let m2 = d2.add(y2);
            m2.x === 0 && m2.y === 0 || m2._unit();
            const g2 = d2.x * y2.x + d2.y * y2.y, x2 = m2.x * y2.x + m2.y * y2.y, v2 = x2 !== 0 ? 1 / x2 : 1 / 0, b2 = 2 * Math.sqrt(2 - 2 * x2), w2 = x2 < Rl && p2 && f2, _2 = d2.x * y2.y - d2.y * y2.x > 0;
            if (w2 && e3 > l2) {
              const t3 = h2.dist(p2);
              if (t3 > 2 * u2) {
                const e4 = h2.sub(h2.sub(p2)._mult(u2 / t3)._round());
                this.updateDistance(p2, e4), this.addCurrentVertex(e4, d2, 0, 0, c2), p2 = e4;
              }
            }
            const A2 = p2 && f2;
            let S2 = A2 ? r2 : a2 ? "butt" : n2;
            if (A2 && S2 === "round" && (v2 < s2 ? S2 = "miter" : v2 <= 2 && (S2 = "fakeround")), S2 === "miter" && v2 > i2 && (S2 = "bevel"), S2 === "bevel" && (v2 > 2 && (S2 = "flipbevel"), v2 < i2 && (S2 = "miter")), p2 && this.updateDistance(p2, h2), S2 === "miter")
              m2._mult(v2), this.addCurrentVertex(h2, m2, 0, 0, c2);
            else if (S2 === "flipbevel") {
              if (v2 > 100)
                m2 = y2.mult(-1);
              else {
                const t3 = v2 * d2.add(y2).mag() / d2.sub(y2).mag();
                m2._perp()._mult(t3 * (_2 ? -1 : 1));
              }
              this.addCurrentVertex(h2, m2, 0, 0, c2), this.addCurrentVertex(h2, m2.mult(-1), 0, 0, c2);
            } else if (S2 === "bevel" || S2 === "fakeround") {
              const t3 = -Math.sqrt(v2 * v2 - 1), e4 = _2 ? t3 : 0, r3 = _2 ? 0 : t3;
              if (p2 && this.addCurrentVertex(h2, d2, e4, r3, c2), S2 === "fakeround") {
                const t4 = Math.round(180 * b2 / Math.PI / 20);
                for (let e5 = 1;e5 < t4; e5++) {
                  let r4 = e5 / t4;
                  if (r4 !== 0.5) {
                    const t5 = r4 - 0.5;
                    r4 += r4 * t5 * (r4 - 1) * ((1.0904 + g2 * (g2 * (3.55645 - 1.43519 * g2) - 3.2452)) * t5 * t5 + (0.848013 + g2 * (0.215638 * g2 - 1.06021)));
                  }
                  const n3 = y2.sub(d2)._mult(r4)._add(d2)._unit()._mult(_2 ? -1 : 1);
                  this.addHalfVertex(h2, n3.x, n3.y, false, _2, 0, c2);
                }
              }
              f2 && this.addCurrentVertex(h2, y2, -e4, -r3, c2);
            } else if (S2 === "butt")
              this.addCurrentVertex(h2, m2, 0, 0, c2);
            else if (S2 === "square") {
              const t3 = p2 ? 1 : -1;
              this.addCurrentVertex(h2, m2, t3, t3, c2);
            } else
              S2 === "round" && (p2 && (this.addCurrentVertex(h2, d2, 0, 0, c2), this.addCurrentVertex(h2, d2, 1, 1, c2, true)), f2 && (this.addCurrentVertex(h2, y2, -1, -1, c2, true), this.addCurrentVertex(h2, y2, 0, 0, c2)));
            if (w2 && e3 < o2 - 1) {
              const t3 = h2.dist(f2);
              if (t3 > 2 * u2) {
                const e4 = h2.add(f2.sub(h2)._mult(u2 / t3)._round());
                this.updateDistance(h2, e4), this.addCurrentVertex(e4, y2, 0, 0, c2), h2 = e4;
              }
            }
          }
        }
        addCurrentVertex(t2, e2, r2, n2, i2, s2 = false) {
          const a2 = e2.y * n2 - e2.x, o2 = -e2.y - e2.x * n2;
          this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, s2, false, r2, i2), this.addHalfVertex(t2, a2, o2, s2, true, -n2, i2), this.distance > Ul / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t2, e2, r2, n2, i2, s2));
        }
        addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, a2, o2) {
          const l2 = 0.5 * (this.lineClips ? this.scaledDistance * (Ul - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (a2 === 0 ? 0 : a2 < 0 ? -1 : 1) | (63 & l2) << 2, l2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const u2 = o2.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), s2 ? this.e2 = u2 : this.e1 = u2;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(t2, e2) {
          this.distance += t2.dist(e2), this.updateScaledDistance();
        }
      }
      let Nl, Zl;
      wi("LineBucket", ql, { omit: ["layers", "patternFeatures"] });
      var Gl = {
        get paint() {
          return Zl = Zl || new rs({
            "line-opacity": new Wi(G.paint_line["line-opacity"]),
            "line-color": new Wi(G.paint_line["line-color"]),
            "line-translate": new Ji(G.paint_line["line-translate"]),
            "line-translate-anchor": new Ji(G.paint_line["line-translate-anchor"]),
            "line-width": new Wi(G.paint_line["line-width"]),
            "line-gap-width": new Wi(G.paint_line["line-gap-width"]),
            "line-offset": new Wi(G.paint_line["line-offset"]),
            "line-blur": new Wi(G.paint_line["line-blur"]),
            "line-dasharray": new ts(G.paint_line["line-dasharray"]),
            "line-pattern": new Qi(G.paint_line["line-pattern"]),
            "line-gradient": new es(G.paint_line["line-gradient"])
          });
        },
        get layout() {
          return Nl = Nl || new rs({
            "line-cap": new Ji(G.layout_line["line-cap"]),
            "line-join": new Wi(G.layout_line["line-join"]),
            "line-miter-limit": new Ji(G.layout_line["line-miter-limit"]),
            "line-round-limit": new Ji(G.layout_line["line-round-limit"]),
            "line-sort-key": new Wi(G.layout_line["line-sort-key"])
          });
        }
      };

      class Kl extends Wi {
        possiblyEvaluate(t2, e2) {
          return e2 = new Ui(Math.floor(e2.zoom), {
            now: e2.now,
            fadeDuration: e2.fadeDuration,
            zoomHistory: e2.zoomHistory,
            transition: e2.transition
          }), super.possiblyEvaluate(t2, e2);
        }
        evaluate(t2, e2, r2, n2) {
          return e2 = g({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
        }
      }
      let Xl;

      class Hl extends is {
        constructor(t2) {
          super(t2, Gl), this.gradientVersion = 0, Xl || (Xl = new Kl(Gl.paint.properties["line-width"].specification), Xl.useIntegerZoom = true);
        }
        _handleSpecialPaintPropertyUpdate(t2) {
          if (t2 === "line-gradient") {
            const t3 = this.gradientExpression();
            this.stepInterpolant = !!function(t4) {
              return t4._styleExpression !== undefined;
            }(t3) && t3._styleExpression.expression instanceof Ae, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(t2, e2) {
          super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = Xl.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
        }
        createBucket(t2) {
          return new ql(t2);
        }
        queryRadius(t2) {
          const e2 = t2, r2 = Yl(to("line-width", this, e2), to("line-gap-width", this, e2)), n2 = to("line-offset", this, e2);
          return r2 / 2 + Math.abs(n2) + eo(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(t2, e2, r2, n2, i2, a2, o2) {
          const l2 = ro(t2, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), a2.angle, o2), u2 = o2 / 2 * Yl(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), c2 = this.paint.get("line-offset").evaluate(e2, r2);
          return c2 && (n2 = function(t3, e3) {
            const r3 = [];
            for (let n3 = 0;n3 < t3.length; n3++) {
              const i3 = t3[n3], a3 = [];
              for (let t4 = 0;t4 < i3.length; t4++) {
                const r4 = i3[t4 - 1], n4 = i3[t4], o3 = i3[t4 + 1], l3 = t4 === 0 ? new s(0, 0) : n4.sub(r4)._unit()._perp(), u3 = t4 === i3.length - 1 ? new s(0, 0) : o3.sub(n4)._unit()._perp(), c3 = l3._add(u3)._unit(), h2 = c3.x * u3.x + c3.y * u3.y;
                h2 !== 0 && c3._mult(1 / h2), a3.push(c3._mult(e3)._add(n4));
              }
              r3.push(a3);
            }
            return r3;
          }(n2, c2 * o2)), function(t3, e3, r3) {
            for (let n3 = 0;n3 < e3.length; n3++) {
              const i3 = e3[n3];
              if (t3.length >= 3) {
                for (let e4 = 0;e4 < i3.length; e4++)
                  if (Wa(t3, i3[e4]))
                    return true;
              }
              if (Ga(t3, i3, r3))
                return true;
            }
            return false;
          }(l2, n2, u2);
        }
        isTileClipped() {
          return true;
        }
      }
      function Yl(t2, e2) {
        return e2 > 0 ? e2 + 2 * t2 : t2;
      }
      const Jl = ls([
        { name: "a_pos_offset", components: 4, type: "Int16" },
        { name: "a_data", components: 4, type: "Uint16" },
        { name: "a_pixeloffset", components: 4, type: "Int16" }
      ], 4), Wl = ls([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      ls([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const Ql = ls([
        { name: "a_placed", components: 2, type: "Uint8" },
        { name: "a_shift", components: 2, type: "Float32" },
        { name: "a_box_real", components: 2, type: "Int16" }
      ]);
      ls([
        { type: "Int16", name: "anchorPointX" },
        { type: "Int16", name: "anchorPointY" },
        { type: "Int16", name: "x1" },
        { type: "Int16", name: "y1" },
        { type: "Int16", name: "x2" },
        { type: "Int16", name: "y2" },
        { type: "Uint32", name: "featureIndex" },
        { type: "Uint16", name: "sourceLayerIndex" },
        { type: "Uint16", name: "bucketIndex" }
      ]);
      const tu = ls([
        { name: "a_pos", components: 2, type: "Int16" },
        { name: "a_anchor_pos", components: 2, type: "Int16" },
        { name: "a_extrude", components: 2, type: "Int16" }
      ], 4), eu = ls([
        { name: "a_pos", components: 2, type: "Float32" },
        { name: "a_radius", components: 1, type: "Float32" },
        { name: "a_flags", components: 2, type: "Int16" }
      ], 4);
      function ru(t2, e2, r2) {
        return t2.sections.forEach((t3) => {
          t3.text = function(t4, e3, r3) {
            const n2 = e3.layout.get("text-transform").evaluate(r3, {});
            return n2 === "uppercase" ? t4 = t4.toLocaleUpperCase() : n2 === "lowercase" && (t4 = t4.toLocaleLowerCase()), Ri.applyArabicShaping && (t4 = Ri.applyArabicShaping(t4)), t4;
          }(t3.text, e2, r2);
        }), t2;
      }
      ls([{ name: "triangle", components: 3, type: "Uint16" }]), ls([
        { type: "Int16", name: "anchorX" },
        { type: "Int16", name: "anchorY" },
        { type: "Uint16", name: "glyphStartIndex" },
        { type: "Uint16", name: "numGlyphs" },
        { type: "Uint32", name: "vertexStartIndex" },
        { type: "Uint32", name: "lineStartIndex" },
        { type: "Uint32", name: "lineLength" },
        { type: "Uint16", name: "segment" },
        { type: "Uint16", name: "lowerSize" },
        { type: "Uint16", name: "upperSize" },
        { type: "Float32", name: "lineOffsetX" },
        { type: "Float32", name: "lineOffsetY" },
        { type: "Uint8", name: "writingMode" },
        { type: "Uint8", name: "placedOrientation" },
        { type: "Uint8", name: "hidden" },
        { type: "Uint32", name: "crossTileID" },
        { type: "Int16", name: "associatedIconIndex" }
      ]), ls([
        { type: "Int16", name: "anchorX" },
        { type: "Int16", name: "anchorY" },
        { type: "Int16", name: "rightJustifiedTextSymbolIndex" },
        { type: "Int16", name: "centerJustifiedTextSymbolIndex" },
        { type: "Int16", name: "leftJustifiedTextSymbolIndex" },
        { type: "Int16", name: "verticalPlacedTextSymbolIndex" },
        { type: "Int16", name: "placedIconSymbolIndex" },
        { type: "Int16", name: "verticalPlacedIconSymbolIndex" },
        { type: "Uint16", name: "key" },
        { type: "Uint16", name: "textBoxStartIndex" },
        { type: "Uint16", name: "textBoxEndIndex" },
        { type: "Uint16", name: "verticalTextBoxStartIndex" },
        { type: "Uint16", name: "verticalTextBoxEndIndex" },
        { type: "Uint16", name: "iconBoxStartIndex" },
        { type: "Uint16", name: "iconBoxEndIndex" },
        { type: "Uint16", name: "verticalIconBoxStartIndex" },
        { type: "Uint16", name: "verticalIconBoxEndIndex" },
        { type: "Uint16", name: "featureIndex" },
        { type: "Uint16", name: "numHorizontalGlyphVertices" },
        { type: "Uint16", name: "numVerticalGlyphVertices" },
        { type: "Uint16", name: "numIconVertices" },
        { type: "Uint16", name: "numVerticalIconVertices" },
        { type: "Uint16", name: "useRuntimeCollisionCircles" },
        { type: "Uint32", name: "crossTileID" },
        { type: "Float32", name: "textBoxScale" },
        { type: "Float32", name: "collisionCircleDiameter" },
        { type: "Uint16", name: "textAnchorOffsetStartIndex" },
        { type: "Uint16", name: "textAnchorOffsetEndIndex" }
      ]), ls([{ type: "Float32", name: "offsetX" }]), ls([
        { type: "Int16", name: "x" },
        { type: "Int16", name: "y" },
        { type: "Int16", name: "tileUnitDistanceFromAnchor" }
      ]), ls([
        { type: "Uint16", name: "textAnchor" },
        { type: "Float32", components: 2, name: "textOffset" }
      ]);
      const nu = {
        "!": "︕",
        "#": "＃",
        $: "＄",
        "%": "％",
        "&": "＆",
        "(": "︵",
        ")": "︶",
        "*": "＊",
        "+": "＋",
        ",": "︐",
        "-": "︲",
        ".": "・",
        "/": "／",
        ":": "︓",
        ";": "︔",
        "<": "︿",
        "=": "＝",
        ">": "﹀",
        "?": "︖",
        "@": "＠",
        "[": "﹇",
        "\\": "＼",
        "]": "﹈",
        "^": "＾",
        _: "︳",
        "`": "｀",
        "{": "︷",
        "|": "―",
        "}": "︸",
        "~": "～",
        "¢": "￠",
        "£": "￡",
        "¥": "￥",
        "¦": "￤",
        "¬": "￢",
        "¯": "￣",
        "–": "︲",
        "—": "︱",
        "‘": "﹃",
        "’": "﹄",
        "“": "﹁",
        "”": "﹂",
        "…": "︙",
        "‧": "・",
        "₩": "￦",
        "、": "︑",
        "。": "︒",
        "〈": "︿",
        "〉": "﹀",
        "《": "︽",
        "》": "︾",
        "「": "﹁",
        "」": "﹂",
        "『": "﹃",
        "』": "﹄",
        "【": "︻",
        "】": "︼",
        "〔": "︹",
        "〕": "︺",
        "〖": "︗",
        "〗": "︘",
        "！": "︕",
        "（": "︵",
        "）": "︶",
        "，": "︐",
        "－": "︲",
        "．": "・",
        "：": "︓",
        "；": "︔",
        "＜": "︿",
        "＞": "﹀",
        "？": "︖",
        "［": "﹇",
        "］": "﹈",
        "＿": "︳",
        "｛": "︷",
        "｜": "―",
        "｝": "︸",
        "｟": "︵",
        "｠": "︶",
        "｡": "︒",
        "｢": "﹁",
        "｣": "﹂"
      };
      var iu = 24, su = lu, au = function(t2, e2, r2, n2, i2) {
        var s2, a2, o2 = 8 * i2 - n2 - 1, l2 = (1 << o2) - 1, u2 = l2 >> 1, c2 = -7, h2 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e2 + h2];
        for (h2 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += o2;c2 > 0; s2 = 256 * s2 + t2[e2 + h2], h2 += p2, c2 -= 8)
          ;
        for (a2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2;c2 > 0; a2 = 256 * a2 + t2[e2 + h2], h2 += p2, c2 -= 8)
          ;
        if (s2 === 0)
          s2 = 1 - u2;
        else {
          if (s2 === l2)
            return a2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
          a2 += Math.pow(2, n2), s2 -= u2;
        }
        return (f2 ? -1 : 1) * a2 * Math.pow(2, s2 - n2);
      }, ou = function(t2, e2, r2, n2, i2, s2) {
        var a2, o2, l2, u2 = 8 * s2 - i2 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, p2 = i2 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, y2 = e2 < 0 || e2 === 0 && 1 / e2 < 0 ? 1 : 0;
        for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (o2 = isNaN(e2) ? 1 : 0, a2 = c2) : (a2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -a2)) < 1 && (a2--, l2 *= 2), (e2 += a2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (a2++, l2 /= 2), a2 + h2 >= c2 ? (o2 = 0, a2 = c2) : a2 + h2 >= 1 ? (o2 = (e2 * l2 - 1) * Math.pow(2, i2), a2 += h2) : (o2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i2), a2 = 0));i2 >= 8; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, i2 -= 8)
          ;
        for (a2 = a2 << i2 | o2, u2 += i2;u2 > 0; t2[r2 + f2] = 255 & a2, f2 += d2, a2 /= 256, u2 -= 8)
          ;
        t2[r2 + f2 - d2] |= 128 * y2;
      };
      function lu(t2) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
      }
      lu.Varint = 0, lu.Fixed64 = 1, lu.Bytes = 2, lu.Fixed32 = 5;
      var uu = 4294967296, cu = 1 / uu, hu = typeof TextDecoder == "undefined" ? null : new TextDecoder("utf-8");
      function pu(t2) {
        return t2.type === lu.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
      }
      function fu(t2, e2, r2) {
        return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
      }
      function du(t2, e2, r2) {
        var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
        r2.realloc(n2);
        for (var i2 = r2.pos - 1;i2 >= t2; i2--)
          r2.buf[i2 + n2] = r2.buf[i2];
      }
      function yu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeVarint(t2[r2]);
      }
      function mu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeSVarint(t2[r2]);
      }
      function gu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeFloat(t2[r2]);
      }
      function xu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeDouble(t2[r2]);
      }
      function vu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeBoolean(t2[r2]);
      }
      function bu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeFixed32(t2[r2]);
      }
      function wu(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeSFixed32(t2[r2]);
      }
      function _u(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeFixed64(t2[r2]);
      }
      function Au(t2, e2) {
        for (var r2 = 0;r2 < t2.length; r2++)
          e2.writeSFixed64(t2[r2]);
      }
      function Su(t2, e2) {
        return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
      }
      function ku(t2, e2, r2) {
        t2[r2] = e2, t2[r2 + 1] = e2 >>> 8, t2[r2 + 2] = e2 >>> 16, t2[r2 + 3] = e2 >>> 24;
      }
      function Mu(t2, e2) {
        return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
      }
      lu.prototype = {
        destroy: function() {
          this.buf = null;
        },
        readFields: function(t2, e2, r2) {
          for (r2 = r2 || this.length;this.pos < r2; ) {
            var n2 = this.readVarint(), i2 = n2 >> 3, s2 = this.pos;
            this.type = 7 & n2, t2(i2, e2, this), this.pos === s2 && this.skip(n2);
          }
          return e2;
        },
        readMessage: function(t2, e2) {
          return this.readFields(t2, e2, this.readVarint() + this.pos);
        },
        readFixed32: function() {
          var t2 = Su(this.buf, this.pos);
          return this.pos += 4, t2;
        },
        readSFixed32: function() {
          var t2 = Mu(this.buf, this.pos);
          return this.pos += 4, t2;
        },
        readFixed64: function() {
          var t2 = Su(this.buf, this.pos) + Su(this.buf, this.pos + 4) * uu;
          return this.pos += 8, t2;
        },
        readSFixed64: function() {
          var t2 = Su(this.buf, this.pos) + Mu(this.buf, this.pos + 4) * uu;
          return this.pos += 8, t2;
        },
        readFloat: function() {
          var t2 = au(this.buf, this.pos, true, 23, 4);
          return this.pos += 4, t2;
        },
        readDouble: function() {
          var t2 = au(this.buf, this.pos, true, 52, 8);
          return this.pos += 8, t2;
        },
        readVarint: function(t2) {
          var e2, r2, n2 = this.buf;
          return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t3, e3, r3) {
            var n3, i2, s2 = r3.buf;
            if (n3 = (112 & (i2 = s2[r3.pos++])) >> 4, i2 < 128)
              return fu(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 3, i2 < 128)
              return fu(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 10, i2 < 128)
              return fu(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 17, i2 < 128)
              return fu(t3, n3, e3);
            if (n3 |= (127 & (i2 = s2[r3.pos++])) << 24, i2 < 128)
              return fu(t3, n3, e3);
            if (n3 |= (1 & (i2 = s2[r3.pos++])) << 31, i2 < 128)
              return fu(t3, n3, e3);
            throw new Error("Expected varint not more than 10 bytes");
          }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
        },
        readVarint64: function() {
          return this.readVarint(true);
        },
        readSVarint: function() {
          var t2 = this.readVarint();
          return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
        },
        readBoolean: function() {
          return Boolean(this.readVarint());
        },
        readString: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.pos;
          return this.pos = t2, t2 - e2 >= 12 && hu ? function(t3, e3, r2) {
            return hu.decode(t3.subarray(e3, r2));
          }(this.buf, e2, t2) : function(t3, e3, r2) {
            for (var n2 = "", i2 = e3;i2 < r2; ) {
              var s2, a2, o2, l2 = t3[i2], u2 = null, c2 = l2 > 239 ? 4 : l2 > 223 ? 3 : l2 > 191 ? 2 : 1;
              if (i2 + c2 > r2)
                break;
              c2 === 1 ? l2 < 128 && (u2 = l2) : c2 === 2 ? (192 & (s2 = t3[i2 + 1])) == 128 && (u2 = (31 & l2) << 6 | 63 & s2) <= 127 && (u2 = null) : c2 === 3 ? (a2 = t3[i2 + 2], (192 & (s2 = t3[i2 + 1])) == 128 && (192 & a2) == 128 && ((u2 = (15 & l2) << 12 | (63 & s2) << 6 | 63 & a2) <= 2047 || u2 >= 55296 && u2 <= 57343) && (u2 = null)) : c2 === 4 && (a2 = t3[i2 + 2], o2 = t3[i2 + 3], (192 & (s2 = t3[i2 + 1])) == 128 && (192 & a2) == 128 && (192 & o2) == 128 && ((u2 = (15 & l2) << 18 | (63 & s2) << 12 | (63 & a2) << 6 | 63 & o2) <= 65535 || u2 >= 1114112) && (u2 = null)), u2 === null ? (u2 = 65533, c2 = 1) : u2 > 65535 && (u2 -= 65536, n2 += String.fromCharCode(u2 >>> 10 & 1023 | 55296), u2 = 56320 | 1023 & u2), n2 += String.fromCharCode(u2), i2 += c2;
            }
            return n2;
          }(this.buf, e2, t2);
        },
        readBytes: function() {
          var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
          return this.pos = t2, e2;
        },
        readPackedVarint: function(t2, e2) {
          if (this.type !== lu.Bytes)
            return t2.push(this.readVarint(e2));
          var r2 = pu(this);
          for (t2 = t2 || [];this.pos < r2; )
            t2.push(this.readVarint(e2));
          return t2;
        },
        readPackedSVarint: function(t2) {
          if (this.type !== lu.Bytes)
            return t2.push(this.readSVarint());
          var e2 = pu(this);
          for (t2 = t2 || [];this.pos < e2; )
            t2.push(this.readSVarint());
          return t2;
        },
        readPackedBoolean: function(t2) {
          if (this.type !== lu.Bytes)
            return t2.push(this.readBoolean());
          var e2 = pu(this);
          for (t2 = t2 || [];this.pos < e2; )
            t2.push(this.readBoolean());
          return t2;
        },
        readPackedFloat: function(t2) {
          if (this.type !== lu.Bytes)
            return t2.push(this.readFloat());
          var e2 = pu(this);
          for (t2 = t2 || [];this.pos < e2; )
            t2.push(this.readFloat());
          return t2;
        },
        readPackedDouble: function(t2) {
          if (this.type !== lu.Bytes)
            return t2.push(this.readDouble());
          var e2 = pu(this);
          for (t2 = t2 || [];this.pos < e2; )
            t2.push(this.readDouble());
          return t2;
        },
        readPackedFixed32: function(t2) {
          if (this.type !== lu.Bytes)
            return t2.push(this.readFixed32());
          var e2 = pu(this);
          for (t2 = t2 || [];this.pos < e2; )
            t2.push(this.readFixed32());
          return t2;
        },
        readPackedSFixed32: function(t2) {
          if (this.type !== lu.Bytes)
            return t2.push(this.readSFixed32());
          var e2 = pu(this);
          for (t2 = t2 || [];this.pos < e2; )
            t2.push(this.readSFixed32());
          return t2;
        },
        readPackedFixed64: function(t2) {
          if (this.type !== lu.Bytes)
            return t2.push(this.readFixed64());
          var e2 = pu(this);
          for (t2 = t2 || [];this.pos < e2; )
            t2.push(this.readFixed64());
          return t2;
        },
        readPackedSFixed64: function(t2) {
          if (this.type !== lu.Bytes)
            return t2.push(this.readSFixed64());
          var e2 = pu(this);
          for (t2 = t2 || [];this.pos < e2; )
            t2.push(this.readSFixed64());
          return t2;
        },
        skip: function(t2) {
          var e2 = 7 & t2;
          if (e2 === lu.Varint)
            for (;this.buf[this.pos++] > 127; )
              ;
          else if (e2 === lu.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (e2 === lu.Fixed32)
            this.pos += 4;
          else {
            if (e2 !== lu.Fixed64)
              throw new Error("Unimplemented type: " + e2);
            this.pos += 8;
          }
        },
        writeTag: function(t2, e2) {
          this.writeVarint(t2 << 3 | e2);
        },
        realloc: function(t2) {
          for (var e2 = this.length || 16;e2 < this.pos + t2; )
            e2 *= 2;
          if (e2 !== this.length) {
            var r2 = new Uint8Array(e2);
            r2.set(this.buf), this.buf = r2, this.length = e2;
          }
        },
        finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        },
        writeFixed32: function(t2) {
          this.realloc(4), ku(this.buf, t2, this.pos), this.pos += 4;
        },
        writeSFixed32: function(t2) {
          this.realloc(4), ku(this.buf, t2, this.pos), this.pos += 4;
        },
        writeFixed64: function(t2) {
          this.realloc(8), ku(this.buf, -1 & t2, this.pos), ku(this.buf, Math.floor(t2 * cu), this.pos + 4), this.pos += 8;
        },
        writeSFixed64: function(t2) {
          this.realloc(8), ku(this.buf, -1 & t2, this.pos), ku(this.buf, Math.floor(t2 * cu), this.pos + 4), this.pos += 8;
        },
        writeVarint: function(t2) {
          (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
            var r2, n2;
            if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552000 || t3 < -18446744073709552000)
              throw new Error("Given varint doesn't fit into 10 bytes");
            e2.realloc(10), function(t4, e3, r3) {
              r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
            }(r2, 0, e2), function(t4, e3) {
              var r3 = (7 & t4) << 4;
              e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
            }(n2, e2);
          }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
        },
        writeSVarint: function(t2) {
          this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
        },
        writeBoolean: function(t2) {
          this.writeVarint(Boolean(t2));
        },
        writeString: function(t2) {
          t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
          var e2 = this.pos;
          this.pos = function(t3, e3, r3) {
            for (var n2, i2, s2 = 0;s2 < e3.length; s2++) {
              if ((n2 = e3.charCodeAt(s2)) > 55295 && n2 < 57344) {
                if (!i2) {
                  n2 > 56319 || s2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                  continue;
                }
                if (n2 < 56320) {
                  t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                  continue;
                }
                n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
              } else
                i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
              n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
            }
            return r3;
          }(this.buf, t2, this.pos);
          var r2 = this.pos - e2;
          r2 >= 128 && du(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
        },
        writeFloat: function(t2) {
          this.realloc(4), ou(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
        },
        writeDouble: function(t2) {
          this.realloc(8), ou(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
        },
        writeBytes: function(t2) {
          var e2 = t2.length;
          this.writeVarint(e2), this.realloc(e2);
          for (var r2 = 0;r2 < e2; r2++)
            this.buf[this.pos++] = t2[r2];
        },
        writeRawMessage: function(t2, e2) {
          this.pos++;
          var r2 = this.pos;
          t2(e2, this);
          var n2 = this.pos - r2;
          n2 >= 128 && du(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
        },
        writeMessage: function(t2, e2, r2) {
          this.writeTag(t2, lu.Bytes), this.writeRawMessage(e2, r2);
        },
        writePackedVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, yu, e2);
        },
        writePackedSVarint: function(t2, e2) {
          e2.length && this.writeMessage(t2, mu, e2);
        },
        writePackedBoolean: function(t2, e2) {
          e2.length && this.writeMessage(t2, vu, e2);
        },
        writePackedFloat: function(t2, e2) {
          e2.length && this.writeMessage(t2, gu, e2);
        },
        writePackedDouble: function(t2, e2) {
          e2.length && this.writeMessage(t2, xu, e2);
        },
        writePackedFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, bu, e2);
        },
        writePackedSFixed32: function(t2, e2) {
          e2.length && this.writeMessage(t2, wu, e2);
        },
        writePackedFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, _u, e2);
        },
        writePackedSFixed64: function(t2, e2) {
          e2.length && this.writeMessage(t2, Au, e2);
        },
        writeBytesField: function(t2, e2) {
          this.writeTag(t2, lu.Bytes), this.writeBytes(e2);
        },
        writeFixed32Field: function(t2, e2) {
          this.writeTag(t2, lu.Fixed32), this.writeFixed32(e2);
        },
        writeSFixed32Field: function(t2, e2) {
          this.writeTag(t2, lu.Fixed32), this.writeSFixed32(e2);
        },
        writeFixed64Field: function(t2, e2) {
          this.writeTag(t2, lu.Fixed64), this.writeFixed64(e2);
        },
        writeSFixed64Field: function(t2, e2) {
          this.writeTag(t2, lu.Fixed64), this.writeSFixed64(e2);
        },
        writeVarintField: function(t2, e2) {
          this.writeTag(t2, lu.Varint), this.writeVarint(e2);
        },
        writeSVarintField: function(t2, e2) {
          this.writeTag(t2, lu.Varint), this.writeSVarint(e2);
        },
        writeStringField: function(t2, e2) {
          this.writeTag(t2, lu.Bytes), this.writeString(e2);
        },
        writeFloatField: function(t2, e2) {
          this.writeTag(t2, lu.Fixed32), this.writeFloat(e2);
        },
        writeDoubleField: function(t2, e2) {
          this.writeTag(t2, lu.Fixed64), this.writeDouble(e2);
        },
        writeBooleanField: function(t2, e2) {
          this.writeVarintField(t2, Boolean(e2));
        }
      };
      var Iu = r(su);
      const zu = 3;
      function Pu(t2, e2, r2) {
        t2 === 1 && r2.readMessage(Cu, e2);
      }
      function Cu(t2, e2, r2) {
        if (t2 === 3) {
          const {
            id: t3,
            bitmap: n2,
            width: i2,
            height: s2,
            left: a2,
            top: o2,
            advance: l2
          } = r2.readMessage(Bu, {});
          e2.push({
            id: t3,
            bitmap: new _o({ width: i2 + 2 * zu, height: s2 + 2 * zu }, n2),
            metrics: { width: i2, height: s2, left: a2, top: o2, advance: l2 }
          });
        }
      }
      function Bu(t2, e2, r2) {
        t2 === 1 ? e2.id = r2.readVarint() : t2 === 2 ? e2.bitmap = r2.readBytes() : t2 === 3 ? e2.width = r2.readVarint() : t2 === 4 ? e2.height = r2.readVarint() : t2 === 5 ? e2.left = r2.readSVarint() : t2 === 6 ? e2.top = r2.readSVarint() : t2 === 7 && (e2.advance = r2.readVarint());
      }
      const Vu = zu;
      function Eu(t2) {
        let e2 = 0, r2 = 0;
        for (const n3 of t2)
          e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
        t2.sort((t3, e3) => e3.h - t3.h);
        const n2 = [
          { x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }
        ];
        let i2 = 0, s2 = 0;
        for (const e3 of t2)
          for (let t3 = n2.length - 1;t3 >= 0; t3--) {
            const r3 = n2[t3];
            if (!(e3.w > r3.w || e3.h > r3.h)) {
              if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                const e4 = n2.pop();
                t3 < n2.length && (n2[t3] = e4);
              } else
                e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
              break;
            }
          }
        return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
      }
      const Fu = 1;

      class Tu {
        constructor(t2, {
          pixelRatio: e2,
          version: r2,
          stretchX: n2,
          stretchY: i2,
          content: s2,
          textFitWidth: a2,
          textFitHeight: o2
        }) {
          this.paddedRect = t2, this.pixelRatio = e2, this.stretchX = n2, this.stretchY = i2, this.content = s2, this.version = r2, this.textFitWidth = a2, this.textFitHeight = o2;
        }
        get tl() {
          return [this.paddedRect.x + Fu, this.paddedRect.y + Fu];
        }
        get br() {
          return [
            this.paddedRect.x + this.paddedRect.w - Fu,
            this.paddedRect.y + this.paddedRect.h - Fu
          ];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [
            (this.paddedRect.w - 2 * Fu) / this.pixelRatio,
            (this.paddedRect.h - 2 * Fu) / this.pixelRatio
          ];
        }
      }

      class $u {
        constructor(t2, e2) {
          const r2 = {}, n2 = {};
          this.haveRenderCallbacks = [];
          const i2 = [];
          this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
          const { w: s2, h: a2 } = Eu(i2), o2 = new Ao({ width: s2 || 1, height: a2 || 1 });
          for (const e3 in t2) {
            const n3 = t2[e3], i3 = r2[e3].paddedRect;
            Ao.copy(n3.data, o2, { x: 0, y: 0 }, { x: i3.x + Fu, y: i3.y + Fu }, n3.data);
          }
          for (const t3 in e2) {
            const r3 = e2[t3], i3 = n2[t3].paddedRect, s3 = i3.x + Fu, a3 = i3.y + Fu, l2 = r3.data.width, u2 = r3.data.height;
            Ao.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 }, r3.data), Ao.copy(r3.data, o2, { x: 0, y: u2 - 1 }, { x: s3, y: a3 - 1 }, { width: l2, height: 1 }), Ao.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3, y: a3 + u2 }, { width: l2, height: 1 }), Ao.copy(r3.data, o2, { x: l2 - 1, y: 0 }, { x: s3 - 1, y: a3 }, { width: 1, height: u2 }), Ao.copy(r3.data, o2, { x: 0, y: 0 }, { x: s3 + l2, y: a3 }, { width: 1, height: u2 });
          }
          this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
        }
        addImages(t2, e2, r2) {
          for (const n2 in t2) {
            const i2 = t2[n2], s2 = { x: 0, y: 0, w: i2.data.width + 2 * Fu, h: i2.data.height + 2 * Fu };
            r2.push(s2), e2[n2] = new Tu(s2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
          }
        }
        patchUpdatedImages(t2, e2) {
          t2.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const r2 in t2.updatedImages)
            this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
        }
        patchUpdatedImage(t2, e2, r2) {
          if (!t2 || !e2)
            return;
          if (t2.version === e2.version)
            return;
          t2.version = e2.version;
          const [n2, i2] = t2.tl;
          r2.update(e2.data, undefined, { x: n2, y: i2 });
        }
      }
      var Lu;
      wi("ImagePosition", Tu), wi("ImageAtlas", $u), t.ah = undefined, (Lu = t.ah || (t.ah = {}))[Lu.none = 0] = "none", Lu[Lu.horizontal = 1] = "horizontal", Lu[Lu.vertical = 2] = "vertical", Lu[Lu.horizontalOnly = 3] = "horizontalOnly";
      const Du = -17;

      class Ou {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null;
        }
        static forText(t2, e2) {
          const r2 = new Ou;
          return r2.scale = t2 || 1, r2.fontStack = e2, r2;
        }
        static forImage(t2) {
          const e2 = new Ou;
          return e2.imageName = t2, e2;
        }
      }

      class ju {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(t2, e2) {
          const r2 = new ju;
          for (let n2 = 0;n2 < t2.sections.length; n2++) {
            const i2 = t2.sections[n2];
            i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
          }
          return r2;
        }
        length() {
          return this.text.length;
        }
        getSection(t2) {
          return this.sections[this.sectionIndex[t2]];
        }
        getSectionIndex(t2) {
          return this.sectionIndex[t2];
        }
        getCharCode(t2) {
          return this.text.charCodeAt(t2);
        }
        verticalizePunctuation() {
          this.text = function(t2) {
            let e2 = "";
            for (let r2 = 0;r2 < t2.length; r2++) {
              const n2 = t2.charCodeAt(r2 + 1) || null, i2 = t2.charCodeAt(r2 - 1) || null;
              e2 += n2 && $i(n2) && !nu[t2[r2 + 1]] || i2 && $i(i2) && !nu[t2[r2 - 1]] || !nu[t2[r2]] ? t2[r2] : nu[t2[r2]];
            }
            return e2;
          }(this.text);
        }
        trim() {
          let t2 = 0;
          for (let e3 = 0;e3 < this.text.length && Uu[this.text.charCodeAt(e3)]; e3++)
            t2++;
          let e2 = this.text.length;
          for (let r2 = this.text.length - 1;r2 >= 0 && r2 >= t2 && Uu[this.text.charCodeAt(r2)]; r2--)
            e2--;
          this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
        }
        substring(t2, e2) {
          const r2 = new ju;
          return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
        }
        addTextSection(t2, e2) {
          this.text += t2.text, this.sections.push(Ou.forText(t2.scale, t2.fontStack || e2));
          const r2 = this.sections.length - 1;
          for (let e3 = 0;e3 < t2.text.length; ++e3)
            this.sectionIndex.push(r2);
        }
        addImageSection(t2) {
          const e2 = t2.image ? t2.image.name : "";
          if (e2.length === 0)
            return void A("Can't add FormattedSection with an empty image.");
          const r2 = this.getNextImageSectionCharCode();
          r2 ? (this.text += String.fromCharCode(r2), this.sections.push(Ou.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : A("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function Ru(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2) {
        const m2 = ju.fromFeature(e2, s2);
        let g2;
        p2 === t.ah.vertical && m2.verticalizePunctuation();
        const { processBidirectionalText: x2, processStyledBidirectionalText: v2 } = Ri;
        if (x2 && m2.sections.length === 1) {
          g2 = [];
          const t2 = x2(m2.toString(), Yu(m2, c2, a2, r2, i2, d2));
          for (const e3 of t2) {
            const t3 = new ju;
            t3.text = e3, t3.sections = m2.sections;
            for (let r3 = 0;r3 < e3.length; r3++)
              t3.sectionIndex.push(0);
            g2.push(t3);
          }
        } else if (v2) {
          g2 = [];
          const t2 = v2(m2.text, m2.sectionIndex, Yu(m2, c2, a2, r2, i2, d2));
          for (const e3 of t2) {
            const t3 = new ju;
            t3.text = e3[0], t3.sectionIndex = e3[1], t3.sections = m2.sections, g2.push(t3);
          }
        } else
          g2 = function(t2, e3) {
            const r3 = [], n3 = t2.text;
            let i3 = 0;
            for (const n4 of e3)
              r3.push(t2.substring(i3, n4)), i3 = n4;
            return i3 < n3.length && r3.push(t2.substring(i3, n3.length)), r3;
          }(m2, Yu(m2, c2, a2, r2, i2, d2));
        const b2 = [], w2 = {
          positionedLines: b2,
          text: m2.toString(),
          top: h2[1],
          bottom: h2[1],
          left: h2[0],
          right: h2[0],
          writingMode: p2,
          iconsInText: false,
          verticalizable: false
        };
        return function(e3, r3, n3, i3, s3, a3, o3, l3, u3, c3, h3, p3) {
          let f3 = 0, d3 = Du, y3 = 0, m3 = 0;
          const g3 = l3 === "right" ? 1 : l3 === "left" ? 0 : 0.5;
          let x3 = 0;
          for (const o4 of s3) {
            o4.trim();
            const s4 = o4.getMaxScale(), l4 = (s4 - 1) * iu, b4 = { positionedGlyphs: [], lineOffset: 0 };
            e3.positionedLines[x3] = b4;
            const w4 = b4.positionedGlyphs;
            let _3 = 0;
            if (!o4.length()) {
              d3 += a3, ++x3;
              continue;
            }
            for (let a4 = 0;a4 < o4.length(); a4++) {
              const y4 = o4.getSection(a4), m4 = o4.getSectionIndex(a4), g4 = o4.getCharCode(a4);
              let x4 = 0, b5 = null, A3 = null, S2 = null, k2 = iu;
              const M2 = !(u3 === t.ah.horizontal || !h3 && !Ti(g4) || h3 && (Uu[g4] || (v3 = g4, /\p{sc=Arab}/u.test(String.fromCodePoint(v3)))));
              if (y4.imageName) {
                const t2 = i3[y4.imageName];
                if (!t2)
                  continue;
                S2 = y4.imageName, e3.iconsInText = e3.iconsInText || true, A3 = t2.paddedRect;
                const r4 = t2.displaySize;
                y4.scale = y4.scale * iu / p3, b5 = {
                  width: r4[0],
                  height: r4[1],
                  left: Fu,
                  top: -Vu,
                  advance: M2 ? r4[1] : r4[0]
                }, x4 = l4 + (iu - r4[1] * y4.scale), k2 = b5.advance;
                const n4 = M2 ? r4[0] * y4.scale - iu * s4 : r4[1] * y4.scale - iu * s4;
                n4 > 0 && n4 > _3 && (_3 = n4);
              } else {
                const t2 = n3[y4.fontStack], e4 = t2 && t2[g4];
                if (e4 && e4.rect)
                  A3 = e4.rect, b5 = e4.metrics;
                else {
                  const t3 = r3[y4.fontStack], e5 = t3 && t3[g4];
                  if (!e5)
                    continue;
                  b5 = e5.metrics;
                }
                x4 = (s4 - y4.scale) * iu;
              }
              M2 ? (e3.verticalizable = true, w4.push({
                glyph: g4,
                imageName: S2,
                x: f3,
                y: d3 + x4,
                vertical: M2,
                scale: y4.scale,
                fontStack: y4.fontStack,
                sectionIndex: m4,
                metrics: b5,
                rect: A3
              }), f3 += k2 * y4.scale + c3) : (w4.push({
                glyph: g4,
                imageName: S2,
                x: f3,
                y: d3 + x4,
                vertical: M2,
                scale: y4.scale,
                fontStack: y4.fontStack,
                sectionIndex: m4,
                metrics: b5,
                rect: A3
              }), f3 += b5.advance * y4.scale + c3);
            }
            w4.length !== 0 && (y3 = Math.max(f3 - c3, y3), Wu(w4, 0, w4.length - 1, g3, _3)), f3 = 0;
            const A2 = a3 * s4 + _3;
            b4.lineOffset = Math.max(_3, l4), d3 += A2, m3 = Math.max(A2, m3), ++x3;
          }
          var v3;
          const b3 = d3 - Du, { horizontalAlign: w3, verticalAlign: _2 } = Ju(o3);
          (function(t2, e4, r4, n4, i4, s4, a4, o4, l4) {
            const u4 = (e4 - r4) * i4;
            let c4 = 0;
            c4 = s4 !== a4 ? -o4 * n4 - Du : (-n4 * l4 + 0.5) * a4;
            for (const e5 of t2)
              for (const t3 of e5.positionedGlyphs)
                t3.x += u4, t3.y += c4;
          })(e3.positionedLines, g3, w3, _2, y3, m3, a3, b3, s3.length), e3.top += -_2 * b3, e3.bottom = e3.top + b3, e3.left += -w3 * y3, e3.right = e3.left + y3;
        }(w2, r2, n2, i2, g2, o2, l2, u2, p2, c2, f2, y2), !function(t2) {
          for (const e3 of t2)
            if (e3.positionedGlyphs.length !== 0)
              return false;
          return true;
        }(b2) && w2;
      }
      const Uu = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, qu = {
        10: true,
        32: true,
        38: true,
        41: true,
        43: true,
        45: true,
        47: true,
        173: true,
        183: true,
        8203: true,
        8208: true,
        8211: true,
        8231: true
      }, Nu = { 40: true };
      function Zu(t2, e2, r2, n2, i2, s2) {
        if (e2.imageName) {
          const t3 = n2[e2.imageName];
          return t3 ? t3.displaySize[0] * e2.scale * iu / s2 + i2 : 0;
        }
        {
          const n3 = r2[e2.fontStack], s3 = n3 && n3[t2];
          return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
        }
      }
      function Gu(t2, e2, r2, n2) {
        const i2 = Math.pow(t2 - e2, 2);
        return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
      }
      function Ku(t2, e2, r2) {
        let n2 = 0;
        return t2 === 10 && (n2 -= 1e4), r2 && (n2 += 150), t2 !== 40 && t2 !== 65288 || (n2 += 50), e2 !== 41 && e2 !== 65289 || (n2 += 50), n2;
      }
      function Xu(t2, e2, r2, n2, i2, s2) {
        let a2 = null, o2 = Gu(e2, r2, i2, s2);
        for (const t3 of n2) {
          const n3 = Gu(e2 - t3.x, r2, i2, s2) + t3.badness;
          n3 <= o2 && (a2 = t3, o2 = n3);
        }
        return { index: t2, x: e2, priorBreak: a2, badness: o2 };
      }
      function Hu(t2) {
        return t2 ? Hu(t2.priorBreak).concat(t2.index) : [];
      }
      function Yu(t2, e2, r2, n2, i2, s2) {
        if (!t2)
          return [];
        const a2 = [], o2 = function(t3, e3, r3, n3, i3, s3) {
          let a3 = 0;
          for (let r4 = 0;r4 < t3.length(); r4++) {
            const o3 = t3.getSection(r4);
            a3 += Zu(t3.getCharCode(r4), o3, n3, i3, e3, s3);
          }
          return a3 / Math.max(1, Math.ceil(a3 / r3));
        }(t2, e2, r2, n2, i2, s2), l2 = t2.text.indexOf("​") >= 0;
        let u2 = 0;
        for (let r3 = 0;r3 < t2.length(); r3++) {
          const h2 = t2.getSection(r3), p2 = t2.getCharCode(r3);
          if (Uu[p2] || (u2 += Zu(p2, h2, n2, i2, e2, s2)), r3 < t2.length() - 1) {
            const e3 = !((c2 = p2) < 11904) && (!!zi["CJK Compatibility Forms"](c2) || !!zi["CJK Compatibility"](c2) || !!zi["CJK Strokes"](c2) || !!zi["CJK Symbols and Punctuation"](c2) || !!zi["Enclosed CJK Letters and Months"](c2) || !!zi["Halfwidth and Fullwidth Forms"](c2) || !!zi["Ideographic Description Characters"](c2) || !!zi["Vertical Forms"](c2) || Fi.test(String.fromCodePoint(c2)));
            (qu[p2] || e3 || h2.imageName || r3 !== t2.length() - 2 && Nu[t2.getCharCode(r3 + 1)]) && a2.push(Xu(r3 + 1, u2, o2, a2, Ku(p2, t2.getCharCode(r3 + 1), e3 && l2), false));
          }
        }
        var c2;
        return Hu(Xu(t2.length(), u2, o2, a2, 0, true));
      }
      function Ju(t2) {
        let e2 = 0.5, r2 = 0.5;
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            e2 = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            e2 = 0;
        }
        switch (t2) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            r2 = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            r2 = 0;
        }
        return { horizontalAlign: e2, verticalAlign: r2 };
      }
      function Wu(t2, e2, r2, n2, i2) {
        if (!n2 && !i2)
          return;
        const s2 = t2[r2], a2 = (t2[r2].x + s2.metrics.advance * s2.scale) * n2;
        for (let n3 = e2;n3 <= r2; n3++)
          t2[n3].x -= a2, t2[n3].y += i2;
      }
      function Qu(t2, e2, r2) {
        const { horizontalAlign: n2, verticalAlign: i2 } = Ju(r2), s2 = e2[0] - t2.displaySize[0] * n2, a2 = e2[1] - t2.displaySize[1] * i2;
        return {
          image: t2,
          top: a2,
          bottom: a2 + t2.displaySize[1],
          left: s2,
          right: s2 + t2.displaySize[0]
        };
      }
      function tc(t2) {
        var e2, r2;
        let { left: n2, top: i2 } = t2, s2 = t2.right - n2, a2 = t2.bottom - i2;
        const o2 = (e2 = t2.image.textFitWidth) !== null && e2 !== undefined ? e2 : "stretchOrShrink", l2 = (r2 = t2.image.textFitHeight) !== null && r2 !== undefined ? r2 : "stretchOrShrink", u2 = (t2.image.content[2] - t2.image.content[0]) / (t2.image.content[3] - t2.image.content[1]);
        if (l2 === "proportional") {
          if (o2 === "stretchOnly" && s2 / a2 < u2 || o2 === "proportional") {
            const t3 = Math.ceil(a2 * u2);
            n2 *= t3 / s2, s2 = t3;
          }
        } else if (o2 === "proportional" && l2 === "stretchOnly" && u2 !== 0 && s2 / a2 > u2) {
          const t3 = Math.ceil(s2 / u2);
          i2 *= t3 / a2, a2 = t3;
        }
        return { x1: n2, y1: i2, x2: n2 + s2, y2: i2 + a2 };
      }
      function ec(t2, e2, r2, n2, i2, s2) {
        const a2 = t2.image;
        let o2;
        if (a2.content) {
          const t3 = a2.content, e3 = a2.pixelRatio || 1;
          o2 = [
            t3[0] / e3,
            t3[1] / e3,
            a2.displaySize[0] - t3[2] / e3,
            a2.displaySize[1] - t3[3] / e3
          ];
        }
        const l2 = e2.left * s2, u2 = e2.right * s2;
        let c2, h2, p2, f2;
        r2 === "width" || r2 === "both" ? (f2 = i2[0] + l2 - n2[3], h2 = i2[0] + u2 + n2[1]) : (f2 = i2[0] + (l2 + u2 - a2.displaySize[0]) / 2, h2 = f2 + a2.displaySize[0]);
        const d2 = e2.top * s2, y2 = e2.bottom * s2;
        return r2 === "height" || r2 === "both" ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + y2 + n2[2]) : (c2 = i2[1] + (d2 + y2 - a2.displaySize[1]) / 2, p2 = c2 + a2.displaySize[1]), { image: a2, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: o2 };
      }
      const rc = 255, nc = 128, ic = rc * nc;
      function sc(t2, e2) {
        const { expression: r2 } = e2;
        if (r2.kind === "constant")
          return { kind: "constant", layoutSize: r2.evaluate(new Ui(t2 + 1)) };
        if (r2.kind === "source")
          return { kind: "source" };
        {
          const { zoomStops: e3, interpolationType: n2 } = r2;
          let i2 = 0;
          for (;i2 < e3.length && e3[i2] <= t2; )
            i2++;
          i2 = Math.max(0, i2 - 1);
          let s2 = i2;
          for (;s2 < e3.length && e3[s2] < t2 + 1; )
            s2++;
          s2 = Math.min(e3.length - 1, s2);
          const a2 = e3[i2], o2 = e3[s2];
          return r2.kind === "composite" ? { kind: "composite", minZoom: a2, maxZoom: o2, interpolationType: n2 } : {
            kind: "camera",
            minZoom: a2,
            maxZoom: o2,
            minSize: r2.evaluate(new Ui(a2)),
            maxSize: r2.evaluate(new Ui(o2)),
            interpolationType: n2
          };
        }
      }
      function ac(t2, e2, r2) {
        let n2 = "never";
        const i2 = t2.get(e2);
        return i2 ? n2 = i2 : t2.get(r2) && (n2 = "always"), n2;
      }
      const oc = fl.VectorTileFeature.types, lc = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function uc(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
        const f2 = o2 ? Math.min(ic, Math.round(o2[0])) : 0, d2 = o2 ? Math.min(ic, Math.round(o2[1])) : 0;
        t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, a2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u2, 16 * c2, 256 * h2, 256 * p2);
      }
      function cc(t2, e2, r2) {
        t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2);
      }
      function hc(t2) {
        for (const e2 of t2.sections)
          if (ji(e2.text))
            return true;
        return false;
      }

      class pc {
        constructor(t2) {
          this.layoutVertexArray = new Ws, this.indexArray = new na, this.programConfigurations = t2, this.segments = new oa, this.dynamicLayoutVertexArray = new Qs, this.opacityVertexArray = new ta, this.hasVisibleVertices = false, this.placedSymbolArray = new $s;
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(t2, e2, r2, n2) {
          this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Jl.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, Wl.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, lc, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      wi("SymbolBuffers", pc);

      class fc {
        constructor(t2, e2, r2) {
          this.layoutVertexArray = new t2, this.layoutAttributes = e2, this.indexArray = new r2, this.segments = new oa, this.collisionVertexArray = new ra;
        }
        upload(t2) {
          this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Ql.members, true);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      wi("CollisionBuffers", fc);

      class dc {
        constructor(e2) {
          this.collisionBoxArray = e2.collisionBoxArray, this.zoom = e2.zoom, this.overscaling = e2.overscaling, this.layers = e2.layers, this.layerIds = this.layers.map((t2) => t2.id), this.index = e2.index, this.pixelRatio = e2.pixelRatio, this.sourceLayerIndex = e2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = lo([]), this.placementViewportMatrix = lo([]);
          const r2 = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = sc(this.zoom, r2["text-size"]), this.iconSizeData = sc(this.zoom, r2["icon-size"]);
          const n2 = this.layers[0].layout, i2 = n2.get("symbol-sort-key"), s2 = n2.get("symbol-z-order");
          this.canOverlap = ac(n2, "text-overlap", "text-allow-overlap") !== "never" || ac(n2, "icon-overlap", "icon-allow-overlap") !== "never" || n2.get("text-ignore-placement") || n2.get("icon-ignore-placement"), this.sortFeaturesByKey = s2 !== "viewport-y" && !i2.isConstant(), this.sortFeaturesByY = (s2 === "viewport-y" || s2 === "auto" && !this.sortFeaturesByKey) && this.canOverlap, n2.get("symbol-placement") === "point" && (this.writingModes = n2.get("text-writing-mode").map((e3) => t.ah[e3])), this.stateDependentLayerIds = this.layers.filter((t2) => t2.isStateDependent()).map((t2) => t2.id), this.sourceID = e2.sourceID;
        }
        createArrays() {
          this.text = new pc(new Ea(this.layers, this.zoom, (t2) => /^text/.test(t2))), this.icon = new pc(new Ea(this.layers, this.zoom, (t2) => /^icon/.test(t2))), this.glyphOffsetArray = new Os, this.lineVertexArray = new js, this.symbolInstances = new Ds, this.textAnchorOffsets = new Us;
        }
        calculateGlyphDependencies(t2, e2, r2, n2, i2) {
          for (let s2 = 0;s2 < t2.length; s2++)
            if (e2[t2.charCodeAt(s2)] = true, (r2 || n2) && i2) {
              const r3 = nu[t2.charAt(s2)];
              r3 && (e2[r3.charCodeAt(0)] = true);
            }
        }
        populate(e2, r2, n2) {
          const i2 = this.layers[0], s2 = i2.layout, a2 = s2.get("text-font"), o2 = s2.get("text-field"), l2 = s2.get("icon-image"), u2 = (o2.value.kind !== "constant" || o2.value.value instanceof Yt && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && (a2.value.kind !== "constant" || a2.value.value.length > 0), c2 = l2.value.kind !== "constant" || !!l2.value.value || Object.keys(l2.parameters).length > 0, h2 = s2.get("symbol-sort-key");
          if (this.features = [], !u2 && !c2)
            return;
          const { iconDependencies: p2, glyphDependencies: f2, availableImages: d2 } = r2, y2 = new Ui(this.zoom);
          for (const { feature: r3, id: o3, index: l3, sourceLayerIndex: m2 } of e2) {
            const e3 = i2._featureFilter.needGeometry, g2 = ja(r3, e3);
            if (!i2._featureFilter.filter(y2, g2, n2))
              continue;
            let x2, v2;
            if (e3 || (g2.geometry = Oa(r3)), u2) {
              const t2 = i2.getValueAndResolveTokens("text-field", g2, n2, d2), e4 = Yt.factory(t2), r4 = this.hasRTLText = this.hasRTLText || hc(e4);
              (!r4 || Ri.getRTLTextPluginStatus() === "unavailable" || r4 && Ri.isParsed()) && (x2 = ru(e4, i2, g2));
            }
            if (c2) {
              const t2 = i2.getValueAndResolveTokens("icon-image", g2, n2, d2);
              v2 = t2 instanceof te ? t2 : te.fromString(t2);
            }
            if (!x2 && !v2)
              continue;
            const b2 = this.sortFeaturesByKey ? h2.evaluate(g2, {}, n2) : undefined;
            if (this.features.push({
              id: o3,
              text: x2,
              icon: v2,
              index: l3,
              sourceLayerIndex: m2,
              geometry: g2.geometry,
              properties: r3.properties,
              type: oc[r3.type],
              sortKey: b2
            }), v2 && (p2[v2.name] = true), x2) {
              const e4 = a2.evaluate(g2, {}, n2).join(","), r4 = s2.get("text-rotation-alignment") !== "viewport" && s2.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t.ah.vertical) >= 0;
              for (const t2 of x2.sections)
                if (t2.image)
                  p2[t2.image.name] = true;
                else {
                  const n3 = Pi(x2.toString()), i3 = t2.fontStack || e4, s3 = f2[i3] = f2[i3] || {};
                  this.calculateGlyphDependencies(t2.text, s3, r4, this.allowVerticalPlacement, n3);
                }
            }
          }
          s2.get("symbol-placement") === "line" && (this.features = function(t2) {
            const e3 = {}, r3 = {}, n3 = [];
            let i3 = 0;
            function s3(e4) {
              n3.push(t2[e4]), i3++;
            }
            function a3(t3, e4, i4) {
              const s4 = r3[t3];
              return delete r3[t3], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
            }
            function o3(t3, r4, i4) {
              const s4 = e3[r4];
              return delete e3[r4], e3[t3] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
            }
            function l3(t3, e4, r4) {
              const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
              return `${t3}:${n4.x}:${n4.y}`;
            }
            for (let u3 = 0;u3 < t2.length; u3++) {
              const c3 = t2[u3], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
              if (!p3) {
                s3(u3);
                continue;
              }
              const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
              if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                const t3 = o3(f3, d3, h3), i4 = a3(f3, d3, n3[t3].geometry);
                delete e3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t3].geometry = null;
              } else
                f3 in r3 ? a3(f3, d3, h3) : (d3 in e3) ? o3(f3, d3, h3) : (s3(u3), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
            }
            return n3.filter((t3) => t3.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((t2, e3) => t2.sortKey - e3.sortKey);
        }
        update(t2, e2, r2) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t2) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t2, e2) {
          const r2 = this.lineVertexArray.length;
          if (t2.segment !== undefined) {
            let r3 = t2.dist(e2[t2.segment + 1]), n2 = t2.dist(e2[t2.segment]);
            const i2 = {};
            for (let n3 = t2.segment + 1;n3 < e2.length; n3++)
              i2[n3] = { x: e2[n3].x, y: e2[n3].y, tileUnitDistanceFromAnchor: r3 }, n3 < e2.length - 1 && (r3 += e2[n3 + 1].dist(e2[n3]));
            for (let r4 = t2.segment || 0;r4 >= 0; r4--)
              i2[r4] = { x: e2[r4].x, y: e2[r4].y, tileUnitDistanceFromAnchor: n2 }, r4 > 0 && (n2 += e2[r4 - 1].dist(e2[r4]));
            for (let t3 = 0;t3 < e2.length; t3++) {
              const e3 = i2[t3];
              this.lineVertexArray.emplaceBack(e3.x, e3.y, e3.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
        }
        addSymbols(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2, p2) {
          const { indexArray: f2, layoutVertexArray: d2 } = e2, y2 = e2.segments.prepareSegment(4 * r2.length, d2, f2, this.canOverlap ? a2.sortKey : undefined), m2 = this.glyphOffsetArray.length, g2 = y2.vertexLength, x2 = this.allowVerticalPlacement && o2 === t.ah.vertical ? Math.PI / 2 : 0, v2 = a2.text && a2.text.sections;
          for (let t2 = 0;t2 < r2.length; t2++) {
            const {
              tl: i3,
              tr: s3,
              bl: o3,
              br: u3,
              tex: c3,
              pixelOffsetTL: h3,
              pixelOffsetBR: m3,
              minFontScaleX: g3,
              minFontScaleY: b2,
              glyphOffset: w2,
              isSDF: _2,
              sectionIndex: A2
            } = r2[t2], S2 = y2.vertexLength, k2 = w2[1];
            uc(d2, l2.x, l2.y, i3.x, k2 + i3.y, c3.x, c3.y, n2, _2, h3.x, h3.y, g3, b2), uc(d2, l2.x, l2.y, s3.x, k2 + s3.y, c3.x + c3.w, c3.y, n2, _2, m3.x, h3.y, g3, b2), uc(d2, l2.x, l2.y, o3.x, k2 + o3.y, c3.x, c3.y + c3.h, n2, _2, h3.x, m3.y, g3, b2), uc(d2, l2.x, l2.y, u3.x, k2 + u3.y, c3.x + c3.w, c3.y + c3.h, n2, _2, m3.x, m3.y, g3, b2), cc(e2.dynamicLayoutVertexArray, l2, x2), f2.emplaceBack(S2, S2 + 1, S2 + 2), f2.emplaceBack(S2 + 1, S2 + 2, S2 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w2[0]), t2 !== r2.length - 1 && A2 === r2[t2 + 1].sectionIndex || e2.programConfigurations.populatePaintArrays(d2.length, a2, a2.index, {}, p2, v2 && v2[A2]);
          }
          e2.placedSymbolArray.emplaceBack(l2.x, l2.y, m2, this.glyphOffsetArray.length - m2, g2, u2, c2, l2.segment, n2 ? n2[0] : 0, n2 ? n2[1] : 0, i2[0], i2[1], o2, 0, false, 0, h2);
        }
        _addCollisionDebugVertex(t2, e2, r2, n2, i2, s2) {
          return e2.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(s2.x), Math.round(s2.y));
        }
        addCollisionDebugVertices(t2, e2, r2, n2, i2, a2, o2) {
          const l2 = i2.segments.prepareSegment(4, i2.layoutVertexArray, i2.indexArray), u2 = l2.vertexLength, c2 = i2.layoutVertexArray, h2 = i2.collisionVertexArray, p2 = o2.anchorX, f2 = o2.anchorY;
          this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(t2, e2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(r2, e2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(r2, n2)), this._addCollisionDebugVertex(c2, h2, a2, p2, f2, new s(t2, n2)), l2.vertexLength += 4;
          const d2 = i2.indexArray;
          d2.emplaceBack(u2, u2 + 1), d2.emplaceBack(u2 + 1, u2 + 2), d2.emplaceBack(u2 + 2, u2 + 3), d2.emplaceBack(u2 + 3, u2), l2.primitiveLength += 4;
        }
        addDebugCollisionBoxes(t2, e2, r2, n2) {
          for (let i2 = t2;i2 < e2; i2++) {
            const t3 = this.collisionBoxArray.get(i2);
            this.addCollisionDebugVertices(t3.x1, t3.y1, t3.x2, t3.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, t3.anchorPoint, r2);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new fc(ea, tu.members, ia), this.iconCollisionBox = new fc(ea, tu.members, ia);
          for (let t2 = 0;t2 < this.symbolInstances.length; t2++) {
            const e2 = this.symbolInstances.get(t2);
            this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
          }
        }
        _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
          const u2 = {};
          for (let n3 = e2;n3 < r2; n3++) {
            const e3 = t2.get(n3);
            u2.textBox = {
              x1: e3.x1,
              y1: e3.y1,
              x2: e3.x2,
              y2: e3.y2,
              anchorPointX: e3.anchorPointX,
              anchorPointY: e3.anchorPointY
            }, u2.textFeatureIndex = e3.featureIndex;
            break;
          }
          for (let e3 = n2;e3 < i2; e3++) {
            const r3 = t2.get(e3);
            u2.verticalTextBox = {
              x1: r3.x1,
              y1: r3.y1,
              x2: r3.x2,
              y2: r3.y2,
              anchorPointX: r3.anchorPointX,
              anchorPointY: r3.anchorPointY
            }, u2.verticalTextFeatureIndex = r3.featureIndex;
            break;
          }
          for (let e3 = s2;e3 < a2; e3++) {
            const r3 = t2.get(e3);
            u2.iconBox = {
              x1: r3.x1,
              y1: r3.y1,
              x2: r3.x2,
              y2: r3.y2,
              anchorPointX: r3.anchorPointX,
              anchorPointY: r3.anchorPointY
            }, u2.iconFeatureIndex = r3.featureIndex;
            break;
          }
          for (let e3 = o2;e3 < l2; e3++) {
            const r3 = t2.get(e3);
            u2.verticalIconBox = {
              x1: r3.x1,
              y1: r3.y1,
              x2: r3.x2,
              y2: r3.y2,
              anchorPointX: r3.anchorPointX,
              anchorPointY: r3.anchorPointY
            }, u2.verticalIconFeatureIndex = r3.featureIndex;
            break;
          }
          return u2;
        }
        deserializeCollisionBoxes(t2) {
          this.collisionArrays = [];
          for (let e2 = 0;e2 < this.symbolInstances.length; e2++) {
            const r2 = this.symbolInstances.get(e2);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(t2, e2) {
          const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
          for (let e3 = r2.vertexStartIndex;e3 < n2; e3 += 4)
            t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
        }
        getSortedSymbolIndexes(t2) {
          if (this.sortedAngle === t2 && this.symbolInstanceIndexes !== undefined)
            return this.symbolInstanceIndexes;
          const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
          for (let t3 = 0;t3 < this.symbolInstances.length; ++t3) {
            s2.push(t3);
            const a2 = this.symbolInstances.get(t3);
            n2.push(0 | Math.round(e2 * a2.anchorX + r2 * a2.anchorY)), i2.push(a2.featureIndex);
          }
          return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
        }
        addToSortKeyRanges(t2, e2) {
          const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({
            sortKey: e2,
            symbolInstanceStart: t2,
            symbolInstanceEnd: t2 + 1
          });
        }
        sortFeatures(t2) {
          if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const t3 of this.symbolInstanceIndexes) {
              const e2 = this.symbolInstances.get(t3);
              this.featureSortOrder.push(e2.featureIndex), [
                e2.rightJustifiedTextSymbolIndex,
                e2.centerJustifiedTextSymbolIndex,
                e2.leftJustifiedTextSymbolIndex
              ].forEach((t4, e3, r2) => {
                t4 >= 0 && r2.indexOf(t4) === e3 && this.addIndicesForPlacedSymbol(this.text, t4);
              }), e2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e2.verticalPlacedTextSymbolIndex), e2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.placedIconSymbolIndex), e2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e2.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let yc, mc;
      wi("SymbolBucket", dc, {
        omit: ["layers", "collisionBoxArray", "features", "compareText"]
      }), dc.MAX_GLYPHS = 65535, dc.addDynamicAttributes = cc;
      var gc = {
        get paint() {
          return mc = mc || new rs({
            "icon-opacity": new Wi(G.paint_symbol["icon-opacity"]),
            "icon-color": new Wi(G.paint_symbol["icon-color"]),
            "icon-halo-color": new Wi(G.paint_symbol["icon-halo-color"]),
            "icon-halo-width": new Wi(G.paint_symbol["icon-halo-width"]),
            "icon-halo-blur": new Wi(G.paint_symbol["icon-halo-blur"]),
            "icon-translate": new Ji(G.paint_symbol["icon-translate"]),
            "icon-translate-anchor": new Ji(G.paint_symbol["icon-translate-anchor"]),
            "text-opacity": new Wi(G.paint_symbol["text-opacity"]),
            "text-color": new Wi(G.paint_symbol["text-color"], {
              runtimeType: pt,
              getOverride: (t2) => t2.textColor,
              hasOverride: (t2) => !!t2.textColor
            }),
            "text-halo-color": new Wi(G.paint_symbol["text-halo-color"]),
            "text-halo-width": new Wi(G.paint_symbol["text-halo-width"]),
            "text-halo-blur": new Wi(G.paint_symbol["text-halo-blur"]),
            "text-translate": new Ji(G.paint_symbol["text-translate"]),
            "text-translate-anchor": new Ji(G.paint_symbol["text-translate-anchor"])
          });
        },
        get layout() {
          return yc = yc || new rs({
            "symbol-placement": new Ji(G.layout_symbol["symbol-placement"]),
            "symbol-spacing": new Ji(G.layout_symbol["symbol-spacing"]),
            "symbol-avoid-edges": new Ji(G.layout_symbol["symbol-avoid-edges"]),
            "symbol-sort-key": new Wi(G.layout_symbol["symbol-sort-key"]),
            "symbol-z-order": new Ji(G.layout_symbol["symbol-z-order"]),
            "icon-allow-overlap": new Ji(G.layout_symbol["icon-allow-overlap"]),
            "icon-overlap": new Ji(G.layout_symbol["icon-overlap"]),
            "icon-ignore-placement": new Ji(G.layout_symbol["icon-ignore-placement"]),
            "icon-optional": new Ji(G.layout_symbol["icon-optional"]),
            "icon-rotation-alignment": new Ji(G.layout_symbol["icon-rotation-alignment"]),
            "icon-size": new Wi(G.layout_symbol["icon-size"]),
            "icon-text-fit": new Ji(G.layout_symbol["icon-text-fit"]),
            "icon-text-fit-padding": new Ji(G.layout_symbol["icon-text-fit-padding"]),
            "icon-image": new Wi(G.layout_symbol["icon-image"]),
            "icon-rotate": new Wi(G.layout_symbol["icon-rotate"]),
            "icon-padding": new Wi(G.layout_symbol["icon-padding"]),
            "icon-keep-upright": new Ji(G.layout_symbol["icon-keep-upright"]),
            "icon-offset": new Wi(G.layout_symbol["icon-offset"]),
            "icon-anchor": new Wi(G.layout_symbol["icon-anchor"]),
            "icon-pitch-alignment": new Ji(G.layout_symbol["icon-pitch-alignment"]),
            "text-pitch-alignment": new Ji(G.layout_symbol["text-pitch-alignment"]),
            "text-rotation-alignment": new Ji(G.layout_symbol["text-rotation-alignment"]),
            "text-field": new Wi(G.layout_symbol["text-field"]),
            "text-font": new Wi(G.layout_symbol["text-font"]),
            "text-size": new Wi(G.layout_symbol["text-size"]),
            "text-max-width": new Wi(G.layout_symbol["text-max-width"]),
            "text-line-height": new Ji(G.layout_symbol["text-line-height"]),
            "text-letter-spacing": new Wi(G.layout_symbol["text-letter-spacing"]),
            "text-justify": new Wi(G.layout_symbol["text-justify"]),
            "text-radial-offset": new Wi(G.layout_symbol["text-radial-offset"]),
            "text-variable-anchor": new Ji(G.layout_symbol["text-variable-anchor"]),
            "text-variable-anchor-offset": new Wi(G.layout_symbol["text-variable-anchor-offset"]),
            "text-anchor": new Wi(G.layout_symbol["text-anchor"]),
            "text-max-angle": new Ji(G.layout_symbol["text-max-angle"]),
            "text-writing-mode": new Ji(G.layout_symbol["text-writing-mode"]),
            "text-rotate": new Wi(G.layout_symbol["text-rotate"]),
            "text-padding": new Ji(G.layout_symbol["text-padding"]),
            "text-keep-upright": new Ji(G.layout_symbol["text-keep-upright"]),
            "text-transform": new Wi(G.layout_symbol["text-transform"]),
            "text-offset": new Wi(G.layout_symbol["text-offset"]),
            "text-allow-overlap": new Ji(G.layout_symbol["text-allow-overlap"]),
            "text-overlap": new Ji(G.layout_symbol["text-overlap"]),
            "text-ignore-placement": new Ji(G.layout_symbol["text-ignore-placement"]),
            "text-optional": new Ji(G.layout_symbol["text-optional"])
          });
        }
      };

      class xc {
        constructor(t2) {
          if (t2.property.overrides === undefined)
            throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = t2.property.overrides ? t2.property.overrides.runtimeType : lt, this.defaultValue = t2;
        }
        evaluate(t2) {
          if (t2.formattedSection) {
            const e2 = this.defaultValue.property.overrides;
            if (e2 && e2.hasOverride(t2.formattedSection))
              return e2.getOverride(t2.formattedSection);
          }
          return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t2) {
          this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return false;
        }
        serialize() {
          return null;
        }
      }
      wi("FormatSectionOverride", xc, { omit: ["defaultValue"] });

      class vc extends is {
        constructor(t2) {
          super(t2, gc);
        }
        recalculate(t2, e2) {
          if (super.recalculate(t2, e2), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const t3 = this.layout.get("text-writing-mode");
            if (t3) {
              const e3 = [];
              for (const r2 of t3)
                e3.indexOf(r2) < 0 && e3.push(r2);
              this.layout._values["text-writing-mode"] = e3;
            } else
              this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t2, e2, r2, n2) {
          const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
          return s2.isDataDriven() || vn(s2.value) || !i2 ? i2 : function(t3, e3) {
            return e3.replace(/{([^{}]+)}/g, (e4, r3) => t3 && (r3 in t3) ? String(t3[r3]) : "");
          }(e2.properties, i2);
        }
        createBucket(t2) {
          return new dc(t2);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const t2 of gc.paint.overridableProperties) {
            if (!vc.hasPaintOverride(this.layout, t2))
              continue;
            const e2 = this.paint.get(t2), r2 = new xc(e2), n2 = new xn(r2, e2.property.specification);
            let i2 = null;
            i2 = e2.value.kind === "constant" || e2.value.kind === "source" ? new wn("source", n2) : new _n("composite", n2, e2.value.zoomStops), this.paint._values[t2] = new Hi(e2.property, i2, e2.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
          return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && vc.hasPaintOverride(this.layout, t2);
        }
        static hasPaintOverride(t2, e2) {
          const r2 = t2.get("text-field"), n2 = gc.paint.properties[e2];
          let i2 = false;
          const s2 = (t3) => {
            for (const e3 of t3)
              if (n2.overrides && n2.overrides.hasOverride(e3))
                return void (i2 = true);
          };
          if (r2.value.kind === "constant" && r2.value.value instanceof Yt)
            s2(r2.value.value.sections);
          else if (r2.value.kind === "source") {
            const t3 = (e4) => {
              i2 || (e4 instanceof se && ne(e4.value) === mt ? s2(e4.value.sections) : e4 instanceof Ze ? s2(e4.sections) : e4.eachChild(t3));
            }, e3 = r2.value;
            e3._styleExpression && t3(e3._styleExpression.expression);
          }
          return i2;
        }
      }
      let bc;
      var wc = {
        get paint() {
          return bc = bc || new rs({
            "background-color": new Ji(G.paint_background["background-color"]),
            "background-pattern": new ts(G.paint_background["background-pattern"]),
            "background-opacity": new Ji(G.paint_background["background-opacity"])
          });
        }
      };

      class _c extends is {
        constructor(t2) {
          super(t2, wc);
        }
      }
      let Ac;
      var Sc = {
        get paint() {
          return Ac = Ac || new rs({
            "raster-opacity": new Ji(G.paint_raster["raster-opacity"]),
            "raster-hue-rotate": new Ji(G.paint_raster["raster-hue-rotate"]),
            "raster-brightness-min": new Ji(G.paint_raster["raster-brightness-min"]),
            "raster-brightness-max": new Ji(G.paint_raster["raster-brightness-max"]),
            "raster-saturation": new Ji(G.paint_raster["raster-saturation"]),
            "raster-contrast": new Ji(G.paint_raster["raster-contrast"]),
            "raster-resampling": new Ji(G.paint_raster["raster-resampling"]),
            "raster-fade-duration": new Ji(G.paint_raster["raster-fade-duration"])
          });
        }
      };

      class kc extends is {
        constructor(t2) {
          super(t2, Sc);
        }
      }

      class Mc extends is {
        constructor(t2) {
          super(t2, {}), this.onAdd = (t3) => {
            this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
          }, this.onRemove = (t3) => {
            this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
          }, this.implementation = t2;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== undefined;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return false;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }

      class Ic {
        constructor(t2) {
          this._methodToThrottle = t2, this._triggered = false, typeof MessageChannel != "undefined" && (this._channel = new MessageChannel, this._channel.port2.onmessage = () => {
            this._triggered = false, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
            this._triggered = false, this._methodToThrottle();
          }, 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      const zc = 6371008.8;

      class Pc {
        constructor(t2, e2) {
          if (isNaN(t2) || isNaN(e2))
            throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
          if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
            throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Pc(m(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t2) {
          const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
          return zc * Math.acos(Math.min(i2, 1));
        }
        static convert(t2) {
          if (t2 instanceof Pc)
            return t2;
          if (Array.isArray(t2) && (t2.length === 2 || t2.length === 3))
            return new Pc(Number(t2[0]), Number(t2[1]));
          if (!Array.isArray(t2) && typeof t2 == "object" && t2 !== null)
            return new Pc(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const Cc = 2 * Math.PI * zc;
      function Bc(t2) {
        return Cc * Math.cos(t2 * Math.PI / 180);
      }
      function Vc(t2) {
        return (180 + t2) / 360;
      }
      function Ec(t2) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
      }
      function Fc(t2, e2) {
        return t2 / Bc(e2);
      }
      function Tc(t2) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
      }

      class $c {
        constructor(t2, e2, r2 = 0) {
          this.x = +t2, this.y = +e2, this.z = +r2;
        }
        static fromLngLat(t2, e2 = 0) {
          const r2 = Pc.convert(t2);
          return new $c(Vc(r2.lng), Ec(r2.lat), Fc(e2, r2.lat));
        }
        toLngLat() {
          return new Pc(360 * this.x - 180, Tc(this.y));
        }
        toAltitude() {
          return this.z * Bc(Tc(this.y));
        }
        meterInMercatorCoordinateUnits() {
          return 1 / Cc * (t2 = Tc(this.y), 1 / Math.cos(t2 * Math.PI / 180));
          var t2;
        }
      }
      function Lc(t2, e2, r2) {
        var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
        return [
          t2 * n2 - 2 * Math.PI * 6378137 / 2,
          e2 * n2 - 2 * Math.PI * 6378137 / 2
        ];
      }

      class Dc {
        constructor(t2, e2, r2) {
          if (!function(t3, e3, r3) {
            return !(t3 < 0 || t3 > 25 || r3 < 0 || r3 >= Math.pow(2, t3) || e3 < 0 || e3 >= Math.pow(2, t3));
          }(t2, e2, r2))
            throw new Error(`x=${e2}, y=${r2}, z=${t2} outside of bounds. 0<=x<${Math.pow(2, t2)}, 0<=y<${Math.pow(2, t2)} 0<=z<=25 `);
          this.z = t2, this.x = e2, this.y = r2, this.key = Rc(0, t2, t2, e2, r2);
        }
        equals(t2) {
          return this.z === t2.z && this.x === t2.x && this.y === t2.y;
        }
        url(t2, e2, r2) {
          const n2 = (s2 = this.y, a2 = this.z, o2 = Lc(256 * (i2 = this.x), 256 * (s2 = Math.pow(2, a2) - s2 - 1), a2), l2 = Lc(256 * (i2 + 1), 256 * (s2 + 1), a2), o2[0] + "," + o2[1] + "," + l2[0] + "," + l2[1]);
          var i2, s2, a2, o2, l2;
          const u2 = function(t3, e3, r3) {
            let n3, i3 = "";
            for (let s3 = t3;s3 > 0; s3--)
              n3 = 1 << s3 - 1, i3 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
            return i3;
          }(this.z, this.x, this.y);
          return t2[(this.x + this.y) % t2.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(r2 === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e2 > 1 ? "@2x" : "").replace(/{quadkey}/g, u2).replace(/{bbox-epsg-3857}/g, n2);
        }
        isChildOf(t2) {
          const e2 = this.z - t2.z;
          return e2 > 0 && t2.x === this.x >> e2 && t2.y === this.y >> e2;
        }
        getTilePoint(t2) {
          const e2 = Math.pow(2, this.z);
          return new s((t2.x * e2 - this.x) * $a, (t2.y * e2 - this.y) * $a);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }

      class Oc {
        constructor(t2, e2) {
          this.wrap = t2, this.canonical = e2, this.key = Rc(t2, e2.z, e2.z, e2.x, e2.y);
        }
      }

      class jc {
        constructor(t2, e2, r2, n2, i2) {
          if (t2 < r2)
            throw new Error(`overscaledZ should be >= z; overscaledZ = ${t2}; z = ${r2}`);
          this.overscaledZ = t2, this.wrap = e2, this.canonical = new Dc(r2, +n2, +i2), this.key = Rc(e2, t2, r2, n2, i2);
        }
        clone() {
          return new jc(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(t2) {
          return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
        }
        scaledTo(t2) {
          if (t2 > this.overscaledZ)
            throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
          const e2 = this.canonical.z - t2;
          return t2 > this.canonical.z ? new jc(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new jc(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
        }
        calculateScaledKey(t2, e2) {
          if (t2 > this.overscaledZ)
            throw new Error(`targetZ > this.overscaledZ; targetZ = ${t2}; overscaledZ = ${this.overscaledZ}`);
          const r2 = this.canonical.z - t2;
          return t2 > this.canonical.z ? Rc(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y) : Rc(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
        }
        isChildOf(t2) {
          if (t2.wrap !== this.wrap)
            return false;
          const e2 = this.canonical.z - t2.canonical.z;
          return t2.overscaledZ === 0 || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
        }
        children(t2) {
          if (this.overscaledZ >= t2)
            return [
              new jc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)
            ];
          const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
          return [
            new jc(e2, this.wrap, e2, r2, n2),
            new jc(e2, this.wrap, e2, r2 + 1, n2),
            new jc(e2, this.wrap, e2, r2, n2 + 1),
            new jc(e2, this.wrap, e2, r2 + 1, n2 + 1)
          ];
        }
        isLessThan(t2) {
          return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
        }
        wrapped() {
          return new jc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t2) {
          return new jc(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new Oc(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(t2) {
          return this.canonical.getTilePoint(new $c(t2.x - this.wrap, t2.y));
        }
      }
      function Rc(t2, e2, r2, n2, i2) {
        (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
        const s2 = 1 << r2;
        return (s2 * s2 * t2 + s2 * i2 + n2).toString(36) + r2.toString(36) + e2.toString(36);
      }
      wi("CanonicalTileID", Dc), wi("OverscaledTileID", jc, { omit: ["posMatrix"] });

      class Uc {
        constructor(t2, e2, r2, n2 = 1, i2 = 1, s2 = 1, a2 = 0) {
          if (this.uid = t2, e2.height !== e2.width)
            throw new RangeError("DEM tiles must be square");
          if (r2 && !["mapbox", "terrarium", "custom"].includes(r2))
            return void A(`"${r2}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = e2.height;
          const o2 = this.dim = e2.height - 2;
          switch (this.data = new Uint32Array(e2.data.buffer), r2) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = n2, this.greenFactor = i2, this.blueFactor = s2, this.baseShift = a2;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let t3 = 0;t3 < o2; t3++)
            this.data[this._idx(-1, t3)] = this.data[this._idx(0, t3)], this.data[this._idx(o2, t3)] = this.data[this._idx(o2 - 1, t3)], this.data[this._idx(t3, -1)] = this.data[this._idx(t3, 0)], this.data[this._idx(t3, o2)] = this.data[this._idx(t3, o2 - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o2, -1)] = this.data[this._idx(o2 - 1, 0)], this.data[this._idx(-1, o2)] = this.data[this._idx(0, o2 - 1)], this.data[this._idx(o2, o2)] = this.data[this._idx(o2 - 1, o2 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let t3 = 0;t3 < o2; t3++)
            for (let e3 = 0;e3 < o2; e3++) {
              const r3 = this.get(t3, e3);
              r3 > this.max && (this.max = r3), r3 < this.min && (this.min = r3);
            }
        }
        get(t2, e2) {
          const r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e2);
          return this.unpack(r2[n2], r2[n2 + 1], r2[n2 + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(t2, e2) {
          if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
            throw new RangeError("out of range source coordinates for DEM data");
          return (e2 + 1) * this.stride + (t2 + 1);
        }
        unpack(t2, e2, r2) {
          return t2 * this.redFactor + e2 * this.greenFactor + r2 * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new Ao({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(t2, e2, r2) {
          if (this.dim !== t2.dim)
            throw new Error("dem dimension mismatch");
          let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, a2 = r2 * this.dim + this.dim;
          switch (e2) {
            case -1:
              n2 = i2 - 1;
              break;
            case 1:
              i2 = n2 + 1;
          }
          switch (r2) {
            case -1:
              s2 = a2 - 1;
              break;
            case 1:
              a2 = s2 + 1;
          }
          const o2 = -e2 * this.dim, l2 = -r2 * this.dim;
          for (let e3 = s2;e3 < a2; e3++)
            for (let r3 = n2;r3 < i2; r3++)
              this.data[this._idx(r3, e3)] = t2.data[this._idx(r3 + o2, e3 + l2)];
        }
      }
      wi("DEMData", Uc);

      class qc {
        constructor(t2) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let e2 = 0;e2 < t2.length; e2++) {
            const r2 = t2[e2];
            this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
          }
        }
        encode(t2) {
          return this._stringToNumber[t2];
        }
        decode(t2) {
          if (t2 >= this._numberToString.length)
            throw new Error(`Out of bounds. Index requested n=${t2} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[t2];
        }
      }

      class Nc {
        constructor(t2, e2, r2, n2, i2) {
          this.type = "Feature", this._vectorTileFeature = t2, t2._z = e2, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
        }
        get geometry() {
          return this._geometry === undefined && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(t2) {
          this._geometry = t2;
        }
        toJSON() {
          const t2 = { geometry: this.geometry };
          for (const e2 in this)
            e2 !== "_geometry" && e2 !== "_vectorTileFeature" && (t2[e2] = this[e2]);
          return t2;
        }
      }

      class Zc {
        constructor(t2, e2) {
          this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new vi($a, 16, 0), this.grid3D = new vi($a, 16, 0), this.featureIndexArray = new Ns, this.promoteId = e2;
        }
        insert(t2, e2, r2, n2, i2, s2) {
          const a2 = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(r2, n2, i2);
          const o2 = s2 ? this.grid3D : this.grid;
          for (let t3 = 0;t3 < e2.length; t3++) {
            const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let t4 = 0;t4 < r3.length; t4++) {
              const e3 = r3[t4];
              n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
            }
            n3[0] < $a && n3[1] < $a && n3[2] >= 0 && n3[3] >= 0 && o2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new fl.VectorTile(new Iu(this.rawTileData)).layers, this.sourceLayerCoder = new qc(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(t2, e2, r2, n2) {
          this.loadVTLayers();
          const i2 = t2.params || {}, a2 = $a / t2.tileSize / t2.scale, o2 = zn(i2.filter), l2 = t2.queryGeometry, u2 = t2.queryPadding * a2, c2 = Kc(l2), h2 = this.grid.query(c2.minX - u2, c2.minY - u2, c2.maxX + u2, c2.maxY + u2), p2 = Kc(t2.cameraQueryGeometry), f2 = this.grid3D.query(p2.minX - u2, p2.minY - u2, p2.maxX + u2, p2.maxY + u2, (e3, r3, n3, i3) => function(t3, e4, r4, n4, i4) {
            for (const s2 of t3)
              if (e4 <= s2.x && r4 <= s2.y && n4 >= s2.x && i4 >= s2.y)
                return true;
            const a3 = [new s(e4, r4), new s(e4, i4), new s(n4, i4), new s(n4, r4)];
            if (t3.length > 2) {
              for (const e5 of a3)
                if (Wa(t3, e5))
                  return true;
            }
            for (let e5 = 0;e5 < t3.length - 1; e5++)
              if (Qa(t3[e5], t3[e5 + 1], a3))
                return true;
            return false;
          }(t2.cameraQueryGeometry, e3 - u2, r3 - u2, n3 + u2, i3 + u2));
          for (const t3 of f2)
            h2.push(t3);
          h2.sort(Xc);
          const d2 = {};
          let y2;
          for (let s2 = 0;s2 < h2.length; s2++) {
            const u3 = h2[s2];
            if (u3 === y2)
              continue;
            y2 = u3;
            const c3 = this.featureIndexArray.get(u3);
            let p3 = null;
            this.loadMatchingFeature(d2, c3.bucketIndex, c3.sourceLayerIndex, c3.featureIndex, o2, i2.layers, i2.availableImages, e2, r2, n2, (e3, r3, n3) => (p3 || (p3 = Oa(e3)), r3.queryIntersectsFeature(l2, e3, n3, p3, this.z, t2.transform, a2, t2.pixelPosMatrix)));
          }
          return d2;
        }
        loadMatchingFeature(t2, e2, r2, n2, i2, s2, a2, o2, l2, u2, c2) {
          const h2 = this.bucketLayerIDs[e2];
          if (s2 && !function(t3, e3) {
            for (let r3 = 0;r3 < t3.length; r3++)
              if (e3.indexOf(t3[r3]) >= 0)
                return true;
            return false;
          }(s2, h2))
            return;
          const p2 = this.sourceLayerCoder.decode(r2), f2 = this.vtLayers[p2].feature(n2);
          if (i2.needGeometry) {
            const t3 = ja(f2, true);
            if (!i2.filter(new Ui(this.tileID.overscaledZ), t3, this.tileID.canonical))
              return;
          } else if (!i2.filter(new Ui(this.tileID.overscaledZ), f2))
            return;
          const d2 = this.getId(f2, p2);
          for (let e3 = 0;e3 < h2.length; e3++) {
            const r3 = h2[e3];
            if (s2 && s2.indexOf(r3) < 0)
              continue;
            const i3 = o2[r3];
            if (!i3)
              continue;
            let p3 = {};
            d2 && u2 && (p3 = u2.getState(i3.sourceLayer || "_geojsonTileLayer", d2));
            const y2 = g({}, l2[r3]);
            y2.paint = Gc(y2.paint, i3.paint, f2, p3, a2), y2.layout = Gc(y2.layout, i3.layout, f2, p3, a2);
            const m2 = !c2 || c2(f2, i3, p3);
            if (!m2)
              continue;
            const x2 = new Nc(f2, this.z, this.x, this.y, d2);
            x2.layer = y2;
            let v2 = t2[r3];
            v2 === undefined && (v2 = t2[r3] = []), v2.push({ featureIndex: n2, feature: x2, intersectionZ: m2 });
          }
        }
        lookupSymbolFeatures(t2, e2, r2, n2, i2, s2, a2, o2) {
          const l2 = {};
          this.loadVTLayers();
          const u2 = zn(i2);
          for (const i3 of t2)
            this.loadMatchingFeature(l2, r2, n2, i3, u2, s2, a2, o2, e2);
          return l2;
        }
        hasLayer(t2) {
          for (const e2 of this.bucketLayerIDs)
            for (const r2 of e2)
              if (t2 === r2)
                return true;
          return false;
        }
        getId(t2, e2) {
          let r2 = t2.id;
          return this.promoteId && (r2 = t2.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[e2]], typeof r2 == "boolean" && (r2 = Number(r2))), r2;
        }
      }
      function Gc(t2, e2, r2, n2, i2) {
        return v(t2, (t3, s2) => {
          const a2 = e2 instanceof Yi ? e2.get(s2) : null;
          return a2 && a2.evaluate ? a2.evaluate(r2, n2, i2) : a2;
        });
      }
      function Kc(t2) {
        let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
        for (const s2 of t2)
          e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
        return { minX: e2, minY: r2, maxX: n2, maxY: i2 };
      }
      function Xc(t2, e2) {
        return e2 - t2;
      }
      function Hc(t2, e2, r2, n2, i2) {
        const a2 = [];
        for (let o2 = 0;o2 < t2.length; o2++) {
          const l2 = t2[o2];
          let u2;
          for (let t3 = 0;t3 < l2.length - 1; t3++) {
            let o3 = l2[t3], c2 = l2[t3 + 1];
            o3.x < e2 && c2.x < e2 || (o3.x < e2 ? o3 = new s(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x < e2 && (c2 = new s(e2, o3.y + (e2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y < r2 && c2.y < r2 || (o3.y < r2 ? o3 = new s(o3.x + (r2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r2)._round() : c2.y < r2 && (c2 = new s(o3.x + (r2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), r2)._round()), o3.x >= n2 && c2.x >= n2 || (o3.x >= n2 ? o3 = new s(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round() : c2.x >= n2 && (c2 = new s(n2, o3.y + (n2 - o3.x) / (c2.x - o3.x) * (c2.y - o3.y))._round()), o3.y >= i2 && c2.y >= i2 || (o3.y >= i2 ? o3 = new s(o3.x + (i2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), i2)._round() : c2.y >= i2 && (c2 = new s(o3.x + (i2 - o3.y) / (c2.y - o3.y) * (c2.x - o3.x), i2)._round()), u2 && o3.equals(u2[u2.length - 1]) || (u2 = [o3], a2.push(u2)), u2.push(c2)))));
          }
        }
        return a2;
      }
      wi("FeatureIndex", Zc, { omit: ["rawTileData", "sourceLayerCoder"] });

      class Yc extends s {
        constructor(t2, e2, r2, n2) {
          super(t2, e2), this.angle = r2, n2 !== undefined && (this.segment = n2);
        }
        clone() {
          return new Yc(this.x, this.y, this.angle, this.segment);
        }
      }
      function Jc(t2, e2, r2, n2, i2) {
        if (e2.segment === undefined || r2 === 0)
          return true;
        let s2 = e2, a2 = e2.segment + 1, o2 = 0;
        for (;o2 > -r2 / 2; ) {
          if (a2--, a2 < 0)
            return false;
          o2 -= t2[a2].dist(s2), s2 = t2[a2];
        }
        o2 += t2[a2].dist(t2[a2 + 1]), a2++;
        const l2 = [];
        let u2 = 0;
        for (;o2 < r2 / 2; ) {
          const e3 = t2[a2], r3 = t2[a2 + 1];
          if (!r3)
            return false;
          let s3 = t2[a2 - 1].angleTo(e3) - e3.angleTo(r3);
          for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: o2, angleDelta: s3 }), u2 += s3;o2 - l2[0].distance > n2; )
            u2 -= l2.shift().angleDelta;
          if (u2 > i2)
            return false;
          a2++, o2 += e3.dist(r3);
        }
        return true;
      }
      function Wc(t2) {
        let e2 = 0;
        for (let r2 = 0;r2 < t2.length - 1; r2++)
          e2 += t2[r2].dist(t2[r2 + 1]);
        return e2;
      }
      function Qc(t2, e2, r2) {
        return t2 ? 0.6 * e2 * r2 : 0;
      }
      function th(t2, e2) {
        return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
      }
      function eh(t2, e2, r2, n2, i2, s2) {
        const a2 = Qc(r2, i2, s2), o2 = th(r2, n2) * s2;
        let l2 = 0;
        const u2 = Wc(t2) / 2;
        for (let r3 = 0;r3 < t2.length - 1; r3++) {
          const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
          if (l2 + s3 > u2) {
            const c2 = (u2 - l2) / s3, h2 = Ce.number(n3.x, i3.x, c2), p2 = Ce.number(n3.y, i3.y, c2), f2 = new Yc(h2, p2, i3.angleTo(n3), r3);
            return f2._round(), !a2 || Jc(t2, f2, o2, a2, e2) ? f2 : undefined;
          }
          l2 += s3;
        }
      }
      function rh(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = Qc(n2, s2, a2), c2 = th(n2, i2), h2 = c2 * a2, p2 = t2[0].x === 0 || t2[0].x === l2 || t2[0].y === 0 || t2[0].y === l2;
        return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), nh(t2, p2 ? e2 / 2 * o2 % e2 : (c2 / 2 + 2 * s2) * a2 * o2 % e2, e2, u2, r2, h2, p2, false, l2);
      }
      function nh(t2, e2, r2, n2, i2, s2, a2, o2, l2) {
        const u2 = s2 / 2, c2 = Wc(t2);
        let h2 = 0, p2 = e2 - r2, f2 = [];
        for (let e3 = 0;e3 < t2.length - 1; e3++) {
          const a3 = t2[e3], o3 = t2[e3 + 1], d2 = a3.dist(o3), y2 = o3.angleTo(a3);
          for (;p2 + r2 < h2 + d2; ) {
            p2 += r2;
            const m2 = (p2 - h2) / d2, g2 = Ce.number(a3.x, o3.x, m2), x2 = Ce.number(a3.y, o3.y, m2);
            if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u2 >= 0 && p2 + u2 <= c2) {
              const r3 = new Yc(g2, x2, y2, e3);
              r3._round(), n2 && !Jc(t2, r3, s2, n2, i2) || f2.push(r3);
            }
          }
          h2 += d2;
        }
        return o2 || f2.length || a2 || (f2 = nh(t2, h2 / 2, r2, n2, i2, s2, a2, true, l2)), f2;
      }
      wi("Anchor", Yc);
      const ih = Fu;
      function sh(t2, e2, r2, n2) {
        const i2 = [], a2 = t2.image, o2 = a2.pixelRatio, l2 = a2.paddedRect.w - 2 * ih, u2 = a2.paddedRect.h - 2 * ih;
        let c2 = { x1: t2.left, y1: t2.top, x2: t2.right, y2: t2.bottom };
        const h2 = a2.stretchX || [[0, l2]], p2 = a2.stretchY || [[0, u2]], f2 = (t3, e3) => t3 + e3[1] - e3[0], d2 = h2.reduce(f2, 0), y2 = p2.reduce(f2, 0), m2 = l2 - d2, g2 = u2 - y2;
        let x2 = 0, v2 = d2, b2 = 0, w2 = y2, _2 = 0, A2 = m2, S2 = 0, k2 = g2;
        if (a2.content && n2) {
          const e3 = a2.content, r3 = e3[2] - e3[0], n3 = e3[3] - e3[1];
          (a2.textFitWidth || a2.textFitHeight) && (c2 = tc(t2)), x2 = ah(h2, 0, e3[0]), b2 = ah(p2, 0, e3[1]), v2 = ah(h2, e3[0], e3[2]), w2 = ah(p2, e3[1], e3[3]), _2 = e3[0] - x2, S2 = e3[1] - b2, A2 = r3 - v2, k2 = n3 - w2;
        }
        const { x1: M2, y1: I2 } = c2, z2 = c2.x2 - M2, P2 = c2.y2 - I2, C2 = (t3, n3, i3, l3) => {
          const u3 = lh(t3.stretch - x2, v2, z2, M2), c3 = uh(t3.fixed - _2, A2, t3.stretch, d2), h3 = lh(n3.stretch - b2, w2, P2, I2), p3 = uh(n3.fixed - S2, k2, n3.stretch, y2), f3 = lh(i3.stretch - x2, v2, z2, M2), m3 = uh(i3.fixed - _2, A2, i3.stretch, d2), g3 = lh(l3.stretch - b2, w2, P2, I2), C3 = uh(l3.fixed - S2, k2, l3.stretch, y2), B2 = new s(u3, h3), V2 = new s(f3, h3), E2 = new s(f3, g3), F2 = new s(u3, g3), T2 = new s(c3 / o2, p3 / o2), $2 = new s(m3 / o2, C3 / o2), L2 = e2 * Math.PI / 180;
          if (L2) {
            const t4 = Math.sin(L2), e3 = Math.cos(L2), r3 = [e3, -t4, t4, e3];
            B2._matMult(r3), V2._matMult(r3), F2._matMult(r3), E2._matMult(r3);
          }
          const D2 = t3.stretch + t3.fixed, O2 = n3.stretch + n3.fixed;
          return {
            tl: B2,
            tr: V2,
            bl: F2,
            br: E2,
            tex: {
              x: a2.paddedRect.x + ih + D2,
              y: a2.paddedRect.y + ih + O2,
              w: i3.stretch + i3.fixed - D2,
              h: l3.stretch + l3.fixed - O2
            },
            writingMode: undefined,
            glyphOffset: [0, 0],
            sectionIndex: 0,
            pixelOffsetTL: T2,
            pixelOffsetBR: $2,
            minFontScaleX: A2 / o2 / z2,
            minFontScaleY: k2 / o2 / P2,
            isSDF: r2
          };
        };
        if (n2 && (a2.stretchX || a2.stretchY)) {
          const t3 = oh(h2, m2, d2), e3 = oh(p2, g2, y2);
          for (let r3 = 0;r3 < t3.length - 1; r3++) {
            const n3 = t3[r3], s2 = t3[r3 + 1];
            for (let t4 = 0;t4 < e3.length - 1; t4++)
              i2.push(C2(n3, e3[t4], s2, e3[t4 + 1]));
          }
        } else
          i2.push(C2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l2 + 1 }, { fixed: 0, stretch: u2 + 1 }));
        return i2;
      }
      function ah(t2, e2, r2) {
        let n2 = 0;
        for (const i2 of t2)
          n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
        return n2;
      }
      function oh(t2, e2, r2) {
        const n2 = [{ fixed: -ih, stretch: 0 }];
        for (const [e3, r3] of t2) {
          const t3 = n2[n2.length - 1];
          n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
        }
        return n2.push({ fixed: e2 + ih, stretch: r2 }), n2;
      }
      function lh(t2, e2, r2, n2) {
        return t2 / e2 * r2 + n2;
      }
      function uh(t2, e2, r2, n2) {
        return t2 - e2 * r2 / n2;
      }

      class ch {
        constructor(t2, e2, r2, n2, i2, a2, o2, l2, u2, c2) {
          var h2;
          if (this.boxStartIndex = t2.length, u2) {
            let { top: t3, bottom: e3 } = a2;
            const r3 = a2.collisionPadding;
            r3 && (t3 -= r3[1], e3 += r3[3]);
            let n3 = e3 - t3;
            n3 > 0 && (n3 = Math.max(10, n3), this.circleDiameter = n3);
          } else {
            const u3 = ((h2 = a2.image) === null || h2 === undefined ? undefined : h2.content) && (a2.image.textFitWidth || a2.image.textFitHeight) ? tc(a2) : { x1: a2.left, y1: a2.top, x2: a2.right, y2: a2.bottom };
            u3.y1 = u3.y1 * o2 - l2[0], u3.y2 = u3.y2 * o2 + l2[2], u3.x1 = u3.x1 * o2 - l2[3], u3.x2 = u3.x2 * o2 + l2[1];
            const p2 = a2.collisionPadding;
            if (p2 && (u3.x1 -= p2[0] * o2, u3.y1 -= p2[1] * o2, u3.x2 += p2[2] * o2, u3.y2 += p2[3] * o2), c2) {
              const t3 = new s(u3.x1, u3.y1), e3 = new s(u3.x2, u3.y1), r3 = new s(u3.x1, u3.y2), n3 = new s(u3.x2, u3.y2), i3 = c2 * Math.PI / 180;
              t3._rotate(i3), e3._rotate(i3), r3._rotate(i3), n3._rotate(i3), u3.x1 = Math.min(t3.x, e3.x, r3.x, n3.x), u3.x2 = Math.max(t3.x, e3.x, r3.x, n3.x), u3.y1 = Math.min(t3.y, e3.y, r3.y, n3.y), u3.y2 = Math.max(t3.y, e3.y, r3.y, n3.y);
            }
            t2.emplaceBack(e2.x, e2.y, u3.x1, u3.y1, u3.x2, u3.y2, r2, n2, i2);
          }
          this.boxEndIndex = t2.length;
        }
      }

      class hh {
        constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
          if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
            for (let t3 = (this.length >> 1) - 1;t3 >= 0; t3--)
              this._down(t3);
        }
        push(t2) {
          this.data.push(t2), this._up(this.length++);
        }
        pop() {
          if (this.length === 0)
            return;
          const t2 = this.data[0], e2 = this.data.pop();
          return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
        }
        peek() {
          return this.data[0];
        }
        _up(t2) {
          const { data: e2, compare: r2 } = this, n2 = e2[t2];
          for (;t2 > 0; ) {
            const i2 = t2 - 1 >> 1, s2 = e2[i2];
            if (r2(n2, s2) >= 0)
              break;
            e2[t2] = s2, t2 = i2;
          }
          e2[t2] = n2;
        }
        _down(t2) {
          const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
          for (;t2 < n2; ) {
            let n3 = 1 + (t2 << 1);
            const s2 = n3 + 1;
            if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0)
              break;
            e2[t2] = e2[n3], t2 = n3;
          }
          e2[t2] = i2;
        }
      }
      function ph(t2, e2 = 1, r2 = false) {
        let n2 = 1 / 0, i2 = 1 / 0, a2 = -1 / 0, o2 = -1 / 0;
        const l2 = t2[0];
        for (let t3 = 0;t3 < l2.length; t3++) {
          const e3 = l2[t3];
          (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > a2) && (a2 = e3.x), (!t3 || e3.y > o2) && (o2 = e3.y);
        }
        const u2 = Math.min(a2 - n2, o2 - i2);
        let c2 = u2 / 2;
        const h2 = new hh([], fh);
        if (u2 === 0)
          return new s(n2, i2);
        for (let e3 = n2;e3 < a2; e3 += u2)
          for (let r3 = i2;r3 < o2; r3 += u2)
            h2.push(new dh(e3 + c2, r3 + c2, c2, t2));
        let p2 = function(t3) {
          let e3 = 0, r3 = 0, n3 = 0;
          const i3 = t3[0];
          for (let t4 = 0, s2 = i3.length, a3 = s2 - 1;t4 < s2; a3 = t4++) {
            const s3 = i3[t4], o3 = i3[a3], l3 = s3.x * o3.y - o3.x * s3.y;
            r3 += (s3.x + o3.x) * l3, n3 += (s3.y + o3.y) * l3, e3 += 3 * l3;
          }
          return new dh(r3 / e3, n3 / e3, 0, t3);
        }(t2), f2 = h2.length;
        for (;h2.length; ) {
          const n3 = h2.pop();
          (n3.d > p2.d || !p2.d) && (p2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, f2)), n3.max - p2.d <= e2 || (c2 = n3.h / 2, h2.push(new dh(n3.p.x - c2, n3.p.y - c2, c2, t2)), h2.push(new dh(n3.p.x + c2, n3.p.y - c2, c2, t2)), h2.push(new dh(n3.p.x - c2, n3.p.y + c2, c2, t2)), h2.push(new dh(n3.p.x + c2, n3.p.y + c2, c2, t2)), f2 += 4);
        }
        return r2 && (console.log(`num probes: ${f2}`), console.log(`best distance: ${p2.d}`)), p2.p;
      }
      function fh(t2, e2) {
        return e2.max - t2.max;
      }
      function dh(t2, e2, r2, n2) {
        this.p = new s(t2, e2), this.h = r2, this.d = function(t3, e3) {
          let r3 = false, n3 = 1 / 0;
          for (let i2 = 0;i2 < e3.length; i2++) {
            const s2 = e3[i2];
            for (let e4 = 0, i3 = s2.length, a2 = i3 - 1;e4 < i3; a2 = e4++) {
              const i4 = s2[e4], o2 = s2[a2];
              i4.y > t3.y != o2.y > t3.y && t3.x < (o2.x - i4.x) * (t3.y - i4.y) / (o2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, Ya(t3, i4, o2));
            }
          }
          return (r3 ? 1 : -1) * Math.sqrt(n3);
        }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
      }
      var yh;
      t.aq = undefined, (yh = t.aq || (t.aq = {}))[yh.center = 1] = "center", yh[yh.left = 2] = "left", yh[yh.right = 3] = "right", yh[yh.top = 4] = "top", yh[yh.bottom = 5] = "bottom", yh[yh["top-left"] = 6] = "top-left", yh[yh["top-right"] = 7] = "top-right", yh[yh["bottom-left"] = 8] = "bottom-left", yh[yh["bottom-right"] = 9] = "bottom-right";
      const mh = 7, gh = Number.POSITIVE_INFINITY;
      function xh(t2, e2) {
        return e2[1] !== gh ? function(t3, e3, r2) {
          let n2 = 0, i2 = 0;
          switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t3) {
            case "top-right":
            case "top-left":
            case "top":
              i2 = r2 - mh;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              i2 = -r2 + mh;
          }
          switch (t3) {
            case "top-right":
            case "bottom-right":
            case "right":
              n2 = -e3;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              n2 = e3;
          }
          return [n2, i2];
        }(t2, e2[0], e2[1]) : function(t3, e3) {
          let r2 = 0, n2 = 0;
          e3 < 0 && (e3 = 0);
          const i2 = e3 / Math.SQRT2;
          switch (t3) {
            case "top-right":
            case "top-left":
              n2 = i2 - mh;
              break;
            case "bottom-right":
            case "bottom-left":
              n2 = -i2 + mh;
              break;
            case "bottom":
              n2 = -e3 + mh;
              break;
            case "top":
              n2 = e3 - mh;
          }
          switch (t3) {
            case "top-right":
            case "bottom-right":
              r2 = -i2;
              break;
            case "top-left":
            case "bottom-left":
              r2 = i2;
              break;
            case "left":
              r2 = e3;
              break;
            case "right":
              r2 = -e3;
          }
          return [r2, n2];
        }(t2, e2[0]);
      }
      function vh(t2, e2, r2) {
        var n2;
        const i2 = t2.layout, s2 = (n2 = i2.get("text-variable-anchor-offset")) === null || n2 === undefined ? undefined : n2.evaluate(e2, {}, r2);
        if (s2) {
          const t3 = s2.values, e3 = [];
          for (let r3 = 0;r3 < t3.length; r3 += 2) {
            const n3 = e3[r3] = t3[r3], i3 = t3[r3 + 1].map((t4) => t4 * iu);
            n3.startsWith("top") ? i3[1] -= mh : n3.startsWith("bottom") && (i3[1] += mh), e3[r3 + 1] = i3;
          }
          return new Qt(e3);
        }
        const a2 = i2.get("text-variable-anchor");
        if (a2) {
          let n3;
          n3 = t2._unevaluatedLayout.getValue("text-radial-offset") !== undefined ? [i2.get("text-radial-offset").evaluate(e2, {}, r2) * iu, gh] : i2.get("text-offset").evaluate(e2, {}, r2).map((t3) => t3 * iu);
          const s3 = [];
          for (const t3 of a2)
            s3.push(t3, xh(t3, n3));
          return new Qt(s3);
        }
        return null;
      }
      function bh(t2) {
        switch (t2) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function wh(e2, r2, n2, i2, s2, a2, o2, l2, u2, c2, h2) {
        let p2 = a2.textMaxSize.evaluate(r2, {});
        p2 === undefined && (p2 = o2);
        const f2 = e2.layers[0].layout, d2 = f2.get("icon-offset").evaluate(r2, {}, h2), y2 = Ah(n2.horizontal), m2 = o2 / 24, g2 = e2.tilePixelRatio * m2, x2 = e2.tilePixelRatio * p2 / 24, v2 = e2.tilePixelRatio * l2, b2 = e2.tilePixelRatio * f2.get("symbol-spacing"), w2 = f2.get("text-padding") * e2.tilePixelRatio, _2 = function(t2, e3, r3, n3 = 1) {
          const i3 = t2.get("icon-padding").evaluate(e3, {}, r3), s3 = i3 && i3.values;
          return [s3[0] * n3, s3[1] * n3, s3[2] * n3, s3[3] * n3];
        }(f2, r2, h2, e2.tilePixelRatio), S2 = f2.get("text-max-angle") / 180 * Math.PI, k2 = f2.get("text-rotation-alignment") !== "viewport" && f2.get("symbol-placement") !== "point", M2 = f2.get("icon-rotation-alignment") === "map" && f2.get("symbol-placement") !== "point", I2 = f2.get("symbol-placement"), z2 = b2 / 2, P2 = f2.get("icon-text-fit");
        let C2;
        i2 && P2 !== "none" && (e2.allowVerticalPlacement && n2.vertical && (C2 = ec(i2, n2.vertical, P2, f2.get("icon-text-fit-padding"), d2, m2)), y2 && (i2 = ec(i2, y2, P2, f2.get("icon-text-fit-padding"), d2, m2)));
        const B2 = (l3, p3) => {
          p3.x < 0 || p3.x >= $a || p3.y < 0 || p3.y >= $a || function(e3, r3, n3, i3, s3, a3, o3, l4, u3, c3, h3, p4, f3, d3, y3, m3, g3, x3, v3, b3, w3, _3, S3, k3, M3) {
            const I3 = e3.addToLineVertexArray(r3, n3);
            let z3, P3, C3, B3, V2 = 0, E2 = 0, F2 = 0, T2 = 0, $2 = -1, L2 = -1;
            const D2 = {};
            let O2 = ma("");
            if (e3.allowVerticalPlacement && i3.vertical) {
              const t2 = l4.layout.get("text-rotate").evaluate(w3, {}, k3) + 90;
              C3 = new ch(u3, r3, c3, h3, p4, i3.vertical, f3, d3, y3, t2), o3 && (B3 = new ch(u3, r3, c3, h3, p4, o3, g3, x3, y3, t2));
            }
            if (s3) {
              const n4 = l4.layout.get("icon-rotate").evaluate(w3, {}), i4 = l4.layout.get("icon-text-fit") !== "none", a4 = sh(s3, n4, S3, i4), f4 = o3 ? sh(o3, n4, S3, i4) : undefined;
              P3 = new ch(u3, r3, c3, h3, p4, s3, g3, x3, false, n4), V2 = 4 * a4.length;
              const d4 = e3.iconSizeData;
              let y4 = null;
              d4.kind === "source" ? (y4 = [nc * l4.layout.get("icon-size").evaluate(w3, {})], y4[0] > ic && A(`${e3.layerIds[0]}: Value for "icon-size" is >= ${rc}. Reduce your "icon-size".`)) : d4.kind === "composite" && (y4 = [
                nc * _3.compositeIconSizes[0].evaluate(w3, {}, k3),
                nc * _3.compositeIconSizes[1].evaluate(w3, {}, k3)
              ], (y4[0] > ic || y4[1] > ic) && A(`${e3.layerIds[0]}: Value for "icon-size" is >= ${rc}. Reduce your "icon-size".`)), e3.addSymbols(e3.icon, a4, y4, b3, v3, w3, t.ah.none, r3, I3.lineStartIndex, I3.lineLength, -1, k3), $2 = e3.icon.placedSymbolArray.length - 1, f4 && (E2 = 4 * f4.length, e3.addSymbols(e3.icon, f4, y4, b3, v3, w3, t.ah.vertical, r3, I3.lineStartIndex, I3.lineLength, -1, k3), L2 = e3.icon.placedSymbolArray.length - 1);
            }
            const j2 = Object.keys(i3.horizontal);
            for (const n4 of j2) {
              const s4 = i3.horizontal[n4];
              if (!z3) {
                O2 = ma(s4.text);
                const t2 = l4.layout.get("text-rotate").evaluate(w3, {}, k3);
                z3 = new ch(u3, r3, c3, h3, p4, s4, f3, d3, y3, t2);
              }
              const o4 = s4.positionedLines.length === 1;
              if (F2 += _h(e3, r3, s4, a3, l4, y3, w3, m3, I3, i3.vertical ? t.ah.horizontal : t.ah.horizontalOnly, o4 ? j2 : [n4], D2, $2, _3, k3), o4)
                break;
            }
            i3.vertical && (T2 += _h(e3, r3, i3.vertical, a3, l4, y3, w3, m3, I3, t.ah.vertical, ["vertical"], D2, L2, _3, k3));
            const R2 = z3 ? z3.boxStartIndex : e3.collisionBoxArray.length, U2 = z3 ? z3.boxEndIndex : e3.collisionBoxArray.length, q2 = C3 ? C3.boxStartIndex : e3.collisionBoxArray.length, N2 = C3 ? C3.boxEndIndex : e3.collisionBoxArray.length, Z2 = P3 ? P3.boxStartIndex : e3.collisionBoxArray.length, G2 = P3 ? P3.boxEndIndex : e3.collisionBoxArray.length, K2 = B3 ? B3.boxStartIndex : e3.collisionBoxArray.length, X2 = B3 ? B3.boxEndIndex : e3.collisionBoxArray.length;
            let H2 = -1;
            const Y2 = (t2, e4) => t2 && t2.circleDiameter ? Math.max(t2.circleDiameter, e4) : e4;
            H2 = Y2(z3, H2), H2 = Y2(C3, H2), H2 = Y2(P3, H2), H2 = Y2(B3, H2);
            const J2 = H2 > -1 ? 1 : 0;
            J2 && (H2 *= M3 / iu), e3.glyphOffsetArray.length >= dc.MAX_GLYPHS && A("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), w3.sortKey !== undefined && e3.addToSortKeyRanges(e3.symbolInstances.length, w3.sortKey);
            const W2 = vh(l4, w3, k3), [Q2, tt2] = function(e4, r4) {
              const n4 = e4.length, i4 = r4 == null ? undefined : r4.values;
              if ((i4 == null ? undefined : i4.length) > 0)
                for (let r5 = 0;r5 < i4.length; r5 += 2) {
                  const n5 = i4[r5 + 1];
                  e4.emplaceBack(t.aq[i4[r5]], n5[0], n5[1]);
                }
              return [n4, e4.length];
            }(e3.textAnchorOffsets, W2);
            e3.symbolInstances.emplaceBack(r3.x, r3.y, D2.right >= 0 ? D2.right : -1, D2.center >= 0 ? D2.center : -1, D2.left >= 0 ? D2.left : -1, D2.vertical || -1, $2, L2, O2, R2, U2, q2, N2, Z2, G2, K2, X2, c3, F2, T2, V2, E2, J2, 0, f3, H2, Q2, tt2);
          }(e2, p3, l3, n2, i2, s2, C2, e2.layers[0], e2.collisionBoxArray, r2.index, r2.sourceLayerIndex, e2.index, g2, [w2, w2, w2, w2], k2, u2, v2, _2, M2, d2, r2, a2, c2, h2, o2);
        };
        if (I2 === "line")
          for (const t2 of Hc(r2.geometry, 0, 0, $a, $a)) {
            const r3 = rh(t2, b2, S2, n2.vertical || y2, i2, 24, x2, e2.overscaling, $a);
            for (const n3 of r3)
              y2 && Sh(e2, y2.text, z2, n3) || B2(t2, n3);
          }
        else if (I2 === "line-center") {
          for (const t2 of r2.geometry)
            if (t2.length > 1) {
              const e3 = eh(t2, S2, n2.vertical || y2, i2, 24, x2);
              e3 && B2(t2, e3);
            }
        } else if (r2.type === "Polygon")
          for (const t2 of xr(r2.geometry, 0)) {
            const e3 = ph(t2, 16);
            B2(t2[0], new Yc(e3.x, e3.y, 0));
          }
        else if (r2.type === "LineString")
          for (const t2 of r2.geometry)
            B2(t2, new Yc(t2[0].x, t2[0].y, 0));
        else if (r2.type === "Point")
          for (const t2 of r2.geometry)
            for (const e3 of t2)
              B2([e3], new Yc(e3.x, e3.y, 0));
      }
      function _h(t2, e2, r2, n2, i2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2) {
        const m2 = function(t3, e3, r3, n3, i3, a3, o3, l3) {
          const u3 = n3.layout.get("text-rotate").evaluate(a3, {}) * Math.PI / 180, c3 = [];
          for (const t4 of e3.positionedLines)
            for (const n4 of t4.positionedGlyphs) {
              if (!n4.rect)
                continue;
              const a4 = n4.rect || {};
              let h3 = Vu + 1, p3 = true, f3 = 1, d3 = 0;
              const y3 = (i3 || l3) && n4.vertical, m3 = n4.metrics.advance * n4.scale / 2;
              if (l3 && e3.verticalizable && (d3 = t4.lineOffset / 2 - (n4.imageName ? -(iu - n4.metrics.width * n4.scale) / 2 : (n4.scale - 1) * iu)), n4.imageName) {
                const t5 = o3[n4.imageName];
                p3 = t5.sdf, f3 = t5.pixelRatio, h3 = Fu / f3;
              }
              const g3 = i3 ? [n4.x + m3, n4.y] : [0, 0];
              let x3 = i3 ? [0, 0] : [n4.x + m3 + r3[0], n4.y + r3[1] - d3], v2 = [0, 0];
              y3 && (v2 = x3, x3 = [0, 0]);
              const b2 = n4.metrics.isDoubleResolution ? 2 : 1, w2 = (n4.metrics.left - h3) * n4.scale - m3 + x3[0], _2 = (-n4.metrics.top - h3) * n4.scale + x3[1], A2 = w2 + a4.w / b2 * n4.scale / f3, S2 = _2 + a4.h / b2 * n4.scale / f3, k2 = new s(w2, _2), M2 = new s(A2, _2), I2 = new s(w2, S2), z2 = new s(A2, S2);
              if (y3) {
                const t5 = new s(-m3, m3 - Du), e4 = -Math.PI / 2, r4 = iu / 2 - m3, i4 = new s(5 - Du - r4, -(n4.imageName ? r4 : 0)), a5 = new s(...v2);
                k2._rotateAround(e4, t5)._add(i4)._add(a5), M2._rotateAround(e4, t5)._add(i4)._add(a5), I2._rotateAround(e4, t5)._add(i4)._add(a5), z2._rotateAround(e4, t5)._add(i4)._add(a5);
              }
              if (u3) {
                const t5 = Math.sin(u3), e4 = Math.cos(u3), r4 = [e4, -t5, t5, e4];
                k2._matMult(r4), M2._matMult(r4), I2._matMult(r4), z2._matMult(r4);
              }
              const P2 = new s(0, 0), C2 = new s(0, 0);
              c3.push({
                tl: k2,
                tr: M2,
                bl: I2,
                br: z2,
                tex: a4,
                writingMode: e3.writingMode,
                glyphOffset: g3,
                sectionIndex: n4.sectionIndex,
                isSDF: p3,
                pixelOffsetTL: P2,
                pixelOffsetBR: C2,
                minFontScaleX: 0,
                minFontScaleY: 0
              });
            }
          return c3;
        }(0, r2, l2, i2, a2, o2, n2, t2.allowVerticalPlacement), g2 = t2.textSizeData;
        let x2 = null;
        g2.kind === "source" ? (x2 = [nc * i2.layout.get("text-size").evaluate(o2, {})], x2[0] > ic && A(`${t2.layerIds[0]}: Value for "text-size" is >= ${rc}. Reduce your "text-size".`)) : g2.kind === "composite" && (x2 = [
          nc * d2.compositeTextSizes[0].evaluate(o2, {}, y2),
          nc * d2.compositeTextSizes[1].evaluate(o2, {}, y2)
        ], (x2[0] > ic || x2[1] > ic) && A(`${t2.layerIds[0]}: Value for "text-size" is >= ${rc}. Reduce your "text-size".`)), t2.addSymbols(t2.text, m2, x2, l2, a2, o2, c2, e2, u2.lineStartIndex, u2.lineLength, f2, y2);
        for (const e3 of h2)
          p2[e3] = t2.text.placedSymbolArray.length - 1;
        return 4 * m2.length;
      }
      function Ah(t2) {
        for (const e2 in t2)
          return t2[e2];
        return null;
      }
      function Sh(t2, e2, r2, n2) {
        const i2 = t2.compareText;
        if (e2 in i2) {
          const t3 = i2[e2];
          for (let e3 = t3.length - 1;e3 >= 0; e3--)
            if (n2.dist(t3[e3]) < r2)
              return true;
        } else
          i2[e2] = [];
        return i2[e2].push(n2), false;
      }
      const kh = [
        Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array
      ];

      class Mh {
        static from(t2) {
          if (!(t2 instanceof ArrayBuffer))
            throw new Error("Data must be an instance of ArrayBuffer.");
          const [e2, r2] = new Uint8Array(t2, 0, 2);
          if (e2 !== 219)
            throw new Error("Data does not appear to be in a KDBush format.");
          const n2 = r2 >> 4;
          if (n2 !== 1)
            throw new Error(`Got v${n2} data when expected v1.`);
          const i2 = kh[15 & r2];
          if (!i2)
            throw new Error("Unrecognized array type.");
          const [s2] = new Uint16Array(t2, 2, 1), [a2] = new Uint32Array(t2, 4, 1);
          return new Mh(a2, s2, i2, t2);
        }
        constructor(t2, e2 = 64, r2 = Float64Array, n2) {
          if (isNaN(t2) || t2 < 0)
            throw new Error(`Unpexpected numItems value: ${t2}.`);
          this.numItems = +t2, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t2 < 65536 ? Uint16Array : Uint32Array;
          const i2 = kh.indexOf(this.ArrayType), s2 = 2 * t2 * this.ArrayType.BYTES_PER_ELEMENT, a2 = t2 * this.IndexArrayType.BYTES_PER_ELEMENT, o2 = (8 - a2 % 8) % 8;
          if (i2 < 0)
            throw new Error(`Unexpected typed array class: ${r2}.`);
          n2 && n2 instanceof ArrayBuffer ? (this.data = n2, this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 2 * t2, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + a2 + o2), this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + a2 + o2, 2 * t2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t2);
        }
        add(t2, e2) {
          const r2 = this._pos >> 1;
          return this.ids[r2] = r2, this.coords[this._pos++] = t2, this.coords[this._pos++] = e2, r2;
        }
        finish() {
          const t2 = this._pos >> 1;
          if (t2 !== this.numItems)
            throw new Error(`Added ${t2} items when expected ${this.numItems}.`);
          return Ih(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
        }
        range(t2, e2, r2, n2) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: i2, coords: s2, nodeSize: a2 } = this, o2 = [0, i2.length - 1, 0], l2 = [];
          for (;o2.length; ) {
            const u2 = o2.pop() || 0, c2 = o2.pop() || 0, h2 = o2.pop() || 0;
            if (c2 - h2 <= a2) {
              for (let a3 = h2;a3 <= c2; a3++) {
                const o3 = s2[2 * a3], u3 = s2[2 * a3 + 1];
                o3 >= t2 && o3 <= r2 && u3 >= e2 && u3 <= n2 && l2.push(i2[a3]);
              }
              continue;
            }
            const p2 = h2 + c2 >> 1, f2 = s2[2 * p2], d2 = s2[2 * p2 + 1];
            f2 >= t2 && f2 <= r2 && d2 >= e2 && d2 <= n2 && l2.push(i2[p2]), (u2 === 0 ? t2 <= f2 : e2 <= d2) && (o2.push(h2), o2.push(p2 - 1), o2.push(1 - u2)), (u2 === 0 ? r2 >= f2 : n2 >= d2) && (o2.push(p2 + 1), o2.push(c2), o2.push(1 - u2));
          }
          return l2;
        }
        within(t2, e2, r2) {
          if (!this._finished)
            throw new Error("Data not yet indexed - call index.finish().");
          const { ids: n2, coords: i2, nodeSize: s2 } = this, a2 = [0, n2.length - 1, 0], o2 = [], l2 = r2 * r2;
          for (;a2.length; ) {
            const u2 = a2.pop() || 0, c2 = a2.pop() || 0, h2 = a2.pop() || 0;
            if (c2 - h2 <= s2) {
              for (let r3 = h2;r3 <= c2; r3++)
                Bh(i2[2 * r3], i2[2 * r3 + 1], t2, e2) <= l2 && o2.push(n2[r3]);
              continue;
            }
            const p2 = h2 + c2 >> 1, f2 = i2[2 * p2], d2 = i2[2 * p2 + 1];
            Bh(f2, d2, t2, e2) <= l2 && o2.push(n2[p2]), (u2 === 0 ? t2 - r2 <= f2 : e2 - r2 <= d2) && (a2.push(h2), a2.push(p2 - 1), a2.push(1 - u2)), (u2 === 0 ? t2 + r2 >= f2 : e2 + r2 >= d2) && (a2.push(p2 + 1), a2.push(c2), a2.push(1 - u2));
          }
          return o2;
        }
      }
      function Ih(t2, e2, r2, n2, i2, s2) {
        if (i2 - n2 <= r2)
          return;
        const a2 = n2 + i2 >> 1;
        zh(t2, e2, a2, n2, i2, s2), Ih(t2, e2, r2, n2, a2 - 1, 1 - s2), Ih(t2, e2, r2, a2 + 1, i2, 1 - s2);
      }
      function zh(t2, e2, r2, n2, i2, s2) {
        for (;i2 > n2; ) {
          if (i2 - n2 > 600) {
            const a3 = i2 - n2 + 1, o3 = r2 - n2 + 1, l3 = Math.log(a3), u2 = 0.5 * Math.exp(2 * l3 / 3), c2 = 0.5 * Math.sqrt(l3 * u2 * (a3 - u2) / a3) * (o3 - a3 / 2 < 0 ? -1 : 1);
            zh(t2, e2, r2, Math.max(n2, Math.floor(r2 - o3 * u2 / a3 + c2)), Math.min(i2, Math.floor(r2 + (a3 - o3) * u2 / a3 + c2)), s2);
          }
          const a2 = e2[2 * r2 + s2];
          let o2 = n2, l2 = i2;
          for (Ph(t2, e2, n2, r2), e2[2 * i2 + s2] > a2 && Ph(t2, e2, n2, i2);o2 < l2; ) {
            for (Ph(t2, e2, o2, l2), o2++, l2--;e2[2 * o2 + s2] < a2; )
              o2++;
            for (;e2[2 * l2 + s2] > a2; )
              l2--;
          }
          e2[2 * n2 + s2] === a2 ? Ph(t2, e2, n2, l2) : (l2++, Ph(t2, e2, l2, i2)), l2 <= r2 && (n2 = l2 + 1), r2 <= l2 && (i2 = l2 - 1);
        }
      }
      function Ph(t2, e2, r2, n2) {
        Ch(t2, r2, n2), Ch(e2, 2 * r2, 2 * n2), Ch(e2, 2 * r2 + 1, 2 * n2 + 1);
      }
      function Ch(t2, e2, r2) {
        const n2 = t2[e2];
        t2[e2] = t2[r2], t2[r2] = n2;
      }
      function Bh(t2, e2, r2, n2) {
        const i2 = t2 - r2, s2 = e2 - n2;
        return i2 * i2 + s2 * s2;
      }
      var Vh;
      t.bg = undefined, (Vh = t.bg || (t.bg = {})).create = "create", Vh.load = "load", Vh.fullLoad = "fullLoad";
      let Eh = null, Fh = [];
      const Th = 1000 / 60, $h = "loadTime", Lh = "fullLoadTime", Dh = {
        mark(t2) {
          performance.mark(t2);
        },
        frame(t2) {
          const e2 = t2;
          Eh != null && Fh.push(e2 - Eh), Eh = e2;
        },
        clearMetrics() {
          Eh = null, Fh = [], performance.clearMeasures($h), performance.clearMeasures(Lh);
          for (const e2 in t.bg)
            performance.clearMarks(t.bg[e2]);
        },
        getPerformanceMetrics() {
          performance.measure($h, t.bg.create, t.bg.load), performance.measure(Lh, t.bg.create, t.bg.fullLoad);
          const e2 = performance.getEntriesByName($h)[0].duration, r2 = performance.getEntriesByName(Lh)[0].duration, n2 = Fh.length, i2 = 1 / (Fh.reduce((t2, e3) => t2 + e3, 0) / n2 / 1000), s2 = Fh.filter((t2) => t2 > Th).reduce((t2, e3) => t2 + (e3 - Th) / Th, 0);
          return {
            loadTime: e2,
            fullLoadTime: r2,
            fps: i2,
            percentDroppedFrames: s2 / (n2 + s2) * 100,
            totalFrames: n2
          };
        }
      };
      t.$ = class extends ps {
      }, t.A = oo, t.B = yi, t.C = function(t2) {
        if (M == null) {
          const e2 = t2.navigator ? t2.navigator.userAgent : null;
          M = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
        }
        return M;
      }, t.D = Ji, t.E = Z, t.F = class {
        constructor(t2, e2) {
          this.target = t2, this.mapId = e2, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new Ic(() => this.process()), this.subscription = function(t3, e3, r2, n2) {
            return t3.addEventListener(e3, r2, false), {
              unsubscribe: () => {
                t3.removeEventListener(e3, r2, false);
              }
            };
          }(this.target, "message", (t3) => this.receive(t3)), this.globalScope = k(self) ? t2 : window;
        }
        registerMessageHandler(t2, e2) {
          this.messageHandlers[t2] = e2;
        }
        sendAsync(t2, e2) {
          return new Promise((r2, n2) => {
            const i2 = Math.round(1000000000000000000 * Math.random()).toString(36).substring(0, 10);
            this.resolveRejects[i2] = { resolve: r2, reject: n2 }, e2 && e2.signal.addEventListener("abort", () => {
              delete this.resolveRejects[i2];
              const e3 = {
                id: i2,
                type: "<cancel>",
                origin: location.origin,
                targetMapId: t2.targetMapId,
                sourceMapId: this.mapId
              };
              this.target.postMessage(e3);
            }, { once: true });
            const s2 = [], a2 = Object.assign(Object.assign({}, t2), {
              id: i2,
              sourceMapId: this.mapId,
              origin: location.origin,
              data: ki(t2.data, s2)
            });
            this.target.postMessage(a2, { transfer: s2 });
          });
        }
        receive(t2) {
          const e2 = t2.data, r2 = e2.id;
          if (!(e2.origin !== "file://" && location.origin !== "file://" && e2.origin !== "resource://android" && location.origin !== "resource://android" && e2.origin !== location.origin || e2.targetMapId && this.mapId !== e2.targetMapId)) {
            if (e2.type === "<cancel>") {
              delete this.tasks[r2];
              const t3 = this.abortControllers[r2];
              return delete this.abortControllers[r2], void (t3 && t3.abort());
            }
            if (k(self) || e2.mustQueue)
              return this.tasks[r2] = e2, this.taskQueue.push(r2), void this.invoker.trigger();
            this.processTask(r2, e2);
          }
        }
        process() {
          if (this.taskQueue.length === 0)
            return;
          const t2 = this.taskQueue.shift(), e2 = this.tasks[t2];
          delete this.tasks[t2], this.taskQueue.length > 0 && this.invoker.trigger(), e2 && this.processTask(t2, e2);
        }
        processTask(t2, r2) {
          return e(this, undefined, undefined, function* () {
            if (r2.type === "<response>") {
              const e3 = this.resolveRejects[t2];
              if (delete this.resolveRejects[t2], !e3)
                return;
              return void (r2.error ? e3.reject(Mi(r2.error)) : e3.resolve(Mi(r2.data)));
            }
            if (!this.messageHandlers[r2.type])
              return void this.completeTask(t2, new Error(`Could not find a registered handler for ${r2.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
            const e2 = Mi(r2.data), n2 = new AbortController;
            this.abortControllers[t2] = n2;
            try {
              const i2 = yield this.messageHandlers[r2.type](r2.sourceMapId, e2, n2);
              this.completeTask(t2, null, i2);
            } catch (e3) {
              this.completeTask(t2, e3);
            }
          });
        }
        completeTask(t2, e2, r2) {
          const n2 = [];
          delete this.abortControllers[t2];
          const i2 = {
            id: t2,
            type: "<response>",
            sourceMapId: this.mapId,
            origin: location.origin,
            error: e2 ? ki(e2) : null,
            data: ki(r2, n2)
          };
          this.target.postMessage(i2, { transfer: n2 });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, t.G = $, t.H = function() {
        var t2 = new oo(16);
        return oo != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
      }, t.I = Tu, t.J = function(t2, e2, r2) {
        var n2, i2, s2, a2, o2, l2, u2, c2, h2, p2, f2, d2, y2 = r2[0], m2 = r2[1], g2 = r2[2];
        return e2 === t2 ? (t2[12] = e2[0] * y2 + e2[4] * m2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * y2 + e2[5] * m2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * y2 + e2[6] * m2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * y2 + e2[7] * m2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], a2 = e2[3], o2 = e2[4], l2 = e2[5], u2 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = a2, t2[4] = o2, t2[5] = l2, t2[6] = u2, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * y2 + o2 * m2 + h2 * g2 + e2[12], t2[13] = i2 * y2 + l2 * m2 + p2 * g2 + e2[13], t2[14] = s2 * y2 + u2 * m2 + f2 * g2 + e2[14], t2[15] = a2 * y2 + c2 * m2 + d2 * g2 + e2[15]), t2;
      }, t.K = function(t2, e2, r2) {
        var n2 = r2[0], i2 = r2[1], s2 = r2[2];
        return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
      }, t.L = uo, t.M = function(t2, e2) {
        const r2 = {};
        for (let n2 = 0;n2 < e2.length; n2++) {
          const i2 = e2[n2];
          i2 in t2 && (r2[i2] = t2[i2]);
        }
        return r2;
      }, t.N = Pc, t.O = Vc, t.P = s, t.Q = Ec, t.R = Ao, t.S = jc, t.T = Zi, t.U = h, t.V = p, t.W = P, t.X = $a, t.Y = ls, t.Z = $c, t._ = e, t.a = F, t.a$ = function(t2, e2) {
        var r2 = t2[0], n2 = t2[1], i2 = t2[2], s2 = t2[3], a2 = t2[4], o2 = t2[5], l2 = t2[6], u2 = t2[7], c2 = t2[8], h2 = t2[9], p2 = t2[10], f2 = t2[11], d2 = t2[12], y2 = t2[13], m2 = t2[14], g2 = t2[15], x2 = e2[0], v2 = e2[1], b2 = e2[2], w2 = e2[3], _2 = e2[4], A2 = e2[5], S2 = e2[6], k2 = e2[7], M2 = e2[8], I2 = e2[9], z2 = e2[10], P2 = e2[11], C2 = e2[12], B2 = e2[13], V2 = e2[14], E2 = e2[15];
        return Math.abs(r2 - x2) <= ao * Math.max(1, Math.abs(r2), Math.abs(x2)) && Math.abs(n2 - v2) <= ao * Math.max(1, Math.abs(n2), Math.abs(v2)) && Math.abs(i2 - b2) <= ao * Math.max(1, Math.abs(i2), Math.abs(b2)) && Math.abs(s2 - w2) <= ao * Math.max(1, Math.abs(s2), Math.abs(w2)) && Math.abs(a2 - _2) <= ao * Math.max(1, Math.abs(a2), Math.abs(_2)) && Math.abs(o2 - A2) <= ao * Math.max(1, Math.abs(o2), Math.abs(A2)) && Math.abs(l2 - S2) <= ao * Math.max(1, Math.abs(l2), Math.abs(S2)) && Math.abs(u2 - k2) <= ao * Math.max(1, Math.abs(u2), Math.abs(k2)) && Math.abs(c2 - M2) <= ao * Math.max(1, Math.abs(c2), Math.abs(M2)) && Math.abs(h2 - I2) <= ao * Math.max(1, Math.abs(h2), Math.abs(I2)) && Math.abs(p2 - z2) <= ao * Math.max(1, Math.abs(p2), Math.abs(z2)) && Math.abs(f2 - P2) <= ao * Math.max(1, Math.abs(f2), Math.abs(P2)) && Math.abs(d2 - C2) <= ao * Math.max(1, Math.abs(d2), Math.abs(C2)) && Math.abs(y2 - B2) <= ao * Math.max(1, Math.abs(y2), Math.abs(B2)) && Math.abs(m2 - V2) <= ao * Math.max(1, Math.abs(m2), Math.abs(V2)) && Math.abs(g2 - E2) <= ao * Math.max(1, Math.abs(g2), Math.abs(E2));
      }, t.a0 = oa, t.a1 = Dc, t.a2 = it, t.a3 = (t2) => {
        const e2 = window.document.createElement("video");
        return e2.muted = true, new Promise((r2) => {
          e2.onloadstart = () => {
            r2(e2);
          };
          for (const r3 of t2) {
            const t3 = window.document.createElement("source");
            j(r3) || (e2.crossOrigin = "Anonymous"), t3.src = r3, e2.appendChild(t3);
          }
        });
      }, t.a4 = function() {
        return x++;
      }, t.a5 = Fs, t.a6 = dc, t.a7 = zn, t.a8 = ja, t.a9 = Nc, t.aA = function(t2) {
        if (t2.type === "custom")
          return new Mc(t2);
        switch (t2.type) {
          case "background":
            return new _c(t2);
          case "circle":
            return new fo(t2);
          case "fill":
            return new ul(t2);
          case "fill-extrusion":
            return new El(t2);
          case "heatmap":
            return new Mo(t2);
          case "hillshade":
            return new Po(t2);
          case "line":
            return new Hl(t2);
          case "raster":
            return new kc(t2);
          case "symbol":
            return new vc(t2);
        }
      }, t.aB = w, t.aC = function(t2, e2) {
        if (!t2)
          return [{ command: "setStyle", args: [e2] }];
        let r2 = [];
        try {
          if (!H(t2.version, e2.version))
            return [{ command: "setStyle", args: [e2] }];
          H(t2.center, e2.center) || r2.push({ command: "setCenter", args: [e2.center] }), H(t2.zoom, e2.zoom) || r2.push({ command: "setZoom", args: [e2.zoom] }), H(t2.bearing, e2.bearing) || r2.push({ command: "setBearing", args: [e2.bearing] }), H(t2.pitch, e2.pitch) || r2.push({ command: "setPitch", args: [e2.pitch] }), H(t2.sprite, e2.sprite) || r2.push({ command: "setSprite", args: [e2.sprite] }), H(t2.glyphs, e2.glyphs) || r2.push({ command: "setGlyphs", args: [e2.glyphs] }), H(t2.transition, e2.transition) || r2.push({ command: "setTransition", args: [e2.transition] }), H(t2.light, e2.light) || r2.push({ command: "setLight", args: [e2.light] }), H(t2.terrain, e2.terrain) || r2.push({ command: "setTerrain", args: [e2.terrain] }), H(t2.sky, e2.sky) || r2.push({ command: "setSky", args: [e2.sky] }), H(t2.projection, e2.projection) || r2.push({ command: "setProjection", args: [e2.projection] });
          const n2 = {}, i2 = [];
          (function(t3, e3, r3, n3) {
            let i3;
            for (i3 in e3 = e3 || {}, t3 = t3 || {})
              Object.prototype.hasOwnProperty.call(t3, i3) && (Object.prototype.hasOwnProperty.call(e3, i3) || W(i3, r3, n3));
            for (i3 in e3)
              Object.prototype.hasOwnProperty.call(e3, i3) && (Object.prototype.hasOwnProperty.call(t3, i3) ? H(t3[i3], e3[i3]) || (t3[i3].type === "geojson" && e3[i3].type === "geojson" && tt(t3, e3, i3) ? Y(r3, { command: "setGeoJSONSourceData", args: [i3, e3[i3].data] }) : Q(i3, e3, r3, n3)) : J(i3, e3, r3));
          })(t2.sources, e2.sources, i2, n2);
          const s2 = [];
          t2.layers && t2.layers.forEach((t3) => {
            "source" in t3 && n2[t3.source] ? r2.push({ command: "removeLayer", args: [t3.id] }) : s2.push(t3);
          }), r2 = r2.concat(i2), function(t3, e3, r3) {
            e3 = e3 || [];
            const n3 = (t3 = t3 || []).map(rt), i3 = e3.map(rt), s3 = t3.reduce(nt, {}), a2 = e3.reduce(nt, {}), o2 = n3.slice(), l2 = Object.create(null);
            let u2, c2, h2, p2, f2;
            for (let t4 = 0, e4 = 0;t4 < n3.length; t4++)
              u2 = n3[t4], Object.prototype.hasOwnProperty.call(a2, u2) ? e4++ : (Y(r3, { command: "removeLayer", args: [u2] }), o2.splice(o2.indexOf(u2, e4), 1));
            for (let t4 = 0, e4 = 0;t4 < i3.length; t4++)
              u2 = i3[i3.length - 1 - t4], o2[o2.length - 1 - t4] !== u2 && (Object.prototype.hasOwnProperty.call(s3, u2) ? (Y(r3, { command: "removeLayer", args: [u2] }), o2.splice(o2.lastIndexOf(u2, o2.length - e4), 1)) : e4++, p2 = o2[o2.length - t4], Y(r3, { command: "addLayer", args: [a2[u2], p2] }), o2.splice(o2.length - t4, 0, u2), l2[u2] = true);
            for (let t4 = 0;t4 < i3.length; t4++)
              if (u2 = i3[t4], c2 = s3[u2], h2 = a2[u2], !l2[u2] && !H(c2, h2))
                if (H(c2.source, h2.source) && H(c2["source-layer"], h2["source-layer"]) && H(c2.type, h2.type)) {
                  for (f2 in et(c2.layout, h2.layout, r3, u2, null, "setLayoutProperty"), et(c2.paint, h2.paint, r3, u2, null, "setPaintProperty"), H(c2.filter, h2.filter) || Y(r3, { command: "setFilter", args: [u2, h2.filter] }), H(c2.minzoom, h2.minzoom) && H(c2.maxzoom, h2.maxzoom) || Y(r3, {
                    command: "setLayerZoomRange",
                    args: [u2, h2.minzoom, h2.maxzoom]
                  }), c2)
                    Object.prototype.hasOwnProperty.call(c2, f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? et(c2[f2], h2[f2], r3, u2, f2.slice(6), "setPaintProperty") : H(c2[f2], h2[f2]) || Y(r3, { command: "setLayerProperty", args: [u2, f2, h2[f2]] }));
                  for (f2 in h2)
                    Object.prototype.hasOwnProperty.call(h2, f2) && !Object.prototype.hasOwnProperty.call(c2, f2) && f2 !== "layout" && f2 !== "paint" && f2 !== "filter" && f2 !== "metadata" && f2 !== "minzoom" && f2 !== "maxzoom" && (f2.indexOf("paint.") === 0 ? et(c2[f2], h2[f2], r3, u2, f2.slice(6), "setPaintProperty") : H(c2[f2], h2[f2]) || Y(r3, { command: "setLayerProperty", args: [u2, f2, h2[f2]] }));
                } else
                  Y(r3, { command: "removeLayer", args: [u2] }), p2 = o2[o2.lastIndexOf(u2) + 1], Y(r3, { command: "addLayer", args: [h2, p2] });
          }(s2, e2.layers, r2);
        } catch (t3) {
          console.warn("Unable to compute style diff:", t3), r2 = [{ command: "setStyle", args: [e2] }];
        }
        return r2;
      }, t.aD = function(t2) {
        const e2 = [], r2 = t2.id;
        return r2 === undefined && e2.push({ message: `layers.${r2}: missing required property "id"` }), t2.render === undefined && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && t2.renderingMode !== "2d" && t2.renderingMode !== "3d" && e2.push({
          message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"`
        }), e2;
      }, t.aE = function t(e2, r2) {
        if (Array.isArray(e2)) {
          if (!Array.isArray(r2) || e2.length !== r2.length)
            return false;
          for (let n2 = 0;n2 < e2.length; n2++)
            if (!t(e2[n2], r2[n2]))
              return false;
          return true;
        }
        if (typeof e2 == "object" && e2 !== null && r2 !== null) {
          if (typeof r2 != "object")
            return false;
          if (Object.keys(e2).length !== Object.keys(r2).length)
            return false;
          for (const n2 in e2)
            if (!t(e2[n2], r2[n2]))
              return false;
          return true;
        }
        return e2 === r2;
      }, t.aF = v, t.aG = b, t.aH = class extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = 0;
        }
        set(t2) {
          this.current !== t2 && (this.current = t2, this.gl.uniform1i(this.location, t2));
        }
      }, t.aI = _a, t.aJ = class extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = ka;
        }
        set(t2) {
          if (t2[12] !== this.current[12] || t2[0] !== this.current[0])
            return this.current = t2, void this.gl.uniformMatrix4fv(this.location, false, t2);
          for (let e2 = 1;e2 < 16; e2++)
            if (t2[e2] !== this.current[e2]) {
              this.current = t2, this.gl.uniformMatrix4fv(this.location, false, t2);
              break;
            }
        }
      }, t.aK = Aa, t.aL = Sa, t.aM = Kt, t.aN = class extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = [0, 0, 0];
        }
        set(t2) {
          t2[0] === this.current[0] && t2[1] === this.current[1] && t2[2] === this.current[2] || (this.current = t2, this.gl.uniform3f(this.location, t2[0], t2[1], t2[2]));
        }
      }, t.aO = class extends wa {
        constructor(t2, e2) {
          super(t2, e2), this.current = [0, 0];
        }
        set(t2) {
          t2[0] === this.current[0] && t2[1] === this.current[1] || (this.current = t2, this.gl.uniform2f(this.location, t2[0], t2[1]));
        }
      }, t.aP = function(t2, e2, r2, n2, i2, s2, a2) {
        var o2 = 1 / (e2 - r2), l2 = 1 / (n2 - i2), u2 = 1 / (s2 - a2);
        return t2[0] = -2 * o2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u2, t2[11] = 0, t2[12] = (e2 + r2) * o2, t2[13] = (i2 + n2) * l2, t2[14] = (a2 + s2) * u2, t2[15] = 1, t2;
      }, t.aQ = ho, t.aR = class extends _s {
      }, t.aS = eu, t.aT = class extends Ss {
      }, t.aU = ko, t.aV = function(t2) {
        return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
      }, t.aW = So, t.aX = Zs, t.aY = na, t.aZ = class extends Bs {
      }, t.a_ = function(t2, e2) {
        return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3] && t2[4] === e2[4] && t2[5] === e2[5] && t2[6] === e2[6] && t2[7] === e2[7] && t2[8] === e2[8] && t2[9] === e2[9] && t2[10] === e2[10] && t2[11] === e2[11] && t2[12] === e2[12] && t2[13] === e2[13] && t2[14] === e2[14] && t2[15] === e2[15];
      }, t.aa = function(t2) {
        const e2 = {};
        if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
          const s2 = n2 || i2;
          return e2[r2] = !s2 || s2.toLowerCase(), "";
        }), e2["max-age"]) {
          const t3 = parseInt(e2["max-age"], 10);
          isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
        }
        return e2;
      }, t.ab = function(t2, e2) {
        const r2 = [];
        for (const n2 in t2)
          n2 in e2 || r2.push(n2);
        return r2;
      }, t.ac = y, t.ad = function(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], a2 = e2[1], o2 = e2[2], l2 = e2[3], u2 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
        return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u2 * n2, t2[1] = a2 * i2 + c2 * n2, t2[2] = o2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u2 * i2 - s2 * n2, t2[5] = c2 * i2 - a2 * n2, t2[6] = h2 * i2 - o2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
      }, t.ae = function(t2) {
        var e2 = new oo(16);
        return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
      }, t.af = po, t.ag = function(t2, e2) {
        let r2 = 0, n2 = 0;
        if (t2.kind === "constant")
          n2 = t2.layoutSize;
        else if (t2.kind !== "source") {
          const { interpolationType: i2, minZoom: s2, maxZoom: a2 } = t2, o2 = i2 ? y(Be.interpolationFactor(i2, e2, s2, a2), 0, 1) : 0;
          t2.kind === "camera" ? n2 = Ce.number(t2.minSize, t2.maxSize, o2) : r2 = o2;
        }
        return { uSizeT: r2, uSize: n2 };
      }, t.ai = function(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
        return t2.kind === "source" ? n2 / nc : t2.kind === "composite" ? Ce.number(n2 / nc, i2 / nc, r2) : e2;
      }, t.aj = cc, t.ak = function(t2, e2, r2, n2) {
        const i2 = e2.y - t2.y, a2 = e2.x - t2.x, o2 = n2.y - r2.y, l2 = n2.x - r2.x, u2 = o2 * a2 - l2 * i2;
        if (u2 === 0)
          return null;
        const c2 = (l2 * (t2.y - r2.y) - o2 * (t2.x - r2.x)) / u2;
        return new s(t2.x + c2 * a2, t2.y + c2 * i2);
      }, t.al = Hc, t.am = qa, t.an = lo, t.ao = function(t2) {
        let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
        for (const s2 of t2)
          e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
        return [e2, r2, n2, i2];
      }, t.ap = iu, t.ar = ac, t.as = function(t2, e2) {
        var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], a2 = e2[4], o2 = e2[5], l2 = e2[6], u2 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], f2 = e2[11], d2 = e2[12], y2 = e2[13], m2 = e2[14], g2 = e2[15], x2 = r2 * o2 - n2 * a2, v2 = r2 * l2 - i2 * a2, b2 = r2 * u2 - s2 * a2, w2 = n2 * l2 - i2 * o2, _2 = n2 * u2 - s2 * o2, A2 = i2 * u2 - s2 * l2, S2 = c2 * y2 - h2 * d2, k2 = c2 * m2 - p2 * d2, M2 = c2 * g2 - f2 * d2, I2 = h2 * m2 - p2 * y2, z2 = h2 * g2 - f2 * y2, P2 = p2 * g2 - f2 * m2, C2 = x2 * P2 - v2 * z2 + b2 * I2 + w2 * M2 - _2 * k2 + A2 * S2;
        return C2 ? (t2[0] = (o2 * P2 - l2 * z2 + u2 * I2) * (C2 = 1 / C2), t2[1] = (i2 * z2 - n2 * P2 - s2 * I2) * C2, t2[2] = (y2 * A2 - m2 * _2 + g2 * w2) * C2, t2[3] = (p2 * _2 - h2 * A2 - f2 * w2) * C2, t2[4] = (l2 * M2 - a2 * P2 - u2 * k2) * C2, t2[5] = (r2 * P2 - i2 * M2 + s2 * k2) * C2, t2[6] = (m2 * b2 - d2 * A2 - g2 * v2) * C2, t2[7] = (c2 * A2 - p2 * b2 + f2 * v2) * C2, t2[8] = (a2 * z2 - o2 * M2 + u2 * S2) * C2, t2[9] = (n2 * M2 - r2 * z2 - s2 * S2) * C2, t2[10] = (d2 * _2 - y2 * b2 + g2 * x2) * C2, t2[11] = (h2 * b2 - c2 * _2 - f2 * x2) * C2, t2[12] = (o2 * k2 - a2 * I2 - l2 * S2) * C2, t2[13] = (r2 * I2 - n2 * k2 + i2 * S2) * C2, t2[14] = (y2 * v2 - d2 * w2 - m2 * x2) * C2, t2[15] = (c2 * w2 - h2 * v2 + p2 * x2) * C2, t2) : null;
      }, t.at = bh, t.au = Ju, t.av = Mh, t.aw = function() {
        const t2 = {}, e2 = G.$version;
        for (const r2 in G.$root) {
          const n2 = G.$root[r2];
          if (n2.required) {
            let i2 = null;
            i2 = r2 === "version" ? e2 : n2.type === "array" ? [] : {}, i2 != null && (t2[r2] = i2);
          }
        }
        return t2;
      }, t.ax = Ii, t.ay = D, t.az = function(t2) {
        t2 = t2.slice();
        const e2 = Object.create(null);
        for (let r2 = 0;r2 < t2.length; r2++)
          e2[t2[r2].id] = t2[r2];
        for (let r2 = 0;r2 < t2.length; r2++)
          "ref" in t2[r2] && (t2[r2] = X(t2[r2], e2[t2[r2].ref]));
        return t2;
      }, t.b = I, t.b0 = function(t2, e2) {
        return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
      }, t.b1 = function(t2, e2, r2) {
        return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2[3] = e2[3] * r2[3], t2;
      }, t.b2 = function(t2, e2) {
        return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] * e2[3];
      }, t.b3 = m, t.b4 = Oc, t.b5 = Fc, t.b6 = function(t2, e2, r2, n2, i2) {
        var s2, a2 = 1 / Math.tan(e2 / 2);
        return t2[0] = a2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = a2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, i2 != null && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
      }, t.b7 = function(t2, e2, r2) {
        var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[4], a2 = e2[5], o2 = e2[6], l2 = e2[7], u2 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
        return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u2 * n2, t2[5] = a2 * i2 + c2 * n2, t2[6] = o2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u2 * i2 - s2 * n2, t2[9] = c2 * i2 - a2 * n2, t2[10] = h2 * i2 - o2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
      }, t.b8 = f, t.b9 = d, t.bA = su, t.bB = function(t2) {
        return t2.message === V;
      }, t.bC = bn, t.bD = Ri, t.ba = function(t2) {
        return t2 * Math.PI / 180;
      }, t.bb = function(t2, e2) {
        const { x: r2, y: n2 } = $c.fromLngLat(e2);
        return !(t2 < 0 || t2 > 25 || n2 < 0 || n2 >= 1 || r2 < 0 || r2 >= 1);
      }, t.bc = function(t2, e2) {
        return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
      }, t.bd = class extends hs {
      }, t.be = zc, t.bf = Dh, t.bh = L, t.bi = function(t2, e2) {
        F.REGISTERED_PROTOCOLS[t2] = e2;
      }, t.bj = function(t2) {
        delete F.REGISTERED_PROTOCOLS[t2];
      }, t.bk = function(t2, e2) {
        const r2 = {};
        for (let n3 = 0;n3 < t2.length; n3++) {
          const i2 = e2 && e2[t2[n3].id] || Ln(t2[n3]);
          e2 && (e2[t2[n3].id] = i2);
          let s2 = r2[i2];
          s2 || (s2 = r2[i2] = []), s2.push(t2[n3]);
        }
        const n2 = [];
        for (const t3 in r2)
          n2.push(r2[t3]);
        return n2;
      }, t.bl = wi, t.bm = qc, t.bn = Zc, t.bo = $u, t.bp = function(e2) {
        e2.bucket.createArrays(), e2.bucket.tilePixelRatio = $a / (512 * e2.bucket.overscaling), e2.bucket.compareText = {}, e2.bucket.iconsNeedLinear = false;
        const r2 = e2.bucket.layers[0], n2 = r2.layout, i2 = r2._unevaluatedLayout._values, s2 = {
          layoutIconSize: i2["icon-size"].possiblyEvaluate(new Ui(e2.bucket.zoom + 1), e2.canonical),
          layoutTextSize: i2["text-size"].possiblyEvaluate(new Ui(e2.bucket.zoom + 1), e2.canonical),
          textMaxSize: i2["text-size"].possiblyEvaluate(new Ui(18))
        };
        if (e2.bucket.textSizeData.kind === "composite") {
          const { minZoom: t2, maxZoom: r3 } = e2.bucket.textSizeData;
          s2.compositeTextSizes = [
            i2["text-size"].possiblyEvaluate(new Ui(t2), e2.canonical),
            i2["text-size"].possiblyEvaluate(new Ui(r3), e2.canonical)
          ];
        }
        if (e2.bucket.iconSizeData.kind === "composite") {
          const { minZoom: t2, maxZoom: r3 } = e2.bucket.iconSizeData;
          s2.compositeIconSizes = [
            i2["icon-size"].possiblyEvaluate(new Ui(t2), e2.canonical),
            i2["icon-size"].possiblyEvaluate(new Ui(r3), e2.canonical)
          ];
        }
        const a2 = n2.get("text-line-height") * iu, o2 = n2.get("text-rotation-alignment") !== "viewport" && n2.get("symbol-placement") !== "point", l2 = n2.get("text-keep-upright"), u2 = n2.get("text-size");
        for (const i3 of e2.bucket.features) {
          const c2 = n2.get("text-font").evaluate(i3, {}, e2.canonical).join(","), h2 = u2.evaluate(i3, {}, e2.canonical), p2 = s2.layoutTextSize.evaluate(i3, {}, e2.canonical), f2 = s2.layoutIconSize.evaluate(i3, {}, e2.canonical), d2 = { horizontal: {}, vertical: undefined }, y2 = i3.text;
          let m2, g2 = [0, 0];
          if (y2) {
            const s3 = y2.toString(), u3 = n2.get("text-letter-spacing").evaluate(i3, {}, e2.canonical) * iu, f3 = Ci(s3) ? u3 : 0, m3 = n2.get("text-anchor").evaluate(i3, {}, e2.canonical), x3 = vh(r2, i3, e2.canonical);
            if (!x3) {
              const t2 = n2.get("text-radial-offset").evaluate(i3, {}, e2.canonical);
              g2 = t2 ? xh(m3, [t2 * iu, gh]) : n2.get("text-offset").evaluate(i3, {}, e2.canonical).map((t3) => t3 * iu);
            }
            let v3 = o2 ? "center" : n2.get("text-justify").evaluate(i3, {}, e2.canonical);
            const b2 = n2.get("symbol-placement") === "point" ? n2.get("text-max-width").evaluate(i3, {}, e2.canonical) * iu : 1 / 0, w2 = () => {
              e2.bucket.allowVerticalPlacement && Pi(s3) && (d2.vertical = Ru(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, "left", f3, g2, t.ah.vertical, true, p2, h2));
            };
            if (!o2 && x3) {
              const r3 = new Set;
              if (v3 === "auto")
                for (let t2 = 0;t2 < x3.values.length; t2 += 2)
                  r3.add(bh(x3.values[t2]));
              else
                r3.add(v3);
              let n3 = false;
              for (const i4 of r3)
                if (!d2.horizontal[i4])
                  if (n3)
                    d2.horizontal[i4] = d2.horizontal[0];
                  else {
                    const r4 = Ru(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, "center", i4, f3, g2, t.ah.horizontal, false, p2, h2);
                    r4 && (d2.horizontal[i4] = r4, n3 = r4.positionedLines.length === 1);
                  }
              w2();
            } else {
              v3 === "auto" && (v3 = bh(m3));
              const r3 = Ru(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, v3, f3, g2, t.ah.horizontal, false, p2, h2);
              r3 && (d2.horizontal[v3] = r3), w2(), Pi(s3) && o2 && l2 && (d2.vertical = Ru(y2, e2.glyphMap, e2.glyphPositions, e2.imagePositions, c2, b2, a2, m3, v3, f3, g2, t.ah.vertical, false, p2, h2));
            }
          }
          let x2 = false;
          if (i3.icon && i3.icon.name) {
            const t2 = e2.imageMap[i3.icon.name];
            t2 && (m2 = Qu(e2.imagePositions[i3.icon.name], n2.get("icon-offset").evaluate(i3, {}, e2.canonical), n2.get("icon-anchor").evaluate(i3, {}, e2.canonical)), x2 = !!t2.sdf, e2.bucket.sdfIcons === undefined ? e2.bucket.sdfIcons = x2 : e2.bucket.sdfIcons !== x2 && A("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t2.pixelRatio !== e2.bucket.pixelRatio || n2.get("icon-rotate").constantOr(1) !== 0) && (e2.bucket.iconsNeedLinear = true));
          }
          const v2 = Ah(d2.horizontal) || d2.vertical;
          e2.bucket.iconsInText = !!v2 && v2.iconsInText, (v2 || m2) && wh(e2.bucket, i3, d2, m2, e2.imageMap, s2, p2, f2, g2, x2, e2.canonical);
        }
        e2.showCollisionBoxes && e2.bucket.generateCollisionDebugBuffers();
      }, t.bq = ql, t.br = sl, t.bs = zl, t.bt = fl, t.bu = Iu, t.bv = class {
        constructor(t2) {
          this._marks = {
            start: [t2.url, "start"].join("#"),
            end: [t2.url, "end"].join("#"),
            measure: t2.url.toString()
          }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let t2 = performance.getEntriesByName(this._marks.measure);
          return t2.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t2;
        }
      }, t.bw = function(t2, r2, n2, i2, s2) {
        return e(this, undefined, undefined, function* () {
          if (p())
            try {
              return yield P(t2, r2, n2, i2, s2);
            } catch (t3) {
            }
          return function(t3, e2, r3, n3, i3) {
            const { width: s3, height: a2 } = t3;
            C && B || (C = new OffscreenCanvas(s3, a2), B = C.getContext("2d", { willReadFrequently: true })), C.width = s3, C.height = a2, B.drawImage(t3, 0, 0, s3, a2);
            const o2 = B.getImageData(e2, r3, n3, i3);
            return B.clearRect(0, 0, s3, a2), o2.data;
          }(t2, r2, n2, i2, s2);
        });
      }, t.bx = Uc, t.by = r, t.bz = n, t.c = E, t.d = (t2) => e(undefined, undefined, undefined, function* () {
        if (t2.byteLength === 0)
          return createImageBitmap(new ImageData(1, 1));
        const e2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
        try {
          return createImageBitmap(e2);
        } catch (t3) {
          throw new Error(`Could not load image because of ${t3.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      }), t.e = g, t.f = (t2) => new Promise((e2, r2) => {
        const n2 = new Image;
        n2.onload = () => {
          e2(n2), URL.revokeObjectURL(n2.src), n2.onload = null, window.requestAnimationFrame(() => {
            n2.src = z;
          });
        }, n2.onerror = () => r2(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const i2 = new Blob([new Uint8Array(t2)], { type: "image/png" });
        n2.src = t2.byteLength ? URL.createObjectURL(i2) : z;
      }), t.g = T, t.h = (t2, e2) => O(g(t2, { type: "json" }), e2), t.i = k, t.j = N, t.k = q, t.l = (t2, e2) => O(g(t2, { type: "arrayBuffer" }), e2), t.m = O, t.n = function(t2) {
        return new Iu(t2).readFields(Pu, []);
      }, t.o = _o, t.p = Eu, t.q = rs, t.r = di, t.s = j, t.t = xi, t.u = fi, t.v = G, t.w = A, t.x = function([t2, e2, r2]) {
        return e2 += 90, e2 *= Math.PI / 180, r2 *= Math.PI / 180, {
          x: t2 * Math.cos(e2) * Math.sin(r2),
          y: t2 * Math.sin(e2) * Math.sin(r2),
          z: t2 * Math.cos(r2)
        };
      }, t.y = Ce, t.z = Ui;
    });
    define2("worker", ["./shared"], function(e) {

      class t {
        constructor(e2) {
          this.keyCache = {}, e2 && this.replace(e2);
        }
        replace(e2) {
          this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
        }
        update(t2, o2) {
          for (const o3 of t2) {
            this._layerConfigs[o3.id] = o3;
            const t3 = this._layers[o3.id] = e.aA(o3);
            t3._featureFilter = e.a7(t3.filter), this.keyCache[o3.id] && delete this.keyCache[o3.id];
          }
          for (const e2 of o2)
            delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
          this.familiesBySource = {};
          const i2 = e.bk(Object.values(this._layerConfigs), this.keyCache);
          for (const e2 of i2) {
            const t3 = e2.map((e3) => this._layers[e3.id]), o3 = t3[0];
            if (o3.visibility === "none")
              continue;
            const i3 = o3.source || "";
            let s2 = this.familiesBySource[i3];
            s2 || (s2 = this.familiesBySource[i3] = {});
            const r2 = o3.sourceLayer || "_geojsonTileLayer";
            let n2 = s2[r2];
            n2 || (n2 = s2[r2] = []), n2.push(t3);
          }
        }
      }

      class o {
        constructor(t2) {
          const o2 = {}, i2 = [];
          for (const e2 in t2) {
            const s3 = t2[e2], r3 = o2[e2] = {};
            for (const e3 in s3) {
              const t3 = s3[+e3];
              if (!t3 || t3.bitmap.width === 0 || t3.bitmap.height === 0)
                continue;
              const o3 = { x: 0, y: 0, w: t3.bitmap.width + 2, h: t3.bitmap.height + 2 };
              i2.push(o3), r3[e3] = { rect: o3, metrics: t3.metrics };
            }
          }
          const { w: s2, h: r2 } = e.p(i2), n2 = new e.o({ width: s2 || 1, height: r2 || 1 });
          for (const i3 in t2) {
            const s3 = t2[i3];
            for (const t3 in s3) {
              const r3 = s3[+t3];
              if (!r3 || r3.bitmap.width === 0 || r3.bitmap.height === 0)
                continue;
              const a2 = o2[i3][t3].rect;
              e.o.copy(r3.bitmap, n2, { x: 0, y: 0 }, { x: a2.x + 1, y: a2.y + 1 }, r3.bitmap);
            }
          }
          this.image = n2, this.positions = o2;
        }
      }
      e.bl("GlyphAtlas", o);

      class i {
        constructor(t2) {
          this.tileID = new e.S(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId, this.inFlightDependencies = [];
        }
        parse(t2, i2, r2, n2) {
          return e._(this, undefined, undefined, function* () {
            this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.a5;
            const a2 = new e.bm(Object.keys(t2.layers).sort()), l2 = new e.bn(this.tileID, this.promoteId);
            l2.bucketLayerIDs = [];
            const c2 = {}, u2 = {
              featureIndex: l2,
              iconDependencies: {},
              patternDependencies: {},
              glyphDependencies: {},
              availableImages: r2
            }, h2 = i2.familiesBySource[this.source];
            for (const o2 in h2) {
              const i3 = t2.layers[o2];
              if (!i3)
                continue;
              i3.version === 1 && e.w(`Vector tile source "${this.source}" layer "${o2}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const n3 = a2.encode(o2), d3 = [];
              for (let e2 = 0;e2 < i3.length; e2++) {
                const t3 = i3.feature(e2), s2 = l2.getId(t3, o2);
                d3.push({ feature: t3, id: s2, index: e2, sourceLayerIndex: n3 });
              }
              for (const t3 of h2[o2]) {
                const o3 = t3[0];
                o3.source !== this.source && e.w(`layer.source = ${o3.source} does not equal this.source = ${this.source}`), o3.minzoom && this.zoom < Math.floor(o3.minzoom) || o3.maxzoom && this.zoom >= o3.maxzoom || o3.visibility !== "none" && (s(t3, this.zoom, r2), (c2[o3.id] = o3.createBucket({
                  index: l2.bucketLayerIDs.length,
                  layers: t3,
                  zoom: this.zoom,
                  pixelRatio: this.pixelRatio,
                  overscaling: this.overscaling,
                  collisionBoxArray: this.collisionBoxArray,
                  sourceLayerIndex: n3,
                  sourceID: this.source
                })).populate(d3, u2, this.tileID.canonical), l2.bucketLayerIDs.push(t3.map((e2) => e2.id)));
              }
            }
            const d2 = e.aF(u2.glyphDependencies, (e2) => Object.keys(e2).map(Number));
            this.inFlightDependencies.forEach((e2) => e2 == null ? undefined : e2.abort()), this.inFlightDependencies = [];
            let f2 = Promise.resolve({});
            if (Object.keys(d2).length) {
              const e2 = new AbortController;
              this.inFlightDependencies.push(e2), f2 = n2.sendAsync({
                type: "GG",
                data: {
                  stacks: d2,
                  source: this.source,
                  tileID: this.tileID,
                  type: "glyphs"
                }
              }, e2);
            }
            const g2 = Object.keys(u2.iconDependencies);
            let p2 = Promise.resolve({});
            if (g2.length) {
              const e2 = new AbortController;
              this.inFlightDependencies.push(e2), p2 = n2.sendAsync({
                type: "GI",
                data: {
                  icons: g2,
                  source: this.source,
                  tileID: this.tileID,
                  type: "icons"
                }
              }, e2);
            }
            const m2 = Object.keys(u2.patternDependencies);
            let y2 = Promise.resolve({});
            if (m2.length) {
              const e2 = new AbortController;
              this.inFlightDependencies.push(e2), y2 = n2.sendAsync({
                type: "GI",
                data: {
                  icons: m2,
                  source: this.source,
                  tileID: this.tileID,
                  type: "patterns"
                }
              }, e2);
            }
            const [v2, w2, x2] = yield Promise.all([f2, p2, y2]), b2 = new o(v2), S2 = new e.bo(w2, x2);
            for (const t3 in c2) {
              const o2 = c2[t3];
              o2 instanceof e.a6 ? (s(o2.layers, this.zoom, r2), e.bp({
                bucket: o2,
                glyphMap: v2,
                glyphPositions: b2.positions,
                imageMap: w2,
                imagePositions: S2.iconPositions,
                showCollisionBoxes: this.showCollisionBoxes,
                canonical: this.tileID.canonical
              })) : o2.hasPattern && (o2 instanceof e.bq || o2 instanceof e.br || o2 instanceof e.bs) && (s(o2.layers, this.zoom, r2), o2.addFeatures(u2, this.tileID.canonical, S2.patternPositions));
            }
            return this.status = "done", {
              buckets: Object.values(c2).filter((e2) => !e2.isEmpty()),
              featureIndex: l2,
              collisionBoxArray: this.collisionBoxArray,
              glyphAtlasImage: b2.image,
              imageAtlas: S2,
              glyphMap: this.returnDependencies ? v2 : null,
              iconMap: this.returnDependencies ? w2 : null,
              glyphPositions: this.returnDependencies ? b2.positions : null
            };
          });
        }
      }
      function s(t2, o2, i2) {
        const s2 = new e.z(o2);
        for (const e2 of t2)
          e2.recalculate(s2, i2);
      }

      class r {
        constructor(e2, t2, o2) {
          this.actor = e2, this.layerIndex = t2, this.availableImages = o2, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            const i2 = yield e.l(t2.request, o2);
            try {
              return {
                vectorTile: new e.bt.VectorTile(new e.bu(i2.data)),
                rawData: i2.data,
                cacheControl: i2.cacheControl,
                expires: i2.expires
              };
            } catch (e2) {
              const o3 = new Uint8Array(i2.data);
              let s2 = `Unable to parse the tile at ${t2.request.url}, `;
              throw s2 += o3[0] === 31 && o3[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e2.message}`, new Error(s2);
            }
          });
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const o2 = t2.uid, s2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.bv(t2.request), r2 = new i(t2);
            this.loading[o2] = r2;
            const n2 = new AbortController;
            r2.abort = n2;
            try {
              const i2 = yield this.loadVectorTile(t2, n2);
              if (delete this.loading[o2], !i2)
                return null;
              const a2 = i2.rawData, l2 = {};
              i2.expires && (l2.expires = i2.expires), i2.cacheControl && (l2.cacheControl = i2.cacheControl);
              const c2 = {};
              if (s2) {
                const e2 = s2.finish();
                e2 && (c2.resourceTiming = JSON.parse(JSON.stringify(e2)));
              }
              r2.vectorTile = i2.vectorTile;
              const u2 = r2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor);
              this.loaded[o2] = r2, this.fetching[o2] = {
                rawTileData: a2,
                cacheControl: l2,
                resourceTiming: c2
              };
              try {
                const t3 = yield u2;
                return e.e({ rawTileData: a2.slice(0) }, t3, l2, c2);
              } finally {
                delete this.fetching[o2];
              }
            } catch (e2) {
              throw delete this.loading[o2], r2.status = "done", this.loaded[o2] = r2, e2;
            }
          });
        }
        reloadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const o2 = t2.uid;
            if (!this.loaded || !this.loaded[o2])
              throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
            const i2 = this.loaded[o2];
            if (i2.showCollisionBoxes = t2.showCollisionBoxes, i2.status === "parsing") {
              const t3 = yield i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor);
              let s2;
              if (this.fetching[o2]) {
                const {
                  rawTileData: i3,
                  cacheControl: r2,
                  resourceTiming: n2
                } = this.fetching[o2];
                delete this.fetching[o2], s2 = e.e({ rawTileData: i3.slice(0) }, t3, r2, n2);
              } else
                s2 = t3;
              return s2;
            }
            if (i2.status === "done" && i2.vectorTile)
              return i2.parse(i2.vectorTile, this.layerIndex, this.availableImages, this.actor);
          });
        }
        abortTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = this.loading, o2 = t2.uid;
            e2 && e2[o2] && e2[o2].abort && (e2[o2].abort.abort(), delete e2[o2]);
          });
        }
        removeTile(t2) {
          return e._(this, undefined, undefined, function* () {
            this.loaded && this.loaded[t2.uid] && delete this.loaded[t2.uid];
          });
        }
      }

      class n {
        constructor() {
          this.loaded = {};
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const {
              uid: o2,
              encoding: i2,
              rawImageData: s2,
              redFactor: r2,
              greenFactor: n2,
              blueFactor: a2,
              baseShift: l2
            } = t2, c2 = s2.width + 2, u2 = s2.height + 2, h2 = e.b(s2) ? new e.R({ width: c2, height: u2 }, yield e.bw(s2, -1, -1, c2, u2)) : s2, d2 = new e.bx(o2, h2, i2, r2, n2, a2, l2);
            return this.loaded = this.loaded || {}, this.loaded[o2] = d2, d2;
          });
        }
        removeTile(e2) {
          const t2 = this.loaded, o2 = e2.uid;
          t2 && t2[o2] && delete t2[o2];
        }
      }
      function a(e2, t2) {
        if (e2.length !== 0) {
          l(e2[0], t2);
          for (var o2 = 1;o2 < e2.length; o2++)
            l(e2[o2], !t2);
        }
      }
      function l(e2, t2) {
        for (var o2 = 0, i2 = 0, s2 = 0, r2 = e2.length, n2 = r2 - 1;s2 < r2; n2 = s2++) {
          var a2 = (e2[s2][0] - e2[n2][0]) * (e2[n2][1] + e2[s2][1]), l2 = o2 + a2;
          i2 += Math.abs(o2) >= Math.abs(a2) ? o2 - l2 + a2 : a2 - l2 + o2, o2 = l2;
        }
        o2 + i2 >= 0 != !!t2 && e2.reverse();
      }
      var c = e.by(function e(t2, o2) {
        var i2, s2 = t2 && t2.type;
        if (s2 === "FeatureCollection")
          for (i2 = 0;i2 < t2.features.length; i2++)
            e(t2.features[i2], o2);
        else if (s2 === "GeometryCollection")
          for (i2 = 0;i2 < t2.geometries.length; i2++)
            e(t2.geometries[i2], o2);
        else if (s2 === "Feature")
          e(t2.geometry, o2);
        else if (s2 === "Polygon")
          a(t2.coordinates, o2);
        else if (s2 === "MultiPolygon")
          for (i2 = 0;i2 < t2.coordinates.length; i2++)
            a(t2.coordinates[i2], o2);
        return t2;
      });
      const u = e.bt.VectorTileFeature.prototype.toGeoJSON;
      var h = { exports: {} }, d = e.bz, f = e.bt.VectorTileFeature, g = p;
      function p(e2, t2) {
        this.options = t2 || {}, this.features = e2, this.length = e2.length;
      }
      function m(e2, t2) {
        this.id = typeof e2.id == "number" ? e2.id : undefined, this.type = e2.type, this.rawGeometry = e2.type === 1 ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
      }
      p.prototype.feature = function(e2) {
        return new m(this.features[e2], this.options.extent);
      }, m.prototype.loadGeometry = function() {
        var e2 = this.rawGeometry;
        this.geometry = [];
        for (var t2 = 0;t2 < e2.length; t2++) {
          for (var o2 = e2[t2], i2 = [], s2 = 0;s2 < o2.length; s2++)
            i2.push(new d(o2[s2][0], o2[s2][1]));
          this.geometry.push(i2);
        }
        return this.geometry;
      }, m.prototype.bbox = function() {
        this.geometry || this.loadGeometry();
        for (var e2 = this.geometry, t2 = 1 / 0, o2 = -1 / 0, i2 = 1 / 0, s2 = -1 / 0, r2 = 0;r2 < e2.length; r2++)
          for (var n2 = e2[r2], a2 = 0;a2 < n2.length; a2++) {
            var l2 = n2[a2];
            t2 = Math.min(t2, l2.x), o2 = Math.max(o2, l2.x), i2 = Math.min(i2, l2.y), s2 = Math.max(s2, l2.y);
          }
        return [t2, i2, o2, s2];
      }, m.prototype.toGeoJSON = f.prototype.toGeoJSON;
      var y = e.bA, v = g;
      function w(e2) {
        var t2 = new y;
        return function(e3, t3) {
          for (var o2 in e3.layers)
            t3.writeMessage(3, x, e3.layers[o2]);
        }(e2, t2), t2.finish();
      }
      function x(e2, t2) {
        var o2;
        t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
        var i2 = { keys: [], values: [], keycache: {}, valuecache: {} };
        for (o2 = 0;o2 < e2.length; o2++)
          i2.feature = e2.feature(o2), t2.writeMessage(2, b, i2);
        var s2 = i2.keys;
        for (o2 = 0;o2 < s2.length; o2++)
          t2.writeStringField(3, s2[o2]);
        var r2 = i2.values;
        for (o2 = 0;o2 < r2.length; o2++)
          t2.writeMessage(4, P, r2[o2]);
      }
      function b(e2, t2) {
        var o2 = e2.feature;
        o2.id !== undefined && t2.writeVarintField(1, o2.id), t2.writeMessage(2, S, e2), t2.writeVarintField(3, o2.type), t2.writeMessage(4, I, o2);
      }
      function S(e2, t2) {
        var { feature: o2, keys: i2, values: s2, keycache: r2, valuecache: n2 } = e2;
        for (var a2 in o2.properties) {
          var l2 = o2.properties[a2], c2 = r2[a2];
          if (l2 !== null) {
            c2 === undefined && (i2.push(a2), r2[a2] = c2 = i2.length - 1), t2.writeVarint(c2);
            var u2 = typeof l2;
            u2 !== "string" && u2 !== "boolean" && u2 !== "number" && (l2 = JSON.stringify(l2));
            var h2 = u2 + ":" + l2, d2 = n2[h2];
            d2 === undefined && (s2.push(l2), n2[h2] = d2 = s2.length - 1), t2.writeVarint(d2);
          }
        }
      }
      function _(e2, t2) {
        return (t2 << 3) + (7 & e2);
      }
      function M(e2) {
        return e2 << 1 ^ e2 >> 31;
      }
      function I(e2, t2) {
        for (var o2 = e2.loadGeometry(), i2 = e2.type, s2 = 0, r2 = 0, n2 = o2.length, a2 = 0;a2 < n2; a2++) {
          var l2 = o2[a2], c2 = 1;
          i2 === 1 && (c2 = l2.length), t2.writeVarint(_(1, c2));
          for (var u2 = i2 === 3 ? l2.length - 1 : l2.length, h2 = 0;h2 < u2; h2++) {
            h2 === 1 && i2 !== 1 && t2.writeVarint(_(2, u2 - 1));
            var d2 = l2[h2].x - s2, f2 = l2[h2].y - r2;
            t2.writeVarint(M(d2)), t2.writeVarint(M(f2)), s2 += d2, r2 += f2;
          }
          i2 === 3 && t2.writeVarint(_(7, 1));
        }
      }
      function P(e2, t2) {
        var o2 = typeof e2;
        o2 === "string" ? t2.writeStringField(1, e2) : o2 === "boolean" ? t2.writeBooleanField(7, e2) : o2 === "number" && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
      }
      h.exports = w, h.exports.fromVectorTileJs = w, h.exports.fromGeojsonVt = function(e2, t2) {
        t2 = t2 || {};
        var o2 = {};
        for (var i2 in e2)
          o2[i2] = new v(e2[i2].features, t2), o2[i2].name = i2, o2[i2].version = t2.version, o2[i2].extent = t2.extent;
        return w({ layers: o2 });
      }, h.exports.GeoJSONWrapper = v;
      var k = e.by(h.exports);
      const T = {
        minZoom: 0,
        maxZoom: 16,
        minPoints: 2,
        radius: 40,
        extent: 512,
        nodeSize: 64,
        log: false,
        generateId: false,
        reduce: null,
        map: (e2) => e2
      }, D = Math.fround || (C = new Float32Array(1), (e2) => (C[0] = +e2, C[0]));
      var C;
      const L = 3, O = 5, F = 6;

      class z {
        constructor(e2) {
          this.options = Object.assign(Object.create(T), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(e2) {
          const { log: t2, minZoom: o2, maxZoom: i2 } = this.options;
          t2 && console.time("total time");
          const s2 = `prepare ${e2.length} points`;
          t2 && console.time(s2), this.points = e2;
          const r2 = [];
          for (let t3 = 0;t3 < e2.length; t3++) {
            const o3 = e2[t3];
            if (!o3.geometry)
              continue;
            const [i3, s3] = o3.geometry.coordinates, n3 = D(G(i3)), a2 = D(j(s3));
            r2.push(n3, a2, 1 / 0, t3, -1, 1), this.options.reduce && r2.push(0);
          }
          let n2 = this.trees[i2 + 1] = this._createTree(r2);
          t2 && console.timeEnd(s2);
          for (let e3 = i2;e3 >= o2; e3--) {
            const o3 = +Date.now();
            n2 = this.trees[e3] = this._createTree(this._cluster(n2, e3)), t2 && console.log("z%d: %d clusters in %dms", e3, n2.numItems, +Date.now() - o3);
          }
          return t2 && console.timeEnd("total time"), this;
        }
        getClusters(e2, t2) {
          let o2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
          const i2 = Math.max(-90, Math.min(90, e2[1]));
          let s2 = e2[2] === 180 ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
          const r2 = Math.max(-90, Math.min(90, e2[3]));
          if (e2[2] - e2[0] >= 360)
            o2 = -180, s2 = 180;
          else if (o2 > s2) {
            const e3 = this.getClusters([o2, i2, 180, r2], t2), n3 = this.getClusters([-180, i2, s2, r2], t2);
            return e3.concat(n3);
          }
          const n2 = this.trees[this._limitZoom(t2)], a2 = n2.range(G(o2), j(r2), G(s2), j(i2)), l2 = n2.data, c2 = [];
          for (const e3 of a2) {
            const t3 = this.stride * e3;
            c2.push(l2[t3 + O] > 1 ? A(l2, t3, this.clusterProps) : this.points[l2[t3 + L]]);
          }
          return c2;
        }
        getChildren(e2) {
          const t2 = this._getOriginId(e2), o2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", s2 = this.trees[o2];
          if (!s2)
            throw new Error(i2);
          const r2 = s2.data;
          if (t2 * this.stride >= r2.length)
            throw new Error(i2);
          const n2 = this.options.radius / (this.options.extent * Math.pow(2, o2 - 1)), a2 = s2.within(r2[t2 * this.stride], r2[t2 * this.stride + 1], n2), l2 = [];
          for (const t3 of a2) {
            const o3 = t3 * this.stride;
            r2[o3 + 4] === e2 && l2.push(r2[o3 + O] > 1 ? A(r2, o3, this.clusterProps) : this.points[r2[o3 + L]]);
          }
          if (l2.length === 0)
            throw new Error(i2);
          return l2;
        }
        getLeaves(e2, t2, o2) {
          const i2 = [];
          return this._appendLeaves(i2, e2, t2 = t2 || 10, o2 = o2 || 0, 0), i2;
        }
        getTile(e2, t2, o2) {
          const i2 = this.trees[this._limitZoom(e2)], s2 = Math.pow(2, e2), { extent: r2, radius: n2 } = this.options, a2 = n2 / r2, l2 = (o2 - a2) / s2, c2 = (o2 + 1 + a2) / s2, u2 = { features: [] };
          return this._addTileFeatures(i2.range((t2 - a2) / s2, l2, (t2 + 1 + a2) / s2, c2), i2.data, t2, o2, s2, u2), t2 === 0 && this._addTileFeatures(i2.range(1 - a2 / s2, l2, 1, c2), i2.data, s2, o2, s2, u2), t2 === s2 - 1 && this._addTileFeatures(i2.range(0, l2, a2 / s2, c2), i2.data, -1, o2, s2, u2), u2.features.length ? u2 : null;
        }
        getClusterExpansionZoom(e2) {
          let t2 = this._getOriginZoom(e2) - 1;
          for (;t2 <= this.options.maxZoom; ) {
            const o2 = this.getChildren(e2);
            if (t2++, o2.length !== 1)
              break;
            e2 = o2[0].properties.cluster_id;
          }
          return t2;
        }
        _appendLeaves(e2, t2, o2, i2, s2) {
          const r2 = this.getChildren(t2);
          for (const t3 of r2) {
            const r3 = t3.properties;
            if (r3 && r3.cluster ? s2 + r3.point_count <= i2 ? s2 += r3.point_count : s2 = this._appendLeaves(e2, r3.cluster_id, o2, i2, s2) : s2 < i2 ? s2++ : e2.push(t3), e2.length === o2)
              break;
          }
          return s2;
        }
        _createTree(t2) {
          const o2 = new e.av(t2.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let e2 = 0;e2 < t2.length; e2 += this.stride)
            o2.add(t2[e2], t2[e2 + 1]);
          return o2.finish(), o2.data = t2, o2;
        }
        _addTileFeatures(e2, t2, o2, i2, s2, r2) {
          for (const n2 of e2) {
            const e3 = n2 * this.stride, a2 = t2[e3 + O] > 1;
            let l2, c2, u2;
            if (a2)
              l2 = E(t2, e3, this.clusterProps), c2 = t2[e3], u2 = t2[e3 + 1];
            else {
              const o3 = this.points[t2[e3 + L]];
              l2 = o3.properties;
              const [i3, s3] = o3.geometry.coordinates;
              c2 = G(i3), u2 = j(s3);
            }
            const h2 = {
              type: 1,
              geometry: [
                [
                  Math.round(this.options.extent * (c2 * s2 - o2)),
                  Math.round(this.options.extent * (u2 * s2 - i2))
                ]
              ],
              tags: l2
            };
            let d2;
            d2 = a2 || this.options.generateId ? t2[e3 + L] : this.points[t2[e3 + L]].id, d2 !== undefined && (h2.id = d2), r2.features.push(h2);
          }
        }
        _limitZoom(e2) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
        }
        _cluster(e2, t2) {
          const { radius: o2, extent: i2, reduce: s2, minPoints: r2 } = this.options, n2 = o2 / (i2 * Math.pow(2, t2)), a2 = e2.data, l2 = [], c2 = this.stride;
          for (let o3 = 0;o3 < a2.length; o3 += c2) {
            if (a2[o3 + 2] <= t2)
              continue;
            a2[o3 + 2] = t2;
            const i3 = a2[o3], u2 = a2[o3 + 1], h2 = e2.within(a2[o3], a2[o3 + 1], n2), d2 = a2[o3 + O];
            let f2 = d2;
            for (const e3 of h2) {
              const o4 = e3 * c2;
              a2[o4 + 2] > t2 && (f2 += a2[o4 + O]);
            }
            if (f2 > d2 && f2 >= r2) {
              let e3, r3 = i3 * d2, n3 = u2 * d2, g2 = -1;
              const p2 = ((o3 / c2 | 0) << 5) + (t2 + 1) + this.points.length;
              for (const i4 of h2) {
                const l3 = i4 * c2;
                if (a2[l3 + 2] <= t2)
                  continue;
                a2[l3 + 2] = t2;
                const u3 = a2[l3 + O];
                r3 += a2[l3] * u3, n3 += a2[l3 + 1] * u3, a2[l3 + 4] = p2, s2 && (e3 || (e3 = this._map(a2, o3, true), g2 = this.clusterProps.length, this.clusterProps.push(e3)), s2(e3, this._map(a2, l3)));
              }
              a2[o3 + 4] = p2, l2.push(r3 / f2, n3 / f2, 1 / 0, p2, -1, f2), s2 && l2.push(g2);
            } else {
              for (let e3 = 0;e3 < c2; e3++)
                l2.push(a2[o3 + e3]);
              if (f2 > 1)
                for (const e3 of h2) {
                  const o4 = e3 * c2;
                  if (!(a2[o4 + 2] <= t2)) {
                    a2[o4 + 2] = t2;
                    for (let e4 = 0;e4 < c2; e4++)
                      l2.push(a2[o4 + e4]);
                  }
                }
            }
          }
          return l2;
        }
        _getOriginId(e2) {
          return e2 - this.points.length >> 5;
        }
        _getOriginZoom(e2) {
          return (e2 - this.points.length) % 32;
        }
        _map(e2, t2, o2) {
          if (e2[t2 + O] > 1) {
            const i3 = this.clusterProps[e2[t2 + F]];
            return o2 ? Object.assign({}, i3) : i3;
          }
          const i2 = this.points[e2[t2 + L]].properties, s2 = this.options.map(i2);
          return o2 && s2 === i2 ? Object.assign({}, s2) : s2;
        }
      }
      function A(e2, t2, o2) {
        return {
          type: "Feature",
          id: e2[t2 + L],
          properties: E(e2, t2, o2),
          geometry: {
            type: "Point",
            coordinates: [(i2 = e2[t2], 360 * (i2 - 0.5)), R(e2[t2 + 1])]
          }
        };
        var i2;
      }
      function E(e2, t2, o2) {
        const i2 = e2[t2 + O], s2 = i2 >= 1e4 ? `${Math.round(i2 / 1000)}k` : i2 >= 1000 ? Math.round(i2 / 100) / 10 + "k" : i2, r2 = e2[t2 + F], n2 = r2 === -1 ? {} : Object.assign({}, o2[r2]);
        return Object.assign(n2, {
          cluster: true,
          cluster_id: e2[t2 + L],
          point_count: i2,
          point_count_abbreviated: s2
        });
      }
      function G(e2) {
        return e2 / 360 + 0.5;
      }
      function j(e2) {
        const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
      }
      function R(e2) {
        const t2 = (180 - 360 * e2) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
      }
      function Z(e2, t2, o2, i2) {
        let s2 = i2;
        const r2 = t2 + (o2 - t2 >> 1);
        let n2, a2 = o2 - t2;
        const l2 = e2[t2], c2 = e2[t2 + 1], u2 = e2[o2], h2 = e2[o2 + 1];
        for (let i3 = t2 + 3;i3 < o2; i3 += 3) {
          const t3 = N(e2[i3], e2[i3 + 1], l2, c2, u2, h2);
          if (t3 > s2)
            n2 = i3, s2 = t3;
          else if (t3 === s2) {
            const e3 = Math.abs(i3 - r2);
            e3 < a2 && (n2 = i3, a2 = e3);
          }
        }
        s2 > i2 && (n2 - t2 > 3 && Z(e2, t2, n2, i2), e2[n2 + 2] = s2, o2 - n2 > 3 && Z(e2, n2, o2, i2));
      }
      function N(e2, t2, o2, i2, s2, r2) {
        let n2 = s2 - o2, a2 = r2 - i2;
        if (n2 !== 0 || a2 !== 0) {
          const l2 = ((e2 - o2) * n2 + (t2 - i2) * a2) / (n2 * n2 + a2 * a2);
          l2 > 1 ? (o2 = s2, i2 = r2) : l2 > 0 && (o2 += n2 * l2, i2 += a2 * l2);
        }
        return n2 = e2 - o2, a2 = t2 - i2, n2 * n2 + a2 * a2;
      }
      function J(e2, t2, o2, i2) {
        const s2 = {
          id: e2 == null ? null : e2,
          type: t2,
          geometry: o2,
          tags: i2,
          minX: 1 / 0,
          minY: 1 / 0,
          maxX: -1 / 0,
          maxY: -1 / 0
        };
        if (t2 === "Point" || t2 === "MultiPoint" || t2 === "LineString")
          W(s2, o2);
        else if (t2 === "Polygon")
          W(s2, o2[0]);
        else if (t2 === "MultiLineString")
          for (const e3 of o2)
            W(s2, e3);
        else if (t2 === "MultiPolygon")
          for (const e3 of o2)
            W(s2, e3[0]);
        return s2;
      }
      function W(e2, t2) {
        for (let o2 = 0;o2 < t2.length; o2 += 3)
          e2.minX = Math.min(e2.minX, t2[o2]), e2.minY = Math.min(e2.minY, t2[o2 + 1]), e2.maxX = Math.max(e2.maxX, t2[o2]), e2.maxY = Math.max(e2.maxY, t2[o2 + 1]);
      }
      function Y(e2, t2, o2, i2) {
        if (!t2.geometry)
          return;
        const s2 = t2.geometry.coordinates;
        if (s2 && s2.length === 0)
          return;
        const r2 = t2.geometry.type, n2 = Math.pow(o2.tolerance / ((1 << o2.maxZoom) * o2.extent), 2);
        let a2 = [], l2 = t2.id;
        if (o2.promoteId ? l2 = t2.properties[o2.promoteId] : o2.generateId && (l2 = i2 || 0), r2 === "Point")
          V(s2, a2);
        else if (r2 === "MultiPoint")
          for (const e3 of s2)
            V(e3, a2);
        else if (r2 === "LineString")
          X(s2, a2, n2, false);
        else if (r2 === "MultiLineString") {
          if (o2.lineMetrics) {
            for (const o3 of s2)
              a2 = [], X(o3, a2, n2, false), e2.push(J(l2, "LineString", a2, t2.properties));
            return;
          }
          q(s2, a2, n2, false);
        } else if (r2 === "Polygon")
          q(s2, a2, n2, true);
        else {
          if (r2 !== "MultiPolygon") {
            if (r2 === "GeometryCollection") {
              for (const s3 of t2.geometry.geometries)
                Y(e2, { id: l2, geometry: s3, properties: t2.properties }, o2, i2);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const e3 of s2) {
            const t3 = [];
            q(e3, t3, n2, true), a2.push(t3);
          }
        }
        e2.push(J(l2, r2, a2, t2.properties));
      }
      function V(e2, t2) {
        t2.push(H(e2[0]), B(e2[1]), 0);
      }
      function X(e2, t2, o2, i2) {
        let s2, r2, n2 = 0;
        for (let o3 = 0;o3 < e2.length; o3++) {
          const a3 = H(e2[o3][0]), l2 = B(e2[o3][1]);
          t2.push(a3, l2, 0), o3 > 0 && (n2 += i2 ? (s2 * l2 - a3 * r2) / 2 : Math.sqrt(Math.pow(a3 - s2, 2) + Math.pow(l2 - r2, 2))), s2 = a3, r2 = l2;
        }
        const a2 = t2.length - 3;
        t2[2] = 1, Z(t2, 0, a2, o2), t2[a2 + 2] = 1, t2.size = Math.abs(n2), t2.start = 0, t2.end = t2.size;
      }
      function q(e2, t2, o2, i2) {
        for (let s2 = 0;s2 < e2.length; s2++) {
          const r2 = [];
          X(e2[s2], r2, o2, i2), t2.push(r2);
        }
      }
      function H(e2) {
        return e2 / 360 + 0.5;
      }
      function B(e2) {
        const t2 = Math.sin(e2 * Math.PI / 180), o2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
        return o2 < 0 ? 0 : o2 > 1 ? 1 : o2;
      }
      function U(e2, t2, o2, i2, s2, r2, n2, a2) {
        if (i2 /= t2, r2 >= (o2 /= t2) && n2 < i2)
          return e2;
        if (n2 < o2 || r2 >= i2)
          return null;
        const l2 = [];
        for (const t3 of e2) {
          const e3 = t3.geometry;
          let r3 = t3.type;
          const n3 = s2 === 0 ? t3.minX : t3.minY, c2 = s2 === 0 ? t3.maxX : t3.maxY;
          if (n3 >= o2 && c2 < i2) {
            l2.push(t3);
            continue;
          }
          if (c2 < o2 || n3 >= i2)
            continue;
          let u2 = [];
          if (r3 === "Point" || r3 === "MultiPoint")
            $(e3, u2, o2, i2, s2);
          else if (r3 === "LineString")
            K(e3, u2, o2, i2, s2, false, a2.lineMetrics);
          else if (r3 === "MultiLineString")
            ee(e3, u2, o2, i2, s2, false);
          else if (r3 === "Polygon")
            ee(e3, u2, o2, i2, s2, true);
          else if (r3 === "MultiPolygon")
            for (const t4 of e3) {
              const e4 = [];
              ee(t4, e4, o2, i2, s2, true), e4.length && u2.push(e4);
            }
          if (u2.length) {
            if (a2.lineMetrics && r3 === "LineString") {
              for (const e4 of u2)
                l2.push(J(t3.id, r3, e4, t3.tags));
              continue;
            }
            r3 !== "LineString" && r3 !== "MultiLineString" || (u2.length === 1 ? (r3 = "LineString", u2 = u2[0]) : r3 = "MultiLineString"), r3 !== "Point" && r3 !== "MultiPoint" || (r3 = u2.length === 3 ? "Point" : "MultiPoint"), l2.push(J(t3.id, r3, u2, t3.tags));
          }
        }
        return l2.length ? l2 : null;
      }
      function $(e2, t2, o2, i2, s2) {
        for (let r2 = 0;r2 < e2.length; r2 += 3) {
          const n2 = e2[r2 + s2];
          n2 >= o2 && n2 <= i2 && te(t2, e2[r2], e2[r2 + 1], e2[r2 + 2]);
        }
      }
      function K(e2, t2, o2, i2, s2, r2, n2) {
        let a2 = Q(e2);
        const l2 = s2 === 0 ? oe : ie;
        let c2, u2, h2 = e2.start;
        for (let d3 = 0;d3 < e2.length - 3; d3 += 3) {
          const f3 = e2[d3], g3 = e2[d3 + 1], p3 = e2[d3 + 2], m2 = e2[d3 + 3], y2 = e2[d3 + 4], v2 = s2 === 0 ? f3 : g3, w2 = s2 === 0 ? m2 : y2;
          let x2 = false;
          n2 && (c2 = Math.sqrt(Math.pow(f3 - m2, 2) + Math.pow(g3 - y2, 2))), v2 < o2 ? w2 > o2 && (u2 = l2(a2, f3, g3, m2, y2, o2), n2 && (a2.start = h2 + c2 * u2)) : v2 > i2 ? w2 < i2 && (u2 = l2(a2, f3, g3, m2, y2, i2), n2 && (a2.start = h2 + c2 * u2)) : te(a2, f3, g3, p3), w2 < o2 && v2 >= o2 && (u2 = l2(a2, f3, g3, m2, y2, o2), x2 = true), w2 > i2 && v2 <= i2 && (u2 = l2(a2, f3, g3, m2, y2, i2), x2 = true), !r2 && x2 && (n2 && (a2.end = h2 + c2 * u2), t2.push(a2), a2 = Q(e2)), n2 && (h2 += c2);
        }
        let d2 = e2.length - 3;
        const f2 = e2[d2], g2 = e2[d2 + 1], p2 = s2 === 0 ? f2 : g2;
        p2 >= o2 && p2 <= i2 && te(a2, f2, g2, e2[d2 + 2]), d2 = a2.length - 3, r2 && d2 >= 3 && (a2[d2] !== a2[0] || a2[d2 + 1] !== a2[1]) && te(a2, a2[0], a2[1], a2[2]), a2.length && t2.push(a2);
      }
      function Q(e2) {
        const t2 = [];
        return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
      }
      function ee(e2, t2, o2, i2, s2, r2) {
        for (const n2 of e2)
          K(n2, t2, o2, i2, s2, r2, false);
      }
      function te(e2, t2, o2, i2) {
        e2.push(t2, o2, i2);
      }
      function oe(e2, t2, o2, i2, s2, r2) {
        const n2 = (r2 - t2) / (i2 - t2);
        return te(e2, r2, o2 + (s2 - o2) * n2, 1), n2;
      }
      function ie(e2, t2, o2, i2, s2, r2) {
        const n2 = (r2 - o2) / (s2 - o2);
        return te(e2, t2 + (i2 - t2) * n2, r2, 1), n2;
      }
      function se(e2, t2) {
        const o2 = [];
        for (let i2 = 0;i2 < e2.length; i2++) {
          const s2 = e2[i2], r2 = s2.type;
          let n2;
          if (r2 === "Point" || r2 === "MultiPoint" || r2 === "LineString")
            n2 = re(s2.geometry, t2);
          else if (r2 === "MultiLineString" || r2 === "Polygon") {
            n2 = [];
            for (const e3 of s2.geometry)
              n2.push(re(e3, t2));
          } else if (r2 === "MultiPolygon") {
            n2 = [];
            for (const e3 of s2.geometry) {
              const o3 = [];
              for (const i3 of e3)
                o3.push(re(i3, t2));
              n2.push(o3);
            }
          }
          o2.push(J(s2.id, r2, n2, s2.tags));
        }
        return o2;
      }
      function re(e2, t2) {
        const o2 = [];
        o2.size = e2.size, e2.start !== undefined && (o2.start = e2.start, o2.end = e2.end);
        for (let i2 = 0;i2 < e2.length; i2 += 3)
          o2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
        return o2;
      }
      function ne(e2, t2) {
        if (e2.transformed)
          return e2;
        const o2 = 1 << e2.z, i2 = e2.x, s2 = e2.y;
        for (const r2 of e2.features) {
          const { geometry: e3, type: n2 } = r2;
          if (r2.geometry = [], n2 === 1)
            for (let n3 = 0;n3 < e3.length; n3 += 2)
              r2.geometry.push(ae(e3[n3], e3[n3 + 1], t2, o2, i2, s2));
          else
            for (let n3 = 0;n3 < e3.length; n3++) {
              const a2 = [];
              for (let r3 = 0;r3 < e3[n3].length; r3 += 2)
                a2.push(ae(e3[n3][r3], e3[n3][r3 + 1], t2, o2, i2, s2));
              r2.geometry.push(a2);
            }
        }
        return e2.transformed = true, e2;
      }
      function ae(e2, t2, o2, i2, s2, r2) {
        return [Math.round(o2 * (e2 * i2 - s2)), Math.round(o2 * (t2 * i2 - r2))];
      }
      function le(e2, t2, o2, i2, s2) {
        const r2 = t2 === s2.maxZoom ? 0 : s2.tolerance / ((1 << t2) * s2.extent), n2 = {
          features: [],
          numPoints: 0,
          numSimplified: 0,
          numFeatures: e2.length,
          source: null,
          x: o2,
          y: i2,
          z: t2,
          transformed: false,
          minX: 2,
          minY: 1,
          maxX: -1,
          maxY: 0
        };
        for (const t3 of e2)
          ce(n2, t3, r2, s2);
        return n2;
      }
      function ce(e2, t2, o2, i2) {
        const { geometry: s2, type: r2 } = t2, n2 = [];
        if (e2.minX = Math.min(e2.minX, t2.minX), e2.minY = Math.min(e2.minY, t2.minY), e2.maxX = Math.max(e2.maxX, t2.maxX), e2.maxY = Math.max(e2.maxY, t2.maxY), r2 === "Point" || r2 === "MultiPoint")
          for (let t3 = 0;t3 < s2.length; t3 += 3)
            n2.push(s2[t3], s2[t3 + 1]), e2.numPoints++, e2.numSimplified++;
        else if (r2 === "LineString")
          ue(n2, s2, e2, o2, false, false);
        else if (r2 === "MultiLineString" || r2 === "Polygon")
          for (let t3 = 0;t3 < s2.length; t3++)
            ue(n2, s2[t3], e2, o2, r2 === "Polygon", t3 === 0);
        else if (r2 === "MultiPolygon")
          for (let t3 = 0;t3 < s2.length; t3++) {
            const i3 = s2[t3];
            for (let t4 = 0;t4 < i3.length; t4++)
              ue(n2, i3[t4], e2, o2, true, t4 === 0);
          }
        if (n2.length) {
          let o3 = t2.tags || null;
          if (r2 === "LineString" && i2.lineMetrics) {
            o3 = {};
            for (const e3 in t2.tags)
              o3[e3] = t2.tags[e3];
            o3.mapbox_clip_start = s2.start / s2.size, o3.mapbox_clip_end = s2.end / s2.size;
          }
          const a2 = {
            geometry: n2,
            type: r2 === "Polygon" || r2 === "MultiPolygon" ? 3 : r2 === "LineString" || r2 === "MultiLineString" ? 2 : 1,
            tags: o3
          };
          t2.id !== null && (a2.id = t2.id), e2.features.push(a2);
        }
      }
      function ue(e2, t2, o2, i2, s2, r2) {
        const n2 = i2 * i2;
        if (i2 > 0 && t2.size < (s2 ? n2 : i2))
          return void (o2.numPoints += t2.length / 3);
        const a2 = [];
        for (let e3 = 0;e3 < t2.length; e3 += 3)
          (i2 === 0 || t2[e3 + 2] > n2) && (o2.numSimplified++, a2.push(t2[e3], t2[e3 + 1])), o2.numPoints++;
        s2 && function(e3, t3) {
          let o3 = 0;
          for (let t4 = 0, i3 = e3.length, s3 = i3 - 2;t4 < i3; s3 = t4, t4 += 2)
            o3 += (e3[t4] - e3[s3]) * (e3[t4 + 1] + e3[s3 + 1]);
          if (o3 > 0 === t3)
            for (let t4 = 0, o4 = e3.length;t4 < o4 / 2; t4 += 2) {
              const i3 = e3[t4], s3 = e3[t4 + 1];
              e3[t4] = e3[o4 - 2 - t4], e3[t4 + 1] = e3[o4 - 1 - t4], e3[o4 - 2 - t4] = i3, e3[o4 - 1 - t4] = s3;
            }
        }(a2, r2), e2.push(a2);
      }
      const he = {
        maxZoom: 14,
        indexMaxZoom: 5,
        indexMaxPoints: 1e5,
        tolerance: 3,
        extent: 4096,
        buffer: 64,
        lineMetrics: false,
        promoteId: null,
        generateId: false,
        debug: 0
      };

      class de {
        constructor(e2, t2) {
          const o2 = (t2 = this.options = function(e3, t3) {
            for (const o3 in t3)
              e3[o3] = t3[o3];
            return e3;
          }(Object.create(he), t2)).debug;
          if (o2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
            throw new Error("maxZoom should be in the 0-24 range");
          if (t2.promoteId && t2.generateId)
            throw new Error("promoteId and generateId cannot be used together.");
          let i2 = function(e3, t3) {
            const o3 = [];
            if (e3.type === "FeatureCollection")
              for (let i3 = 0;i3 < e3.features.length; i3++)
                Y(o3, e3.features[i3], t3, i3);
            else
              Y(o3, e3.type === "Feature" ? e3 : { geometry: e3 }, t3);
            return o3;
          }(e2, t2);
          this.tiles = {}, this.tileCoords = [], o2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i2 = function(e3, t3) {
            const o3 = t3.buffer / t3.extent;
            let i3 = e3;
            const s2 = U(e3, 1, -1 - o3, o3, 0, -1, 2, t3), r2 = U(e3, 1, 1 - o3, 2 + o3, 0, -1, 2, t3);
            return (s2 || r2) && (i3 = U(e3, 1, -o3, 1 + o3, 0, -1, 2, t3) || [], s2 && (i3 = se(s2, 1).concat(i3)), r2 && (i3 = i3.concat(se(r2, -1)))), i3;
          }(i2, t2), i2.length && this.splitTile(i2, 0, 0, 0), o2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(e2, t2, o2, i2, s2, r2, n2) {
          const a2 = [e2, t2, o2, i2], l2 = this.options, c2 = l2.debug;
          for (;a2.length; ) {
            i2 = a2.pop(), o2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
            const u2 = 1 << t2, h2 = fe(t2, o2, i2);
            let d2 = this.tiles[h2];
            if (!d2 && (c2 > 1 && console.time("creation"), d2 = this.tiles[h2] = le(e2, t2, o2, i2, l2), this.tileCoords.push({ z: t2, x: o2, y: i2 }), c2)) {
              c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, o2, i2, d2.numFeatures, d2.numPoints, d2.numSimplified), console.timeEnd("creation"));
              const e3 = `z${t2}`;
              this.stats[e3] = (this.stats[e3] || 0) + 1, this.total++;
            }
            if (d2.source = e2, s2 == null) {
              if (t2 === l2.indexMaxZoom || d2.numPoints <= l2.indexMaxPoints)
                continue;
            } else {
              if (t2 === l2.maxZoom || t2 === s2)
                continue;
              if (s2 != null) {
                const e3 = s2 - t2;
                if (o2 !== r2 >> e3 || i2 !== n2 >> e3)
                  continue;
              }
            }
            if (d2.source = null, e2.length === 0)
              continue;
            c2 > 1 && console.time("clipping");
            const f2 = 0.5 * l2.buffer / l2.extent, g2 = 0.5 - f2, p2 = 0.5 + f2, m2 = 1 + f2;
            let y2 = null, v2 = null, w2 = null, x2 = null, b2 = U(e2, u2, o2 - f2, o2 + p2, 0, d2.minX, d2.maxX, l2), S2 = U(e2, u2, o2 + g2, o2 + m2, 0, d2.minX, d2.maxX, l2);
            e2 = null, b2 && (y2 = U(b2, u2, i2 - f2, i2 + p2, 1, d2.minY, d2.maxY, l2), v2 = U(b2, u2, i2 + g2, i2 + m2, 1, d2.minY, d2.maxY, l2), b2 = null), S2 && (w2 = U(S2, u2, i2 - f2, i2 + p2, 1, d2.minY, d2.maxY, l2), x2 = U(S2, u2, i2 + g2, i2 + m2, 1, d2.minY, d2.maxY, l2), S2 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(y2 || [], t2 + 1, 2 * o2, 2 * i2), a2.push(v2 || [], t2 + 1, 2 * o2, 2 * i2 + 1), a2.push(w2 || [], t2 + 1, 2 * o2 + 1, 2 * i2), a2.push(x2 || [], t2 + 1, 2 * o2 + 1, 2 * i2 + 1);
          }
        }
        getTile(e2, t2, o2) {
          e2 = +e2, t2 = +t2, o2 = +o2;
          const i2 = this.options, { extent: s2, debug: r2 } = i2;
          if (e2 < 0 || e2 > 24)
            return null;
          const n2 = 1 << e2, a2 = fe(e2, t2 = t2 + n2 & n2 - 1, o2);
          if (this.tiles[a2])
            return ne(this.tiles[a2], s2);
          r2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, o2);
          let l2, c2 = e2, u2 = t2, h2 = o2;
          for (;!l2 && c2 > 0; )
            c2--, u2 >>= 1, h2 >>= 1, l2 = this.tiles[fe(c2, u2, h2)];
          return l2 && l2.source ? (r2 > 1 && (console.log("found parent tile z%d-%d-%d", c2, u2, h2), console.time("drilling down")), this.splitTile(l2.source, c2, u2, h2, e2, t2, o2), r2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? ne(this.tiles[a2], s2) : null) : null;
        }
      }
      function fe(e2, t2, o2) {
        return 32 * ((1 << e2) * o2 + t2) + e2;
      }
      function ge(e2, t2) {
        return t2 ? e2.properties[t2] : e2.id;
      }
      function pe(e2, t2) {
        if (e2 == null)
          return true;
        if (e2.type === "Feature")
          return ge(e2, t2) != null;
        if (e2.type === "FeatureCollection") {
          const o2 = new Set;
          for (const i2 of e2.features) {
            const e3 = ge(i2, t2);
            if (e3 == null)
              return false;
            if (o2.has(e3))
              return false;
            o2.add(e3);
          }
          return true;
        }
        return false;
      }
      function me(e2, t2) {
        const o2 = new Map;
        if (e2 == null)
          ;
        else if (e2.type === "Feature")
          o2.set(ge(e2, t2), e2);
        else
          for (const i2 of e2.features)
            o2.set(ge(i2, t2), i2);
        return o2;
      }

      class ye extends r {
        constructor() {
          super(...arguments), this._dataUpdateable = new Map;
        }
        loadVectorTile(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            const o3 = t2.tileID.canonical;
            if (!this._geoJSONIndex)
              throw new Error("Unable to parse the data into a cluster or geojson");
            const i2 = this._geoJSONIndex.getTile(o3.z, o3.x, o3.y);
            if (!i2)
              return null;
            const s2 = new class {
              constructor(t3) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.X, this.length = t3.length, this._features = t3;
              }
              feature(t3) {
                return new class {
                  constructor(t4) {
                    this._feature = t4, this.extent = e.X, this.type = t4.type, this.properties = t4.tags, "id" in t4 && !isNaN(t4.id) && (this.id = parseInt(t4.id, 10));
                  }
                  loadGeometry() {
                    if (this._feature.type === 1) {
                      const t4 = [];
                      for (const o4 of this._feature.geometry)
                        t4.push([new e.P(o4[0], o4[1])]);
                      return t4;
                    }
                    {
                      const t4 = [];
                      for (const o4 of this._feature.geometry) {
                        const i3 = [];
                        for (const t5 of o4)
                          i3.push(new e.P(t5[0], t5[1]));
                        t4.push(i3);
                      }
                      return t4;
                    }
                  }
                  toGeoJSON(e2, t4, o4) {
                    return u.call(this, e2, t4, o4);
                  }
                }(this._features[t3]);
              }
            }(i2.features);
            let r2 = k(s2);
            return r2.byteOffset === 0 && r2.byteLength === r2.buffer.byteLength || (r2 = new Uint8Array(r2)), { vectorTile: s2, rawData: r2.buffer };
          });
        }
        loadData(t2) {
          return e._(this, undefined, undefined, function* () {
            var o2;
            (o2 = this._pendingRequest) === null || o2 === undefined || o2.abort();
            const i2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.bv(t2.request);
            this._pendingRequest = new AbortController;
            try {
              this._pendingData = this.loadAndProcessGeoJSON(t2, this._pendingRequest), this._geoJSONIndex = t2.cluster ? new z(function({ superclusterOptions: t3, clusterProperties: o4 }) {
                if (!o4 || !t3)
                  return t3;
                const i3 = {}, s3 = {}, r2 = { accumulated: null, zoom: 0 }, n2 = { properties: null }, a2 = Object.keys(o4);
                for (const t4 of a2) {
                  const [r3, n3] = o4[t4], a3 = e.bC(n3), l2 = e.bC(typeof r3 == "string" ? [r3, ["accumulated"], ["get", t4]] : r3);
                  i3[t4] = a3.value, s3[t4] = l2.value;
                }
                return t3.map = (e2) => {
                  n2.properties = e2;
                  const t4 = {};
                  for (const e3 of a2)
                    t4[e3] = i3[e3].evaluate(r2, n2);
                  return t4;
                }, t3.reduce = (e2, t4) => {
                  n2.properties = t4;
                  for (const t5 of a2)
                    r2.accumulated = e2[t5], e2[t5] = s3[t5].evaluate(r2, n2);
                }, t3;
              }(t2)).load((yield this._pendingData).features) : (s2 = yield this._pendingData, new de(s2, t2.geojsonVtOptions)), this.loaded = {};
              const o3 = {};
              if (i2) {
                const e2 = i2.finish();
                e2 && (o3.resourceTiming = {}, o3.resourceTiming[t2.source] = JSON.parse(JSON.stringify(e2)));
              }
              return o3;
            } catch (t3) {
              if (delete this._pendingRequest, e.bB(t3))
                return { abandoned: true };
              throw t3;
            }
            var s2;
          });
        }
        getData() {
          return e._(this, undefined, undefined, function* () {
            return this._pendingData;
          });
        }
        reloadTile(e2) {
          const t2 = this.loaded;
          return t2 && t2[e2.uid] ? super.reloadTile(e2) : this.loadTile(e2);
        }
        loadAndProcessGeoJSON(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            let i2 = yield this.loadGeoJSON(t2, o2);
            if (delete this._pendingRequest, typeof i2 != "object")
              throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
            if (c(i2, true), t2.filter) {
              const o3 = e.bC(t2.filter, {
                type: "boolean",
                "property-type": "data-driven",
                overridable: false,
                transition: false
              });
              if (o3.result === "error")
                throw new Error(o3.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
              const s2 = i2.features.filter((e2) => o3.value.evaluate({ zoom: 0 }, e2));
              i2 = { type: "FeatureCollection", features: s2 };
            }
            return i2;
          });
        }
        loadGeoJSON(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            const { promoteId: i2 } = t2;
            if (t2.request) {
              const s2 = yield e.h(t2.request, o2);
              return this._dataUpdateable = pe(s2.data, i2) ? me(s2.data, i2) : undefined, s2.data;
            }
            if (typeof t2.data == "string")
              try {
                const e2 = JSON.parse(t2.data);
                return this._dataUpdateable = pe(e2, i2) ? me(e2, i2) : undefined, e2;
              } catch (e2) {
                throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
              }
            if (!t2.dataDiff)
              throw new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable)
              throw new Error(`Cannot update existing geojson data in ${t2.source}`);
            return function(e2, t3, o3) {
              var i3, s2, r2, n2;
              if (t3.removeAll && e2.clear(), t3.remove)
                for (const o4 of t3.remove)
                  e2.delete(o4);
              if (t3.add)
                for (const i4 of t3.add) {
                  const t4 = ge(i4, o3);
                  t4 != null && e2.set(t4, i4);
                }
              if (t3.update)
                for (const o4 of t3.update) {
                  let t4 = e2.get(o4.id);
                  if (t4 == null)
                    continue;
                  const a2 = !o4.removeAllProperties && (((i3 = o4.removeProperties) === null || i3 === undefined ? undefined : i3.length) > 0 || ((s2 = o4.addOrUpdateProperties) === null || s2 === undefined ? undefined : s2.length) > 0);
                  if ((o4.newGeometry || o4.removeAllProperties || a2) && (t4 = Object.assign({}, t4), e2.set(o4.id, t4), a2 && (t4.properties = Object.assign({}, t4.properties))), o4.newGeometry && (t4.geometry = o4.newGeometry), o4.removeAllProperties)
                    t4.properties = {};
                  else if (((r2 = o4.removeProperties) === null || r2 === undefined ? undefined : r2.length) > 0)
                    for (const e3 of o4.removeProperties)
                      Object.prototype.hasOwnProperty.call(t4.properties, e3) && delete t4.properties[e3];
                  if (((n2 = o4.addOrUpdateProperties) === null || n2 === undefined ? undefined : n2.length) > 0)
                    for (const { key: e3, value: i4 } of o4.addOrUpdateProperties)
                      t4.properties[e3] = i4;
                }
            }(this._dataUpdateable, t2.dataDiff, i2), {
              type: "FeatureCollection",
              features: Array.from(this._dataUpdateable.values())
            };
          });
        }
        removeSource(t2) {
          return e._(this, undefined, undefined, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom(e2) {
          return this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId);
        }
        getClusterChildren(e2) {
          return this._geoJSONIndex.getChildren(e2.clusterId);
        }
        getClusterLeaves(e2) {
          return this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset);
        }
      }

      class ve {
        constructor(t2) {
          this.self = t2, this.actor = new e.F(t2), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (e2, t3) => {
            if (this.externalWorkerSourceTypes[e2])
              throw new Error(`Worker source with name "${e2}" already registered.`);
            this.externalWorkerSourceTypes[e2] = t3;
          }, this.self.addProtocol = e.bi, this.self.removeProtocol = e.bj, this.self.registerRTLTextPlugin = (t3) => {
            if (e.bD.isParsed())
              throw new Error("RTL text plugin already registered.");
            e.bD.setMethods(t3);
          }, this.actor.registerMessageHandler("LDT", (e2, t3) => this._getDEMWorkerSource(e2, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RDT", (t3, o2) => e._(this, undefined, undefined, function* () {
            this._getDEMWorkerSource(t3, o2.source).removeTile(o2);
          })), this.actor.registerMessageHandler("GCEZ", (t3, o2) => e._(this, undefined, undefined, function* () {
            return this._getWorkerSource(t3, o2.type, o2.source).getClusterExpansionZoom(o2);
          })), this.actor.registerMessageHandler("GCC", (t3, o2) => e._(this, undefined, undefined, function* () {
            return this._getWorkerSource(t3, o2.type, o2.source).getClusterChildren(o2);
          })), this.actor.registerMessageHandler("GCL", (t3, o2) => e._(this, undefined, undefined, function* () {
            return this._getWorkerSource(t3, o2.type, o2.source).getClusterLeaves(o2);
          })), this.actor.registerMessageHandler("LD", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadData(t3)), this.actor.registerMessageHandler("GD", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).getData()), this.actor.registerMessageHandler("LT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).loadTile(t3)), this.actor.registerMessageHandler("RT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).reloadTile(t3)), this.actor.registerMessageHandler("AT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).abortTile(t3)), this.actor.registerMessageHandler("RMT", (e2, t3) => this._getWorkerSource(e2, t3.type, t3.source).removeTile(t3)), this.actor.registerMessageHandler("RS", (t3, o2) => e._(this, undefined, undefined, function* () {
            if (!this.workerSources[t3] || !this.workerSources[t3][o2.type] || !this.workerSources[t3][o2.type][o2.source])
              return;
            const e2 = this.workerSources[t3][o2.type][o2.source];
            delete this.workerSources[t3][o2.type][o2.source], e2.removeSource !== undefined && e2.removeSource(o2);
          })), this.actor.registerMessageHandler("RM", (t3) => e._(this, undefined, undefined, function* () {
            delete this.layerIndexes[t3], delete this.availableImages[t3], delete this.workerSources[t3], delete this.demWorkerSources[t3];
          })), this.actor.registerMessageHandler("SR", (t3, o2) => e._(this, undefined, undefined, function* () {
            this.referrer = o2;
          })), this.actor.registerMessageHandler("SRPS", (e2, t3) => this._syncRTLPluginState(e2, t3)), this.actor.registerMessageHandler("IS", (t3, o2) => e._(this, undefined, undefined, function* () {
            this.self.importScripts(o2);
          })), this.actor.registerMessageHandler("SI", (e2, t3) => this._setImages(e2, t3)), this.actor.registerMessageHandler("UL", (t3, o2) => e._(this, undefined, undefined, function* () {
            this._getLayerIndex(t3).update(o2.layers, o2.removedIds);
          })), this.actor.registerMessageHandler("SL", (t3, o2) => e._(this, undefined, undefined, function* () {
            this._getLayerIndex(t3).replace(o2);
          }));
        }
        _setImages(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            this.availableImages[t2] = o2;
            for (const e2 in this.workerSources[t2]) {
              const i2 = this.workerSources[t2][e2];
              for (const e3 in i2)
                i2[e3].availableImages = o2;
            }
          });
        }
        _syncRTLPluginState(t2, o2) {
          return e._(this, undefined, undefined, function* () {
            if (e.bD.isParsed())
              return e.bD.getState();
            if (o2.pluginStatus !== "loading")
              return e.bD.setState(o2), o2;
            const t3 = o2.pluginURL;
            if (this.self.importScripts(t3), e.bD.isParsed()) {
              const o3 = { pluginStatus: "loaded", pluginURL: t3 };
              return e.bD.setState(o3), o3;
            }
            throw e.bD.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${t3}`);
          });
        }
        _getAvailableImages(e2) {
          let t2 = this.availableImages[e2];
          return t2 || (t2 = []), t2;
        }
        _getLayerIndex(e2) {
          let o2 = this.layerIndexes[e2];
          return o2 || (o2 = this.layerIndexes[e2] = new t), o2;
        }
        _getWorkerSource(e2, t2, o2) {
          if (this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), !this.workerSources[e2][t2][o2]) {
            const i2 = {
              sendAsync: (t3, o3) => (t3.targetMapId = e2, this.actor.sendAsync(t3, o3))
            };
            switch (t2) {
              case "vector":
                this.workerSources[e2][t2][o2] = new r(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                break;
              case "geojson":
                this.workerSources[e2][t2][o2] = new ye(i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
                break;
              default:
                this.workerSources[e2][t2][o2] = new this.externalWorkerSourceTypes[t2](i2, this._getLayerIndex(e2), this._getAvailableImages(e2));
            }
          }
          return this.workerSources[e2][t2][o2];
        }
        _getDEMWorkerSource(e2, t2) {
          return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new n), this.demWorkerSources[e2][t2];
        }
      }
      return e.i(self) && (self.worker = new ve(self)), ve;
    });
    define2("index", ["exports", "./shared"], function(t, e) {
      var i = "4.7.0";
      let a, s;
      const o = {
        now: typeof performance != "undefined" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),
        frameAsync: (t2) => new Promise((i2, a2) => {
          const s2 = requestAnimationFrame(i2);
          t2.signal.addEventListener("abort", () => {
            cancelAnimationFrame(s2), a2(e.c());
          });
        }),
        getImageData(t2, e2 = 0) {
          return this.getImageCanvasContext(t2).getImageData(-e2, -e2, t2.width + 2 * e2, t2.height + 2 * e2);
        },
        getImageCanvasContext(t2) {
          const e2 = window.document.createElement("canvas"), i2 = e2.getContext("2d", { willReadFrequently: true });
          if (!i2)
            throw new Error("failed to create canvas 2d context");
          return e2.width = t2.width, e2.height = t2.height, i2.drawImage(t2, 0, 0, t2.width, t2.height), i2;
        },
        resolveURL: (t2) => (a || (a = document.createElement("a")), a.href = t2, a.href),
        hardwareConcurrency: typeof navigator != "undefined" && navigator.hardwareConcurrency || 4,
        get prefersReducedMotion() {
          return !!matchMedia && (s == null && (s = matchMedia("(prefers-reduced-motion: reduce)")), s.matches);
        }
      };

      class r {
        static testProp(t2) {
          if (!r.docStyle)
            return t2[0];
          for (let e2 = 0;e2 < t2.length; e2++)
            if (t2[e2] in r.docStyle)
              return t2[e2];
          return t2[0];
        }
        static create(t2, e2, i2) {
          const a2 = window.document.createElement(t2);
          return e2 !== undefined && (a2.className = e2), i2 && i2.appendChild(a2), a2;
        }
        static createNS(t2, e2) {
          return window.document.createElementNS(t2, e2);
        }
        static disableDrag() {
          r.docStyle && r.selectProp && (r.userSelect = r.docStyle[r.selectProp], r.docStyle[r.selectProp] = "none");
        }
        static enableDrag() {
          r.docStyle && r.selectProp && (r.docStyle[r.selectProp] = r.userSelect);
        }
        static setTransform(t2, e2) {
          t2.style[r.transformProp] = e2;
        }
        static addEventListener(t2, e2, i2, a2 = {}) {
          t2.addEventListener(e2, i2, "passive" in a2 ? a2 : a2.capture);
        }
        static removeEventListener(t2, e2, i2, a2 = {}) {
          t2.removeEventListener(e2, i2, "passive" in a2 ? a2 : a2.capture);
        }
        static suppressClickInternal(t2) {
          t2.preventDefault(), t2.stopPropagation(), window.removeEventListener("click", r.suppressClickInternal, true);
        }
        static suppressClick() {
          window.addEventListener("click", r.suppressClickInternal, true), window.setTimeout(() => {
            window.removeEventListener("click", r.suppressClickInternal, true);
          }, 0);
        }
        static getScale(t2) {
          const e2 = t2.getBoundingClientRect();
          return {
            x: e2.width / t2.offsetWidth || 1,
            y: e2.height / t2.offsetHeight || 1,
            boundingClientRect: e2
          };
        }
        static getPoint(t2, i2, a2) {
          const s2 = i2.boundingClientRect;
          return new e.P((a2.clientX - s2.left) / i2.x - t2.clientLeft, (a2.clientY - s2.top) / i2.y - t2.clientTop);
        }
        static mousePos(t2, e2) {
          const i2 = r.getScale(t2);
          return r.getPoint(t2, i2, e2);
        }
        static touchPos(t2, e2) {
          const i2 = [], a2 = r.getScale(t2);
          for (let s2 = 0;s2 < e2.length; s2++)
            i2.push(r.getPoint(t2, a2, e2[s2]));
          return i2;
        }
        static mouseButton(t2) {
          return t2.button;
        }
        static remove(t2) {
          t2.parentNode && t2.parentNode.removeChild(t2);
        }
      }
      r.docStyle = typeof window != "undefined" && window.document && window.document.documentElement.style, r.selectProp = r.testProp([
        "userSelect",
        "MozUserSelect",
        "WebkitUserSelect",
        "msUserSelect"
      ]), r.transformProp = r.testProp(["transform", "WebkitTransform"]);
      const n = {
        supported: false,
        testSupport: function(t2) {
          !c && h && (u ? d(t2) : l = t2);
        }
      };
      let l, h, c = false, u = false;
      function d(t2) {
        const e2 = t2.createTexture();
        t2.bindTexture(t2.TEXTURE_2D, e2);
        try {
          if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, h), t2.isContextLost())
            return;
          n.supported = true;
        } catch (t3) {
        }
        t2.deleteTexture(e2), c = true;
      }
      var _;
      typeof document != "undefined" && (h = document.createElement("img"), h.onload = () => {
        l && d(l), l = null, u = true;
      }, h.onerror = () => {
        c = true, l = null;
      }, h.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(t2) {
        let i2, a2, s2, o2;
        t2.resetRequestQueue = () => {
          i2 = [], a2 = 0, s2 = 0, o2 = {};
        }, t2.addThrottleControl = (t3) => {
          const e2 = s2++;
          return o2[e2] = t3, e2;
        }, t2.removeThrottleControl = (t3) => {
          delete o2[t3], l2();
        }, t2.getImage = (t3, a3, s3 = true) => new Promise((o3, r3) => {
          n.supported && (t3.headers || (t3.headers = {}), t3.headers.accept = "image/webp,*/*"), e.e(t3, { type: "image" }), i2.push({
            abortController: a3,
            requestParameters: t3,
            supportImageRefresh: s3,
            state: "queued",
            onError: (t4) => {
              r3(t4);
            },
            onSuccess: (t4) => {
              o3(t4);
            }
          }), l2();
        });
        const r2 = (t3) => e._(this, undefined, undefined, function* () {
          t3.state = "running";
          const {
            requestParameters: i3,
            supportImageRefresh: s3,
            onError: o3,
            onSuccess: r3,
            abortController: n2
          } = t3, c2 = s3 === false && !e.i(self) && !e.g(i3.url) && (!i3.headers || Object.keys(i3.headers).reduce((t4, e2) => t4 && e2 === "accept", true));
          a2++;
          const u2 = c2 ? h2(i3, n2) : e.m(i3, n2);
          try {
            const i4 = yield u2;
            delete t3.abortController, t3.state = "completed", i4.data instanceof HTMLImageElement || e.b(i4.data) ? r3(i4) : i4.data && r3({
              data: yield (d2 = i4.data, typeof createImageBitmap == "function" ? e.d(d2) : e.f(d2)),
              cacheControl: i4.cacheControl,
              expires: i4.expires
            });
          } catch (e2) {
            delete t3.abortController, o3(e2);
          } finally {
            a2--, l2();
          }
          var d2;
        }), l2 = () => {
          const t3 = (() => {
            for (const t4 of Object.keys(o2))
              if (o2[t4]())
                return true;
            return false;
          })() ? e.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : e.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let e2 = a2;e2 < t3 && i2.length > 0; e2++) {
            const t4 = i2.shift();
            t4.abortController.signal.aborted ? e2-- : r2(t4);
          }
        }, h2 = (t3, i3) => new Promise((a3, s3) => {
          const o3 = new Image, r3 = t3.url, n2 = t3.credentials;
          n2 && n2 === "include" ? o3.crossOrigin = "use-credentials" : (n2 && n2 === "same-origin" || !e.s(r3)) && (o3.crossOrigin = "anonymous"), i3.signal.addEventListener("abort", () => {
            o3.src = "", s3(e.c());
          }), o3.fetchPriority = "high", o3.onload = () => {
            o3.onerror = o3.onload = null, a3({ data: o3 });
          }, o3.onerror = () => {
            o3.onerror = o3.onload = null, i3.signal.aborted || s3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }, o3.src = r3;
        });
      }(_ || (_ = {})), _.resetRequestQueue();

      class p {
        constructor(t2) {
          this._transformRequestFn = t2;
        }
        transformRequest(t2, e2) {
          return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
        }
        setTransformRequest(t2) {
          this._transformRequestFn = t2;
        }
      }
      function m(t2) {
        var i2 = new e.A(3);
        return i2[0] = t2[0], i2[1] = t2[1], i2[2] = t2[2], i2;
      }
      var f, g = function(t2, e2, i2) {
        return t2[0] = e2[0] - i2[0], t2[1] = e2[1] - i2[1], t2[2] = e2[2] - i2[2], t2;
      };
      f = new e.A(3), e.A != Float32Array && (f[0] = 0, f[1] = 0, f[2] = 0);
      var v = function(t2) {
        var e2 = t2[0], i2 = t2[1];
        return e2 * e2 + i2 * i2;
      };
      function x(t2) {
        const e2 = [];
        if (typeof t2 == "string")
          e2.push({ id: "default", url: t2 });
        else if (t2 && t2.length > 0) {
          const i2 = [];
          for (const { id: a2, url: s2 } of t2) {
            const t3 = `${a2}${s2}`;
            i2.indexOf(t3) === -1 && (i2.push(t3), e2.push({ id: a2, url: s2 }));
          }
        }
        return e2;
      }
      function y(t2, e2, i2) {
        const a2 = t2.split("?");
        return a2[0] += `${e2}${i2}`, a2.join("?");
      }
      (function() {
        var t2 = new e.A(2);
        e.A != Float32Array && (t2[0] = 0, t2[1] = 0);
      })();

      class b {
        constructor(t2, e2, i2, a2) {
          this.context = t2, this.format = i2, this.texture = t2.gl.createTexture(), this.update(e2, a2);
        }
        update(t2, i2, a2) {
          const { width: s2, height: o2 } = t2, r2 = !(this.size && this.size[0] === s2 && this.size[1] === o2 || a2), { context: n2 } = this, { gl: l2 } = n2;
          if (this.useMipmap = Boolean(i2 && i2.useMipmap), l2.bindTexture(l2.TEXTURE_2D, this.texture), n2.pixelStoreUnpackFlipY.set(false), n2.pixelStoreUnpack.set(1), n2.pixelStoreUnpackPremultiplyAlpha.set(this.format === l2.RGBA && (!i2 || i2.premultiply !== false)), r2)
            this.size = [s2, o2], t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || e.b(t2) ? l2.texImage2D(l2.TEXTURE_2D, 0, this.format, this.format, l2.UNSIGNED_BYTE, t2) : l2.texImage2D(l2.TEXTURE_2D, 0, this.format, s2, o2, 0, this.format, l2.UNSIGNED_BYTE, t2.data);
          else {
            const { x: i3, y: r3 } = a2 || { x: 0, y: 0 };
            t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || e.b(t2) ? l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, r3, l2.RGBA, l2.UNSIGNED_BYTE, t2) : l2.texSubImage2D(l2.TEXTURE_2D, 0, i3, r3, s2, o2, l2.RGBA, l2.UNSIGNED_BYTE, t2.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && l2.generateMipmap(l2.TEXTURE_2D);
        }
        bind(t2, e2, i2) {
          const { context: a2 } = this, { gl: s2 } = a2;
          s2.bindTexture(s2.TEXTURE_2D, this.texture), i2 !== s2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i2 = s2.LINEAR), t2 !== this.filter && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MAG_FILTER, t2), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MIN_FILTER, i2 || t2), this.filter = t2), e2 !== this.wrap && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_S, e2), s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_T, e2), this.wrap = e2);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: t2 } = this.context;
          t2.deleteTexture(this.texture), this.texture = null;
        }
      }
      function w(t2) {
        const { userImage: e2 } = t2;
        return !!(e2 && e2.render && e2.render()) && (t2.data.replace(new Uint8Array(e2.data.buffer)), true);
      }

      class T extends e.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new e.R({ width: 1, height: 1 }), this.dirty = true;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(t2) {
          if (this.loaded !== t2 && (this.loaded = t2, t2)) {
            for (const { ids: t3, promiseResolve: e2 } of this.requestors)
              e2(this._getImagesForIds(t3));
            this.requestors = [];
          }
        }
        getImage(t2) {
          const i2 = this.images[t2];
          if (i2 && !i2.data && i2.spriteData) {
            const t3 = i2.spriteData;
            i2.data = new e.R({ width: t3.width, height: t3.height }, t3.context.getImageData(t3.x, t3.y, t3.width, t3.height).data), i2.spriteData = null;
          }
          return i2;
        }
        addImage(t2, e2) {
          if (this.images[t2])
            throw new Error(`Image id ${t2} already exist, use updateImage instead`);
          this._validate(t2, e2) && (this.images[t2] = e2);
        }
        _validate(t2, i2) {
          let a2 = true;
          const s2 = i2.data || i2.spriteData;
          return this._validateStretch(i2.stretchX, s2 && s2.width) || (this.fire(new e.j(new Error(`Image "${t2}" has invalid "stretchX" value`))), a2 = false), this._validateStretch(i2.stretchY, s2 && s2.height) || (this.fire(new e.j(new Error(`Image "${t2}" has invalid "stretchY" value`))), a2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.j(new Error(`Image "${t2}" has invalid "content" value`))), a2 = false), a2;
        }
        _validateStretch(t2, e2) {
          if (!t2)
            return true;
          let i2 = 0;
          for (const a2 of t2) {
            if (a2[0] < i2 || a2[1] < a2[0] || e2 < a2[1])
              return false;
            i2 = a2[1];
          }
          return true;
        }
        _validateContent(t2, e2) {
          if (!t2)
            return true;
          if (t2.length !== 4)
            return false;
          const i2 = e2.spriteData, a2 = i2 && i2.width || e2.data.width, s2 = i2 && i2.height || e2.data.height;
          return !(t2[0] < 0 || a2 < t2[0] || t2[1] < 0 || s2 < t2[1] || t2[2] < 0 || a2 < t2[2] || t2[3] < 0 || s2 < t2[3] || t2[2] < t2[0] || t2[3] < t2[1]);
        }
        updateImage(t2, e2, i2 = true) {
          const a2 = this.getImage(t2);
          if (i2 && (a2.data.width !== e2.data.width || a2.data.height !== e2.data.height))
            throw new Error(`size mismatch between old image (${a2.data.width}x${a2.data.height}) and new image (${e2.data.width}x${e2.data.height}).`);
          e2.version = a2.version + 1, this.images[t2] = e2, this.updatedImages[t2] = true;
        }
        removeImage(t2) {
          const e2 = this.images[t2];
          delete this.images[t2], delete this.patterns[t2], e2.userImage && e2.userImage.onRemove && e2.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(t2) {
          return new Promise((e2, i2) => {
            let a2 = true;
            if (!this.isLoaded())
              for (const e3 of t2)
                this.images[e3] || (a2 = false);
            this.isLoaded() || a2 ? e2(this._getImagesForIds(t2)) : this.requestors.push({ ids: t2, promiseResolve: e2 });
          });
        }
        _getImagesForIds(t2) {
          const i2 = {};
          for (const a2 of t2) {
            let t3 = this.getImage(a2);
            t3 || (this.fire(new e.k("styleimagemissing", { id: a2 })), t3 = this.getImage(a2)), t3 ? i2[a2] = {
              data: t3.data.clone(),
              pixelRatio: t3.pixelRatio,
              sdf: t3.sdf,
              version: t3.version,
              stretchX: t3.stretchX,
              stretchY: t3.stretchY,
              content: t3.content,
              textFitWidth: t3.textFitWidth,
              textFitHeight: t3.textFitHeight,
              hasRenderCallback: Boolean(t3.userImage && t3.userImage.render)
            } : e.w(`Image "${a2}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return i2;
        }
        getPixelSize() {
          const { width: t2, height: e2 } = this.atlasImage;
          return { width: t2, height: e2 };
        }
        getPattern(t2) {
          const i2 = this.patterns[t2], a2 = this.getImage(t2);
          if (!a2)
            return null;
          if (i2 && i2.position.version === a2.version)
            return i2.position;
          if (i2)
            i2.position.version = a2.version;
          else {
            const i3 = { w: a2.data.width + 2, h: a2.data.height + 2, x: 0, y: 0 }, s2 = new e.I(i3, a2);
            this.patterns[t2] = { bin: i3, position: s2 };
          }
          return this._updatePatternAtlas(), this.patterns[t2].position;
        }
        bind(t2) {
          const e2 = t2.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new b(t2, this.atlasImage, e2.RGBA), this.atlasTexture.bind(e2.LINEAR, e2.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const t2 = [];
          for (const e2 in this.patterns)
            t2.push(this.patterns[e2].bin);
          const { w: i2, h: a2 } = e.p(t2), s2 = this.atlasImage;
          s2.resize({ width: i2 || 1, height: a2 || 1 });
          for (const t3 in this.patterns) {
            const { bin: i3 } = this.patterns[t3], a3 = i3.x + 1, o2 = i3.y + 1, r2 = this.getImage(t3).data, n2 = r2.width, l2 = r2.height;
            e.R.copy(r2, s2, { x: 0, y: 0 }, { x: a3, y: o2 }, { width: n2, height: l2 }), e.R.copy(r2, s2, { x: 0, y: l2 - 1 }, { x: a3, y: o2 - 1 }, { width: n2, height: 1 }), e.R.copy(r2, s2, { x: 0, y: 0 }, { x: a3, y: o2 + l2 }, { width: n2, height: 1 }), e.R.copy(r2, s2, { x: n2 - 1, y: 0 }, { x: a3 - 1, y: o2 }, { width: 1, height: l2 }), e.R.copy(r2, s2, { x: 0, y: 0 }, { x: a3 + n2, y: o2 }, { width: 1, height: l2 });
          }
          this.dirty = true;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(t2) {
          for (const i2 of t2) {
            if (this.callbackDispatchedThisFrame[i2])
              continue;
            this.callbackDispatchedThisFrame[i2] = true;
            const t3 = this.getImage(i2);
            t3 || e.w(`Image with ID: "${i2}" was not found`), w(t3) && this.updateImage(i2, t3);
          }
        }
      }
      const I = 100000000000000000000;
      function E(t2, e2, i2, a2, s2, o2, r2, n2, l2) {
        for (let h2 = e2;h2 < e2 + a2; h2++)
          P(t2, i2 * o2 + h2, o2, s2, r2, n2, l2);
        for (let h2 = i2;h2 < i2 + s2; h2++)
          P(t2, h2 * o2 + e2, 1, a2, r2, n2, l2);
      }
      function P(t2, e2, i2, a2, s2, o2, r2) {
        o2[0] = 0, r2[0] = -I, r2[1] = I, s2[0] = t2[e2];
        for (let n2 = 1, l2 = 0, h2 = 0;n2 < a2; n2++) {
          s2[n2] = t2[e2 + n2 * i2];
          const a3 = n2 * n2;
          do {
            const t3 = o2[l2];
            h2 = (s2[n2] - s2[t3] + a3 - t3 * t3) / (n2 - t3) / 2;
          } while (h2 <= r2[l2] && --l2 > -1);
          l2++, o2[l2] = n2, r2[l2] = h2, r2[l2 + 1] = I;
        }
        for (let n2 = 0, l2 = 0;n2 < a2; n2++) {
          for (;r2[l2 + 1] < n2; )
            l2++;
          const a3 = o2[l2], h2 = n2 - a3;
          t2[e2 + n2 * i2] = s2[a3] + h2 * h2;
        }
      }

      class C {
        constructor(t2, e2) {
          this.requestManager = t2, this.localIdeographFontFamily = e2, this.entries = {};
        }
        setURL(t2) {
          this.url = t2;
        }
        getGlyphs(t2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = [];
            for (const i3 in t2)
              for (const a3 of t2[i3])
                e2.push(this._getAndCacheGlyphsPromise(i3, a3));
            const i2 = yield Promise.all(e2), a2 = {};
            for (const { stack: t3, id: e3, glyph: s2 } of i2)
              a2[t3] || (a2[t3] = {}), a2[t3][e3] = s2 && {
                id: s2.id,
                bitmap: s2.bitmap.clone(),
                metrics: s2.metrics
              };
            return a2;
          });
        }
        _getAndCacheGlyphsPromise(t2, i2) {
          return e._(this, undefined, undefined, function* () {
            let e2 = this.entries[t2];
            e2 || (e2 = this.entries[t2] = { glyphs: {}, requests: {}, ranges: {} });
            let a2 = e2.glyphs[i2];
            if (a2 !== undefined)
              return { stack: t2, id: i2, glyph: a2 };
            if (a2 = this._tinySDF(e2, t2, i2), a2)
              return e2.glyphs[i2] = a2, { stack: t2, id: i2, glyph: a2 };
            const s2 = Math.floor(i2 / 256);
            if (256 * s2 > 65535)
              throw new Error("glyphs > 65535 not supported");
            if (e2.ranges[s2])
              return { stack: t2, id: i2, glyph: a2 };
            if (!this.url)
              throw new Error("glyphsUrl is not set");
            if (!e2.requests[s2]) {
              const i3 = C.loadGlyphRange(t2, s2, this.url, this.requestManager);
              e2.requests[s2] = i3;
            }
            const o2 = yield e2.requests[s2];
            for (const t3 in o2)
              this._doesCharSupportLocalGlyph(+t3) || (e2.glyphs[+t3] = o2[+t3]);
            return e2.ranges[s2] = true, { stack: t2, id: i2, glyph: o2[i2] || null };
          });
        }
        _doesCharSupportLocalGlyph(t2) {
          return !!this.localIdeographFontFamily && /\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(String.fromCodePoint(t2));
        }
        _tinySDF(t2, i2, a2) {
          const s2 = this.localIdeographFontFamily;
          if (!s2)
            return;
          if (!this._doesCharSupportLocalGlyph(a2))
            return;
          let o2 = t2.tinySDF;
          if (!o2) {
            let e2 = "400";
            /bold/i.test(i2) ? e2 = "900" : /medium/i.test(i2) ? e2 = "500" : /light/i.test(i2) && (e2 = "200"), o2 = t2.tinySDF = new C.TinySDF({
              fontSize: 48,
              buffer: 6,
              radius: 16,
              cutoff: 0.25,
              fontFamily: s2,
              fontWeight: e2
            });
          }
          const r2 = o2.draw(String.fromCharCode(a2));
          return {
            id: a2,
            bitmap: new e.o({ width: r2.width || 60, height: r2.height || 60 }, r2.data),
            metrics: {
              width: r2.glyphWidth / 2 || 24,
              height: r2.glyphHeight / 2 || 24,
              left: r2.glyphLeft / 2 + 0.5 || 0,
              top: r2.glyphTop / 2 - 27.5 || -8,
              advance: r2.glyphAdvance / 2 || 24,
              isDoubleResolution: true
            }
          };
        }
      }
      C.loadGlyphRange = function(t2, i2, a2, s2) {
        return e._(this, undefined, undefined, function* () {
          const o2 = 256 * i2, r2 = o2 + 255, n2 = s2.transformRequest(a2.replace("{fontstack}", t2).replace("{range}", `${o2}-${r2}`), "Glyphs"), l2 = yield e.l(n2, new AbortController);
          if (!l2 || !l2.data)
            throw new Error(`Could not load glyph range. range: ${i2}, ${o2}-${r2}`);
          const h2 = {};
          for (const t3 of e.n(l2.data))
            h2[t3.id] = t3;
          return h2;
        });
      }, C.TinySDF = class {
        constructor({
          fontSize: t2 = 24,
          buffer: e2 = 3,
          radius: i2 = 8,
          cutoff: a2 = 0.25,
          fontFamily: s2 = "sans-serif",
          fontWeight: o2 = "normal",
          fontStyle: r2 = "normal"
        } = {}) {
          this.buffer = e2, this.cutoff = a2, this.radius = i2;
          const n2 = this.size = t2 + 4 * e2, l2 = this._createCanvas(n2), h2 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
          h2.font = `${r2} ${o2} ${t2}px ${s2}`, h2.textBaseline = "alphabetic", h2.textAlign = "left", h2.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Uint16Array(n2);
        }
        _createCanvas(t2) {
          const e2 = document.createElement("canvas");
          return e2.width = e2.height = t2, e2;
        }
        draw(t2) {
          const {
            width: e2,
            actualBoundingBoxAscent: i2,
            actualBoundingBoxDescent: a2,
            actualBoundingBoxLeft: s2,
            actualBoundingBoxRight: o2
          } = this.ctx.measureText(t2), r2 = Math.ceil(i2), n2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o2 - s2))), l2 = Math.min(this.size - this.buffer, r2 + Math.ceil(a2)), h2 = n2 + 2 * this.buffer, c2 = l2 + 2 * this.buffer, u2 = Math.max(h2 * c2, 0), d2 = new Uint8ClampedArray(u2), _2 = {
            data: d2,
            width: h2,
            height: c2,
            glyphWidth: n2,
            glyphHeight: l2,
            glyphTop: r2,
            glyphLeft: 0,
            glyphAdvance: e2
          };
          if (n2 === 0 || l2 === 0)
            return _2;
          const { ctx: p2, buffer: m2, gridInner: f2, gridOuter: g2 } = this;
          p2.clearRect(m2, m2, n2, l2), p2.fillText(t2, m2, m2 + r2);
          const v2 = p2.getImageData(m2, m2, n2, l2);
          g2.fill(I, 0, u2), f2.fill(0, 0, u2);
          for (let t3 = 0;t3 < l2; t3++)
            for (let e3 = 0;e3 < n2; e3++) {
              const i3 = v2.data[4 * (t3 * n2 + e3) + 3] / 255;
              if (i3 === 0)
                continue;
              const a3 = (t3 + m2) * h2 + e3 + m2;
              if (i3 === 1)
                g2[a3] = 0, f2[a3] = I;
              else {
                const t4 = 0.5 - i3;
                g2[a3] = t4 > 0 ? t4 * t4 : 0, f2[a3] = t4 < 0 ? t4 * t4 : 0;
              }
            }
          E(g2, 0, 0, h2, c2, h2, this.f, this.v, this.z), E(f2, m2, m2, n2, l2, h2, this.f, this.v, this.z);
          for (let t3 = 0;t3 < u2; t3++) {
            const e3 = Math.sqrt(g2[t3]) - Math.sqrt(f2[t3]);
            d2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
          }
          return _2;
        }
      };

      class S {
        constructor() {
          this.specification = e.v.light.position;
        }
        possiblyEvaluate(t2, i2) {
          return e.x(t2.expression.evaluate(i2));
        }
        interpolate(t2, i2, a2) {
          return {
            x: e.y.number(t2.x, i2.x, a2),
            y: e.y.number(t2.y, i2.y, a2),
            z: e.y.number(t2.z, i2.z, a2)
          };
        }
      }
      let z;

      class D extends e.E {
        constructor(t2) {
          super(), z = z || new e.q({
            anchor: new e.D(e.v.light.anchor),
            position: new S,
            color: new e.D(e.v.light.color),
            intensity: new e.D(e.v.light.intensity)
          }), this._transitionable = new e.T(z), this.setLight(t2), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(t2, i2 = {}) {
          if (!this._validate(e.r, t2, i2))
            for (const e2 in t2) {
              const i3 = t2[e2];
              e2.endsWith("-transition") ? this._transitionable.setTransition(e2.slice(0, -11), i3) : this._transitionable.setValue(e2, i3);
            }
        }
        updateTransitions(t2) {
          this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t2) {
          this.properties = this._transitioning.possiblyEvaluate(t2);
        }
        _validate(t2, i2, a2) {
          return (!a2 || a2.validate !== false) && e.t(this, t2.call(e.u, {
            value: i2,
            style: { glyphs: true, sprite: true },
            styleSpec: e.v
          }));
        }
      }
      const M = new e.q({
        "sky-color": new e.D(e.v.sky["sky-color"]),
        "horizon-color": new e.D(e.v.sky["horizon-color"]),
        "fog-color": new e.D(e.v.sky["fog-color"]),
        "fog-ground-blend": new e.D(e.v.sky["fog-ground-blend"]),
        "horizon-fog-blend": new e.D(e.v.sky["horizon-fog-blend"]),
        "sky-horizon-blend": new e.D(e.v.sky["sky-horizon-blend"]),
        "atmosphere-blend": new e.D(e.v.sky["atmosphere-blend"])
      });

      class A extends e.E {
        constructor(t2) {
          super(), this._transitionable = new e.T(M), this.setSky(t2), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new e.z(0));
        }
        setSky(t2, i2 = {}) {
          if (!this._validate(e.B, t2, i2)) {
            t2 || (t2 = {
              "sky-color": "transparent",
              "horizon-color": "transparent",
              "fog-color": "transparent",
              "fog-ground-blend": 1,
              "atmosphere-blend": 0
            });
            for (const e2 in t2) {
              const i3 = t2[e2];
              e2.endsWith("-transition") ? this._transitionable.setTransition(e2.slice(0, -11), i3) : this._transitionable.setValue(e2, i3);
            }
          }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(t2) {
          this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t2) {
          this.properties = this._transitioning.possiblyEvaluate(t2);
        }
        _validate(t2, i2, a2 = {}) {
          return (a2 == null ? undefined : a2.validate) !== false && e.t(this, t2.call(e.u, e.e({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.v })));
        }
        calculateFogBlendOpacity(t2) {
          return t2 < 60 ? 0 : t2 < 70 ? (t2 - 60) / 10 : 1;
        }
      }

      class R {
        constructor(t2, e2) {
          this.width = t2, this.height = e2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(t2, e2) {
          const i2 = t2.join(",") + String(e2);
          return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(t2, e2)), this.dashEntry[i2];
        }
        getDashRanges(t2, e2, i2) {
          const a2 = [];
          let s2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * i2 : 0, o2 = t2[0] * i2, r2 = true;
          a2.push({ left: s2, right: o2, isDash: r2, zeroLength: t2[0] === 0 });
          let n2 = t2[0];
          for (let e3 = 1;e3 < t2.length; e3++) {
            r2 = !r2;
            const l2 = t2[e3];
            s2 = n2 * i2, n2 += l2, o2 = n2 * i2, a2.push({ left: s2, right: o2, isDash: r2, zeroLength: l2 === 0 });
          }
          return a2;
        }
        addRoundDash(t2, e2, i2) {
          const a2 = e2 / 2;
          for (let e3 = -i2;e3 <= i2; e3++) {
            const s2 = this.width * (this.nextRow + i2 + e3);
            let o2 = 0, r2 = t2[o2];
            for (let n2 = 0;n2 < this.width; n2++) {
              n2 / r2.right > 1 && (r2 = t2[++o2]);
              const l2 = Math.abs(n2 - r2.left), h2 = Math.abs(n2 - r2.right), c2 = Math.min(l2, h2);
              let u2;
              const d2 = e3 / i2 * (a2 + 1);
              if (r2.isDash) {
                const t3 = a2 - Math.abs(d2);
                u2 = Math.sqrt(c2 * c2 + t3 * t3);
              } else
                u2 = a2 - Math.sqrt(c2 * c2 + d2 * d2);
              this.data[s2 + n2] = Math.max(0, Math.min(255, u2 + 128));
            }
          }
        }
        addRegularDash(t2) {
          for (let e3 = t2.length - 1;e3 >= 0; --e3) {
            const i3 = t2[e3], a3 = t2[e3 + 1];
            i3.zeroLength ? t2.splice(e3, 1) : a3 && a3.isDash === i3.isDash && (a3.left = i3.left, t2.splice(e3, 1));
          }
          const e2 = t2[0], i2 = t2[t2.length - 1];
          e2.isDash === i2.isDash && (e2.left = i2.left - this.width, i2.right = e2.right + this.width);
          const a2 = this.width * this.nextRow;
          let s2 = 0, o2 = t2[s2];
          for (let e3 = 0;e3 < this.width; e3++) {
            e3 / o2.right > 1 && (o2 = t2[++s2]);
            const i3 = Math.abs(e3 - o2.left), r2 = Math.abs(e3 - o2.right), n2 = Math.min(i3, r2);
            this.data[a2 + e3] = Math.max(0, Math.min(255, (o2.isDash ? n2 : -n2) + 128));
          }
        }
        addDash(t2, i2) {
          const a2 = i2 ? 7 : 0, s2 = 2 * a2 + 1;
          if (this.nextRow + s2 > this.height)
            return e.w("LineAtlas out of space"), null;
          let o2 = 0;
          for (let e2 = 0;e2 < t2.length; e2++)
            o2 += t2[e2];
          if (o2 !== 0) {
            const e2 = this.width / o2, s3 = this.getDashRanges(t2, this.width, e2);
            i2 ? this.addRoundDash(s3, e2, a2) : this.addRegularDash(s3);
          }
          const r2 = {
            y: (this.nextRow + a2 + 0.5) / this.height,
            height: 2 * a2 / this.height,
            width: o2
          };
          return this.nextRow += s2, this.dirty = true, r2;
        }
        bind(t2) {
          const e2 = t2.gl;
          this.texture ? (e2.bindTexture(e2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, this.width, this.height, e2.ALPHA, e2.UNSIGNED_BYTE, this.data))) : (this.texture = e2.createTexture(), e2.bindTexture(e2.TEXTURE_2D, this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR), e2.texImage2D(e2.TEXTURE_2D, 0, e2.ALPHA, this.width, this.height, 0, e2.ALPHA, e2.UNSIGNED_BYTE, this.data));
        }
      }
      const k = "maplibre_preloaded_worker_pool";

      class L {
        constructor() {
          this.active = {};
        }
        acquire(t2) {
          if (!this.workers)
            for (this.workers = [];this.workers.length < L.workerCount; )
              this.workers.push(new Worker(e.a.WORKER_URL));
          return this.active[t2] = true, this.workers.slice();
        }
        release(t2) {
          delete this.active[t2], this.numActive() === 0 && (this.workers.forEach((t3) => {
            t3.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[k];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const F = Math.floor(o.hardwareConcurrency / 2);
      let B, O;
      function N() {
        return B || (B = new L), B;
      }
      L.workerCount = e.C(globalThis) ? Math.max(Math.min(F, 3), 1) : 1;

      class U {
        constructor(t2, i2) {
          this.workerPool = t2, this.actors = [], this.currentActor = 0, this.id = i2;
          const a2 = this.workerPool.acquire(i2);
          for (let t3 = 0;t3 < a2.length; t3++) {
            const s2 = new e.F(a2[t3], i2);
            s2.name = `Worker ${t3}`, this.actors.push(s2);
          }
          if (!this.actors.length)
            throw new Error("No actors found");
        }
        broadcast(t2, e2) {
          const i2 = [];
          for (const a2 of this.actors)
            i2.push(a2.sendAsync({ type: t2, data: e2 }));
          return Promise.all(i2);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove(t2 = true) {
          this.actors.forEach((t3) => {
            t3.remove();
          }), this.actors = [], t2 && this.workerPool.release(this.id);
        }
        registerMessageHandler(t2, e2) {
          for (const i2 of this.actors)
            i2.registerMessageHandler(t2, e2);
        }
      }
      function j() {
        return O || (O = new U(N(), e.G), O.registerMessageHandler("GR", (t2, i2, a2) => e.m(i2, a2))), O;
      }
      function Z(t2, i2) {
        const a2 = e.H();
        return e.J(a2, a2, [1, 1, 0]), e.K(a2, a2, [0.5 * t2.width, 0.5 * t2.height, 1]), e.L(a2, a2, t2.calculatePosMatrix(i2.toUnwrapped()));
      }
      function q(t2, e2, i2, a2, s2, o2) {
        const r2 = function(t3, e3, i3) {
          if (t3)
            for (const a3 of t3) {
              const t4 = e3[a3];
              if (t4 && t4.source === i3 && t4.type === "fill-extrusion")
                return true;
            }
          else
            for (const t4 in e3) {
              const a3 = e3[t4];
              if (a3.source === i3 && a3.type === "fill-extrusion")
                return true;
            }
          return false;
        }(s2 && s2.layers, e2, t2.id), n2 = o2.maxPitchScaleFactor(), l2 = t2.tilesIn(a2, n2, r2);
        l2.sort(V);
        const h2 = [];
        for (const a3 of l2)
          h2.push({
            wrappedTileID: a3.tileID.wrapped().key,
            queryResults: a3.tile.queryRenderedFeatures(e2, i2, t2._state, a3.queryGeometry, a3.cameraQueryGeometry, a3.scale, s2, o2, n2, Z(t2.transform, a3.tileID))
          });
        const c2 = function(t3) {
          const e3 = {}, i3 = {};
          for (const a3 of t3) {
            const { queryResults: t4, wrappedTileID: s3 } = a3, o3 = i3[s3] = i3[s3] || {};
            for (const i4 in t4) {
              const a4 = t4[i4], s4 = o3[i4] = o3[i4] || {}, r3 = e3[i4] = e3[i4] || [];
              for (const t5 of a4)
                s4[t5.featureIndex] || (s4[t5.featureIndex] = true, r3.push(t5));
            }
          }
          return e3;
        }(h2);
        for (const e3 in c2)
          c2[e3].forEach((e4) => {
            const i3 = e4.feature, a3 = t2.getFeatureState(i3.layer["source-layer"], i3.id);
            i3.source = i3.layer.source, i3.layer["source-layer"] && (i3.sourceLayer = i3.layer["source-layer"]), i3.state = a3;
          });
        return c2;
      }
      function V(t2, e2) {
        const i2 = t2.tileID, a2 = e2.tileID;
        return i2.overscaledZ - a2.overscaledZ || i2.canonical.y - a2.canonical.y || i2.wrap - a2.wrap || i2.canonical.x - a2.canonical.x;
      }
      function G(t2, i2, a2) {
        return e._(this, undefined, undefined, function* () {
          let s2 = t2;
          if (t2.url ? s2 = (yield e.h(i2.transformRequest(t2.url, "Source"), a2)).data : yield o.frameAsync(a2), !s2)
            return null;
          const r2 = e.M(e.e(s2, t2), [
            "tiles",
            "minzoom",
            "maxzoom",
            "attribution",
            "bounds",
            "scheme",
            "tileSize",
            "encoding"
          ]);
          return "vector_layers" in s2 && s2.vector_layers && (r2.vectorLayerIds = s2.vector_layers.map((t3) => t3.id)), r2;
        });
      }

      class H {
        constructor(t2, e2) {
          t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : Array.isArray(t2) && (t2.length === 4 ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1])));
        }
        setNorthEast(t2) {
          return this._ne = t2 instanceof e.N ? new e.N(t2.lng, t2.lat) : e.N.convert(t2), this;
        }
        setSouthWest(t2) {
          return this._sw = t2 instanceof e.N ? new e.N(t2.lng, t2.lat) : e.N.convert(t2), this;
        }
        extend(t2) {
          const i2 = this._sw, a2 = this._ne;
          let s2, o2;
          if (t2 instanceof e.N)
            s2 = t2, o2 = t2;
          else {
            if (!(t2 instanceof H))
              return Array.isArray(t2) ? t2.length === 4 || t2.every(Array.isArray) ? this.extend(H.convert(t2)) : this.extend(e.N.convert(t2)) : t2 && (("lng" in t2) || ("lon" in t2)) && ("lat" in t2) ? this.extend(e.N.convert(t2)) : this;
            if (s2 = t2._sw, o2 = t2._ne, !s2 || !o2)
              return this;
          }
          return i2 || a2 ? (i2.lng = Math.min(s2.lng, i2.lng), i2.lat = Math.min(s2.lat, i2.lat), a2.lng = Math.max(o2.lng, a2.lng), a2.lat = Math.max(o2.lat, a2.lat)) : (this._sw = new e.N(s2.lng, s2.lat), this._ne = new e.N(o2.lng, o2.lat)), this;
        }
        getCenter() {
          return new e.N((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new e.N(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new e.N(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(t2) {
          const { lng: i2, lat: a2 } = e.N.convert(t2);
          let s2 = this._sw.lng <= i2 && i2 <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (s2 = this._sw.lng >= i2 && i2 >= this._ne.lng), this._sw.lat <= a2 && a2 <= this._ne.lat && s2;
        }
        static convert(t2) {
          return t2 instanceof H ? t2 : t2 ? new H(t2) : t2;
        }
        static fromLngLat(t2, i2 = 0) {
          const a2 = 360 * i2 / 40075017, s2 = a2 / Math.cos(Math.PI / 180 * t2.lat);
          return new H(new e.N(t2.lng - s2, t2.lat - a2), new e.N(t2.lng + s2, t2.lat + a2));
        }
        adjustAntiMeridian() {
          const t2 = new e.N(this._sw.lng, this._sw.lat), i2 = new e.N(this._ne.lng, this._ne.lat);
          return new H(t2, t2.lng > i2.lng ? new e.N(i2.lng + 360, i2.lat) : i2);
        }
      }

      class W {
        constructor(t2, e2, i2) {
          this.bounds = H.convert(this.validateBounds(t2)), this.minzoom = e2 || 0, this.maxzoom = i2 || 24;
        }
        validateBounds(t2) {
          return Array.isArray(t2) && t2.length === 4 ? [
            Math.max(-180, t2[0]),
            Math.max(-90, t2[1]),
            Math.min(180, t2[2]),
            Math.min(90, t2[3])
          ] : [-180, -90, 180, 90];
        }
        contains(t2) {
          const i2 = Math.pow(2, t2.z), a2 = Math.floor(e.O(this.bounds.getWest()) * i2), s2 = Math.floor(e.Q(this.bounds.getNorth()) * i2), o2 = Math.ceil(e.O(this.bounds.getEast()) * i2), r2 = Math.ceil(e.Q(this.bounds.getSouth()) * i2);
          return t2.x >= a2 && t2.x < o2 && t2.y >= s2 && t2.y < r2;
        }
      }

      class $ extends e.E {
        constructor(t2, i2, a2, s2) {
          if (super(), this.id = t2, this.dispatcher = a2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e.e(this, e.M(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.e({ type: "vector" }, i2), this._collectResourceTiming = i2.collectResourceTiming, this.tileSize !== 512)
            throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(s2);
        }
        load() {
          return e._(this, undefined, undefined, function* () {
            this._loaded = false, this.fire(new e.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController;
            try {
              const t2 = yield G(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), t2 && (e.e(this, t2), t2.bounds && (this.tileBounds = new W(t2.bounds, this.minzoom, this.maxzoom)), this.fire(new e.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (t2) {
              this._tileJSONRequest = null, this.fire(new e.j(t2));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(t2) {
          return !this.tileBounds || this.tileBounds.contains(t2.canonical);
        }
        onAdd(t2) {
          this.map = t2, this.load();
        }
        setSourceProperty(t2) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), t2(), this.load();
        }
        setTiles(t2) {
          return this.setSourceProperty(() => {
            this._options.tiles = t2;
          }), this;
        }
        setUrl(t2) {
          return this.setSourceProperty(() => {
            this.url = t2, this._options.url = t2;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        serialize() {
          return e.e({}, this._options);
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = t2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), i2 = {
              request: this.map._requestManager.transformRequest(e2, "Tile"),
              uid: t2.uid,
              tileID: t2.tileID,
              zoom: t2.tileID.overscaledZ,
              tileSize: this.tileSize * t2.tileID.overscaleFactor(),
              type: this.type,
              source: this.id,
              pixelRatio: this.map.getPixelRatio(),
              showCollisionBoxes: this.map.showCollisionBoxes,
              promoteId: this.promoteId
            };
            i2.request.collectResourceTiming = this._collectResourceTiming;
            let a2 = "RT";
            if (t2.actor && t2.state !== "expired") {
              if (t2.state === "loading")
                return new Promise((e3, i3) => {
                  t2.reloadPromise = { resolve: e3, reject: i3 };
                });
            } else
              t2.actor = this.dispatcher.getActor(), a2 = "LT";
            t2.abortController = new AbortController;
            try {
              const e3 = yield t2.actor.sendAsync({ type: a2, data: i2 }, t2.abortController);
              if (delete t2.abortController, t2.aborted)
                return;
              this._afterTileLoadWorkerResponse(t2, e3);
            } catch (e3) {
              if (delete t2.abortController, t2.aborted)
                return;
              if (e3 && e3.status !== 404)
                throw e3;
              this._afterTileLoadWorkerResponse(t2, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(t2, e2) {
          if (e2 && e2.resourceTiming && (t2.resourceTiming = e2.resourceTiming), e2 && this.map._refreshExpiredTiles && t2.setExpiryData(e2), t2.loadVectorData(e2, this.map.painter), t2.reloadPromise) {
            const e3 = t2.reloadPromise;
            t2.reloadPromise = null, this.loadTile(t2).then(e3.resolve).catch(e3.reject);
          }
        }
        abortTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.abortController && (t2.abortController.abort(), delete t2.abortController), t2.actor && (yield t2.actor.sendAsync({
              type: "AT",
              data: { uid: t2.uid, type: this.type, source: this.id }
            }));
          });
        }
        unloadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.unloadVectorData(), t2.actor && (yield t2.actor.sendAsync({
              type: "RMT",
              data: { uid: t2.uid, type: this.type, source: this.id }
            }));
          });
        }
        hasTransition() {
          return false;
        }
      }

      class X extends e.E {
        constructor(t2, i2, a2, s2) {
          super(), this.id = t2, this.dispatcher = a2, this.setEventedParent(s2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e.e({ type: "raster" }, i2), e.e(this, e.M(i2, ["url", "scheme", "tileSize"]));
        }
        load() {
          return e._(this, undefined, undefined, function* () {
            this._loaded = false, this.fire(new e.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController;
            try {
              const t2 = yield G(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = true, t2 && (e.e(this, t2), t2.bounds && (this.tileBounds = new W(t2.bounds, this.minzoom, this.maxzoom)), this.fire(new e.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (t2) {
              this._tileJSONRequest = null, this.fire(new e.j(t2));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t2) {
          this.map = t2, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        setSourceProperty(t2) {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), t2(), this.load();
        }
        setTiles(t2) {
          return this.setSourceProperty(() => {
            this._options.tiles = t2;
          }), this;
        }
        setUrl(t2) {
          return this.setSourceProperty(() => {
            this.url = t2, this._options.url = t2;
          }), this;
        }
        serialize() {
          return e.e({}, this._options);
        }
        hasTile(t2) {
          return !this.tileBounds || this.tileBounds.contains(t2.canonical);
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = t2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            t2.abortController = new AbortController;
            try {
              const i2 = yield _.getImage(this.map._requestManager.transformRequest(e2, "Tile"), t2.abortController, this.map._refreshExpiredTiles);
              if (delete t2.abortController, t2.aborted)
                return void (t2.state = "unloaded");
              if (i2 && i2.data) {
                this.map._refreshExpiredTiles && i2.cacheControl && i2.expires && t2.setExpiryData({ cacheControl: i2.cacheControl, expires: i2.expires });
                const e3 = this.map.painter.context, a2 = e3.gl, s2 = i2.data;
                t2.texture = this.map.painter.getTileTexture(s2.width), t2.texture ? t2.texture.update(s2, { useMipmap: true }) : (t2.texture = new b(e3, s2, a2.RGBA, { useMipmap: true }), t2.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST)), t2.state = "loaded";
              }
            } catch (e3) {
              if (delete t2.abortController, t2.aborted)
                t2.state = "unloaded";
              else if (e3)
                throw t2.state = "errored", e3;
            }
          });
        }
        abortTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.abortController && (t2.abortController.abort(), delete t2.abortController);
          });
        }
        unloadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.texture && this.map.painter.saveTileTexture(t2.texture);
          });
        }
        hasTransition() {
          return false;
        }
      }

      class K extends X {
        constructor(t2, i2, a2, s2) {
          super(t2, i2, a2, s2), this.type = "raster-dem", this.maxzoom = 22, this._options = e.e({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox", this.redFactor = i2.redFactor, this.greenFactor = i2.greenFactor, this.blueFactor = i2.blueFactor, this.baseShift = i2.baseShift;
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const i2 = t2.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a2 = this.map._requestManager.transformRequest(i2, "Tile");
            t2.neighboringTiles = this._getNeighboringTiles(t2.tileID), t2.abortController = new AbortController;
            try {
              const i3 = yield _.getImage(a2, t2.abortController, this.map._refreshExpiredTiles);
              if (delete t2.abortController, t2.aborted)
                return void (t2.state = "unloaded");
              if (i3 && i3.data) {
                const a3 = i3.data;
                this.map._refreshExpiredTiles && i3.cacheControl && i3.expires && t2.setExpiryData({ cacheControl: i3.cacheControl, expires: i3.expires });
                const s2 = e.b(a3) && e.U() ? a3 : yield this.readImageNow(a3), o2 = {
                  type: this.type,
                  uid: t2.uid,
                  source: this.id,
                  rawImageData: s2,
                  encoding: this.encoding,
                  redFactor: this.redFactor,
                  greenFactor: this.greenFactor,
                  blueFactor: this.blueFactor,
                  baseShift: this.baseShift
                };
                if (!t2.actor || t2.state === "expired") {
                  t2.actor = this.dispatcher.getActor();
                  const e2 = yield t2.actor.sendAsync({ type: "LDT", data: o2 });
                  t2.dem = e2, t2.needsHillshadePrepare = true, t2.needsTerrainPrepare = true, t2.state = "loaded";
                }
              }
            } catch (e2) {
              if (delete t2.abortController, t2.aborted)
                t2.state = "unloaded";
              else if (e2)
                throw t2.state = "errored", e2;
            }
          });
        }
        readImageNow(t2) {
          return e._(this, undefined, undefined, function* () {
            if (typeof VideoFrame != "undefined" && e.V()) {
              const i2 = t2.width + 2, a2 = t2.height + 2;
              try {
                return new e.R({ width: i2, height: a2 }, yield e.W(t2, -1, -1, i2, a2));
              } catch (t3) {
              }
            }
            return o.getImageData(t2, 1);
          });
        }
        _getNeighboringTiles(t2) {
          const i2 = t2.canonical, a2 = Math.pow(2, i2.z), s2 = (i2.x - 1 + a2) % a2, o2 = i2.x === 0 ? t2.wrap - 1 : t2.wrap, r2 = (i2.x + 1 + a2) % a2, n2 = i2.x + 1 === a2 ? t2.wrap + 1 : t2.wrap, l2 = {};
          return l2[new e.S(t2.overscaledZ, o2, i2.z, s2, i2.y).key] = { backfilled: false }, l2[new e.S(t2.overscaledZ, n2, i2.z, r2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new e.S(t2.overscaledZ, o2, i2.z, s2, i2.y - 1).key] = { backfilled: false }, l2[new e.S(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y - 1).key] = {
            backfilled: false
          }, l2[new e.S(t2.overscaledZ, n2, i2.z, r2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < a2 && (l2[new e.S(t2.overscaledZ, o2, i2.z, s2, i2.y + 1).key] = { backfilled: false }, l2[new e.S(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y + 1).key] = {
            backfilled: false
          }, l2[new e.S(t2.overscaledZ, n2, i2.z, r2, i2.y + 1).key] = { backfilled: false }), l2;
        }
        unloadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.demTexture && this.map.painter.saveTileTexture(t2.demTexture), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), t2.dem && delete t2.dem, delete t2.neighboringTiles, t2.state = "unloaded", t2.actor && (yield t2.actor.sendAsync({
              type: "RDT",
              data: { type: this.type, uid: t2.uid, source: this.id }
            }));
          });
        }
      }

      class J extends e.E {
        constructor(t2, i2, a2, s2) {
          super(), this.id = t2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = a2.getActor(), this.setEventedParent(s2), this._data = i2.data, this._options = e.e({}, i2), this._collectResourceTiming = i2.collectResourceTiming, i2.maxzoom !== undefined && (this.maxzoom = i2.maxzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
          const o2 = e.X / this.tileSize;
          i2.clusterMaxZoom !== undefined && this.maxzoom <= i2.clusterMaxZoom && e.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i2.clusterMaxZoom}".`), this.workerOptions = e.e({
            source: this.id,
            cluster: i2.cluster || false,
            geojsonVtOptions: {
              buffer: (i2.buffer !== undefined ? i2.buffer : 128) * o2,
              tolerance: (i2.tolerance !== undefined ? i2.tolerance : 0.375) * o2,
              extent: e.X,
              maxZoom: this.maxzoom,
              lineMetrics: i2.lineMetrics || false,
              generateId: i2.generateId || false
            },
            superclusterOptions: {
              maxZoom: i2.clusterMaxZoom !== undefined ? i2.clusterMaxZoom : this.maxzoom - 1,
              minPoints: Math.max(2, i2.clusterMinPoints || 2),
              extent: e.X,
              radius: (i2.clusterRadius || 50) * o2,
              log: false,
              generateId: i2.generateId || false
            },
            clusterProperties: i2.clusterProperties,
            filter: i2.filter
          }, i2.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
        }
        load() {
          return e._(this, undefined, undefined, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(t2) {
          this.map = t2, this.load();
        }
        setData(t2) {
          return this._data = t2, this._updateWorkerData(), this;
        }
        updateData(t2) {
          return this._updateWorkerData(t2), this;
        }
        getData() {
          return e._(this, undefined, undefined, function* () {
            const t2 = e.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: "GD", data: t2 });
          });
        }
        setClusterOptions(t2) {
          return this.workerOptions.cluster = t2.cluster, t2 && (t2.clusterRadius !== undefined && (this.workerOptions.superclusterOptions.radius = t2.clusterRadius), t2.clusterMaxZoom !== undefined && (this.workerOptions.superclusterOptions.maxZoom = t2.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(t2) {
          return this.actor.sendAsync({
            type: "GCEZ",
            data: { type: this.type, clusterId: t2, source: this.id }
          });
        }
        getClusterChildren(t2) {
          return this.actor.sendAsync({
            type: "GCC",
            data: { type: this.type, clusterId: t2, source: this.id }
          });
        }
        getClusterLeaves(t2, e2, i2) {
          return this.actor.sendAsync({
            type: "GCL",
            data: {
              type: this.type,
              source: this.id,
              clusterId: t2,
              limit: e2,
              offset: i2
            }
          });
        }
        _updateWorkerData(t2) {
          return e._(this, undefined, undefined, function* () {
            const i2 = e.e({ type: this.type }, this.workerOptions);
            t2 ? i2.dataDiff = t2 : typeof this._data == "string" ? (i2.request = this.map._requestManager.transformRequest(o.resolveURL(this._data), "Source"), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new e.k("dataloading", { dataType: "source" }));
            try {
              const t3 = yield this.actor.sendAsync({ type: "LD", data: i2 });
              if (this._pendingLoads--, this._removed || t3.abandoned)
                return void this.fire(new e.k("dataabort", { dataType: "source" }));
              let a2 = null;
              t3.resourceTiming && t3.resourceTiming[this.id] && (a2 = t3.resourceTiming[this.id].slice(0));
              const s2 = { dataType: "source" };
              this._collectResourceTiming && a2 && a2.length > 0 && e.e(s2, { resourceTiming: a2 }), this.fire(new e.k("data", Object.assign(Object.assign({}, s2), { sourceDataType: "metadata" }))), this.fire(new e.k("data", Object.assign(Object.assign({}, s2), { sourceDataType: "content" })));
            } catch (t3) {
              if (this._pendingLoads--, this._removed)
                return void this.fire(new e.k("dataabort", { dataType: "source" }));
              this.fire(new e.j(t3));
            }
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = t2.actor ? "RT" : "LT";
            t2.actor = this.actor;
            const i2 = {
              type: this.type,
              uid: t2.uid,
              tileID: t2.tileID,
              zoom: t2.tileID.overscaledZ,
              maxZoom: this.maxzoom,
              tileSize: this.tileSize,
              source: this.id,
              pixelRatio: this.map.getPixelRatio(),
              showCollisionBoxes: this.map.showCollisionBoxes,
              promoteId: this.promoteId
            };
            t2.abortController = new AbortController;
            const a2 = yield this.actor.sendAsync({ type: e2, data: i2 }, t2.abortController);
            delete t2.abortController, t2.unloadVectorData(), t2.aborted || t2.loadVectorData(a2, this.map.painter, e2 === "RT");
          });
        }
        abortTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.abortController && (t2.abortController.abort(), delete t2.abortController), t2.aborted = true;
          });
        }
        unloadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            t2.unloadVectorData(), yield this.actor.sendAsync({
              type: "RMT",
              data: { uid: t2.uid, type: this.type, source: this.id }
            });
          });
        }
        onRemove() {
          this._removed = true, this.actor.sendAsync({
            type: "RS",
            data: { type: this.type, source: this.id }
          });
        }
        serialize() {
          return e.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return false;
        }
      }
      var Y = e.Y([
        { name: "a_pos", type: "Int16", components: 2 },
        { name: "a_texture_pos", type: "Int16", components: 2 }
      ]);

      class Q extends e.E {
        constructor(t2, e2, i2, a2) {
          super(), this.id = t2, this.dispatcher = i2, this.coordinates = e2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(a2), this.options = e2;
        }
        load(t2) {
          return e._(this, undefined, undefined, function* () {
            this._loaded = false, this.fire(new e.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController;
            try {
              const e2 = yield _.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
              this._request = null, this._loaded = true, e2 && e2.data && (this.image = e2.data, t2 && (this.coordinates = t2), this._finishLoading());
            } catch (t3) {
              this._request = null, this._loaded = true, this.fire(new e.j(t3));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(t2) {
          return t2.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = t2.url, this.load(t2.coordinates).finally(() => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new e.k("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(t2) {
          this.map = t2, this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), this._request = null);
        }
        setCoordinates(t2) {
          this.coordinates = t2;
          const i2 = t2.map(e.Z.fromLngLat);
          this.tileID = function(t3) {
            let i3 = 1 / 0, a3 = 1 / 0, s2 = -1 / 0, o2 = -1 / 0;
            for (const e2 of t3)
              i3 = Math.min(i3, e2.x), a3 = Math.min(a3, e2.y), s2 = Math.max(s2, e2.x), o2 = Math.max(o2, e2.y);
            const r2 = Math.max(s2 - i3, o2 - a3), n2 = Math.max(0, Math.floor(-Math.log(r2) / Math.LN2)), l2 = Math.pow(2, n2);
            return new e.a1(n2, Math.floor((i3 + s2) / 2 * l2), Math.floor((a3 + o2) / 2 * l2));
          }(i2), this.minzoom = this.maxzoom = this.tileID.z;
          const a2 = i2.map((t3) => this.tileID.getTilePoint(t3)._round());
          return this._boundsArray = new e.$, this._boundsArray.emplaceBack(a2[0].x, a2[0].y, 0, 0), this._boundsArray.emplaceBack(a2[1].x, a2[1].y, e.X, 0), this._boundsArray.emplaceBack(a2[3].x, a2[3].y, 0, e.X), this._boundsArray.emplaceBack(a2[2].x, a2[2].y, e.X, e.X), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new e.k("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image)
            return;
          const t2 = this.map.painter.context, i2 = t2.gl;
          this.boundsBuffer || (this.boundsBuffer = t2.createVertexBuffer(this._boundsArray, Y.members)), this.boundsSegments || (this.boundsSegments = e.a0.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new b(t2, this.image, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
          let a2 = false;
          for (const t3 in this.tiles) {
            const e2 = this.tiles[t3];
            e2.state !== "loaded" && (e2.state = "loaded", e2.texture = this.texture, a2 = true);
          }
          a2 && this.fire(new e.k("data", {
            dataType: "source",
            sourceDataType: "idle",
            sourceId: this.id
          }));
        }
        loadTile(t2) {
          return e._(this, undefined, undefined, function* () {
            this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}) : t2.state = "errored";
          });
        }
        serialize() {
          return {
            type: "image",
            url: this.options.url,
            coordinates: this.coordinates
          };
        }
        hasTransition() {
          return false;
        }
      }

      class tt extends Q {
        constructor(t2, e2, i2, a2) {
          super(t2, e2, i2, a2), this.roundZoom = true, this.type = "video", this.options = e2;
        }
        load() {
          return e._(this, undefined, undefined, function* () {
            this._loaded = false;
            const t2 = this.options;
            this.urls = [];
            for (const e2 of t2.urls)
              this.urls.push(this.map._requestManager.transformRequest(e2, "Source").url);
            try {
              const t3 = yield e.a3(this.urls);
              if (this._loaded = true, !t3)
                return;
              this.video = t3, this.video.loop = true, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading();
            } catch (t3) {
              this.fire(new e.j(t3));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(t2) {
          if (this.video) {
            const i2 = this.video.seekable;
            t2 < i2.start(0) || t2 > i2.end(0) ? this.fire(new e.j(new e.a2(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = t2;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(t2) {
          this.map || (this.map = t2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
            return;
          const t2 = this.map.painter.context, i2 = t2.gl;
          this.boundsBuffer || (this.boundsBuffer = t2.createVertexBuffer(this._boundsArray, Y.members)), this.boundsSegments || (this.boundsSegments = e.a0.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new b(t2, this.video, i2.RGBA), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE));
          let a2 = false;
          for (const t3 in this.tiles) {
            const e2 = this.tiles[t3];
            e2.state !== "loaded" && (e2.state = "loaded", e2.texture = this.texture, a2 = true);
          }
          a2 && this.fire(new e.k("data", {
            dataType: "source",
            sourceDataType: "idle",
            sourceId: this.id
          }));
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }

      class et extends Q {
        constructor(t2, i2, a2, s2) {
          super(t2, i2, a2, s2), i2.coordinates ? Array.isArray(i2.coordinates) && i2.coordinates.length === 4 && !i2.coordinates.some((t3) => !Array.isArray(t3) || t3.length !== 2 || t3.some((t4) => typeof t4 != "number")) || this.fire(new e.j(new e.a2(`sources.${t2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.j(new e.a2(`sources.${t2}`, null, 'missing required property "coordinates"'))), i2.animate && typeof i2.animate != "boolean" && this.fire(new e.j(new e.a2(`sources.${t2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? typeof i2.canvas == "string" || i2.canvas instanceof HTMLCanvasElement || this.fire(new e.j(new e.a2(`sources.${t2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.j(new e.a2(`sources.${t2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = i2.animate === undefined || i2.animate;
        }
        load() {
          return e._(this, undefined, undefined, function* () {
            this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = true, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = false);
            }, this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(t2) {
          this.map = t2, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let t2 = false;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, t2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t2 = true), this._hasInvalidDimensions())
            return;
          if (Object.keys(this.tiles).length === 0)
            return;
          const i2 = this.map.painter.context, a2 = i2.gl;
          this.boundsBuffer || (this.boundsBuffer = i2.createVertexBuffer(this._boundsArray, Y.members)), this.boundsSegments || (this.boundsSegments = e.a0.simpleSegment(0, 0, 4, 2)), this.texture ? (t2 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new b(i2, this.canvas, a2.RGBA, { premultiply: true });
          let s2 = false;
          for (const t3 in this.tiles) {
            const e2 = this.tiles[t3];
            e2.state !== "loaded" && (e2.state = "loaded", e2.texture = this.texture, s2 = true);
          }
          s2 && this.fire(new e.k("data", {
            dataType: "source",
            sourceDataType: "idle",
            sourceId: this.id
          }));
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const t2 of [this.canvas.width, this.canvas.height])
            if (isNaN(t2) || t2 <= 0)
              return true;
          return false;
        }
      }
      const it = {}, at = (t2) => {
        switch (t2) {
          case "geojson":
            return J;
          case "image":
            return Q;
          case "raster":
            return X;
          case "raster-dem":
            return K;
          case "vector":
            return $;
          case "video":
            return tt;
          case "canvas":
            return et;
        }
        return it[t2];
      }, st = "RTLPluginLoaded";

      class ot extends e.E {
        constructor() {
          super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = j();
        }
        _syncState(t2) {
          return this.status = t2, this.dispatcher.broadcast("SRPS", { pluginStatus: t2, pluginURL: this.url }).catch((t3) => {
            throw this.status = "error", t3;
          });
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = "unavailable", this.url = null;
        }
        setRTLTextPlugin(t2) {
          return e._(this, arguments, undefined, function* (t3, e2 = false) {
            if (this.url)
              throw new Error("setRTLTextPlugin cannot be called multiple times.");
            if (this.url = o.resolveURL(t3), !this.url)
              throw new Error(`requested url ${t3} is invalid`);
            if (this.status === "unavailable") {
              if (!e2)
                return this._requestImport();
              this.status = "deferred", this._syncState(this.status);
            } else if (this.status === "requested")
              return this._requestImport();
          });
        }
        _requestImport() {
          return e._(this, undefined, undefined, function* () {
            yield this._syncState("loading"), this.status = "loaded", this.fire(new e.k(st));
          });
        }
        lazyLoad() {
          this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
        }
      }
      let rt = null;
      function nt() {
        return rt || (rt = new ot), rt;
      }

      class lt {
        constructor(t2, i2) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = t2, this.uid = e.a4(), this.uses = 0, this.tileSize = i2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(t2) {
          const e2 = t2 + this.timeAdded;
          e2 < this.fadeEndTime || (this.fadeEndTime = e2);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(t2) {
          this.demTexture && t2.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(t2, i2, a2) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t2) {
            t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e2) {
              const i3 = {};
              if (!e2)
                return i3;
              for (const a3 of t3) {
                const t4 = a3.layerIds.map((t5) => e2.getLayer(t5)).filter(Boolean);
                if (t4.length !== 0) {
                  a3.layers = t4, a3.stateDependentLayerIds && (a3.stateDependentLayers = a3.stateDependentLayerIds.map((e3) => t4.filter((t5) => t5.id === e3)[0]));
                  for (const e3 of t4)
                    i3[e3.id] = a3;
                }
              }
              return i3;
            }(t2.buckets, i2.style), this.hasSymbolBuckets = false;
            for (const t3 in this.buckets) {
              const i3 = this.buckets[t3];
              if (i3 instanceof e.a6) {
                if (this.hasSymbolBuckets = true, !a2)
                  break;
                i3.justReloaded = true;
              }
            }
            if (this.hasRTLText = false, this.hasSymbolBuckets)
              for (const t3 in this.buckets) {
                const i3 = this.buckets[t3];
                if (i3 instanceof e.a6 && i3.hasRTLText) {
                  this.hasRTLText = true, nt().lazyLoad();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const t3 in this.buckets) {
              const e2 = this.buckets[t3];
              this.queryPadding = Math.max(this.queryPadding, i2.style.getLayer(t3).queryRadius(e2));
            }
            t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage);
          } else
            this.collisionBoxArray = new e.a5;
        }
        unloadVectorData() {
          for (const t2 in this.buckets)
            this.buckets[t2].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(t2) {
          return this.buckets[t2.id];
        }
        upload(t2) {
          for (const e3 in this.buckets) {
            const i2 = this.buckets[e3];
            i2.uploadPending() && i2.upload(t2);
          }
          const e2 = t2.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new b(t2, this.imageAtlas.image, e2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new b(t2, this.glyphAtlasImage, e2.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(t2) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
        }
        queryRenderedFeatures(t2, e2, i2, a2, s2, o2, r2, n2, l2, h2) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
            queryGeometry: a2,
            cameraQueryGeometry: s2,
            scale: o2,
            tileSize: this.tileSize,
            pixelPosMatrix: h2,
            transform: n2,
            params: r2,
            queryPadding: this.queryPadding * l2
          }, t2, e2, i2) : {};
        }
        querySourceFeatures(t2, i2) {
          const a2 = this.latestFeatureIndex;
          if (!a2 || !a2.rawTileData)
            return;
          const s2 = a2.loadVTLayers(), o2 = i2 && i2.sourceLayer ? i2.sourceLayer : "", r2 = s2._geojsonTileLayer || s2[o2];
          if (!r2)
            return;
          const n2 = e.a7(i2 && i2.filter), { z: l2, x: h2, y: c2 } = this.tileID.canonical, u2 = { z: l2, x: h2, y: c2 };
          for (let i3 = 0;i3 < r2.length; i3++) {
            const s3 = r2.feature(i3);
            if (n2.needGeometry) {
              const t3 = e.a8(s3, true);
              if (!n2.filter(new e.z(this.tileID.overscaledZ), t3, this.tileID.canonical))
                continue;
            } else if (!n2.filter(new e.z(this.tileID.overscaledZ), s3))
              continue;
            const d2 = a2.getId(s3, o2), _2 = new e.a9(s3, l2, h2, c2, d2);
            _2.tile = u2, t2.push(_2);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(t2) {
          const i2 = this.expirationTime;
          if (t2.cacheControl) {
            const i3 = e.aa(t2.cacheControl);
            i3["max-age"] && (this.expirationTime = Date.now() + 1000 * i3["max-age"]);
          } else
            t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
          if (this.expirationTime) {
            const t3 = Date.now();
            let e2 = false;
            if (this.expirationTime > t3)
              e2 = false;
            else if (i2)
              if (this.expirationTime < i2)
                e2 = true;
              else {
                const a2 = this.expirationTime - i2;
                a2 ? this.expirationTime = t3 + Math.max(a2, 30000) : e2 = true;
              }
            else
              e2 = true;
            e2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime)
            return this.expiredRequestCount ? 1000 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(t2, e2) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(t2).length === 0)
            return;
          const i2 = this.latestFeatureIndex.loadVTLayers();
          for (const a2 in this.buckets) {
            if (!e2.style.hasLayer(a2))
              continue;
            const s2 = this.buckets[a2], o2 = s2.layers[0].sourceLayer || "_geojsonTileLayer", r2 = i2[o2], n2 = t2[o2];
            if (!r2 || !n2 || Object.keys(n2).length === 0)
              continue;
            s2.update(n2, r2, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const l2 = e2 && e2.style && e2.style.getLayer(a2);
            l2 && (this.queryPadding = Math.max(this.queryPadding, l2.queryRadius(s2)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== undefined;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < o.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = undefined;
        }
        setHoldDuration(t2) {
          this.symbolFadeHoldUntil = o.now() + t2;
        }
        setDependencies(t2, e2) {
          const i2 = {};
          for (const t3 of e2)
            i2[t3] = true;
          this.dependencies[t2] = i2;
        }
        hasDependency(t2, e2) {
          for (const i2 of t2) {
            const t3 = this.dependencies[i2];
            if (t3) {
              for (const i3 of e2)
                if (t3[i3])
                  return true;
            }
          }
          return false;
        }
      }

      class ht {
        constructor(t2, e2) {
          this.max = t2, this.onRemove = e2, this.reset();
        }
        reset() {
          for (const t2 in this.data)
            for (const e2 of this.data[t2])
              e2.timeout && clearTimeout(e2.timeout), this.onRemove(e2.value);
          return this.data = {}, this.order = [], this;
        }
        add(t2, e2, i2) {
          const a2 = t2.wrapped().key;
          this.data[a2] === undefined && (this.data[a2] = []);
          const s2 = { value: e2, timeout: undefined };
          if (i2 !== undefined && (s2.timeout = setTimeout(() => {
            this.remove(t2, s2);
          }, i2)), this.data[a2].push(s2), this.order.push(a2), this.order.length > this.max) {
            const t3 = this._getAndRemoveByKey(this.order[0]);
            t3 && this.onRemove(t3);
          }
          return this;
        }
        has(t2) {
          return t2.wrapped().key in this.data;
        }
        getAndRemove(t2) {
          return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
        }
        _getAndRemoveByKey(t2) {
          const e2 = this.data[t2].shift();
          return e2.timeout && clearTimeout(e2.timeout), this.data[t2].length === 0 && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
        }
        getByKey(t2) {
          const e2 = this.data[t2];
          return e2 ? e2[0].value : null;
        }
        get(t2) {
          return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
        }
        remove(t2, e2) {
          if (!this.has(t2))
            return this;
          const i2 = t2.wrapped().key, a2 = e2 === undefined ? 0 : this.data[i2].indexOf(e2), s2 = this.data[i2][a2];
          return this.data[i2].splice(a2, 1), s2.timeout && clearTimeout(s2.timeout), this.data[i2].length === 0 && delete this.data[i2], this.onRemove(s2.value), this.order.splice(this.order.indexOf(i2), 1), this;
        }
        setMaxSize(t2) {
          for (this.max = t2;this.order.length > this.max; ) {
            const t3 = this._getAndRemoveByKey(this.order[0]);
            t3 && this.onRemove(t3);
          }
          return this;
        }
        filter(t2) {
          const e2 = [];
          for (const i2 in this.data)
            for (const a2 of this.data[i2])
              t2(a2.value) || e2.push(a2);
          for (const t3 of e2)
            this.remove(t3.value.tileID, t3);
        }
      }

      class ct {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(t2, i2, a2) {
          const s2 = String(i2);
          if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][s2] = this.stateChanges[t2][s2] || {}, e.e(this.stateChanges[t2][s2], a2), this.deletedStates[t2] === null) {
            this.deletedStates[t2] = {};
            for (const e2 in this.state[t2])
              e2 !== s2 && (this.deletedStates[t2][e2] = null);
          } else if (this.deletedStates[t2] && this.deletedStates[t2][s2] === null) {
            this.deletedStates[t2][s2] = {};
            for (const e2 in this.state[t2][s2])
              a2[e2] || (this.deletedStates[t2][s2][e2] = null);
          } else
            for (const e2 in a2)
              this.deletedStates[t2] && this.deletedStates[t2][s2] && this.deletedStates[t2][s2][e2] === null && delete this.deletedStates[t2][s2][e2];
        }
        removeFeatureState(t2, e2, i2) {
          if (this.deletedStates[t2] === null)
            return;
          const a2 = String(e2);
          if (this.deletedStates[t2] = this.deletedStates[t2] || {}, i2 && e2 !== undefined)
            this.deletedStates[t2][a2] !== null && (this.deletedStates[t2][a2] = this.deletedStates[t2][a2] || {}, this.deletedStates[t2][a2][i2] = null);
          else if (e2 !== undefined)
            if (this.stateChanges[t2] && this.stateChanges[t2][a2])
              for (i2 in this.deletedStates[t2][a2] = {}, this.stateChanges[t2][a2])
                this.deletedStates[t2][a2][i2] = null;
            else
              this.deletedStates[t2][a2] = null;
          else
            this.deletedStates[t2] = null;
        }
        getState(t2, i2) {
          const a2 = String(i2), s2 = e.e({}, (this.state[t2] || {})[a2], (this.stateChanges[t2] || {})[a2]);
          if (this.deletedStates[t2] === null)
            return {};
          if (this.deletedStates[t2]) {
            const e2 = this.deletedStates[t2][i2];
            if (e2 === null)
              return {};
            for (const t3 in e2)
              delete s2[t3];
          }
          return s2;
        }
        initializeTileState(t2, e2) {
          t2.setFeatureState(this.state, e2);
        }
        coalesceChanges(t2, i2) {
          const a2 = {};
          for (const t3 in this.stateChanges) {
            this.state[t3] = this.state[t3] || {};
            const i3 = {};
            for (const a3 in this.stateChanges[t3])
              this.state[t3][a3] || (this.state[t3][a3] = {}), e.e(this.state[t3][a3], this.stateChanges[t3][a3]), i3[a3] = this.state[t3][a3];
            a2[t3] = i3;
          }
          for (const t3 in this.deletedStates) {
            this.state[t3] = this.state[t3] || {};
            const i3 = {};
            if (this.deletedStates[t3] === null)
              for (const e2 in this.state[t3])
                i3[e2] = {}, this.state[t3][e2] = {};
            else
              for (const e2 in this.deletedStates[t3]) {
                if (this.deletedStates[t3][e2] === null)
                  this.state[t3][e2] = {};
                else
                  for (const i4 of Object.keys(this.deletedStates[t3][e2]))
                    delete this.state[t3][e2][i4];
                i3[e2] = this.state[t3][e2];
              }
            a2[t3] = a2[t3] || {}, e.e(a2[t3], i3);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(a2).length !== 0)
            for (const e2 in t2)
              t2[e2].setFeatureState(a2, i2);
        }
      }

      class ut extends e.E {
        constructor(t2, e2, i2) {
          super(), this.id = t2, this.dispatcher = i2, this.on("data", (t3) => this._dataHandler(t3)), this.on("dataloading", () => {
            this._sourceErrored = false;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((t3, e3, i3, a2) => {
            const s2 = new (at(e3.type))(t3, e3, i3, a2);
            if (s2.id !== t3)
              throw new Error(`Expected Source id to be ${t3} instead of ${s2.id}`);
            return s2;
          })(t2, e2, i2, this), this._tiles = {}, this._cache = new ht(0, (t3) => this._unloadTile(t3)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new ct, this._didEmitContent = false, this._updated = false;
        }
        onAdd(t2) {
          this.map = t2, this._maxTileCacheSize = t2 ? t2._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t2 ? t2._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t2);
        }
        onRemove(t2) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t2);
        }
        loaded() {
          if (this._sourceErrored)
            return true;
          if (!this._sourceLoaded)
            return false;
          if (!this._source.loaded())
            return false;
          if (!(this.used === undefined && this.usedForTerrain === undefined || this.used || this.usedForTerrain))
            return true;
          if (!this._updated)
            return false;
          for (const t2 in this._tiles) {
            const e2 = this._tiles[t2];
            if (e2.state !== "loaded" && e2.state !== "errored")
              return false;
          }
          return true;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = true;
        }
        resume() {
          if (!this._paused)
            return;
          const t2 = this._shouldReloadOnResume;
          this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(t2, i2, a2) {
          return e._(this, undefined, undefined, function* () {
            try {
              yield this._source.loadTile(t2), this._tileLoaded(t2, i2, a2);
            } catch (i3) {
              t2.state = "errored", i3.status !== 404 ? this._source.fire(new e.j(i3, { tile: t2 })) : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(t2) {
          this._source.unloadTile && this._source.unloadTile(t2);
        }
        _abortTile(t2) {
          this._source.abortTile && this._source.abortTile(t2), this._source.fire(new e.k("dataabort", { tile: t2, coord: t2.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t2) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const e2 in this._tiles) {
            const i2 = this._tiles[e2];
            i2.upload(t2), i2.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((t2) => t2.tileID).sort(dt).map((t2) => t2.key);
        }
        getRenderableIds(t2) {
          const i2 = [];
          for (const e2 in this._tiles)
            this._isIdRenderable(e2, t2) && i2.push(this._tiles[e2]);
          return t2 ? i2.sort((t3, i3) => {
            const a2 = t3.tileID, s2 = i3.tileID, o2 = new e.P(a2.canonical.x, a2.canonical.y)._rotate(this.transform.angle), r2 = new e.P(s2.canonical.x, s2.canonical.y)._rotate(this.transform.angle);
            return a2.overscaledZ - s2.overscaledZ || r2.y - o2.y || r2.x - o2.x;
          }).map((t3) => t3.tileID.key) : i2.map((t3) => t3.tileID).sort(dt).map((t3) => t3.key);
        }
        hasRenderableParent(t2) {
          const e2 = this.findLoadedParent(t2, 0);
          return !!e2 && this._isIdRenderable(e2.tileID.key);
        }
        _isIdRenderable(t2, e2) {
          return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e2 || !this._tiles[t2].holdingForFade());
        }
        reload() {
          if (this._paused)
            this._shouldReloadOnResume = true;
          else {
            this._cache.reset();
            for (const t2 in this._tiles)
              this._tiles[t2].state !== "errored" && this._reloadTile(t2, "reloading");
          }
        }
        _reloadTile(t2, i2) {
          return e._(this, undefined, undefined, function* () {
            const e2 = this._tiles[t2];
            e2 && (e2.state !== "loading" && (e2.state = i2), yield this._loadTile(e2, t2, i2));
          });
        }
        _tileLoaded(t2, i2, a2) {
          t2.timeAdded = o.now(), a2 === "expired" && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(i2, t2), this.getSource().type === "raster-dem" && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null), t2.aborted || this._source.fire(new e.k("data", { dataType: "source", tile: t2, coord: t2.tileID }));
        }
        _backfillDEM(t2) {
          const e2 = this.getRenderableIds();
          for (let a2 = 0;a2 < e2.length; a2++) {
            const s2 = e2[a2];
            if (t2.neighboringTiles && t2.neighboringTiles[s2]) {
              const e3 = this.getTileByID(s2);
              i2(t2, e3), i2(e3, t2);
            }
          }
          function i2(t3, e3) {
            t3.needsHillshadePrepare = true, t3.needsTerrainPrepare = true;
            let i3 = e3.tileID.canonical.x - t3.tileID.canonical.x;
            const a2 = e3.tileID.canonical.y - t3.tileID.canonical.y, s2 = Math.pow(2, t3.tileID.canonical.z), o2 = e3.tileID.key;
            i3 === 0 && a2 === 0 || Math.abs(a2) > 1 || (Math.abs(i3) > 1 && (Math.abs(i3 + s2) === 1 ? i3 += s2 : Math.abs(i3 - s2) === 1 && (i3 -= s2)), e3.dem && t3.dem && (t3.dem.backfillBorder(e3.dem, i3, a2), t3.neighboringTiles && t3.neighboringTiles[o2] && (t3.neighboringTiles[o2].backfilled = true)));
          }
        }
        getTile(t2) {
          return this.getTileByID(t2.key);
        }
        getTileByID(t2) {
          return this._tiles[t2];
        }
        _retainLoadedChildren(t2, e2, i2, a2) {
          for (const s2 in this._tiles) {
            let o2 = this._tiles[s2];
            if (a2[s2] || !o2.hasData() || o2.tileID.overscaledZ <= e2 || o2.tileID.overscaledZ > i2)
              continue;
            let r2 = o2.tileID;
            for (;o2 && o2.tileID.overscaledZ > e2 + 1; ) {
              const t3 = o2.tileID.scaledTo(o2.tileID.overscaledZ - 1);
              o2 = this._tiles[t3.key], o2 && o2.hasData() && (r2 = t3);
            }
            let n2 = r2;
            for (;n2.overscaledZ > e2; )
              if (n2 = n2.scaledTo(n2.overscaledZ - 1), t2[n2.key]) {
                a2[r2.key] = r2;
                break;
              }
          }
        }
        findLoadedParent(t2, e2) {
          if (t2.key in this._loadedParentTiles) {
            const i2 = this._loadedParentTiles[t2.key];
            return i2 && i2.tileID.overscaledZ >= e2 ? i2 : null;
          }
          for (let i2 = t2.overscaledZ - 1;i2 >= e2; i2--) {
            const e3 = t2.scaledTo(i2), a2 = this._getLoadedTile(e3);
            if (a2)
              return a2;
          }
        }
        findLoadedSibling(t2) {
          return this._getLoadedTile(t2);
        }
        _getLoadedTile(t2) {
          const e2 = this._tiles[t2.key];
          return e2 && e2.hasData() ? e2 : this._cache.getByKey(t2.wrapped().key);
        }
        updateCacheSize(t2) {
          const i2 = Math.ceil(t2.width / this._source.tileSize) + 1, a2 = Math.ceil(t2.height / this._source.tileSize) + 1, s2 = Math.floor(i2 * a2 * (this._maxTileCacheZoomLevels === null ? e.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o2 = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, s2) : s2;
          this._cache.setMaxSize(o2);
        }
        handleWrapJump(t2) {
          const e2 = Math.round((t2 - (this._prevLng === undefined ? t2 : this._prevLng)) / 360);
          if (this._prevLng = t2, e2) {
            const t3 = {};
            for (const i2 in this._tiles) {
              const a2 = this._tiles[i2];
              a2.tileID = a2.tileID.unwrapTo(a2.tileID.wrap + e2), t3[a2.tileID.key] = a2;
            }
            this._tiles = t3;
            for (const t4 in this._timers)
              clearTimeout(this._timers[t4]), delete this._timers[t4];
            for (const t4 in this._tiles)
              this._setTileReloadTimer(t4, this._tiles[t4]);
          }
        }
        _updateCoveredAndRetainedTiles(t2, e2, i2, a2, s2, r2) {
          const n2 = {}, l2 = {}, h2 = Object.keys(t2), c2 = o.now();
          for (const i3 of h2) {
            const a3 = t2[i3], s3 = this._tiles[i3];
            if (!s3 || s3.fadeEndTime !== 0 && s3.fadeEndTime <= c2)
              continue;
            const o2 = this.findLoadedParent(a3, e2), r3 = this.findLoadedSibling(a3), h3 = o2 || r3 || null;
            h3 && (this._addTile(h3.tileID), n2[h3.tileID.key] = h3.tileID), l2[i3] = a3;
          }
          this._retainLoadedChildren(l2, a2, i2, t2);
          for (const e3 in n2)
            t2[e3] || (this._coveredTiles[e3] = true, t2[e3] = n2[e3]);
          if (r2) {
            const e3 = {}, i3 = {};
            for (const t3 of s2)
              this._tiles[t3.key].hasData() ? e3[t3.key] = t3 : i3[t3.key] = t3;
            for (const a3 in i3) {
              const s3 = i3[a3].children(this._source.maxzoom);
              this._tiles[s3[0].key] && this._tiles[s3[1].key] && this._tiles[s3[2].key] && this._tiles[s3[3].key] && (e3[s3[0].key] = t2[s3[0].key] = s3[0], e3[s3[1].key] = t2[s3[1].key] = s3[1], e3[s3[2].key] = t2[s3[2].key] = s3[2], e3[s3[3].key] = t2[s3[3].key] = s3[3], delete i3[a3]);
            }
            for (const a3 in i3) {
              const s3 = i3[a3], o2 = this.findLoadedParent(s3, this._source.minzoom), r3 = this.findLoadedSibling(s3), n3 = o2 || r3 || null;
              if (n3) {
                e3[n3.tileID.key] = t2[n3.tileID.key] = n3.tileID;
                for (const t3 in e3)
                  e3[t3].isChildOf(n3.tileID) && delete e3[t3];
              }
            }
            for (const t3 in this._tiles)
              e3[t3] || (this._coveredTiles[t3] = true);
          }
        }
        update(t2, i2) {
          if (!this._sourceLoaded || this._paused)
            return;
          let a2;
          this.transform = t2, this.terrain = i2, this.updateCacheSize(t2), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? a2 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new e.S(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y)) : (a2 = t2.coveringTiles({
            tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
            minzoom: this._source.minzoom,
            maxzoom: this._source.maxzoom,
            roundZoom: !this.usedForTerrain && this._source.roundZoom,
            reparseOverscaled: this._source.reparseOverscaled,
            terrain: i2
          }), this._source.hasTile && (a2 = a2.filter((t3) => this._source.hasTile(t3)))) : a2 = [];
          const s2 = t2.coveringZoomLevel(this._source), o2 = Math.max(s2 - ut.maxOverzooming, this._source.minzoom), r2 = Math.max(s2 + ut.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const t3 = {};
            for (const e2 of a2)
              if (e2.canonical.z > this._source.minzoom) {
                const i3 = e2.scaledTo(e2.canonical.z - 1);
                t3[i3.key] = i3;
                const a3 = e2.scaledTo(Math.max(this._source.minzoom, Math.min(e2.canonical.z, 5)));
                t3[a3.key] = a3;
              }
            a2 = a2.concat(Object.values(t3));
          }
          const n2 = a2.length === 0 && !this._updated && this._didEmitContent;
          this._updated = true, n2 && this.fire(new e.k("data", {
            sourceDataType: "idle",
            dataType: "source",
            sourceId: this.id
          }));
          const l2 = this._updateRetainedTiles(a2, s2);
          _t(this._source.type) && this._updateCoveredAndRetainedTiles(l2, o2, r2, s2, a2, i2);
          for (const t3 in l2)
            this._tiles[t3].clearFadeHold();
          const h2 = e.ab(this._tiles, l2);
          for (const t3 of h2) {
            const e2 = this._tiles[t3];
            e2.hasSymbolBuckets && !e2.holdingForFade() ? e2.setHoldDuration(this.map._fadeDuration) : e2.hasSymbolBuckets && !e2.symbolFadeFinished() || this._removeTile(t3);
          }
          this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const t2 in this._tiles)
            this._tiles[t2].holdingForFade() && this._removeTile(t2);
        }
        _updateRetainedTiles(t2, e2) {
          var i2;
          const a2 = {}, s2 = {}, o2 = Math.max(e2 - ut.maxOverzooming, this._source.minzoom), r2 = Math.max(e2 + ut.maxUnderzooming, this._source.minzoom), n2 = {};
          for (const i3 of t2) {
            const t3 = this._addTile(i3);
            a2[i3.key] = i3, t3.hasData() || e2 < this._source.maxzoom && (n2[i3.key] = i3);
          }
          this._retainLoadedChildren(n2, e2, r2, a2);
          for (const r3 of t2) {
            let t3 = this._tiles[r3.key];
            if (t3.hasData())
              continue;
            if (e2 + 1 > this._source.maxzoom) {
              const t4 = r3.children(this._source.maxzoom)[0], e3 = this.getTile(t4);
              if (e3 && e3.hasData()) {
                a2[t4.key] = t4;
                continue;
              }
            } else {
              const t4 = r3.children(this._source.maxzoom);
              if (a2[t4[0].key] && a2[t4[1].key] && a2[t4[2].key] && a2[t4[3].key])
                continue;
            }
            let n3 = t3.wasRequested();
            for (let e3 = r3.overscaledZ - 1;e3 >= o2; --e3) {
              const o3 = r3.scaledTo(e3);
              if (s2[o3.key])
                break;
              if (s2[o3.key] = true, t3 = this.getTile(o3), !t3 && n3 && (t3 = this._addTile(o3)), t3) {
                const e4 = t3.hasData();
                if ((e4 || !((i2 = this.map) === null || i2 === undefined ? undefined : i2.cancelPendingTileRequestsWhileZooming) || n3) && (a2[o3.key] = o3), n3 = t3.wasRequested(), e4)
                  break;
              }
            }
          }
          return a2;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const t2 in this._tiles) {
            const e2 = [];
            let i2, a2 = this._tiles[t2].tileID;
            for (;a2.overscaledZ > 0; ) {
              if (a2.key in this._loadedParentTiles) {
                i2 = this._loadedParentTiles[a2.key];
                break;
              }
              e2.push(a2.key);
              const t3 = a2.scaledTo(a2.overscaledZ - 1);
              if (i2 = this._getLoadedTile(t3), i2)
                break;
              a2 = t3;
            }
            for (const t3 of e2)
              this._loadedParentTiles[t3] = i2;
          }
        }
        _updateLoadedSiblingTileCache() {
          this._loadedSiblingTiles = {};
          for (const t2 in this._tiles) {
            const e2 = this._tiles[t2].tileID, i2 = this._getLoadedTile(e2);
            this._loadedSiblingTiles[e2.key] = i2;
          }
        }
        _addTile(t2) {
          let i2 = this._tiles[t2.key];
          if (i2)
            return i2;
          i2 = this._cache.getAndRemove(t2), i2 && (this._setTileReloadTimer(t2.key, i2), i2.tileID = t2, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, i2)));
          const a2 = i2;
          return i2 || (i2 = new lt(t2, this._source.tileSize * t2.overscaleFactor()), this._loadTile(i2, t2.key, i2.state)), i2.uses++, this._tiles[t2.key] = i2, a2 || this._source.fire(new e.k("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
        }
        _setTileReloadTimer(t2, e2) {
          t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
          const i2 = e2.getExpiryTimeout();
          i2 && (this._timers[t2] = setTimeout(() => {
            this._reloadTile(t2, "expired"), delete this._timers[t2];
          }, i2));
        }
        _removeTile(t2) {
          const e2 = this._tiles[t2];
          e2 && (e2.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e2.uses > 0 || (e2.hasData() && e2.state !== "reloading" ? this._cache.add(e2.tileID, e2, e2.getExpiryTimeout()) : (e2.aborted = true, this._abortTile(e2), this._unloadTile(e2))));
        }
        _dataHandler(t2) {
          const e2 = t2.sourceDataType;
          t2.dataType === "source" && e2 === "metadata" && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && t2.dataType === "source" && e2 === "content" && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
        }
        clearTiles() {
          this._shouldReloadOnResume = false, this._paused = false;
          for (const t2 in this._tiles)
            this._removeTile(t2);
          this._cache.reset();
        }
        tilesIn(t2, i2, a2) {
          const s2 = [], o2 = this.transform;
          if (!o2)
            return s2;
          const r2 = a2 ? o2.getCameraQueryGeometry(t2) : t2, n2 = t2.map((t3) => o2.pointCoordinate(t3, this.terrain)), l2 = r2.map((t3) => o2.pointCoordinate(t3, this.terrain)), h2 = this.getIds();
          let c2 = 1 / 0, u2 = 1 / 0, d2 = -1 / 0, _2 = -1 / 0;
          for (const t3 of l2)
            c2 = Math.min(c2, t3.x), u2 = Math.min(u2, t3.y), d2 = Math.max(d2, t3.x), _2 = Math.max(_2, t3.y);
          for (let t3 = 0;t3 < h2.length; t3++) {
            const a3 = this._tiles[h2[t3]];
            if (a3.holdingForFade())
              continue;
            const r3 = a3.tileID, p2 = Math.pow(2, o2.zoom - a3.tileID.overscaledZ), m2 = i2 * a3.queryPadding * e.X / a3.tileSize / p2, f2 = [r3.getTilePoint(new e.Z(c2, u2)), r3.getTilePoint(new e.Z(d2, _2))];
            if (f2[0].x - m2 < e.X && f2[0].y - m2 < e.X && f2[1].x + m2 >= 0 && f2[1].y + m2 >= 0) {
              const t4 = n2.map((t5) => r3.getTilePoint(t5)), e2 = l2.map((t5) => r3.getTilePoint(t5));
              s2.push({
                tile: a3,
                tileID: r3,
                queryGeometry: t4,
                cameraQueryGeometry: e2,
                scale: p2
              });
            }
          }
          return s2;
        }
        getVisibleCoordinates(t2) {
          const e2 = this.getRenderableIds(t2).map((t3) => this._tiles[t3].tileID);
          for (const t3 of e2)
            t3.posMatrix = this.transform.calculatePosMatrix(t3.toUnwrapped());
          return e2;
        }
        hasTransition() {
          if (this._source.hasTransition())
            return true;
          if (_t(this._source.type)) {
            const t2 = o.now();
            for (const e2 in this._tiles)
              if (this._tiles[e2].fadeEndTime >= t2)
                return true;
          }
          return false;
        }
        setFeatureState(t2, e2, i2) {
          this._state.updateState(t2 = t2 || "_geojsonTileLayer", e2, i2);
        }
        removeFeatureState(t2, e2, i2) {
          this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e2, i2);
        }
        getFeatureState(t2, e2) {
          return this._state.getState(t2 = t2 || "_geojsonTileLayer", e2);
        }
        setDependencies(t2, e2, i2) {
          const a2 = this._tiles[t2];
          a2 && a2.setDependencies(e2, i2);
        }
        reloadTilesForDependencies(t2, e2) {
          for (const i2 in this._tiles)
            this._tiles[i2].hasDependency(t2, e2) && this._reloadTile(i2, "reloading");
          this._cache.filter((i2) => !i2.hasDependency(t2, e2));
        }
      }
      function dt(t2, e2) {
        const i2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), a2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
        return t2.overscaledZ - e2.overscaledZ || a2 - i2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
      }
      function _t(t2) {
        return t2 === "raster" || t2 === "image" || t2 === "video";
      }
      ut.maxOverzooming = 10, ut.maxUnderzooming = 3;

      class pt {
        constructor(t2, e2) {
          this.reset(t2, e2);
        }
        reset(t2, e2) {
          this.points = t2 || [], this._distances = [0];
          for (let t3 = 1;t3 < this.points.length; t3++)
            this._distances[t3] = this._distances[t3 - 1] + this.points[t3].dist(this.points[t3 - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(t2) {
          if (this.points.length === 1)
            return this.points[0];
          t2 = e.ac(t2, 0, 1);
          let i2 = 1, a2 = this._distances[i2];
          const s2 = t2 * this.paddedLength + this.padding;
          for (;a2 < s2 && i2 < this._distances.length; )
            a2 = this._distances[++i2];
          const o2 = i2 - 1, r2 = this._distances[o2], n2 = a2 - r2, l2 = n2 > 0 ? (s2 - r2) / n2 : 0;
          return this.points[o2].mult(1 - l2).add(this.points[i2].mult(l2));
        }
      }
      function mt(t2, e2) {
        let i2 = true;
        return t2 === "always" || t2 !== "never" && e2 !== "never" || (i2 = false), i2;
      }

      class ft {
        constructor(t2, e2, i2) {
          const a2 = this.boxCells = [], s2 = this.circleCells = [];
          this.xCellCount = Math.ceil(t2 / i2), this.yCellCount = Math.ceil(e2 / i2);
          for (let t3 = 0;t3 < this.xCellCount * this.yCellCount; t3++)
            a2.push([]), s2.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t2, this.height = e2, this.xScale = this.xCellCount / t2, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(t2, e2, i2, a2, s2) {
          this._forEachCell(e2, i2, a2, s2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t2), this.bboxes.push(e2), this.bboxes.push(i2), this.bboxes.push(a2), this.bboxes.push(s2);
        }
        insertCircle(t2, e2, i2, a2) {
          this._forEachCell(e2 - a2, i2 - a2, e2 + a2, i2 + a2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t2), this.circles.push(e2), this.circles.push(i2), this.circles.push(a2);
        }
        _insertBoxCell(t2, e2, i2, a2, s2, o2) {
          this.boxCells[s2].push(o2);
        }
        _insertCircleCell(t2, e2, i2, a2, s2, o2) {
          this.circleCells[s2].push(o2);
        }
        _query(t2, e2, i2, a2, s2, o2, r2) {
          if (i2 < 0 || t2 > this.width || a2 < 0 || e2 > this.height)
            return [];
          const n2 = [];
          if (t2 <= 0 && e2 <= 0 && this.width <= i2 && this.height <= a2) {
            if (s2)
              return [{ key: null, x1: t2, y1: e2, x2: i2, y2: a2 }];
            for (let t3 = 0;t3 < this.boxKeys.length; t3++)
              n2.push({
                key: this.boxKeys[t3],
                x1: this.bboxes[4 * t3],
                y1: this.bboxes[4 * t3 + 1],
                x2: this.bboxes[4 * t3 + 2],
                y2: this.bboxes[4 * t3 + 3]
              });
            for (let t3 = 0;t3 < this.circleKeys.length; t3++) {
              const e3 = this.circles[3 * t3], i3 = this.circles[3 * t3 + 1], a3 = this.circles[3 * t3 + 2];
              n2.push({
                key: this.circleKeys[t3],
                x1: e3 - a3,
                y1: i3 - a3,
                x2: e3 + a3,
                y2: i3 + a3
              });
            }
          } else
            this._forEachCell(t2, e2, i2, a2, this._queryCell, n2, { hitTest: s2, overlapMode: o2, seenUids: { box: {}, circle: {} } }, r2);
          return n2;
        }
        query(t2, e2, i2, a2) {
          return this._query(t2, e2, i2, a2, false, null);
        }
        hitTest(t2, e2, i2, a2, s2, o2) {
          return this._query(t2, e2, i2, a2, true, s2, o2).length > 0;
        }
        hitTestCircle(t2, e2, i2, a2, s2) {
          const o2 = t2 - i2, r2 = t2 + i2, n2 = e2 - i2, l2 = e2 + i2;
          if (r2 < 0 || o2 > this.width || l2 < 0 || n2 > this.height)
            return false;
          const h2 = [];
          return this._forEachCell(o2, n2, r2, l2, this._queryCellCircle, h2, {
            hitTest: true,
            overlapMode: a2,
            circle: { x: t2, y: e2, radius: i2 },
            seenUids: { box: {}, circle: {} }
          }, s2), h2.length > 0;
        }
        _queryCell(t2, e2, i2, a2, s2, o2, r2, n2) {
          const { seenUids: l2, hitTest: h2, overlapMode: c2 } = r2, u2 = this.boxCells[s2];
          if (u2 !== null) {
            const s3 = this.bboxes;
            for (const r3 of u2)
              if (!l2.box[r3]) {
                l2.box[r3] = true;
                const u3 = 4 * r3, d3 = this.boxKeys[r3];
                if (t2 <= s3[u3 + 2] && e2 <= s3[u3 + 3] && i2 >= s3[u3 + 0] && a2 >= s3[u3 + 1] && (!n2 || n2(d3)) && (!h2 || !mt(c2, d3.overlapMode)) && (o2.push({ key: d3, x1: s3[u3], y1: s3[u3 + 1], x2: s3[u3 + 2], y2: s3[u3 + 3] }), h2))
                  return true;
              }
          }
          const d2 = this.circleCells[s2];
          if (d2 !== null) {
            const s3 = this.circles;
            for (const r3 of d2)
              if (!l2.circle[r3]) {
                l2.circle[r3] = true;
                const u3 = 3 * r3, d3 = this.circleKeys[r3];
                if (this._circleAndRectCollide(s3[u3], s3[u3 + 1], s3[u3 + 2], t2, e2, i2, a2) && (!n2 || n2(d3)) && (!h2 || !mt(c2, d3.overlapMode))) {
                  const t3 = s3[u3], e3 = s3[u3 + 1], i3 = s3[u3 + 2];
                  if (o2.push({ key: d3, x1: t3 - i3, y1: e3 - i3, x2: t3 + i3, y2: e3 + i3 }), h2)
                    return true;
                }
              }
          }
          return false;
        }
        _queryCellCircle(t2, e2, i2, a2, s2, o2, r2, n2) {
          const { circle: l2, seenUids: h2, overlapMode: c2 } = r2, u2 = this.boxCells[s2];
          if (u2 !== null) {
            const t3 = this.bboxes;
            for (const e3 of u2)
              if (!h2.box[e3]) {
                h2.box[e3] = true;
                const i3 = 4 * e3, a3 = this.boxKeys[e3];
                if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, t3[i3 + 0], t3[i3 + 1], t3[i3 + 2], t3[i3 + 3]) && (!n2 || n2(a3)) && !mt(c2, a3.overlapMode))
                  return o2.push(true), true;
              }
          }
          const d2 = this.circleCells[s2];
          if (d2 !== null) {
            const t3 = this.circles;
            for (const e3 of d2)
              if (!h2.circle[e3]) {
                h2.circle[e3] = true;
                const i3 = 3 * e3, a3 = this.circleKeys[e3];
                if (this._circlesCollide(t3[i3], t3[i3 + 1], t3[i3 + 2], l2.x, l2.y, l2.radius) && (!n2 || n2(a3)) && !mt(c2, a3.overlapMode))
                  return o2.push(true), true;
              }
          }
        }
        _forEachCell(t2, e2, i2, a2, s2, o2, r2, n2) {
          const l2 = this._convertToXCellCoord(t2), h2 = this._convertToYCellCoord(e2), c2 = this._convertToXCellCoord(i2), u2 = this._convertToYCellCoord(a2);
          for (let d2 = l2;d2 <= c2; d2++)
            for (let l3 = h2;l3 <= u2; l3++)
              if (s2.call(this, t2, e2, i2, a2, this.xCellCount * l3 + d2, o2, r2, n2))
                return;
        }
        _convertToXCellCoord(t2) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t2 * this.xScale)));
        }
        _convertToYCellCoord(t2) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t2 * this.yScale)));
        }
        _circlesCollide(t2, e2, i2, a2, s2, o2) {
          const r2 = a2 - t2, n2 = s2 - e2, l2 = i2 + o2;
          return l2 * l2 > r2 * r2 + n2 * n2;
        }
        _circleAndRectCollide(t2, e2, i2, a2, s2, o2, r2) {
          const n2 = (o2 - a2) / 2, l2 = Math.abs(t2 - (a2 + n2));
          if (l2 > n2 + i2)
            return false;
          const h2 = (r2 - s2) / 2, c2 = Math.abs(e2 - (s2 + h2));
          if (c2 > h2 + i2)
            return false;
          if (l2 <= n2 || c2 <= h2)
            return true;
          const u2 = l2 - n2, d2 = c2 - h2;
          return u2 * u2 + d2 * d2 <= i2 * i2;
        }
      }
      function gt(t2, i2, a2, s2, o2) {
        const r2 = e.H();
        return i2 ? (e.K(r2, r2, [1 / o2, 1 / o2, 1]), a2 || e.ad(r2, r2, s2.angle)) : e.L(r2, s2.labelPlaneMatrix, t2), r2;
      }
      function vt(t2, i2, a2, s2, o2) {
        if (i2) {
          const i3 = e.ae(t2);
          return e.K(i3, i3, [o2, o2, 1]), a2 || e.ad(i3, i3, -s2.angle), i3;
        }
        return s2.glCoordMatrix;
      }
      function xt(t2, i2, a2, s2) {
        let o2;
        s2 ? (o2 = [t2, i2, s2(t2, i2), 1], e.af(o2, o2, a2)) : (o2 = [t2, i2, 0, 1], kt(o2, o2, a2));
        const r2 = o2[3];
        return {
          point: new e.P(o2[0] / r2, o2[1] / r2),
          signedDistanceFromCamera: r2,
          isOccluded: false
        };
      }
      function yt(t2, e2) {
        return 0.5 + t2 / e2 * 0.5;
      }
      function bt(t2, e2) {
        return t2.x >= -e2[0] && t2.x <= e2[0] && t2.y >= -e2[1] && t2.y <= e2[1];
      }
      function wt(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2, m2) {
        const f2 = s2 ? t2.textSizeData : t2.iconSizeData, g2 = e.ag(f2, a2.transform.zoom), v2 = [256 / a2.width * 2 + 1, 256 / a2.height * 2 + 1], x2 = s2 ? t2.text.dynamicLayoutVertexArray : t2.icon.dynamicLayoutVertexArray;
        x2.clear();
        const y2 = t2.lineVertexArray, b2 = s2 ? t2.text.placedSymbolArray : t2.icon.placedSymbolArray, w2 = a2.transform.width / a2.transform.height;
        let T2 = false;
        for (let s3 = 0;s3 < b2.length; s3++) {
          const I2 = b2.get(s3);
          if (I2.hidden || I2.writingMode === e.ah.vertical && !T2) {
            Rt(I2.numGlyphs, x2);
            continue;
          }
          T2 = false;
          const E2 = xt(I2.anchorX, I2.anchorY, i2, m2);
          if (!bt(E2.point, v2)) {
            Rt(I2.numGlyphs, x2);
            continue;
          }
          const P2 = yt(a2.transform.cameraToCenterDistance, E2.signedDistanceFromCamera), C2 = e.ai(f2, g2, I2), S2 = n2 ? C2 / P2 : C2 * P2, z2 = {
            getElevation: m2,
            labelPlaneMatrix: o2,
            lineVertexArray: y2,
            pitchWithMap: n2,
            projectionCache: {
              projections: {},
              offsets: {},
              cachedAnchorPoint: undefined,
              anyProjectionOccluded: false
            },
            projection: c2,
            tileAnchorPoint: new e.P(I2.anchorX, I2.anchorY),
            unwrappedTileID: u2,
            width: d2,
            height: _2,
            translation: p2
          }, D2 = Et(z2, I2, S2, false, l2, i2, r2, t2.glyphOffsetArray, x2, w2, h2);
          T2 = D2.useVertical, (D2.notEnoughRoom || T2 || D2.needsFlipping && Et(z2, I2, S2, true, l2, i2, r2, t2.glyphOffsetArray, x2, w2, h2).notEnoughRoom) && Rt(I2.numGlyphs, x2);
        }
        s2 ? t2.text.dynamicLayoutVertexBuffer.updateData(x2) : t2.icon.dynamicLayoutVertexBuffer.updateData(x2);
      }
      function Tt(t2, e2, i2, a2, s2, o2, r2, n2) {
        const l2 = o2.glyphStartIndex + o2.numGlyphs, h2 = o2.lineStartIndex, c2 = o2.lineStartIndex + o2.lineLength, u2 = e2.getoffsetX(o2.glyphStartIndex), d2 = e2.getoffsetX(l2 - 1), _2 = Mt(t2 * u2, i2, a2, s2, o2.segment, h2, c2, n2, r2);
        if (!_2)
          return null;
        const p2 = Mt(t2 * d2, i2, a2, s2, o2.segment, h2, c2, n2, r2);
        return p2 ? n2.projectionCache.anyProjectionOccluded ? null : { first: _2, last: p2 } : null;
      }
      function It(t2, i2, a2, s2) {
        return t2 === e.ah.horizontal && Math.abs(a2.y - i2.y) > Math.abs(a2.x - i2.x) * s2 ? { useVertical: true } : (t2 === e.ah.vertical ? i2.y < a2.y : i2.x > a2.x) ? { needsFlipping: true } : null;
      }
      function Et(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u2) {
        const d2 = a2 / 24, _2 = i2.lineOffsetX * d2, p2 = i2.lineOffsetY * d2;
        let m2;
        if (i2.numGlyphs > 1) {
          const e2 = i2.glyphStartIndex + i2.numGlyphs, a3 = i2.lineStartIndex, r3 = i2.lineStartIndex + i2.lineLength, h3 = Tt(d2, l2, _2, p2, s2, i2, u2, t2);
          if (!h3)
            return { notEnoughRoom: true };
          const f2 = xt(h3.first.point.x, h3.first.point.y, n2, t2.getElevation).point, g2 = xt(h3.last.point.x, h3.last.point.y, n2, t2.getElevation).point;
          if (o2 && !s2) {
            const t3 = It(i2.writingMode, f2, g2, c2);
            if (t3)
              return t3;
          }
          m2 = [h3.first];
          for (let o3 = i2.glyphStartIndex + 1;o3 < e2 - 1; o3++)
            m2.push(Mt(d2 * l2.getoffsetX(o3), _2, p2, s2, i2.segment, a3, r3, t2, u2));
          m2.push(h3.last);
        } else {
          if (o2 && !s2) {
            const a4 = xt(t2.tileAnchorPoint.x, t2.tileAnchorPoint.y, r2, t2.getElevation).point, s3 = i2.lineStartIndex + i2.segment + 1, o3 = new e.P(t2.lineVertexArray.getx(s3), t2.lineVertexArray.gety(s3)), n3 = xt(o3.x, o3.y, r2, t2.getElevation), l3 = n3.signedDistanceFromCamera > 0 ? n3.point : function(t3, e2, i3, a5, s4, o4) {
              return Pt(t3, e2, i3, 1, s4, o4);
            }(t2.tileAnchorPoint, o3, a4, 0, r2, t2), h3 = It(i2.writingMode, a4, l3, c2);
            if (h3)
              return h3;
          }
          const a3 = Mt(d2 * l2.getoffsetX(i2.glyphStartIndex), _2, p2, s2, i2.segment, i2.lineStartIndex, i2.lineStartIndex + i2.lineLength, t2, u2);
          if (!a3 || t2.projectionCache.anyProjectionOccluded)
            return { notEnoughRoom: true };
          m2 = [a3];
        }
        for (const t3 of m2)
          e.aj(h2, t3.point, t3.angle);
        return {};
      }
      function Pt(t2, e2, i2, a2, s2, o2) {
        const r2 = t2.add(t2.sub(e2)._unit()), n2 = s2 !== undefined ? xt(r2.x, r2.y, s2, o2.getElevation).point : St(r2.x, r2.y, o2).point, l2 = i2.sub(n2);
        return i2.add(l2._mult(a2 / l2.mag()));
      }
      function Ct(t2, i2, a2) {
        const s2 = i2.projectionCache;
        if (s2.projections[t2])
          return s2.projections[t2];
        const o2 = new e.P(i2.lineVertexArray.getx(t2), i2.lineVertexArray.gety(t2)), r2 = St(o2.x, o2.y, i2);
        if (r2.signedDistanceFromCamera > 0)
          return s2.projections[t2] = r2.point, s2.anyProjectionOccluded = s2.anyProjectionOccluded || r2.isOccluded, r2.point;
        const n2 = t2 - a2.direction;
        return function(t3, e2, i3, a3, s3) {
          return Pt(t3, e2, i3, a3, undefined, s3);
        }(a2.distanceFromAnchor === 0 ? i2.tileAnchorPoint : new e.P(i2.lineVertexArray.getx(n2), i2.lineVertexArray.gety(n2)), o2, a2.previousVertex, a2.absOffsetX - a2.distanceFromAnchor + 1, i2);
      }
      function St(t2, e2, i2) {
        const a2 = t2 + i2.translation[0], s2 = e2 + i2.translation[1];
        let o2;
        return !i2.pitchWithMap && i2.projection.useSpecialProjectionForSymbols ? (o2 = i2.projection.projectTileCoordinates(a2, s2, i2.unwrappedTileID, i2.getElevation), o2.point.x = (0.5 * o2.point.x + 0.5) * i2.width, o2.point.y = (0.5 * -o2.point.y + 0.5) * i2.height) : (o2 = xt(a2, s2, i2.labelPlaneMatrix, i2.getElevation), o2.isOccluded = false), o2;
      }
      function zt(t2, e2, i2) {
        return t2._unit()._perp()._mult(e2 * i2);
      }
      function Dt(t2, i2, a2, s2, o2, r2, n2, l2, h2) {
        if (l2.projectionCache.offsets[t2])
          return l2.projectionCache.offsets[t2];
        const c2 = a2.add(i2);
        if (t2 + h2.direction < s2 || t2 + h2.direction >= o2)
          return l2.projectionCache.offsets[t2] = c2, c2;
        const u2 = Ct(t2 + h2.direction, l2, h2), d2 = zt(u2.sub(a2), n2, h2.direction), _2 = a2.add(d2), p2 = u2.add(d2);
        return l2.projectionCache.offsets[t2] = e.ak(r2, c2, _2, p2) || c2, l2.projectionCache.offsets[t2];
      }
      function Mt(t2, e2, i2, a2, s2, o2, r2, n2, l2) {
        const h2 = a2 ? t2 - e2 : t2 + e2;
        let c2 = h2 > 0 ? 1 : -1, u2 = 0;
        a2 && (c2 *= -1, u2 = Math.PI), c2 < 0 && (u2 += Math.PI);
        let d2, _2 = c2 > 0 ? o2 + s2 : o2 + s2 + 1;
        n2.projectionCache.cachedAnchorPoint ? d2 = n2.projectionCache.cachedAnchorPoint : (d2 = St(n2.tileAnchorPoint.x, n2.tileAnchorPoint.y, n2).point, n2.projectionCache.cachedAnchorPoint = d2);
        let p2, m2, f2 = d2, g2 = d2, v2 = 0, x2 = 0;
        const y2 = Math.abs(h2), b2 = [];
        let w2;
        for (;v2 + x2 <= y2; ) {
          if (_2 += c2, _2 < o2 || _2 >= r2)
            return null;
          v2 += x2, g2 = f2, m2 = p2;
          const t3 = {
            absOffsetX: y2,
            direction: c2,
            distanceFromAnchor: v2,
            previousVertex: g2
          };
          if (f2 = Ct(_2, n2, t3), i2 === 0)
            b2.push(g2), w2 = f2.sub(g2);
          else {
            let e3;
            const a3 = f2.sub(g2);
            e3 = a3.mag() === 0 ? zt(Ct(_2 + c2, n2, t3).sub(f2), i2, c2) : zt(a3, i2, c2), m2 || (m2 = g2.add(e3)), p2 = Dt(_2, e3, f2, o2, r2, m2, i2, n2, t3), b2.push(m2), w2 = p2.sub(m2);
          }
          x2 = w2.mag();
        }
        const T2 = w2._mult((y2 - v2) / x2)._add(m2 || g2), I2 = u2 + Math.atan2(f2.y - g2.y, f2.x - g2.x);
        return b2.push(T2), { point: T2, angle: l2 ? I2 : 0, path: b2 };
      }
      const At = new Float32Array([
        -1 / 0,
        -1 / 0,
        0,
        -1 / 0,
        -1 / 0,
        0,
        -1 / 0,
        -1 / 0,
        0,
        -1 / 0,
        -1 / 0,
        0
      ]);
      function Rt(t2, e2) {
        for (let i2 = 0;i2 < t2; i2++) {
          const t3 = e2.length;
          e2.resize(t3 + 4), e2.float32.set(At, 3 * t3);
        }
      }
      function kt(t2, e2, i2) {
        const a2 = e2[0], s2 = e2[1];
        return t2[0] = i2[0] * a2 + i2[4] * s2 + i2[12], t2[1] = i2[1] * a2 + i2[5] * s2 + i2[13], t2[3] = i2[3] * a2 + i2[7] * s2 + i2[15], t2;
      }
      const Lt = 100;

      class Ft {
        constructor(t2, e2, i2 = new ft(t2.width + 200, t2.height + 200, 25), a2 = new ft(t2.width + 200, t2.height + 200, 25)) {
          this.transform = t2, this.mapProjection = e2, this.grid = i2, this.ignoredGrid = a2, this.pitchFactor = Math.cos(t2._pitch) * t2.cameraToCenterDistance, this.screenRightBoundary = t2.width + Lt, this.screenBottomBoundary = t2.height + Lt, this.gridRightBoundary = t2.width + 200, this.gridBottomBoundary = t2.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(t2, e2, i2, a2, s2, o2, r2, n2, l2, h2, c2) {
          const u2 = t2.anchorPointX + n2[0], d2 = t2.anchorPointY + n2[1], _2 = this.projectAndGetPerspectiveRatio(a2, u2, d2, s2, h2), p2 = i2 * _2.perspectiveRatio;
          let m2;
          if (o2 || r2)
            m2 = this._projectCollisionBox(t2, p2, a2, s2, o2, r2, n2, _2, h2, c2);
          else {
            const e3 = _2.point.x + (c2 ? c2.x * p2 : 0), i3 = _2.point.y + (c2 ? c2.y * p2 : 0);
            m2 = {
              allPointsOccluded: false,
              box: [e3 + t2.x1 * p2, i3 + t2.y1 * p2, e3 + t2.x2 * p2, i3 + t2.y2 * p2]
            };
          }
          const [f2, g2, v2, x2] = m2.box;
          return this.mapProjection.useSpecialProjectionForSymbols && (o2 ? m2.allPointsOccluded : this.mapProjection.isOccluded(u2, d2, s2)) || _2.perspectiveRatio < this.perspectiveRatioCutoff || !this.isInsideGrid(f2, g2, v2, x2) || e2 !== "always" && this.grid.hitTest(f2, g2, v2, x2, e2, l2) ? { box: [f2, g2, v2, x2], placeable: false, offscreen: false } : {
            box: [f2, g2, v2, x2],
            placeable: true,
            offscreen: this.isOffscreen(f2, g2, v2, x2)
          };
        }
        placeCollisionCircles(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2, m2, f2) {
          const g2 = [], v2 = new e.P(i2.anchorX, i2.anchorY), x2 = this.getPerspectiveRatio(r2, v2.x, v2.y, n2, f2), y2 = (u2 ? o2 / x2 : o2 * x2) / e.ap, b2 = {
            getElevation: f2,
            labelPlaneMatrix: l2,
            lineVertexArray: a2,
            pitchWithMap: u2,
            projectionCache: {
              projections: {},
              offsets: {},
              cachedAnchorPoint: undefined,
              anyProjectionOccluded: false
            },
            projection: this.mapProjection,
            tileAnchorPoint: v2,
            unwrappedTileID: n2,
            width: this.transform.width,
            height: this.transform.height,
            translation: m2
          }, w2 = Tt(y2, s2, i2.lineOffsetX * y2, i2.lineOffsetY * y2, false, i2, false, b2);
          let T2 = false, I2 = false, E2 = true;
          if (w2) {
            const i3 = 0.5 * _2 * x2 + p2, a3 = new e.P(-100, -100), s3 = new e.P(this.screenRightBoundary, this.screenBottomBoundary), o3 = new pt, r3 = w2.first, n3 = w2.last;
            let l3 = [];
            for (let t3 = r3.path.length - 1;t3 >= 1; t3--)
              l3.push(r3.path[t3]);
            for (let t3 = 1;t3 < n3.path.length; t3++)
              l3.push(n3.path[t3]);
            const u3 = 2.5 * i3;
            if (h2) {
              const t3 = this.projectPathToScreenSpace(l3, b2, h2);
              l3 = t3.some((t4) => t4.signedDistanceFromCamera <= 0) ? [] : t3.map((t4) => t4.point);
            }
            let m3 = [];
            if (l3.length > 0) {
              const t3 = l3[0].clone(), i4 = l3[0].clone();
              for (let e2 = 1;e2 < l3.length; e2++)
                t3.x = Math.min(t3.x, l3[e2].x), t3.y = Math.min(t3.y, l3[e2].y), i4.x = Math.max(i4.x, l3[e2].x), i4.y = Math.max(i4.y, l3[e2].y);
              m3 = t3.x >= a3.x && i4.x <= s3.x && t3.y >= a3.y && i4.y <= s3.y ? [l3] : i4.x < a3.x || t3.x > s3.x || i4.y < a3.y || t3.y > s3.y ? [] : e.al([l3], a3.x, a3.y, s3.x, s3.y);
            }
            for (const e2 of m3) {
              o3.reset(e2, 0.25 * i3);
              let a4 = 0;
              a4 = o3.length <= 0.5 * i3 ? 1 : Math.ceil(o3.paddedLength / u3) + 1;
              for (let e3 = 0;e3 < a4; e3++) {
                const s4 = e3 / Math.max(a4 - 1, 1), r4 = o3.lerp(s4), n4 = r4.x + Lt, l4 = r4.y + Lt;
                g2.push(n4, l4, i3, 0);
                const h3 = n4 - i3, u4 = l4 - i3, _3 = n4 + i3, p3 = l4 + i3;
                if (E2 = E2 && this.isOffscreen(h3, u4, _3, p3), I2 = I2 || this.isInsideGrid(h3, u4, _3, p3), t2 !== "always" && this.grid.hitTestCircle(n4, l4, i3, t2, d2) && (T2 = true, !c2))
                  return { circles: [], offscreen: false, collisionDetected: T2 };
              }
            }
          }
          return {
            circles: !c2 && T2 || !I2 || x2 < this.perspectiveRatioCutoff ? [] : g2,
            offscreen: E2,
            collisionDetected: T2
          };
        }
        projectPathToScreenSpace(t2, e2, i2) {
          return t2.map((t3) => xt(t3.x, t3.y, i2, e2.getElevation));
        }
        queryRenderedSymbols(t2) {
          if (t2.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
            return {};
          const i2 = [];
          let a2 = 1 / 0, s2 = 1 / 0, o2 = -1 / 0, r2 = -1 / 0;
          for (const n3 of t2) {
            const t3 = new e.P(n3.x + Lt, n3.y + Lt);
            a2 = Math.min(a2, t3.x), s2 = Math.min(s2, t3.y), o2 = Math.max(o2, t3.x), r2 = Math.max(r2, t3.y), i2.push(t3);
          }
          const n2 = this.grid.query(a2, s2, o2, r2).concat(this.ignoredGrid.query(a2, s2, o2, r2)), l2 = {}, h2 = {};
          for (const t3 of n2) {
            const a3 = t3.key;
            if (l2[a3.bucketInstanceId] === undefined && (l2[a3.bucketInstanceId] = {}), l2[a3.bucketInstanceId][a3.featureIndex])
              continue;
            const s3 = [
              new e.P(t3.x1, t3.y1),
              new e.P(t3.x2, t3.y1),
              new e.P(t3.x2, t3.y2),
              new e.P(t3.x1, t3.y2)
            ];
            e.am(i2, s3) && (l2[a3.bucketInstanceId][a3.featureIndex] = true, h2[a3.bucketInstanceId] === undefined && (h2[a3.bucketInstanceId] = []), h2[a3.bucketInstanceId].push(a3.featureIndex));
          }
          return h2;
        }
        insertCollisionBox(t2, e2, i2, a2, s2, o2) {
          (i2 ? this.ignoredGrid : this.grid).insert({
            bucketInstanceId: a2,
            featureIndex: s2,
            collisionGroupID: o2,
            overlapMode: e2
          }, t2[0], t2[1], t2[2], t2[3]);
        }
        insertCollisionCircles(t2, e2, i2, a2, s2, o2) {
          const r2 = i2 ? this.ignoredGrid : this.grid, n2 = {
            bucketInstanceId: a2,
            featureIndex: s2,
            collisionGroupID: o2,
            overlapMode: e2
          };
          for (let e3 = 0;e3 < t2.length; e3 += 4)
            r2.insertCircle(n2, t2[e3], t2[e3 + 1], t2[e3 + 2]);
        }
        projectAndGetPerspectiveRatio(t2, i2, a2, s2, o2) {
          let r2;
          o2 ? (r2 = [i2, a2, o2(i2, a2), 1], e.af(r2, r2, t2)) : (r2 = [i2, a2, 0, 1], kt(r2, r2, t2));
          const n2 = r2[3];
          return {
            point: new e.P((r2[0] / n2 + 1) / 2 * this.transform.width + Lt, (-r2[1] / n2 + 1) / 2 * this.transform.height + Lt),
            perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / n2 * 0.5,
            isOccluded: false,
            signedDistanceFromCamera: n2
          };
        }
        getPerspectiveRatio(t2, e2, i2, a2, s2) {
          const o2 = this.mapProjection.useSpecialProjectionForSymbols ? this.mapProjection.projectTileCoordinates(e2, i2, a2, s2) : xt(e2, i2, t2, s2);
          return 0.5 + this.transform.cameraToCenterDistance / o2.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(t2, e2, i2, a2) {
          return i2 < Lt || t2 >= this.screenRightBoundary || a2 < Lt || e2 > this.screenBottomBoundary;
        }
        isInsideGrid(t2, e2, i2, a2) {
          return i2 >= 0 && t2 < this.gridRightBoundary && a2 >= 0 && e2 < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t2 = e.an([]);
          return e.J(t2, t2, [-100, -100, 0]), t2;
        }
        _projectCollisionBox(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2) {
          let u2 = new e.P(1, 0), d2 = new e.P(0, 1);
          const _2 = new e.P(t2.anchorPointX + n2[0], t2.anchorPointY + n2[1]);
          if (r2 && !o2) {
            const t3 = this.projectAndGetPerspectiveRatio(a2, _2.x + 1, _2.y, s2, h2).point.sub(l2.point).unit(), i3 = Math.atan(t3.y / t3.x) + (t3.x < 0 ? Math.PI : 0), o3 = Math.sin(i3), r3 = Math.cos(i3);
            u2 = new e.P(r3, o3), d2 = new e.P(-o3, r3);
          } else if (!r2 && o2) {
            const t3 = -this.transform.angle, i3 = Math.sin(t3), a3 = Math.cos(t3);
            u2 = new e.P(a3, i3), d2 = new e.P(-i3, a3);
          }
          let p2 = l2.point, m2 = i2;
          if (o2) {
            p2 = _2;
            const t3 = this.transform.zoom - Math.floor(this.transform.zoom);
            m2 = Math.pow(2, -t3), m2 *= this.mapProjection.getPitchedTextCorrection(this.transform, _2, s2), c2 || (m2 *= e.ac(0.5 + l2.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4));
          }
          c2 && (p2 = p2.add(u2.mult(c2.x * m2)).add(d2.mult(c2.y * m2)));
          const f2 = t2.x1 * m2, g2 = t2.x2 * m2, v2 = (f2 + g2) / 2, x2 = t2.y1 * m2, y2 = t2.y2 * m2, b2 = (x2 + y2) / 2, w2 = [
            { offsetX: f2, offsetY: x2 },
            { offsetX: v2, offsetY: x2 },
            { offsetX: g2, offsetY: x2 },
            { offsetX: g2, offsetY: b2 },
            { offsetX: g2, offsetY: y2 },
            { offsetX: v2, offsetY: y2 },
            { offsetX: f2, offsetY: y2 },
            { offsetX: f2, offsetY: b2 }
          ];
          let T2 = [];
          for (const { offsetX: t3, offsetY: i3 } of w2)
            T2.push(new e.P(p2.x + u2.x * t3 + d2.x * i3, p2.y + u2.y * t3 + d2.y * i3));
          let I2 = false;
          if (o2) {
            const t3 = T2.map((t4) => this.projectAndGetPerspectiveRatio(a2, t4.x, t4.y, s2, h2));
            I2 = t3.some((t4) => !t4.isOccluded), T2 = t3.map((t4) => t4.point);
          } else
            I2 = true;
          return { box: e.ao(T2), allPointsOccluded: !I2 };
        }
      }
      function Bt(t2, i2, a2) {
        return i2 * (e.X / (t2.tileSize * Math.pow(2, a2 - t2.tileID.overscaledZ)));
      }

      class Ot {
        constructor(t2, e2, i2, a2) {
          this.opacity = t2 ? Math.max(0, Math.min(1, t2.opacity + (t2.placed ? e2 : -e2))) : a2 && i2 ? 1 : 0, this.placed = i2;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }

      class Nt {
        constructor(t2, e2, i2, a2, s2) {
          this.text = new Ot(t2 ? t2.text : null, e2, i2, s2), this.icon = new Ot(t2 ? t2.icon : null, e2, a2, s2);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }

      class Ut {
        constructor(t2, e2, i2) {
          this.text = t2, this.icon = e2, this.skipFade = i2;
        }
      }

      class jt {
        constructor() {
          this.invProjMatrix = e.H(), this.viewportMatrix = e.H(), this.circles = [];
        }
      }

      class Zt {
        constructor(t2, e2, i2, a2, s2) {
          this.bucketInstanceId = t2, this.featureIndex = e2, this.sourceLayerIndex = i2, this.bucketIndex = a2, this.tileID = s2;
        }
      }

      class qt {
        constructor(t2) {
          this.crossSourceCollisions = t2, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(t2) {
          if (this.crossSourceCollisions)
            return { ID: 0, predicate: null };
          if (!this.collisionGroups[t2]) {
            const e2 = ++this.maxGroupID;
            this.collisionGroups[t2] = {
              ID: e2,
              predicate: (t3) => t3.collisionGroupID === e2
            };
          }
          return this.collisionGroups[t2];
        }
      }
      function Vt(t2, i2, a2, s2, o2) {
        const { horizontalAlign: r2, verticalAlign: n2 } = e.au(t2);
        return new e.P(-(r2 - 0.5) * i2 + s2[0] * o2, -(n2 - 0.5) * a2 + s2[1] * o2);
      }

      class Gt {
        constructor(t2, e2, i2, a2, s2, o2) {
          this.transform = t2.clone(), this.terrain = i2, this.collisionIndex = new Ft(this.transform, e2), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = a2, this.retainedQueryData = {}, this.collisionGroups = new qt(s2), this.collisionCircleArrays = {}, this.collisionBoxArrays = new Map, this.prevPlacement = o2, o2 && (o2.prevPlacement = undefined), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(t2) {
          const e2 = this.terrain;
          return e2 ? (i2, a2) => e2.getElevation(t2, i2, a2) : null;
        }
        getBucketParts(t2, i2, a2, s2) {
          const o2 = a2.getBucket(i2), r2 = a2.latestFeatureIndex;
          if (!o2 || !r2 || i2.id !== o2.layerIds[0])
            return;
          const n2 = a2.collisionBoxArray, l2 = o2.layers[0].layout, h2 = o2.layers[0].paint, c2 = Math.pow(2, this.transform.zoom - a2.tileID.overscaledZ), u2 = a2.tileSize / e.X, d2 = a2.tileID.toUnwrapped(), _2 = this.transform.calculatePosMatrix(d2), p2 = l2.get("text-pitch-alignment") === "map", m2 = l2.get("text-rotation-alignment") === "map", f2 = Bt(a2, 1, this.transform.zoom), g2 = this.collisionIndex.mapProjection.translatePosition(this.transform, a2, h2.get("text-translate"), h2.get("text-translate-anchor")), v2 = this.collisionIndex.mapProjection.translatePosition(this.transform, a2, h2.get("icon-translate"), h2.get("icon-translate-anchor")), x2 = gt(_2, p2, m2, this.transform, f2);
          let y2 = null;
          if (p2) {
            const t3 = vt(_2, p2, m2, this.transform, f2);
            y2 = e.L([], this.transform.labelPlaneMatrix, t3);
          }
          this.retainedQueryData[o2.bucketInstanceId] = new Zt(o2.bucketInstanceId, r2, o2.sourceLayerIndex, o2.index, a2.tileID);
          const b2 = {
            bucket: o2,
            layout: l2,
            translationText: g2,
            translationIcon: v2,
            posMatrix: _2,
            unwrappedTileID: d2,
            textLabelPlaneMatrix: x2,
            labelToScreenMatrix: y2,
            scale: c2,
            textPixelRatio: u2,
            holdingForFade: a2.holdingForFade(),
            collisionBoxArray: n2,
            partiallyEvaluatedTextSize: e.ag(o2.textSizeData, this.transform.zoom),
            collisionGroup: this.collisionGroups.get(o2.sourceID)
          };
          if (s2)
            for (const e2 of o2.sortKeyRanges) {
              const { sortKey: i3, symbolInstanceStart: a3, symbolInstanceEnd: s3 } = e2;
              t2.push({
                sortKey: i3,
                symbolInstanceStart: a3,
                symbolInstanceEnd: s3,
                parameters: b2
              });
            }
          else
            t2.push({
              symbolInstanceStart: 0,
              symbolInstanceEnd: o2.symbolInstances.length,
              parameters: b2
            });
        }
        attemptAnchorPlacement(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2, m2, f2, g2, v2, x2) {
          const y2 = e.aq[t2.textAnchor], b2 = [t2.textOffset0, t2.textOffset1], w2 = Vt(y2, a2, s2, b2, o2), T2 = this.collisionIndex.placeCollisionBox(i2, d2, l2, h2, c2, n2, r2, f2, u2.predicate, x2, w2);
          if ((!v2 || this.collisionIndex.placeCollisionBox(v2, d2, l2, h2, c2, n2, r2, g2, u2.predicate, x2, w2).placeable) && T2.placeable) {
            let t3;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[_2.crossTileID] && this.prevPlacement.placements[_2.crossTileID] && this.prevPlacement.placements[_2.crossTileID].text && (t3 = this.prevPlacement.variableOffsets[_2.crossTileID].anchor), _2.crossTileID === 0)
              throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[_2.crossTileID] = {
              textOffset: b2,
              width: a2,
              height: s2,
              anchor: y2,
              textBoxScale: o2,
              prevAnchor: t3
            }, this.markUsedJustification(p2, y2, _2, m2), p2.allowVerticalPlacement && (this.markUsedOrientation(p2, m2, _2), this.placedOrientations[_2.crossTileID] = m2), { shift: w2, placedGlyphBoxes: T2 };
          }
        }
        placeLayerBucketPart(t2, i2, a2) {
          const {
            bucket: s2,
            layout: o2,
            translationText: r2,
            translationIcon: n2,
            posMatrix: l2,
            unwrappedTileID: h2,
            textLabelPlaneMatrix: c2,
            labelToScreenMatrix: u2,
            textPixelRatio: d2,
            holdingForFade: _2,
            collisionBoxArray: p2,
            partiallyEvaluatedTextSize: m2,
            collisionGroup: f2
          } = t2.parameters, g2 = o2.get("text-optional"), v2 = o2.get("icon-optional"), x2 = e.ar(o2, "text-overlap", "text-allow-overlap"), y2 = x2 === "always", b2 = e.ar(o2, "icon-overlap", "icon-allow-overlap"), w2 = b2 === "always", T2 = o2.get("text-rotation-alignment") === "map", I2 = o2.get("text-pitch-alignment") === "map", E2 = o2.get("icon-text-fit") !== "none", P2 = o2.get("symbol-z-order") === "viewport-y", C2 = y2 && (w2 || !s2.hasIconData() || v2), S2 = w2 && (y2 || !s2.hasTextData() || g2);
          !s2.collisionArrays && p2 && s2.deserializeCollisionBoxes(p2);
          const z2 = this._getTerrainElevationFunc(this.retainedQueryData[s2.bucketInstanceId].tileID), D2 = (t3, p3, w3) => {
            var P3, D3;
            if (i2[t3.crossTileID])
              return;
            if (_2)
              return void (this.placements[t3.crossTileID] = new Ut(false, false, false));
            let M2 = false, A2 = false, R2 = true, k2 = null, L2 = { box: null, placeable: false, offscreen: null }, F2 = { box: null, placeable: false, offscreen: null }, B2 = null, O2 = null, N2 = null, U2 = 0, j2 = 0, Z2 = 0;
            p3.textFeatureIndex ? U2 = p3.textFeatureIndex : t3.useRuntimeCollisionCircles && (U2 = t3.featureIndex), p3.verticalTextFeatureIndex && (j2 = p3.verticalTextFeatureIndex);
            const q2 = p3.textBox;
            if (q2) {
              const i3 = (i4) => {
                let a3 = e.ah.horizontal;
                if (s2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                  const e2 = this.prevPlacement.placedOrientations[t3.crossTileID];
                  e2 && (this.placedOrientations[t3.crossTileID] = e2, a3 = e2, this.markUsedOrientation(s2, a3, t3));
                }
                return a3;
              }, o3 = (i4, a3) => {
                if (s2.allowVerticalPlacement && t3.numVerticalGlyphVertices > 0 && p3.verticalTextBox) {
                  for (const t4 of s2.writingModes)
                    if (t4 === e.ah.vertical ? (L2 = a3(), F2 = L2) : L2 = i4(), L2 && L2.placeable)
                      break;
                } else
                  L2 = i4();
              }, c3 = t3.textAnchorOffsetStartIndex, u3 = t3.textAnchorOffsetEndIndex;
              if (u3 === c3) {
                const a3 = (e2, i4) => {
                  const a4 = this.collisionIndex.placeCollisionBox(e2, x2, d2, l2, h2, I2, T2, r2, f2.predicate, z2);
                  return a4 && a4.placeable && (this.markUsedOrientation(s2, i4, t3), this.placedOrientations[t3.crossTileID] = i4), a4;
                };
                o3(() => a3(q2, e.ah.horizontal), () => {
                  const i4 = p3.verticalTextBox;
                  return s2.allowVerticalPlacement && t3.numVerticalGlyphVertices > 0 && i4 ? a3(i4, e.ah.vertical) : { box: null, offscreen: null };
                }), i3(L2 && L2.placeable);
              } else {
                let _3 = e.aq[(D3 = (P3 = this.prevPlacement) === null || P3 === undefined ? undefined : P3.variableOffsets[t3.crossTileID]) === null || D3 === undefined ? undefined : D3.anchor];
                const m3 = (i4, o4, p4) => {
                  const m4 = i4.x2 - i4.x1, g4 = i4.y2 - i4.y1, v3 = t3.textBoxScale, y3 = E2 && b2 === "never" ? o4 : null;
                  let w4 = null, P4 = x2 === "never" ? 1 : 2, C3 = "never";
                  _3 && P4++;
                  for (let e2 = 0;e2 < P4; e2++) {
                    for (let e3 = c3;e3 < u3; e3++) {
                      const a3 = s2.textAnchorOffsets.get(e3);
                      if (_3 && a3.textAnchor !== _3)
                        continue;
                      const o5 = this.attemptAnchorPlacement(a3, i4, m4, g4, v3, T2, I2, d2, l2, h2, f2, C3, t3, s2, p4, r2, n2, y3, z2);
                      if (o5 && (w4 = o5.placedGlyphBoxes, w4 && w4.placeable))
                        return M2 = true, k2 = o5.shift, w4;
                    }
                    _3 ? _3 = null : C3 = x2;
                  }
                  return a2 && !w4 && (w4 = {
                    box: this.collisionIndex.placeCollisionBox(q2, "always", d2, l2, h2, I2, T2, r2, f2.predicate, z2, new e.P(0, 0)).box,
                    offscreen: false,
                    placeable: false
                  }), w4;
                };
                o3(() => m3(q2, p3.iconBox, e.ah.horizontal), () => {
                  const i4 = p3.verticalTextBox;
                  return s2.allowVerticalPlacement && (!L2 || !L2.placeable) && t3.numVerticalGlyphVertices > 0 && i4 ? m3(i4, p3.verticalIconBox, e.ah.vertical) : { box: null, occluded: true, offscreen: null };
                }), L2 && (M2 = L2.placeable, R2 = L2.offscreen);
                const g3 = i3(L2 && L2.placeable);
                if (!M2 && this.prevPlacement) {
                  const e2 = this.prevPlacement.variableOffsets[t3.crossTileID];
                  e2 && (this.variableOffsets[t3.crossTileID] = e2, this.markUsedJustification(s2, e2.anchor, t3, g3));
                }
              }
            }
            if (B2 = L2, M2 = B2 && B2.placeable, R2 = B2 && B2.offscreen, t3.useRuntimeCollisionCircles) {
              const i3 = s2.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex), n3 = e.ai(s2.textSizeData, m2, i3), d3 = o2.get("text-padding");
              O2 = this.collisionIndex.placeCollisionCircles(x2, i3, s2.lineVertexArray, s2.glyphOffsetArray, n3, l2, h2, c2, u2, a2, I2, f2.predicate, t3.collisionCircleDiameter, d3, r2, z2), O2.circles.length && O2.collisionDetected && !a2 && e.w("Collisions detected, but collision boxes are not shown"), M2 = y2 || O2.circles.length > 0 && !O2.collisionDetected, R2 = R2 && O2.offscreen;
            }
            if (p3.iconFeatureIndex && (Z2 = p3.iconFeatureIndex), p3.iconBox) {
              const t4 = (t5) => this.collisionIndex.placeCollisionBox(t5, b2, d2, l2, h2, I2, T2, n2, f2.predicate, z2, E2 && k2 ? k2 : undefined);
              F2 && F2.placeable && p3.verticalIconBox ? (N2 = t4(p3.verticalIconBox), A2 = N2.placeable) : (N2 = t4(p3.iconBox), A2 = N2.placeable), R2 = R2 && N2.offscreen;
            }
            const V2 = g2 || t3.numHorizontalGlyphVertices === 0 && t3.numVerticalGlyphVertices === 0, G2 = v2 || t3.numIconVertices === 0;
            V2 || G2 ? G2 ? V2 || (A2 = A2 && M2) : M2 = A2 && M2 : A2 = M2 = A2 && M2;
            const H2 = A2 && N2.placeable;
            if (M2 && B2.placeable && this.collisionIndex.insertCollisionBox(B2.box, x2, o2.get("text-ignore-placement"), s2.bucketInstanceId, F2 && F2.placeable && j2 ? j2 : U2, f2.ID), H2 && this.collisionIndex.insertCollisionBox(N2.box, b2, o2.get("icon-ignore-placement"), s2.bucketInstanceId, Z2, f2.ID), O2 && M2 && this.collisionIndex.insertCollisionCircles(O2.circles, x2, o2.get("text-ignore-placement"), s2.bucketInstanceId, U2, f2.ID), a2 && this.storeCollisionData(s2.bucketInstanceId, w3, p3, B2, N2, O2), t3.crossTileID === 0)
              throw new Error("symbolInstance.crossTileID can't be 0");
            if (s2.bucketInstanceId === 0)
              throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[t3.crossTileID] = new Ut(M2 || C2, A2 || S2, R2 || s2.justReloaded), i2[t3.crossTileID] = true;
          };
          if (P2) {
            if (t2.symbolInstanceStart !== 0)
              throw new Error("bucket.bucketInstanceId should be 0");
            const e2 = s2.getSortedSymbolIndexes(this.transform.angle);
            for (let t3 = e2.length - 1;t3 >= 0; --t3) {
              const i3 = e2[t3];
              D2(s2.symbolInstances.get(i3), s2.collisionArrays[i3], i3);
            }
          } else
            for (let e2 = t2.symbolInstanceStart;e2 < t2.symbolInstanceEnd; e2++)
              D2(s2.symbolInstances.get(e2), s2.collisionArrays[e2], e2);
          if (a2 && s2.bucketInstanceId in this.collisionCircleArrays) {
            const t3 = this.collisionCircleArrays[s2.bucketInstanceId];
            e.as(t3.invProjMatrix, l2), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
          }
          s2.justReloaded = false;
        }
        storeCollisionData(t2, e2, i2, a2, s2, o2) {
          if (i2.textBox || i2.iconBox) {
            let o3, r2;
            this.collisionBoxArrays.has(t2) ? o3 = this.collisionBoxArrays.get(t2) : (o3 = new Map, this.collisionBoxArrays.set(t2, o3)), o3.has(e2) ? r2 = o3.get(e2) : (r2 = { text: null, icon: null }, o3.set(e2, r2)), i2.textBox && (r2.text = a2.box), i2.iconBox && (r2.icon = s2.box);
          }
          if (o2) {
            let e3 = this.collisionCircleArrays[t2];
            e3 === undefined && (e3 = this.collisionCircleArrays[t2] = new jt);
            for (let t3 = 0;t3 < o2.circles.length; t3 += 4)
              e3.circles.push(o2.circles[t3 + 0]), e3.circles.push(o2.circles[t3 + 1]), e3.circles.push(o2.circles[t3 + 2]), e3.circles.push(o2.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(t2, i2, a2, s2) {
          let o2;
          o2 = s2 === e.ah.vertical ? a2.verticalPlacedTextSymbolIndex : {
            left: a2.leftJustifiedTextSymbolIndex,
            center: a2.centerJustifiedTextSymbolIndex,
            right: a2.rightJustifiedTextSymbolIndex
          }[e.at(i2)];
          const r2 = [
            a2.leftJustifiedTextSymbolIndex,
            a2.centerJustifiedTextSymbolIndex,
            a2.rightJustifiedTextSymbolIndex,
            a2.verticalPlacedTextSymbolIndex
          ];
          for (const e2 of r2)
            e2 >= 0 && (t2.text.placedSymbolArray.get(e2).crossTileID = o2 >= 0 && e2 !== o2 ? 0 : a2.crossTileID);
        }
        markUsedOrientation(t2, i2, a2) {
          const s2 = i2 === e.ah.horizontal || i2 === e.ah.horizontalOnly ? i2 : 0, o2 = i2 === e.ah.vertical ? i2 : 0, r2 = [
            a2.leftJustifiedTextSymbolIndex,
            a2.centerJustifiedTextSymbolIndex,
            a2.rightJustifiedTextSymbolIndex
          ];
          for (const e2 of r2)
            t2.text.placedSymbolArray.get(e2).placedOrientation = s2;
          a2.verticalPlacedTextSymbolIndex && (t2.text.placedSymbolArray.get(a2.verticalPlacedTextSymbolIndex).placedOrientation = o2);
        }
        commit(t2) {
          this.commitTime = t2, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const e2 = this.prevPlacement;
          let i2 = false;
          this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
          const a2 = e2 ? e2.symbolFadeChange(t2) : 1, s2 = e2 ? e2.opacities : {}, o2 = e2 ? e2.variableOffsets : {}, r2 = e2 ? e2.placedOrientations : {};
          for (const t3 in this.placements) {
            const e3 = this.placements[t3], o3 = s2[t3];
            o3 ? (this.opacities[t3] = new Nt(o3, a2, e3.text, e3.icon), i2 = i2 || e3.text !== o3.text.placed || e3.icon !== o3.icon.placed) : (this.opacities[t3] = new Nt(null, a2, e3.text, e3.icon, e3.skipFade), i2 = i2 || e3.text || e3.icon);
          }
          for (const t3 in s2) {
            const e3 = s2[t3];
            if (!this.opacities[t3]) {
              const s3 = new Nt(e3, a2, false, false);
              s3.isHidden() || (this.opacities[t3] = s3, i2 = i2 || e3.text.placed || e3.icon.placed);
            }
          }
          for (const t3 in o2)
            this.variableOffsets[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.variableOffsets[t3] = o2[t3]);
          for (const t3 in r2)
            this.placedOrientations[t3] || !this.opacities[t3] || this.opacities[t3].isHidden() || (this.placedOrientations[t3] = r2[t3]);
          if (e2 && e2.lastPlacementChangeTime === undefined)
            throw new Error("Last placement time for previous placement is not defined");
          i2 ? this.lastPlacementChangeTime = t2 : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t2);
        }
        updateLayerOpacities(t2, e2) {
          const i2 = {};
          for (const a2 of e2) {
            const e3 = a2.getBucket(t2);
            e3 && a2.latestFeatureIndex && t2.id === e3.layerIds[0] && this.updateBucketOpacities(e3, a2.tileID, i2, a2.collisionBoxArray);
          }
        }
        updateBucketOpacities(t2, i2, a2, s2) {
          t2.hasTextData() && (t2.text.opacityVertexArray.clear(), t2.text.hasVisibleVertices = false), t2.hasIconData() && (t2.icon.opacityVertexArray.clear(), t2.icon.hasVisibleVertices = false), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexArray.clear(), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexArray.clear();
          const o2 = t2.layers[0], r2 = o2.layout, n2 = new Nt(null, 0, false, false, true), l2 = r2.get("text-allow-overlap"), h2 = r2.get("icon-allow-overlap"), c2 = o2._unevaluatedLayout.hasValue("text-variable-anchor") || o2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), u2 = r2.get("text-rotation-alignment") === "map", d2 = r2.get("text-pitch-alignment") === "map", _2 = r2.get("icon-text-fit") !== "none", p2 = new Nt(null, 0, l2 && (h2 || !t2.hasIconData() || r2.get("icon-optional")), h2 && (l2 || !t2.hasTextData() || r2.get("text-optional")), true);
          !t2.collisionArrays && s2 && (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) && t2.deserializeCollisionBoxes(s2);
          const m2 = (t3, e2, i3) => {
            for (let a3 = 0;a3 < e2 / 4; a3++)
              t3.opacityVertexArray.emplaceBack(i3);
            t3.hasVisibleVertices = t3.hasVisibleVertices || i3 !== ee;
          }, f2 = this.collisionBoxArrays.get(t2.bucketInstanceId);
          for (let i3 = 0;i3 < t2.symbolInstances.length; i3++) {
            const s3 = t2.symbolInstances.get(i3), {
              numHorizontalGlyphVertices: o3,
              numVerticalGlyphVertices: r3,
              crossTileID: l3
            } = s3;
            let h3 = this.opacities[l3];
            a2[l3] ? h3 = n2 : h3 || (h3 = p2, this.opacities[l3] = h3), a2[l3] = true;
            const g2 = s3.numIconVertices > 0, v2 = this.placedOrientations[s3.crossTileID], x2 = v2 === e.ah.vertical, y2 = v2 === e.ah.horizontal || v2 === e.ah.horizontalOnly;
            if (o3 > 0 || r3 > 0) {
              const e2 = te(h3.text);
              m2(t2.text, o3, x2 ? ee : e2), m2(t2.text, r3, y2 ? ee : e2);
              const i4 = h3.text.isHidden();
              [
                s3.rightJustifiedTextSymbolIndex,
                s3.centerJustifiedTextSymbolIndex,
                s3.leftJustifiedTextSymbolIndex
              ].forEach((e3) => {
                e3 >= 0 && (t2.text.placedSymbolArray.get(e3).hidden = i4 || x2 ? 1 : 0);
              }), s3.verticalPlacedTextSymbolIndex >= 0 && (t2.text.placedSymbolArray.get(s3.verticalPlacedTextSymbolIndex).hidden = i4 || y2 ? 1 : 0);
              const a3 = this.variableOffsets[s3.crossTileID];
              a3 && this.markUsedJustification(t2, a3.anchor, s3, v2);
              const n3 = this.placedOrientations[s3.crossTileID];
              n3 && (this.markUsedJustification(t2, "left", s3, n3), this.markUsedOrientation(t2, n3, s3));
            }
            if (g2) {
              const e2 = te(h3.icon), i4 = !(_2 && s3.verticalPlacedIconSymbolIndex && x2);
              s3.placedIconSymbolIndex >= 0 && (m2(t2.icon, s3.numIconVertices, i4 ? e2 : ee), t2.icon.placedSymbolArray.get(s3.placedIconSymbolIndex).hidden = h3.icon.isHidden()), s3.verticalPlacedIconSymbolIndex >= 0 && (m2(t2.icon, s3.numVerticalIconVertices, i4 ? ee : e2), t2.icon.placedSymbolArray.get(s3.verticalPlacedIconSymbolIndex).hidden = h3.icon.isHidden());
            }
            const b2 = f2 && f2.has(i3) ? f2.get(i3) : { text: null, icon: null };
            if (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) {
              const a3 = t2.collisionArrays[i3];
              if (a3) {
                let i4 = new e.P(0, 0);
                if (a3.textBox || a3.verticalTextBox) {
                  let e2 = true;
                  if (c2) {
                    const t3 = this.variableOffsets[l3];
                    t3 ? (i4 = Vt(t3.anchor, t3.width, t3.height, t3.textOffset, t3.textBoxScale), u2 && i4._rotate(d2 ? this.transform.angle : -this.transform.angle)) : e2 = false;
                  }
                  if (a3.textBox || a3.verticalTextBox) {
                    let s4;
                    a3.textBox && (s4 = x2), a3.verticalTextBox && (s4 = y2), Ht(t2.textCollisionBox.collisionVertexArray, h3.text.placed, !e2 || s4, b2.text, i4.x, i4.y);
                  }
                }
                if (a3.iconBox || a3.verticalIconBox) {
                  const e2 = Boolean(!y2 && a3.verticalIconBox);
                  let s4;
                  a3.iconBox && (s4 = e2), a3.verticalIconBox && (s4 = !e2), Ht(t2.iconCollisionBox.collisionVertexArray, h3.icon.placed, s4, b2.icon, _2 ? i4.x : 0, _2 ? i4.y : 0);
                }
              }
            }
          }
          if (t2.sortFeatures(this.transform.angle), this.retainedQueryData[t2.bucketInstanceId] && (this.retainedQueryData[t2.bucketInstanceId].featureSortOrder = t2.featureSortOrder), t2.hasTextData() && t2.text.opacityVertexBuffer && t2.text.opacityVertexBuffer.updateData(t2.text.opacityVertexArray), t2.hasIconData() && t2.icon.opacityVertexBuffer && t2.icon.opacityVertexBuffer.updateData(t2.icon.opacityVertexArray), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexBuffer && t2.iconCollisionBox.collisionVertexBuffer.updateData(t2.iconCollisionBox.collisionVertexArray), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexBuffer && t2.textCollisionBox.collisionVertexBuffer.updateData(t2.textCollisionBox.collisionVertexArray), t2.text.opacityVertexArray.length !== t2.text.layoutVertexArray.length / 4)
            throw new Error(`bucket.text.opacityVertexArray.length (= ${t2.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${t2.text.layoutVertexArray.length}) / 4`);
          if (t2.icon.opacityVertexArray.length !== t2.icon.layoutVertexArray.length / 4)
            throw new Error(`bucket.icon.opacityVertexArray.length (= ${t2.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${t2.icon.layoutVertexArray.length}) / 4`);
          if (t2.bucketInstanceId in this.collisionCircleArrays) {
            const e2 = this.collisionCircleArrays[t2.bucketInstanceId];
            t2.placementInvProjMatrix = e2.invProjMatrix, t2.placementViewportMatrix = e2.viewportMatrix, t2.collisionCircleArray = e2.circles, delete this.collisionCircleArrays[t2.bucketInstanceId];
          }
        }
        symbolFadeChange(t2) {
          return this.fadeDuration === 0 ? 1 : (t2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(t2) {
          return Math.max(0, (this.transform.zoom - t2) / 1.5);
        }
        hasTransitions(t2) {
          return this.stale || t2 - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(t2, e2) {
          const i2 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
          return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i2 > t2;
        }
        setStale() {
          this.stale = true;
        }
      }
      function Ht(t2, e2, i2, a2, s2, o2) {
        a2 && a2.length !== 0 || (a2 = [0, 0, 0, 0]);
        const r2 = a2[0] - Lt, n2 = a2[1] - Lt, l2 = a2[2] - Lt, h2 = a2[3] - Lt;
        t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, o2 || 0, r2, n2), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, o2 || 0, l2, n2), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, o2 || 0, l2, h2), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, s2 || 0, o2 || 0, r2, h2);
      }
      const Wt = Math.pow(2, 25), $t = Math.pow(2, 24), Xt = Math.pow(2, 17), Kt = Math.pow(2, 16), Jt = Math.pow(2, 9), Yt = Math.pow(2, 8), Qt = Math.pow(2, 1);
      function te(t2) {
        if (t2.opacity === 0 && !t2.placed)
          return 0;
        if (t2.opacity === 1 && t2.placed)
          return 4294967295;
        const e2 = t2.placed ? 1 : 0, i2 = Math.floor(127 * t2.opacity);
        return i2 * Wt + e2 * $t + i2 * Xt + e2 * Kt + i2 * Jt + e2 * Yt + i2 * Qt + e2;
      }
      const ee = 0;
      function ie() {
        return {
          isOccluded: (t2, e2, i2) => false,
          getPitchedTextCorrection: (t2, e2, i2) => 1,
          get useSpecialProjectionForSymbols() {
            return false;
          },
          projectTileCoordinates(t2, e2, i2, a2) {
            throw new Error("Not implemented.");
          },
          translatePosition: (t2, e2, i2, a2) => function(t3, e3, i3, a3, s2 = false) {
            if (!i3[0] && !i3[1])
              return [0, 0];
            const o2 = s2 ? a3 === "map" ? t3.angle : 0 : a3 === "viewport" ? -t3.angle : 0;
            if (o2) {
              const t4 = Math.sin(o2), e4 = Math.cos(o2);
              i3 = [i3[0] * e4 - i3[1] * t4, i3[0] * t4 + i3[1] * e4];
            }
            return [s2 ? i3[0] : Bt(e3, i3[0], t3.zoom), s2 ? i3[1] : Bt(e3, i3[1], t3.zoom)];
          }(t2, e2, i2, a2),
          getCircleRadiusCorrection: (t2) => 1
        };
      }

      class ae {
        constructor(t2) {
          this._sortAcrossTiles = t2.layout.get("symbol-z-order") !== "viewport-y" && !t2.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(t2, e2, i2, a2, s2) {
          const o2 = this._bucketParts;
          for (;this._currentTileIndex < t2.length; )
            if (e2.getBucketParts(o2, a2, t2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, s2())
              return true;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o2.sort((t3, e3) => t3.sortKey - e3.sortKey));this._currentPartIndex < o2.length; )
            if (e2.placeLayerBucketPart(o2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, s2())
              return true;
          return false;
        }
      }

      class se {
        constructor(t2, e2, i2, a2, s2, o2, r2, n2) {
          this.placement = new Gt(t2, ie(), e2, o2, r2, n2), this._currentPlacementIndex = i2.length - 1, this._forceFullPlacement = a2, this._showCollisionBoxes = s2, this._done = false;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t2, e2, i2) {
          const a2 = o.now(), s2 = () => !this._forceFullPlacement && o.now() - a2 > 2;
          for (;this._currentPlacementIndex >= 0; ) {
            const a3 = e2[t2[this._currentPlacementIndex]], o2 = this.placement.collisionIndex.transform.zoom;
            if (a3.type === "symbol" && (!a3.minzoom || a3.minzoom <= o2) && (!a3.maxzoom || a3.maxzoom > o2)) {
              if (this._inProgressLayer || (this._inProgressLayer = new ae(a3)), this._inProgressLayer.continuePlacement(i2[a3.source], this.placement, this._showCollisionBoxes, a3, s2))
                return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = true;
        }
        commit(t2) {
          return this.placement.commit(t2), this.placement;
        }
      }
      const oe = 512 / e.X / 2;

      class re {
        constructor(t2, i2, a2) {
          this.tileID = t2, this.bucketInstanceId = a2, this._symbolsByKey = {};
          const s2 = new Map;
          for (let t3 = 0;t3 < i2.length; t3++) {
            const e2 = i2.get(t3), a3 = e2.key, o2 = s2.get(a3);
            o2 ? o2.push(e2) : s2.set(a3, [e2]);
          }
          for (const [t3, i3] of s2) {
            const a3 = {
              positions: i3.map((t4) => ({
                x: Math.floor(t4.anchorX * oe),
                y: Math.floor(t4.anchorY * oe)
              })),
              crossTileIDs: i3.map((t4) => t4.crossTileID)
            };
            if (a3.positions.length > 128) {
              const t4 = new e.av(a3.positions.length, 16, Uint16Array);
              for (const { x: e2, y: i4 } of a3.positions)
                t4.add(e2, i4);
              t4.finish(), delete a3.positions, a3.index = t4;
            }
            this._symbolsByKey[t3] = a3;
          }
        }
        getScaledCoordinates(t2, i2) {
          const { x: a2, y: s2, z: o2 } = this.tileID.canonical, { x: r2, y: n2, z: l2 } = i2.canonical, h2 = oe / Math.pow(2, l2 - o2), c2 = (n2 * e.X + t2.anchorY) * h2, u2 = s2 * e.X * oe;
          return {
            x: Math.floor((r2 * e.X + t2.anchorX) * h2 - a2 * e.X * oe),
            y: Math.floor(c2 - u2)
          };
        }
        findMatches(t2, e2, i2) {
          const a2 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z);
          for (let s2 = 0;s2 < t2.length; s2++) {
            const o2 = t2.get(s2);
            if (o2.crossTileID)
              continue;
            const r2 = this._symbolsByKey[o2.key];
            if (!r2)
              continue;
            const n2 = this.getScaledCoordinates(o2, e2);
            if (r2.index) {
              const t3 = r2.index.range(n2.x - a2, n2.y - a2, n2.x + a2, n2.y + a2).sort();
              for (const e3 of t3) {
                const t4 = r2.crossTileIDs[e3];
                if (!i2[t4]) {
                  i2[t4] = true, o2.crossTileID = t4;
                  break;
                }
              }
            } else if (r2.positions)
              for (let t3 = 0;t3 < r2.positions.length; t3++) {
                const e3 = r2.positions[t3], s3 = r2.crossTileIDs[t3];
                if (Math.abs(e3.x - n2.x) <= a2 && Math.abs(e3.y - n2.y) <= a2 && !i2[s3]) {
                  i2[s3] = true, o2.crossTileID = s3;
                  break;
                }
              }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map(({ crossTileIDs: t2 }) => t2);
        }
      }

      class ne {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }

      class le {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(t2) {
          const e2 = Math.round((t2 - this.lng) / 360);
          if (e2 !== 0)
            for (const t3 in this.indexes) {
              const i2 = this.indexes[t3], a2 = {};
              for (const t4 in i2) {
                const s2 = i2[t4];
                s2.tileID = s2.tileID.unwrapTo(s2.tileID.wrap + e2), a2[s2.tileID.key] = s2;
              }
              this.indexes[t3] = a2;
            }
          this.lng = t2;
        }
        addBucket(t2, e2, i2) {
          if (this.indexes[t2.overscaledZ] && this.indexes[t2.overscaledZ][t2.key]) {
            if (this.indexes[t2.overscaledZ][t2.key].bucketInstanceId === e2.bucketInstanceId)
              return false;
            this.removeBucketCrossTileIDs(t2.overscaledZ, this.indexes[t2.overscaledZ][t2.key]);
          }
          for (let t3 = 0;t3 < e2.symbolInstances.length; t3++)
            e2.symbolInstances.get(t3).crossTileID = 0;
          this.usedCrossTileIDs[t2.overscaledZ] || (this.usedCrossTileIDs[t2.overscaledZ] = {});
          const a2 = this.usedCrossTileIDs[t2.overscaledZ];
          for (const i3 in this.indexes) {
            const s2 = this.indexes[i3];
            if (Number(i3) > t2.overscaledZ)
              for (const i4 in s2) {
                const o2 = s2[i4];
                o2.tileID.isChildOf(t2) && o2.findMatches(e2.symbolInstances, t2, a2);
              }
            else {
              const o2 = s2[t2.scaledTo(Number(i3)).key];
              o2 && o2.findMatches(e2.symbolInstances, t2, a2);
            }
          }
          for (let t3 = 0;t3 < e2.symbolInstances.length; t3++) {
            const s2 = e2.symbolInstances.get(t3);
            s2.crossTileID || (s2.crossTileID = i2.generate(), a2[s2.crossTileID] = true);
          }
          return this.indexes[t2.overscaledZ] === undefined && (this.indexes[t2.overscaledZ] = {}), this.indexes[t2.overscaledZ][t2.key] = new re(t2, e2.symbolInstances, e2.bucketInstanceId), true;
        }
        removeBucketCrossTileIDs(t2, e2) {
          for (const i2 of e2.getCrossTileIDsLists())
            for (const e3 of i2)
              delete this.usedCrossTileIDs[t2][e3];
        }
        removeStaleBuckets(t2) {
          let e2 = false;
          for (const i2 in this.indexes) {
            const a2 = this.indexes[i2];
            for (const s2 in a2)
              t2[a2[s2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, a2[s2]), delete a2[s2], e2 = true);
          }
          return e2;
        }
      }

      class he {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new ne, this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(t2, e2, i2) {
          let a2 = this.layerIndexes[t2.id];
          a2 === undefined && (a2 = this.layerIndexes[t2.id] = new le);
          let s2 = false;
          const o2 = {};
          a2.handleWrapJump(i2);
          for (const i3 of e2) {
            const e3 = i3.getBucket(t2);
            e3 && t2.id === e3.layerIds[0] && (e3.bucketInstanceId || (e3.bucketInstanceId = ++this.maxBucketInstanceId), a2.addBucket(i3.tileID, e3, this.crossTileIDs) && (s2 = true), o2[e3.bucketInstanceId] = true);
          }
          return a2.removeStaleBuckets(o2) && (s2 = true), s2;
        }
        pruneUnusedLayers(t2) {
          const e2 = {};
          t2.forEach((t3) => {
            e2[t3] = true;
          });
          for (const t3 in this.layerIndexes)
            e2[t3] || delete this.layerIndexes[t3];
        }
      }
      const ce = (t2, i2) => e.t(t2, i2 && i2.filter((t3) => t3.identifier !== "source.canvas")), ue = e.aw();

      class de extends e.E {
        constructor(t2, i2 = {}) {
          super(), this._rtlPluginLoaded = () => {
            for (const t3 in this.sourceCaches) {
              const e2 = this.sourceCaches[t3].getSource().type;
              e2 !== "vector" && e2 !== "geojson" || this.sourceCaches[t3].reload();
            }
          }, this.map = t2, this.dispatcher = new U(N(), t2._getMapId()), this.dispatcher.registerMessageHandler("GG", (t3, e2) => this.getGlyphs(t3, e2)), this.dispatcher.registerMessageHandler("GI", (t3, e2) => this.getImages(t3, e2)), this.imageManager = new T, this.imageManager.setEventedParent(this), this.glyphManager = new C(t2._requestManager, i2.localIdeographFontFamily), this.lineAtlas = new R(256, 512), this.crossTileSymbolIndex = new he, this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new e.ax, this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", e.ay()), nt().on(st, this._rtlPluginLoaded), this.on("data", (t3) => {
            if (t3.dataType !== "source" || t3.sourceDataType !== "metadata")
              return;
            const e2 = this.sourceCaches[t3.sourceId];
            if (!e2)
              return;
            const i3 = e2.getSource();
            if (i3 && i3.vectorLayerIds)
              for (const t4 in this._layers) {
                const e3 = this._layers[t4];
                e3.source === i3.id && this._validateLayer(e3);
              }
          });
        }
        loadURL(t2, i2 = {}, a2) {
          this.fire(new e.k("dataloading", { dataType: "style" })), i2.validate = typeof i2.validate != "boolean" || i2.validate;
          const s2 = this.map._requestManager.transformRequest(t2, "Style");
          this._loadStyleRequest = new AbortController;
          const o2 = this._loadStyleRequest;
          e.h(s2, this._loadStyleRequest).then((t3) => {
            this._loadStyleRequest = null, this._load(t3.data, i2, a2);
          }).catch((t3) => {
            this._loadStyleRequest = null, t3 && !o2.signal.aborted && this.fire(new e.j(t3));
          });
        }
        loadJSON(t2, i2 = {}, a2) {
          this.fire(new e.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController, o.frameAsync(this._frameRequest).then(() => {
            this._frameRequest = null, i2.validate = i2.validate !== false, this._load(t2, i2, a2);
          }).catch(() => {
          });
        }
        loadEmpty() {
          this.fire(new e.k("dataloading", { dataType: "style" })), this._load(ue, { validate: false });
        }
        _load(t2, i2, a2) {
          var s2;
          const o2 = i2.transformStyle ? i2.transformStyle(a2, t2) : t2;
          if (!i2.validate || !ce(this, e.u(o2))) {
            this._loaded = true, this.stylesheet = o2;
            for (const t3 in o2.sources)
              this.addSource(t3, o2.sources[t3], { validate: false });
            o2.sprite ? this._loadSprite(o2.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(o2.glyphs), this._createLayers(), this.light = new D(this.stylesheet.light), this.sky = new A(this.stylesheet.sky), this.map.setTerrain((s2 = this.stylesheet.terrain) !== null && s2 !== undefined ? s2 : null), this.fire(new e.k("data", { dataType: "style" })), this.fire(new e.k("style.load"));
          }
        }
        _createLayers() {
          const t2 = e.az(this.stylesheet.layers);
          this.dispatcher.broadcast("SL", t2), this._order = t2.map((t3) => t3.id), this._layers = {}, this._serializedLayers = null;
          for (const i2 of t2) {
            const t3 = e.aA(i2);
            t3.setEventedParent(this, { layer: { id: i2.id } }), this._layers[i2.id] = t3;
          }
        }
        _loadSprite(t2, i2 = false, a2 = undefined) {
          let s2;
          this.imageManager.setLoaded(false), this._spriteRequest = new AbortController, function(t3, i3, a3, s3) {
            return e._(this, undefined, undefined, function* () {
              const r2 = x(t3), n2 = a3 > 1 ? "@2x" : "", l2 = {}, h2 = {};
              for (const { id: t4, url: a4 } of r2) {
                const o2 = i3.transformRequest(y(a4, n2, ".json"), "SpriteJSON");
                l2[t4] = e.h(o2, s3);
                const r3 = i3.transformRequest(y(a4, n2, ".png"), "SpriteImage");
                h2[t4] = _.getImage(r3, s3);
              }
              return yield Promise.all([...Object.values(l2), ...Object.values(h2)]), function(t4, i4) {
                return e._(this, undefined, undefined, function* () {
                  const e2 = {};
                  for (const a4 in t4) {
                    e2[a4] = {};
                    const s4 = o.getImageCanvasContext((yield i4[a4]).data), r3 = (yield t4[a4]).data;
                    for (const t5 in r3) {
                      const {
                        width: i5,
                        height: o2,
                        x: n3,
                        y: l3,
                        sdf: h3,
                        pixelRatio: c2,
                        stretchX: u2,
                        stretchY: d2,
                        content: _2,
                        textFitWidth: p2,
                        textFitHeight: m2
                      } = r3[t5];
                      e2[a4][t5] = {
                        data: null,
                        pixelRatio: c2,
                        sdf: h3,
                        stretchX: u2,
                        stretchY: d2,
                        content: _2,
                        textFitWidth: p2,
                        textFitHeight: m2,
                        spriteData: { width: i5, height: o2, x: n3, y: l3, context: s4 }
                      };
                    }
                  }
                  return e2;
                });
              }(l2, h2);
            });
          }(t2, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((t3) => {
            if (this._spriteRequest = null, t3)
              for (const e2 in t3) {
                this._spritesImagesIds[e2] = [];
                const a3 = this._spritesImagesIds[e2] ? this._spritesImagesIds[e2].filter((e3) => !(e3 in t3)) : [];
                for (const t4 of a3)
                  this.imageManager.removeImage(t4), this._changedImages[t4] = true;
                for (const a4 in t3[e2]) {
                  const s3 = e2 === "default" ? a4 : `${e2}:${a4}`;
                  this._spritesImagesIds[e2].push(s3), s3 in this.imageManager.images ? this.imageManager.updateImage(s3, t3[e2][a4], false) : this.imageManager.addImage(s3, t3[e2][a4]), i2 && (this._changedImages[s3] = true);
                }
              }
          }).catch((t3) => {
            this._spriteRequest = null, s2 = t3, this.fire(new e.j(s2));
          }).finally(() => {
            this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i2 && (this._changed = true), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" })), a2 && a2(s2);
          });
        }
        _unloadSprite() {
          for (const t2 of Object.values(this._spritesImagesIds).flat())
            this.imageManager.removeImage(t2), this._changedImages[t2] = true;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" }));
        }
        _validateLayer(t2) {
          const i2 = this.sourceCaches[t2.source];
          if (!i2)
            return;
          const a2 = t2.sourceLayer;
          if (!a2)
            return;
          const s2 = i2.getSource();
          (s2.type === "geojson" || s2.vectorLayerIds && s2.vectorLayerIds.indexOf(a2) === -1) && this.fire(new e.j(new Error(`Source layer "${a2}" does not exist on source "${s2.id}" as specified by style layer "${t2.id}".`)));
        }
        loaded() {
          if (!this._loaded)
            return false;
          if (Object.keys(this._updatedSources).length)
            return false;
          for (const t2 in this.sourceCaches)
            if (!this.sourceCaches[t2].loaded())
              return false;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(t2, i2 = false) {
          const a2 = this._serializedAllLayers();
          if (!t2 || t2.length === 0)
            return Object.values(i2 ? e.aB(a2) : a2);
          const s2 = [];
          for (const o2 of t2)
            if (a2[o2]) {
              const t3 = i2 ? e.aB(a2[o2]) : a2[o2];
              s2.push(t3);
            }
          return s2;
        }
        _serializedAllLayers() {
          let t2 = this._serializedLayers;
          if (t2)
            return t2;
          t2 = this._serializedLayers = {};
          const e2 = Object.keys(this._layers);
          for (const i2 of e2) {
            const e3 = this._layers[i2];
            e3.type !== "custom" && (t2[i2] = e3.serialize());
          }
          return t2;
        }
        hasTransitions() {
          if (this.light && this.light.hasTransition())
            return true;
          if (this.sky && this.sky.hasTransition())
            return true;
          for (const t2 in this.sourceCaches)
            if (this.sourceCaches[t2].hasTransition())
              return true;
          for (const t2 in this._layers)
            if (this._layers[t2].hasTransition())
              return true;
          return false;
        }
        _checkLoaded() {
          if (!this._loaded)
            throw new Error("Style is not done loading.");
        }
        update(t2) {
          if (!this._loaded)
            return;
          const i2 = this._changed;
          if (i2) {
            const e2 = Object.keys(this._updatedLayers), i3 = Object.keys(this._removedLayers);
            (e2.length || i3.length) && this._updateWorkerLayers(e2, i3);
            for (const t3 in this._updatedSources) {
              const e3 = this._updatedSources[t3];
              if (e3 === "reload")
                this._reloadSource(t3);
              else {
                if (e3 !== "clear")
                  throw new Error(`Invalid action ${e3}`);
                this._clearSource(t3);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const e3 in this._updatedPaintProps)
              this._layers[e3].updateTransitions(t2);
            this.light.updateTransitions(t2), this.sky.updateTransitions(t2), this._resetUpdates();
          }
          const a2 = {};
          for (const t3 in this.sourceCaches) {
            const e2 = this.sourceCaches[t3];
            a2[t3] = e2.used, e2.used = false;
          }
          for (const e2 of this._order) {
            const i3 = this._layers[e2];
            i3.recalculate(t2, this._availableImages), !i3.isHidden(t2.zoom) && i3.source && (this.sourceCaches[i3.source].used = true);
          }
          for (const t3 in a2) {
            const i3 = this.sourceCaches[t3];
            !!a2[t3] != !!i3.used && i3.fire(new e.k("data", {
              sourceDataType: "visibility",
              dataType: "source",
              sourceId: t3
            }));
          }
          this.light.recalculate(t2), this.sky.recalculate(t2), this.z = t2.zoom, i2 && this.fire(new e.k("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const t2 = Object.keys(this._changedImages);
          if (t2.length) {
            for (const e2 in this.sourceCaches)
              this.sourceCaches[e2].reloadTilesForDependencies(["icons", "patterns"], t2);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const t2 in this.sourceCaches)
              this.sourceCaches[t2].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = false;
          }
        }
        _updateWorkerLayers(t2, e2) {
          this.dispatcher.broadcast("UL", {
            layers: this._serializeByIds(t2, false),
            removedIds: e2
          });
        }
        _resetUpdates() {
          this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
        }
        setState(t2, i2 = {}) {
          var a2;
          this._checkLoaded();
          const s2 = this.serialize();
          if (t2 = i2.transformStyle ? i2.transformStyle(s2, t2) : t2, ((a2 = i2.validate) === null || a2 === undefined || a2) && ce(this, e.u(t2)))
            return false;
          (t2 = e.aB(t2)).layers = e.az(t2.layers);
          const o2 = e.aC(s2, t2), r2 = this._getOperationsToPerform(o2);
          if (r2.unimplemented.length > 0)
            throw new Error(`Unimplemented: ${r2.unimplemented.join(", ")}.`);
          if (r2.operations.length === 0)
            return false;
          for (const t3 of r2.operations)
            t3();
          return this.stylesheet = t2, this._serializedLayers = null, true;
        }
        _getOperationsToPerform(t2) {
          const e2 = [], i2 = [];
          for (const a2 of t2)
            switch (a2.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
                continue;
              case "addLayer":
                e2.push(() => this.addLayer.apply(this, a2.args));
                break;
              case "removeLayer":
                e2.push(() => this.removeLayer.apply(this, a2.args));
                break;
              case "setPaintProperty":
                e2.push(() => this.setPaintProperty.apply(this, a2.args));
                break;
              case "setLayoutProperty":
                e2.push(() => this.setLayoutProperty.apply(this, a2.args));
                break;
              case "setFilter":
                e2.push(() => this.setFilter.apply(this, a2.args));
                break;
              case "addSource":
                e2.push(() => this.addSource.apply(this, a2.args));
                break;
              case "removeSource":
                e2.push(() => this.removeSource.apply(this, a2.args));
                break;
              case "setLayerZoomRange":
                e2.push(() => this.setLayerZoomRange.apply(this, a2.args));
                break;
              case "setLight":
                e2.push(() => this.setLight.apply(this, a2.args));
                break;
              case "setGeoJSONSourceData":
                e2.push(() => this.setGeoJSONSourceData.apply(this, a2.args));
                break;
              case "setGlyphs":
                e2.push(() => this.setGlyphs.apply(this, a2.args));
                break;
              case "setSprite":
                e2.push(() => this.setSprite.apply(this, a2.args));
                break;
              case "setSky":
                e2.push(() => this.setSky.apply(this, a2.args));
                break;
              case "setTerrain":
                e2.push(() => this.map.setTerrain.apply(this, a2.args));
                break;
              case "setTransition":
                e2.push(() => {
                });
                break;
              default:
                i2.push(a2.command);
            }
          return { operations: e2, unimplemented: i2 };
        }
        addImage(t2, i2) {
          if (this.getImage(t2))
            return this.fire(new e.j(new Error(`An image named "${t2}" already exists.`)));
          this.imageManager.addImage(t2, i2), this._afterImageUpdated(t2);
        }
        updateImage(t2, e2) {
          this.imageManager.updateImage(t2, e2);
        }
        getImage(t2) {
          return this.imageManager.getImage(t2);
        }
        removeImage(t2) {
          if (!this.getImage(t2))
            return this.fire(new e.j(new Error(`An image named "${t2}" does not exist.`)));
          this.imageManager.removeImage(t2), this._afterImageUpdated(t2);
        }
        _afterImageUpdated(t2) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[t2] = true, this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(t2, i2, a2 = {}) {
          if (this._checkLoaded(), this.sourceCaches[t2] !== undefined)
            throw new Error(`Source "${t2}" already exists.`);
          if (!i2.type)
            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(e.u.source, `sources.${t2}`, i2, null, a2))
            return;
          this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
          const s2 = this.sourceCaches[t2] = new ut(t2, i2, this.dispatcher);
          s2.style = this, s2.setEventedParent(this, () => ({
            isSourceLoaded: s2.loaded(),
            source: s2.serialize(),
            sourceId: t2
          })), s2.onAdd(this.map), this._changed = true;
        }
        removeSource(t2) {
          if (this._checkLoaded(), this.sourceCaches[t2] === undefined)
            throw new Error("There is no source with this ID");
          for (const i3 in this._layers)
            if (this._layers[i3].source === t2)
              return this.fire(new e.j(new Error(`Source "${t2}" cannot be removed while layer "${i3}" is using it.`)));
          const i2 = this.sourceCaches[t2];
          delete this.sourceCaches[t2], delete this._updatedSources[t2], i2.fire(new e.k("data", {
            sourceDataType: "metadata",
            dataType: "source",
            sourceId: t2
          })), i2.setEventedParent(null), i2.onRemove(this.map), this._changed = true;
        }
        setGeoJSONSourceData(t2, e2) {
          if (this._checkLoaded(), this.sourceCaches[t2] === undefined)
            throw new Error(`There is no source with this ID=${t2}`);
          const i2 = this.sourceCaches[t2].getSource();
          if (i2.type !== "geojson")
            throw new Error(`geojsonSource.type is ${i2.type}, which is !== 'geojson`);
          i2.setData(e2), this._changed = true;
        }
        getSource(t2) {
          return this.sourceCaches[t2] && this.sourceCaches[t2].getSource();
        }
        addLayer(t2, i2, a2 = {}) {
          this._checkLoaded();
          const s2 = t2.id;
          if (this.getLayer(s2))
            return void this.fire(new e.j(new Error(`Layer "${s2}" already exists on this map.`)));
          let o2;
          if (t2.type === "custom") {
            if (ce(this, e.aD(t2)))
              return;
            o2 = e.aA(t2);
          } else {
            if ("source" in t2 && typeof t2.source == "object" && (this.addSource(s2, t2.source), t2 = e.aB(t2), t2 = e.e(t2, { source: s2 })), this._validate(e.u.layer, `layers.${s2}`, t2, { arrayIndex: -1 }, a2))
              return;
            o2 = e.aA(t2), this._validateLayer(o2), o2.setEventedParent(this, { layer: { id: s2 } });
          }
          const r2 = i2 ? this._order.indexOf(i2) : this._order.length;
          if (i2 && r2 === -1)
            this.fire(new e.j(new Error(`Cannot add layer "${s2}" before non-existing layer "${i2}".`)));
          else {
            if (this._order.splice(r2, 0, s2), this._layerOrderChanged = true, this._layers[s2] = o2, this._removedLayers[s2] && o2.source && o2.type !== "custom") {
              const t3 = this._removedLayers[s2];
              delete this._removedLayers[s2], t3.type !== o2.type ? this._updatedSources[o2.source] = "clear" : (this._updatedSources[o2.source] = "reload", this.sourceCaches[o2.source].pause());
            }
            this._updateLayer(o2), o2.onAdd && o2.onAdd(this.map);
          }
        }
        moveLayer(t2, i2) {
          if (this._checkLoaded(), this._changed = true, !this._layers[t2])
            return void this.fire(new e.j(new Error(`The layer '${t2}' does not exist in the map's style and cannot be moved.`)));
          if (t2 === i2)
            return;
          const a2 = this._order.indexOf(t2);
          this._order.splice(a2, 1);
          const s2 = i2 ? this._order.indexOf(i2) : this._order.length;
          i2 && s2 === -1 ? this.fire(new e.j(new Error(`Cannot move layer "${t2}" before non-existing layer "${i2}".`))) : (this._order.splice(s2, 0, t2), this._layerOrderChanged = true);
        }
        removeLayer(t2) {
          this._checkLoaded();
          const i2 = this._layers[t2];
          if (!i2)
            return void this.fire(new e.j(new Error(`Cannot remove non-existing layer "${t2}".`)));
          i2.setEventedParent(null);
          const a2 = this._order.indexOf(t2);
          this._order.splice(a2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[t2] = i2, delete this._layers[t2], this._serializedLayers && delete this._serializedLayers[t2], delete this._updatedLayers[t2], delete this._updatedPaintProps[t2], i2.onRemove && i2.onRemove(this.map);
        }
        getLayer(t2) {
          return this._layers[t2];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(t2) {
          return t2 in this._layers;
        }
        setLayerZoomRange(t2, i2, a2) {
          this._checkLoaded();
          const s2 = this.getLayer(t2);
          s2 ? s2.minzoom === i2 && s2.maxzoom === a2 || (i2 != null && (s2.minzoom = i2), a2 != null && (s2.maxzoom = a2), this._updateLayer(s2)) : this.fire(new e.j(new Error(`Cannot set the zoom range of non-existing layer "${t2}".`)));
        }
        setFilter(t2, i2, a2 = {}) {
          this._checkLoaded();
          const s2 = this.getLayer(t2);
          if (s2) {
            if (!e.aE(s2.filter, i2))
              return i2 == null ? (s2.filter = undefined, void this._updateLayer(s2)) : void (this._validate(e.u.filter, `layers.${s2.id}.filter`, i2, null, a2) || (s2.filter = e.aB(i2), this._updateLayer(s2)));
          } else
            this.fire(new e.j(new Error(`Cannot filter non-existing layer "${t2}".`)));
        }
        getFilter(t2) {
          return e.aB(this.getLayer(t2).filter);
        }
        setLayoutProperty(t2, i2, a2, s2 = {}) {
          this._checkLoaded();
          const o2 = this.getLayer(t2);
          o2 ? e.aE(o2.getLayoutProperty(i2), a2) || (o2.setLayoutProperty(i2, a2, s2), this._updateLayer(o2)) : this.fire(new e.j(new Error(`Cannot style non-existing layer "${t2}".`)));
        }
        getLayoutProperty(t2, i2) {
          const a2 = this.getLayer(t2);
          if (a2)
            return a2.getLayoutProperty(i2);
          this.fire(new e.j(new Error(`Cannot get style of non-existing layer "${t2}".`)));
        }
        setPaintProperty(t2, i2, a2, s2 = {}) {
          this._checkLoaded();
          const o2 = this.getLayer(t2);
          o2 ? e.aE(o2.getPaintProperty(i2), a2) || (o2.setPaintProperty(i2, a2, s2) && this._updateLayer(o2), this._changed = true, this._updatedPaintProps[t2] = true, this._serializedLayers = null) : this.fire(new e.j(new Error(`Cannot style non-existing layer "${t2}".`)));
        }
        getPaintProperty(t2, e2) {
          return this.getLayer(t2).getPaintProperty(e2);
        }
        setFeatureState(t2, i2) {
          this._checkLoaded();
          const { source: a2, sourceLayer: s2 } = t2, o2 = this.sourceCaches[a2];
          if (o2 === undefined)
            return void this.fire(new e.j(new Error(`The source '${a2}' does not exist in the map's style.`)));
          const r2 = o2.getSource().type;
          r2 === "geojson" && s2 ? this.fire(new e.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : r2 !== "vector" || s2 ? (t2.id === undefined && this.fire(new e.j(new Error("The feature id parameter must be provided."))), o2.setFeatureState(s2, t2.id, i2)) : this.fire(new e.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(t2, i2) {
          this._checkLoaded();
          const a2 = t2.source, s2 = this.sourceCaches[a2];
          if (s2 === undefined)
            return void this.fire(new e.j(new Error(`The source '${a2}' does not exist in the map's style.`)));
          const o2 = s2.getSource().type, r2 = o2 === "vector" ? t2.sourceLayer : undefined;
          o2 !== "vector" || r2 ? i2 && typeof t2.id != "string" && typeof t2.id != "number" ? this.fire(new e.j(new Error("A feature id is required to remove its specific state property."))) : s2.removeFeatureState(r2, t2.id, i2) : this.fire(new e.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(t2) {
          this._checkLoaded();
          const { source: i2, sourceLayer: a2 } = t2, s2 = this.sourceCaches[i2];
          if (s2 !== undefined)
            return s2.getSource().type !== "vector" || a2 ? (t2.id === undefined && this.fire(new e.j(new Error("The feature id parameter must be provided."))), s2.getFeatureState(a2, t2.id)) : void this.fire(new e.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new e.j(new Error(`The source '${i2}' does not exist in the map's style.`)));
        }
        getTransition() {
          return e.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded)
            return;
          const t2 = e.aF(this.sourceCaches, (t3) => t3.serialize()), i2 = this._serializeByIds(this._order, true), a2 = this.map.getTerrain() || undefined, s2 = this.stylesheet;
          return e.aG({
            version: s2.version,
            name: s2.name,
            metadata: s2.metadata,
            light: s2.light,
            sky: s2.sky,
            center: s2.center,
            zoom: s2.zoom,
            bearing: s2.bearing,
            pitch: s2.pitch,
            sprite: s2.sprite,
            glyphs: s2.glyphs,
            transition: s2.transition,
            sources: t2,
            layers: i2,
            terrain: a2
          }, (t3) => t3 !== undefined);
        }
        _updateLayer(t2) {
          this._updatedLayers[t2.id] = true, t2.source && !this._updatedSources[t2.source] && this.sourceCaches[t2.source].getSource().type !== "raster" && (this._updatedSources[t2.source] = "reload", this.sourceCaches[t2.source].pause()), this._serializedLayers = null, this._changed = true;
        }
        _flattenAndSortRenderedFeatures(t2) {
          const e2 = (t3) => this._layers[t3].type === "fill-extrusion", i2 = {}, a2 = [];
          for (let s3 = this._order.length - 1;s3 >= 0; s3--) {
            const o2 = this._order[s3];
            if (e2(o2)) {
              i2[o2] = s3;
              for (const e3 of t2) {
                const t3 = e3[o2];
                if (t3)
                  for (const e4 of t3)
                    a2.push(e4);
              }
            }
          }
          a2.sort((t3, e3) => e3.intersectionZ - t3.intersectionZ);
          const s2 = [];
          for (let o2 = this._order.length - 1;o2 >= 0; o2--) {
            const r2 = this._order[o2];
            if (e2(r2))
              for (let t3 = a2.length - 1;t3 >= 0; t3--) {
                const e3 = a2[t3].feature;
                if (i2[e3.layer.id] < o2)
                  break;
                s2.push(e3), a2.pop();
              }
            else
              for (const e3 of t2) {
                const t3 = e3[r2];
                if (t3)
                  for (const e4 of t3)
                    s2.push(e4.feature);
              }
          }
          return s2;
        }
        queryRenderedFeatures(t2, i2, a2) {
          i2 && i2.filter && this._validate(e.u.filter, "queryRenderedFeatures.filter", i2.filter, null, i2);
          const s2 = {};
          if (i2 && i2.layers) {
            if (!Array.isArray(i2.layers))
              return this.fire(new e.j(new Error("parameters.layers must be an Array."))), [];
            for (const t3 of i2.layers) {
              const i3 = this._layers[t3];
              if (!i3)
                return this.fire(new e.j(new Error(`The layer '${t3}' does not exist in the map's style and cannot be queried for features.`))), [];
              s2[i3.source] = true;
            }
          }
          const o2 = [];
          i2.availableImages = this._availableImages;
          const r2 = this._serializedAllLayers();
          for (const e2 in this.sourceCaches)
            i2.layers && !s2[e2] || o2.push(q(this.sourceCaches[e2], this._layers, r2, t2, i2, a2));
          return this.placement && o2.push(function(t3, e2, i3, a3, s3, o3, r3) {
            const n2 = {}, l2 = o3.queryRenderedSymbols(a3), h2 = [];
            for (const t4 of Object.keys(l2).map(Number))
              h2.push(r3[t4]);
            h2.sort(V);
            for (const i4 of h2) {
              const a4 = i4.featureIndex.lookupSymbolFeatures(l2[i4.bucketInstanceId], e2, i4.bucketIndex, i4.sourceLayerIndex, s3.filter, s3.layers, s3.availableImages, t3);
              for (const t4 in a4) {
                const e3 = n2[t4] = n2[t4] || [], s4 = a4[t4];
                s4.sort((t5, e4) => {
                  const a5 = i4.featureSortOrder;
                  if (a5) {
                    const i5 = a5.indexOf(t5.featureIndex);
                    return a5.indexOf(e4.featureIndex) - i5;
                  }
                  return e4.featureIndex - t5.featureIndex;
                });
                for (const t5 of s4)
                  e3.push(t5);
              }
            }
            for (const e3 in n2)
              n2[e3].forEach((a4) => {
                const s4 = a4.feature, o4 = i3[t3[e3].source].getFeatureState(s4.layer["source-layer"], s4.id);
                s4.source = s4.layer.source, s4.layer["source-layer"] && (s4.sourceLayer = s4.layer["source-layer"]), s4.state = o4;
              });
            return n2;
          }(this._layers, r2, this.sourceCaches, t2, i2, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o2);
        }
        querySourceFeatures(t2, i2) {
          i2 && i2.filter && this._validate(e.u.filter, "querySourceFeatures.filter", i2.filter, null, i2);
          const a2 = this.sourceCaches[t2];
          return a2 ? function(t3, e2) {
            const i3 = t3.getRenderableIds().map((e3) => t3.getTileByID(e3)), a3 = [], s2 = {};
            for (let t4 = 0;t4 < i3.length; t4++) {
              const o2 = i3[t4], r2 = o2.tileID.canonical.key;
              s2[r2] || (s2[r2] = true, o2.querySourceFeatures(a3, e2));
            }
            return a3;
          }(a2, i2) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(t2, i2 = {}) {
          this._checkLoaded();
          const a2 = this.light.getLight();
          let s2 = false;
          for (const i3 in t2)
            if (!e.aE(t2[i3], a2[i3])) {
              s2 = true;
              break;
            }
          if (!s2)
            return;
          const r2 = {
            now: o.now(),
            transition: e.e({ duration: 300, delay: 0 }, this.stylesheet.transition)
          };
          this.light.setLight(t2, i2), this.light.updateTransitions(r2);
        }
        getSky() {
          var t2;
          return (t2 = this.stylesheet) === null || t2 === undefined ? undefined : t2.sky;
        }
        setSky(t2, i2 = {}) {
          const a2 = this.getSky();
          let s2 = false;
          if (!t2 && !a2)
            return;
          if (t2 && !a2)
            s2 = true;
          else if (!t2 && a2)
            s2 = true;
          else
            for (const i3 in t2)
              if (!e.aE(t2[i3], a2[i3])) {
                s2 = true;
                break;
              }
          if (!s2)
            return;
          const r2 = {
            now: o.now(),
            transition: e.e({ duration: 300, delay: 0 }, this.stylesheet.transition)
          };
          this.stylesheet.sky = t2, this.sky.setSky(t2, i2), this.sky.updateTransitions(r2);
        }
        _validate(t2, i2, a2, s2, o2 = {}) {
          return (!o2 || o2.validate !== false) && ce(this, t2.call(e.u, e.e({ key: i2, style: this.serialize(), value: a2, styleSpec: e.v }, s2)));
        }
        _remove(t2 = true) {
          this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), nt().off(st, this._rtlPluginLoaded);
          for (const t3 in this._layers)
            this._layers[t3].setEventedParent(null);
          for (const t3 in this.sourceCaches) {
            const e2 = this.sourceCaches[t3];
            e2.setEventedParent(null), e2.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), t2 && this.dispatcher.broadcast("RM", undefined), this.dispatcher.remove(t2);
        }
        _clearSource(t2) {
          this.sourceCaches[t2].clearTiles();
        }
        _reloadSource(t2) {
          this.sourceCaches[t2].resume(), this.sourceCaches[t2].reload();
        }
        _updateSources(t2) {
          for (const e2 in this.sourceCaches)
            this.sourceCaches[e2].update(t2, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const t2 in this.sourceCaches)
            this._reloadSource(t2);
        }
        _updatePlacement(t2, e2, i2, a2, s2 = false) {
          let r2 = false, n2 = false;
          const l2 = {};
          for (const e3 of this._order) {
            const i3 = this._layers[e3];
            if (i3.type !== "symbol")
              continue;
            if (!l2[i3.source]) {
              const t3 = this.sourceCaches[i3.source];
              l2[i3.source] = t3.getRenderableIds(true).map((e4) => t3.getTileByID(e4)).sort((t4, e4) => e4.tileID.overscaledZ - t4.tileID.overscaledZ || (t4.tileID.isLessThan(e4.tileID) ? -1 : 1));
            }
            const a3 = this.crossTileSymbolIndex.addLayer(i3, l2[i3.source], t2.center.lng);
            r2 = r2 || a3;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((s2 = s2 || this._layerOrderChanged || i2 === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(o.now(), t2.zoom)) && (this.pauseablePlacement = new se(t2, this.map.terrain, this._order, s2, e2, i2, a2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(o.now()), n2 = true), r2 && this.pauseablePlacement.placement.setStale()), n2 || r2)
            for (const t3 of this._order) {
              const e3 = this._layers[t3];
              e3.type === "symbol" && this.placement.updateLayerOpacities(e3, l2[e3.source]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(o.now());
        }
        _releaseSymbolFadeTiles() {
          for (const t2 in this.sourceCaches)
            this.sourceCaches[t2].releaseSymbolFadeTiles();
        }
        getImages(t2, i2) {
          return e._(this, undefined, undefined, function* () {
            const t3 = yield this.imageManager.getImages(i2.icons);
            this._updateTilesForChangedImages();
            const e2 = this.sourceCaches[i2.source];
            return e2 && e2.setDependencies(i2.tileID.key, i2.type, i2.icons), t3;
          });
        }
        getGlyphs(t2, i2) {
          return e._(this, undefined, undefined, function* () {
            const t3 = yield this.glyphManager.getGlyphs(i2.stacks), e2 = this.sourceCaches[i2.source];
            return e2 && e2.setDependencies(i2.tileID.key, i2.type, [""]), t3;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(t2, i2 = {}) {
          this._checkLoaded(), t2 && this._validate(e.u.glyphs, "glyphs", t2, null, i2) || (this._glyphsDidChange = true, this.stylesheet.glyphs = t2, this.glyphManager.entries = {}, this.glyphManager.setURL(t2));
        }
        addSprite(t2, i2, a2 = {}, s2) {
          this._checkLoaded();
          const o2 = [{ id: t2, url: i2 }], r2 = [...x(this.stylesheet.sprite), ...o2];
          this._validate(e.u.sprite, "sprite", r2, null, a2) || (this.stylesheet.sprite = r2, this._loadSprite(o2, true, s2));
        }
        removeSprite(t2) {
          this._checkLoaded();
          const i2 = x(this.stylesheet.sprite);
          if (i2.find((e2) => e2.id === t2)) {
            if (this._spritesImagesIds[t2])
              for (const e2 of this._spritesImagesIds[t2])
                this.imageManager.removeImage(e2), this._changedImages[e2] = true;
            i2.splice(i2.findIndex((e2) => e2.id === t2), 1), this.stylesheet.sprite = i2.length > 0 ? i2 : undefined, delete this._spritesImagesIds[t2], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new e.k("data", { dataType: "style" }));
          } else
            this.fire(new e.j(new Error(`Sprite "${t2}" doesn't exists on this map.`)));
        }
        getSprite() {
          return x(this.stylesheet.sprite);
        }
        setSprite(t2, i2 = {}, a2) {
          this._checkLoaded(), t2 && this._validate(e.u.sprite, "sprite", t2, null, i2) || (this.stylesheet.sprite = t2, t2 ? this._loadSprite(t2, true, a2) : (this._unloadSprite(), a2 && a2(null)));
        }
      }
      var _e = e.Y([{ name: "a_pos", type: "Int16", components: 2 }]);
      const pe = {
        prelude: me(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}`),
        background: me(`uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
        backgroundPattern: me(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
        circle: me(`varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
        clippingMask: me("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"),
        heatmap: me(`uniform highp float u_intensity;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,get_elevation(floor(a_pos*0.5)),1);gl_Position=u_matrix*pos;}`),
        heatmapTexture: me(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
        collisionBox: me("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_anchor_pos;attribute vec2 a_placed;attribute vec2 a_box_real;uniform mat4 u_matrix;uniform vec2 u_pixel_extrude_scale;varying float v_placed;varying float v_notUsed;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
        collisionCircle: me("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
        debug: me("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"),
        fill: me(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_FragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);}`),
        fillOutline: me(`varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`),
        fillOutlinePattern: me(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}`),
        fillPattern: me(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
        fillExtrusion: me(`varying vec4 v_color;void main() {gl_FragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
        fillExtrusionPattern: me(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;
#ifdef TERRAIN3D
attribute vec2 a_centroid;
#endif
varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
        hillshadePrepare: me(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
        hillshade: me(`uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"),
        line: me(`uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
        lineGradient: me(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
attribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
        linePattern: me(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
        lineSDF: me(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
attribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`),
        raster: me(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"),
        symbolIcon: me(`uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_tex;varying float v_fade_opacity;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
        symbolSDF: me(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec2 v_data0;varying vec3 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
        symbolTextAndIcon: me(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
gl_FragColor=vec4(1.0);
#endif
}`, `attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;varying vec4 v_data0;varying vec4 v_data1;vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_matrix*vec4(posInTile,elevation,1.0);}
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
        terrain: me("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;varying vec2 v_texture_pos;varying float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture2D(u_texture,v_texture_pos);if (v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);gl_FragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {gl_FragColor=surface_color;}}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform mat4 u_fog_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
        terrainDepth: me("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}"),
        terrainCoords: me("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=u_matrix*vec4(a_pos3d.xy,ele-ele_delta,1.0);}"),
        sky: me("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform float u_horizon;uniform float u_sky_horizon_blend;void main() {float y=gl_FragCoord.y;if (y > u_horizon) {float blend=y-u_horizon;if (blend < u_sky_horizon_blend) {gl_FragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {gl_FragColor=u_sky_color;}}}", "attribute vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
      };
      function me(t2, e2) {
        const i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, a2 = e2.match(/attribute ([\w]+) ([\w]+)/g), s2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r2 = o2 ? o2.concat(s2) : s2, n2 = {};
        return {
          fragmentSource: t2 = t2.replace(i2, (t3, e3, i3, a3, s3) => (n2[s3] = true, e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${s3}
varying ${i3} ${a3} ${s3};
#else
uniform ${i3} ${a3} u_${s3};
#endif
` : `
#ifdef HAS_UNIFORM_u_${s3}
    ${i3} ${a3} ${s3} = u_${s3};
#endif
`)),
          vertexSource: e2 = e2.replace(i2, (t3, e3, i3, a3, s3) => {
            const o3 = a3 === "float" ? "vec2" : "vec4", r3 = s3.match(/color/) ? "color" : o3;
            return n2[s3] ? e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${s3}
uniform lowp float u_${s3}_t;
attribute ${i3} ${o3} a_${s3};
varying ${i3} ${a3} ${s3};
#else
uniform ${i3} ${a3} u_${s3};
#endif
` : r3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${s3}
    ${s3} = a_${s3};
#else
    ${i3} ${a3} ${s3} = u_${s3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${s3}
    ${s3} = unpack_mix_${r3}(a_${s3}, u_${s3}_t);
#else
    ${i3} ${a3} ${s3} = u_${s3};
#endif
` : e3 === "define" ? `
#ifndef HAS_UNIFORM_u_${s3}
uniform lowp float u_${s3}_t;
attribute ${i3} ${o3} a_${s3};
#else
uniform ${i3} ${a3} u_${s3};
#endif
` : r3 === "vec4" ? `
#ifndef HAS_UNIFORM_u_${s3}
    ${i3} ${a3} ${s3} = a_${s3};
#else
    ${i3} ${a3} ${s3} = u_${s3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${s3}
    ${i3} ${a3} ${s3} = unpack_mix_${r3}(a_${s3}, u_${s3}_t);
#else
    ${i3} ${a3} ${s3} = u_${s3};
#endif
`;
          }),
          staticAttributes: a2,
          staticUniforms: r2
        };
      }

      class fe {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(t2, e2, i2, a2, s2, o2, r2, n2, l2) {
          this.context = t2;
          let h2 = this.boundPaintVertexBuffers.length !== a2.length;
          for (let t3 = 0;!h2 && t3 < a2.length; t3++)
            this.boundPaintVertexBuffers[t3] !== a2[t3] && (h2 = true);
          !this.vao || this.boundProgram !== e2 || this.boundLayoutVertexBuffer !== i2 || h2 || this.boundIndexBuffer !== s2 || this.boundVertexOffset !== o2 || this.boundDynamicVertexBuffer !== r2 || this.boundDynamicVertexBuffer2 !== n2 || this.boundDynamicVertexBuffer3 !== l2 ? this.freshBind(e2, i2, a2, s2, o2, r2, n2, l2) : (t2.bindVertexArray.set(this.vao), r2 && r2.bind(), s2 && s2.dynamicDraw && s2.bind(), n2 && n2.bind(), l2 && l2.bind());
        }
        freshBind(t2, e2, i2, a2, s2, o2, r2, n2) {
          const l2 = t2.numAttributes, h2 = this.context, c2 = h2.gl;
          this.vao && this.destroy(), this.vao = h2.createVertexArray(), h2.bindVertexArray.set(this.vao), this.boundProgram = t2, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = a2, this.boundVertexOffset = s2, this.boundDynamicVertexBuffer = o2, this.boundDynamicVertexBuffer2 = r2, this.boundDynamicVertexBuffer3 = n2, e2.enableAttributes(c2, t2);
          for (const e3 of i2)
            e3.enableAttributes(c2, t2);
          o2 && o2.enableAttributes(c2, t2), r2 && r2.enableAttributes(c2, t2), n2 && n2.enableAttributes(c2, t2), e2.bind(), e2.setVertexAttribPointers(c2, t2, s2);
          for (const e3 of i2)
            e3.bind(), e3.setVertexAttribPointers(c2, t2, s2);
          o2 && (o2.bind(), o2.setVertexAttribPointers(c2, t2, s2)), a2 && a2.bind(), r2 && (r2.bind(), r2.setVertexAttribPointers(c2, t2, s2)), n2 && (n2.bind(), n2.setVertexAttribPointers(c2, t2, s2)), h2.currentNumAttributes = l2;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      const ge = (t2, i2, a2, s2, o2) => ({
        u_matrix: t2,
        u_texture: 0,
        u_ele_delta: i2,
        u_fog_matrix: a2,
        u_fog_color: s2 ? s2.properties.get("fog-color") : e.aM.white,
        u_fog_ground_blend: s2 ? s2.properties.get("fog-ground-blend") : 1,
        u_fog_ground_blend_opacity: s2 ? s2.calculateFogBlendOpacity(o2) : 0,
        u_horizon_color: s2 ? s2.properties.get("horizon-color") : e.aM.white,
        u_horizon_fog_blend: s2 ? s2.properties.get("horizon-fog-blend") : 1
      });
      function ve(t2) {
        const e2 = [];
        for (let i2 = 0;i2 < t2.length; i2++) {
          if (t2[i2] === null)
            continue;
          const a2 = t2[i2].split(" ");
          e2.push(a2.pop());
        }
        return e2;
      }

      class xe {
        constructor(t2, i2, a2, s2, o2, r2) {
          const n2 = t2.gl;
          this.program = n2.createProgram();
          const l2 = ve(i2.staticAttributes), h2 = a2 ? a2.getBinderAttributes() : [], c2 = l2.concat(h2), u2 = pe.prelude.staticUniforms ? ve(pe.prelude.staticUniforms) : [], d2 = i2.staticUniforms ? ve(i2.staticUniforms) : [], _2 = a2 ? a2.getBinderUniforms() : [], p2 = u2.concat(d2).concat(_2), m2 = [];
          for (const t3 of p2)
            m2.indexOf(t3) < 0 && m2.push(t3);
          const f2 = a2 ? a2.defines() : [];
          o2 && f2.push("#define OVERDRAW_INSPECTOR;"), r2 && f2.push("#define TERRAIN3D;");
          const g2 = f2.concat(pe.prelude.fragmentSource, i2.fragmentSource).join(`
`), v2 = f2.concat(pe.prelude.vertexSource, i2.vertexSource).join(`
`), x2 = n2.createShader(n2.FRAGMENT_SHADER);
          if (n2.isContextLost())
            return void (this.failedToCreate = true);
          if (n2.shaderSource(x2, g2), n2.compileShader(x2), !n2.getShaderParameter(x2, n2.COMPILE_STATUS))
            throw new Error(`Could not compile fragment shader: ${n2.getShaderInfoLog(x2)}`);
          n2.attachShader(this.program, x2);
          const y2 = n2.createShader(n2.VERTEX_SHADER);
          if (n2.isContextLost())
            return void (this.failedToCreate = true);
          if (n2.shaderSource(y2, v2), n2.compileShader(y2), !n2.getShaderParameter(y2, n2.COMPILE_STATUS))
            throw new Error(`Could not compile vertex shader: ${n2.getShaderInfoLog(y2)}`);
          n2.attachShader(this.program, y2), this.attributes = {};
          const b2 = {};
          this.numAttributes = c2.length;
          for (let t3 = 0;t3 < this.numAttributes; t3++)
            c2[t3] && (n2.bindAttribLocation(this.program, t3, c2[t3]), this.attributes[c2[t3]] = t3);
          if (n2.linkProgram(this.program), !n2.getProgramParameter(this.program, n2.LINK_STATUS))
            throw new Error(`Program failed to link: ${n2.getProgramInfoLog(this.program)}`);
          n2.deleteShader(y2), n2.deleteShader(x2);
          for (let t3 = 0;t3 < m2.length; t3++) {
            const e2 = m2[t3];
            if (e2 && !b2[e2]) {
              const t4 = n2.getUniformLocation(this.program, e2);
              t4 && (b2[e2] = t4);
            }
          }
          this.fixedUniforms = s2(t2, b2), this.terrainUniforms = ((t3, i3) => ({
            u_depth: new e.aH(t3, i3.u_depth),
            u_terrain: new e.aH(t3, i3.u_terrain),
            u_terrain_dim: new e.aI(t3, i3.u_terrain_dim),
            u_terrain_matrix: new e.aJ(t3, i3.u_terrain_matrix),
            u_terrain_unpack: new e.aK(t3, i3.u_terrain_unpack),
            u_terrain_exaggeration: new e.aI(t3, i3.u_terrain_exaggeration)
          }))(t2, b2), this.binderUniforms = a2 ? a2.getUniforms(t2, b2) : [];
        }
        draw(t2, e2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2, m2, f2, g2) {
          const v2 = t2.gl;
          if (this.failedToCreate)
            return;
          if (t2.program.set(this.program), t2.setDepthMode(i2), t2.setStencilMode(a2), t2.setColorMode(s2), t2.setCullFace(o2), n2) {
            t2.activeTexture.set(v2.TEXTURE2), v2.bindTexture(v2.TEXTURE_2D, n2.depthTexture), t2.activeTexture.set(v2.TEXTURE3), v2.bindTexture(v2.TEXTURE_2D, n2.texture);
            for (const t3 in this.terrainUniforms)
              this.terrainUniforms[t3].set(n2[t3]);
          }
          for (const t3 in this.fixedUniforms)
            this.fixedUniforms[t3].set(r2[t3]);
          p2 && p2.setUniforms(t2, this.binderUniforms, d2, { zoom: _2 });
          let x2 = 0;
          switch (e2) {
            case v2.LINES:
              x2 = 2;
              break;
            case v2.TRIANGLES:
              x2 = 3;
              break;
            case v2.LINE_STRIP:
              x2 = 1;
          }
          for (const i3 of u2.get()) {
            const a3 = i3.vaos || (i3.vaos = {});
            (a3[l2] || (a3[l2] = new fe)).bind(t2, this, h2, p2 ? p2.getPaintVertexBuffers() : [], c2, i3.vertexOffset, m2, f2, g2), v2.drawElements(e2, i3.primitiveLength * x2, v2.UNSIGNED_SHORT, i3.primitiveOffset * x2 * 2);
          }
        }
      }
      function ye(t2, e2, i2) {
        const a2 = 1 / Bt(i2, 1, e2.transform.tileZoom), s2 = Math.pow(2, i2.tileID.overscaledZ), o2 = i2.tileSize * Math.pow(2, e2.transform.tileZoom) / s2, r2 = o2 * (i2.tileID.canonical.x + i2.tileID.wrap * s2), n2 = o2 * i2.tileID.canonical.y;
        return {
          u_image: 0,
          u_texsize: i2.imageAtlasTexture.size,
          u_scale: [a2, t2.fromScale, t2.toScale],
          u_fade: t2.t,
          u_pixel_coord_upper: [r2 >> 16, n2 >> 16],
          u_pixel_coord_lower: [65535 & r2, 65535 & n2]
        };
      }
      const be = (t2, i2, a2, s2) => {
        const o2 = i2.style.light, r2 = o2.properties.get("position"), n2 = [r2.x, r2.y, r2.z], l2 = function() {
          var t3 = new e.A(9);
          return e.A != Float32Array && (t3[1] = 0, t3[2] = 0, t3[3] = 0, t3[5] = 0, t3[6] = 0, t3[7] = 0), t3[0] = 1, t3[4] = 1, t3[8] = 1, t3;
        }();
        o2.properties.get("anchor") === "viewport" && function(t3, e2) {
          var i3 = Math.sin(e2), a3 = Math.cos(e2);
          t3[0] = a3, t3[1] = i3, t3[2] = 0, t3[3] = -i3, t3[4] = a3, t3[5] = 0, t3[6] = 0, t3[7] = 0, t3[8] = 1;
        }(l2, -i2.transform.angle), function(t3, e2, i3) {
          var a3 = e2[0], s3 = e2[1], o3 = e2[2];
          t3[0] = a3 * i3[0] + s3 * i3[3] + o3 * i3[6], t3[1] = a3 * i3[1] + s3 * i3[4] + o3 * i3[7], t3[2] = a3 * i3[2] + s3 * i3[5] + o3 * i3[8];
        }(n2, n2, l2);
        const h2 = o2.properties.get("color");
        return {
          u_matrix: t2,
          u_lightpos: n2,
          u_lightintensity: o2.properties.get("intensity"),
          u_lightcolor: [h2.r, h2.g, h2.b],
          u_vertical_gradient: +a2,
          u_opacity: s2
        };
      }, we = (t2, i2, a2, s2, o2, r2, n2) => e.e(be(t2, i2, a2, s2), ye(r2, i2, n2), {
        u_height_factor: -Math.pow(2, o2.overscaledZ) / n2.tileSize / 8
      }), Te = (t2) => ({ u_matrix: t2 }), Ie = (t2, i2, a2, s2) => e.e(Te(t2), ye(a2, i2, s2)), Ee = (t2, e2) => ({ u_matrix: t2, u_world: e2 }), Pe = (t2, i2, a2, s2, o2) => e.e(Ie(t2, i2, a2, s2), { u_world: o2 }), Ce = (t2, e2, i2, a2) => {
        const s2 = t2.transform;
        let o2, r2;
        if (a2.paint.get("circle-pitch-alignment") === "map") {
          const t3 = Bt(i2, 1, s2.zoom);
          o2 = true, r2 = [t3, t3];
        } else
          o2 = false, r2 = s2.pixelsToGLUnits;
        return {
          u_camera_to_center_distance: s2.cameraToCenterDistance,
          u_scale_with_map: +(a2.paint.get("circle-pitch-scale") === "map"),
          u_matrix: t2.translatePosMatrix(e2.posMatrix, i2, a2.paint.get("circle-translate"), a2.paint.get("circle-translate-anchor")),
          u_pitch_with_map: +o2,
          u_device_pixel_ratio: t2.pixelRatio,
          u_extrude_scale: r2
        };
      }, Se = (t2, e2, i2) => ({
        u_matrix: t2,
        u_inv_matrix: e2,
        u_camera_to_center_distance: i2.cameraToCenterDistance,
        u_viewport_size: [i2.width, i2.height]
      }), ze = (t2, e2, i2 = 1) => ({
        u_matrix: t2,
        u_color: e2,
        u_overlay: 0,
        u_overlay_scale: i2
      }), De = (t2) => ({ u_matrix: t2 }), Me = (t2, e2, i2, a2) => ({
        u_matrix: t2,
        u_extrude_scale: Bt(e2, 1, i2),
        u_intensity: a2
      }), Ae = (t2, i2, a2, s2) => {
        const o2 = e.H();
        e.aP(o2, 0, t2.width, t2.height, 0, 0, 1);
        const r2 = t2.context.gl;
        return {
          u_matrix: o2,
          u_world: [r2.drawingBufferWidth, r2.drawingBufferHeight],
          u_image: a2,
          u_color_ramp: s2,
          u_opacity: i2.paint.get("heatmap-opacity")
        };
      };
      function Re(t2, i2) {
        const a2 = Math.pow(2, i2.canonical.z), s2 = i2.canonical.y;
        return [
          new e.Z(0, s2 / a2).toLngLat().lat,
          new e.Z(0, (s2 + 1) / a2).toLngLat().lat
        ];
      }
      const ke = (t2, e2, i2, a2) => {
        const s2 = t2.transform;
        return {
          u_matrix: Ne(t2, e2, i2, a2),
          u_ratio: 1 / Bt(e2, 1, s2.zoom),
          u_device_pixel_ratio: t2.pixelRatio,
          u_units_to_pixels: [1 / s2.pixelsToGLUnits[0], 1 / s2.pixelsToGLUnits[1]]
        };
      }, Le = (t2, i2, a2, s2, o2) => e.e(ke(t2, i2, a2, o2), { u_image: 0, u_image_height: s2 }), Fe = (t2, e2, i2, a2, s2) => {
        const o2 = t2.transform, r2 = Oe(e2, o2);
        return {
          u_matrix: Ne(t2, e2, i2, s2),
          u_texsize: e2.imageAtlasTexture.size,
          u_ratio: 1 / Bt(e2, 1, o2.zoom),
          u_device_pixel_ratio: t2.pixelRatio,
          u_image: 0,
          u_scale: [r2, a2.fromScale, a2.toScale],
          u_fade: a2.t,
          u_units_to_pixels: [1 / o2.pixelsToGLUnits[0], 1 / o2.pixelsToGLUnits[1]]
        };
      }, Be = (t2, i2, a2, s2, o2, r2) => {
        const n2 = t2.lineAtlas, l2 = Oe(i2, t2.transform), h2 = a2.layout.get("line-cap") === "round", c2 = n2.getDash(s2.from, h2), u2 = n2.getDash(s2.to, h2), d2 = c2.width * o2.fromScale, _2 = u2.width * o2.toScale;
        return e.e(ke(t2, i2, a2, r2), {
          u_patternscale_a: [l2 / d2, -c2.height / 2],
          u_patternscale_b: [l2 / _2, -u2.height / 2],
          u_sdfgamma: n2.width / (256 * Math.min(d2, _2) * t2.pixelRatio) / 2,
          u_image: 0,
          u_tex_y_a: c2.y,
          u_tex_y_b: u2.y,
          u_mix: o2.t
        });
      };
      function Oe(t2, e2) {
        return 1 / Bt(t2, 1, e2.tileZoom);
      }
      function Ne(t2, e2, i2, a2) {
        return t2.translatePosMatrix(a2 ? a2.posMatrix : e2.tileID.posMatrix, e2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
      }
      const Ue = (t2, e2, i2, a2, s2) => {
        return {
          u_matrix: t2,
          u_tl_parent: e2,
          u_scale_parent: i2,
          u_buffer_scale: 1,
          u_fade_t: a2.mix,
          u_opacity: a2.opacity * s2.paint.get("raster-opacity"),
          u_image0: 0,
          u_image1: 1,
          u_brightness_low: s2.paint.get("raster-brightness-min"),
          u_brightness_high: s2.paint.get("raster-brightness-max"),
          u_saturation_factor: (r2 = s2.paint.get("raster-saturation"), r2 > 0 ? 1 - 1 / (1.001 - r2) : -r2),
          u_contrast_factor: (o2 = s2.paint.get("raster-contrast"), o2 > 0 ? 1 / (1 - o2) : 1 + o2),
          u_spin_weights: je(s2.paint.get("raster-hue-rotate"))
        };
        var o2, r2;
      };
      function je(t2) {
        t2 *= Math.PI / 180;
        const e2 = Math.sin(t2), i2 = Math.cos(t2);
        return [
          (2 * i2 + 1) / 3,
          (-Math.sqrt(3) * e2 - i2 + 1) / 3,
          (Math.sqrt(3) * e2 - i2 + 1) / 3
        ];
      }
      const Ze = (t2, e2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u2, d2, _2) => {
        const p2 = r2.transform;
        return {
          u_is_size_zoom_constant: +(t2 === "constant" || t2 === "source"),
          u_is_size_feature_constant: +(t2 === "constant" || t2 === "camera"),
          u_size_t: e2 ? e2.uSizeT : 0,
          u_size: e2 ? e2.uSize : 0,
          u_camera_to_center_distance: p2.cameraToCenterDistance,
          u_pitch: p2.pitch / 360 * 2 * Math.PI,
          u_rotate_symbol: +i2,
          u_aspect_ratio: p2.width / p2.height,
          u_fade_change: r2.options.fadeDuration ? r2.symbolFadeChange : 1,
          u_matrix: n2,
          u_label_plane_matrix: l2,
          u_coord_matrix: h2,
          u_is_text: +u2,
          u_pitch_with_map: +a2,
          u_is_along_line: s2,
          u_is_variable_anchor: o2,
          u_texsize: d2,
          u_texture: 0,
          u_translation: c2,
          u_pitched_scale: _2
        };
      }, qe = (t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2, m2) => {
        const f2 = n2.transform;
        return e.e(Ze(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u2, d2, _2, m2), {
          u_gamma_scale: s2 ? Math.cos(f2._pitch) * f2.cameraToCenterDistance : 1,
          u_device_pixel_ratio: n2.pixelRatio,
          u_is_halo: +p2
        });
      }, Ve = (t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2) => e.e(qe(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u2, true, d2, true, p2), {
        u_texsize_icon: _2,
        u_texture_icon: 1
      }), Ge = (t2, e2, i2) => ({ u_matrix: t2, u_opacity: e2, u_color: i2 }), He = (t2, i2, a2, s2, o2, r2) => e.e(function(t3, e2, i3, a3) {
        const s3 = i3.imageManager.getPattern(t3.from.toString()), o3 = i3.imageManager.getPattern(t3.to.toString()), { width: r3, height: n2 } = i3.imageManager.getPixelSize(), l2 = Math.pow(2, a3.tileID.overscaledZ), h2 = a3.tileSize * Math.pow(2, i3.transform.tileZoom) / l2, c2 = h2 * (a3.tileID.canonical.x + a3.tileID.wrap * l2), u2 = h2 * a3.tileID.canonical.y;
        return {
          u_image: 0,
          u_pattern_tl_a: s3.tl,
          u_pattern_br_a: s3.br,
          u_pattern_tl_b: o3.tl,
          u_pattern_br_b: o3.br,
          u_texsize: [r3, n2],
          u_mix: e2.t,
          u_pattern_size_a: s3.displaySize,
          u_pattern_size_b: o3.displaySize,
          u_scale_a: e2.fromScale,
          u_scale_b: e2.toScale,
          u_tile_units_to_pixels: 1 / Bt(a3, 1, i3.transform.tileZoom),
          u_pixel_coord_upper: [c2 >> 16, u2 >> 16],
          u_pixel_coord_lower: [65535 & c2, 65535 & u2]
        };
      }(s2, r2, a2, o2), { u_matrix: t2, u_opacity: i2 }), We = {
        fillExtrusion: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_lightpos: new e.aN(t2, i2.u_lightpos),
          u_lightintensity: new e.aI(t2, i2.u_lightintensity),
          u_lightcolor: new e.aN(t2, i2.u_lightcolor),
          u_vertical_gradient: new e.aI(t2, i2.u_vertical_gradient),
          u_opacity: new e.aI(t2, i2.u_opacity)
        }),
        fillExtrusionPattern: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_lightpos: new e.aN(t2, i2.u_lightpos),
          u_lightintensity: new e.aI(t2, i2.u_lightintensity),
          u_lightcolor: new e.aN(t2, i2.u_lightcolor),
          u_vertical_gradient: new e.aI(t2, i2.u_vertical_gradient),
          u_height_factor: new e.aI(t2, i2.u_height_factor),
          u_image: new e.aH(t2, i2.u_image),
          u_texsize: new e.aO(t2, i2.u_texsize),
          u_pixel_coord_upper: new e.aO(t2, i2.u_pixel_coord_upper),
          u_pixel_coord_lower: new e.aO(t2, i2.u_pixel_coord_lower),
          u_scale: new e.aN(t2, i2.u_scale),
          u_fade: new e.aI(t2, i2.u_fade),
          u_opacity: new e.aI(t2, i2.u_opacity)
        }),
        fill: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix) }),
        fillPattern: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_image: new e.aH(t2, i2.u_image),
          u_texsize: new e.aO(t2, i2.u_texsize),
          u_pixel_coord_upper: new e.aO(t2, i2.u_pixel_coord_upper),
          u_pixel_coord_lower: new e.aO(t2, i2.u_pixel_coord_lower),
          u_scale: new e.aN(t2, i2.u_scale),
          u_fade: new e.aI(t2, i2.u_fade)
        }),
        fillOutline: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_world: new e.aO(t2, i2.u_world)
        }),
        fillOutlinePattern: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_world: new e.aO(t2, i2.u_world),
          u_image: new e.aH(t2, i2.u_image),
          u_texsize: new e.aO(t2, i2.u_texsize),
          u_pixel_coord_upper: new e.aO(t2, i2.u_pixel_coord_upper),
          u_pixel_coord_lower: new e.aO(t2, i2.u_pixel_coord_lower),
          u_scale: new e.aN(t2, i2.u_scale),
          u_fade: new e.aI(t2, i2.u_fade)
        }),
        circle: (t2, i2) => ({
          u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance),
          u_scale_with_map: new e.aH(t2, i2.u_scale_with_map),
          u_pitch_with_map: new e.aH(t2, i2.u_pitch_with_map),
          u_extrude_scale: new e.aO(t2, i2.u_extrude_scale),
          u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio),
          u_matrix: new e.aJ(t2, i2.u_matrix)
        }),
        collisionBox: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_pixel_extrude_scale: new e.aO(t2, i2.u_pixel_extrude_scale)
        }),
        collisionCircle: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_inv_matrix: new e.aJ(t2, i2.u_inv_matrix),
          u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance),
          u_viewport_size: new e.aO(t2, i2.u_viewport_size)
        }),
        debug: (t2, i2) => ({
          u_color: new e.aL(t2, i2.u_color),
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_overlay: new e.aH(t2, i2.u_overlay),
          u_overlay_scale: new e.aI(t2, i2.u_overlay_scale)
        }),
        clippingMask: (t2, i2) => ({ u_matrix: new e.aJ(t2, i2.u_matrix) }),
        heatmap: (t2, i2) => ({
          u_extrude_scale: new e.aI(t2, i2.u_extrude_scale),
          u_intensity: new e.aI(t2, i2.u_intensity),
          u_matrix: new e.aJ(t2, i2.u_matrix)
        }),
        heatmapTexture: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_world: new e.aO(t2, i2.u_world),
          u_image: new e.aH(t2, i2.u_image),
          u_color_ramp: new e.aH(t2, i2.u_color_ramp),
          u_opacity: new e.aI(t2, i2.u_opacity)
        }),
        hillshade: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_image: new e.aH(t2, i2.u_image),
          u_latrange: new e.aO(t2, i2.u_latrange),
          u_light: new e.aO(t2, i2.u_light),
          u_shadow: new e.aL(t2, i2.u_shadow),
          u_highlight: new e.aL(t2, i2.u_highlight),
          u_accent: new e.aL(t2, i2.u_accent)
        }),
        hillshadePrepare: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_image: new e.aH(t2, i2.u_image),
          u_dimension: new e.aO(t2, i2.u_dimension),
          u_zoom: new e.aI(t2, i2.u_zoom),
          u_unpack: new e.aK(t2, i2.u_unpack)
        }),
        line: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_ratio: new e.aI(t2, i2.u_ratio),
          u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio),
          u_units_to_pixels: new e.aO(t2, i2.u_units_to_pixels)
        }),
        lineGradient: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_ratio: new e.aI(t2, i2.u_ratio),
          u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio),
          u_units_to_pixels: new e.aO(t2, i2.u_units_to_pixels),
          u_image: new e.aH(t2, i2.u_image),
          u_image_height: new e.aI(t2, i2.u_image_height)
        }),
        linePattern: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_texsize: new e.aO(t2, i2.u_texsize),
          u_ratio: new e.aI(t2, i2.u_ratio),
          u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio),
          u_image: new e.aH(t2, i2.u_image),
          u_units_to_pixels: new e.aO(t2, i2.u_units_to_pixels),
          u_scale: new e.aN(t2, i2.u_scale),
          u_fade: new e.aI(t2, i2.u_fade)
        }),
        lineSDF: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_ratio: new e.aI(t2, i2.u_ratio),
          u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio),
          u_units_to_pixels: new e.aO(t2, i2.u_units_to_pixels),
          u_patternscale_a: new e.aO(t2, i2.u_patternscale_a),
          u_patternscale_b: new e.aO(t2, i2.u_patternscale_b),
          u_sdfgamma: new e.aI(t2, i2.u_sdfgamma),
          u_image: new e.aH(t2, i2.u_image),
          u_tex_y_a: new e.aI(t2, i2.u_tex_y_a),
          u_tex_y_b: new e.aI(t2, i2.u_tex_y_b),
          u_mix: new e.aI(t2, i2.u_mix)
        }),
        raster: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_tl_parent: new e.aO(t2, i2.u_tl_parent),
          u_scale_parent: new e.aI(t2, i2.u_scale_parent),
          u_buffer_scale: new e.aI(t2, i2.u_buffer_scale),
          u_fade_t: new e.aI(t2, i2.u_fade_t),
          u_opacity: new e.aI(t2, i2.u_opacity),
          u_image0: new e.aH(t2, i2.u_image0),
          u_image1: new e.aH(t2, i2.u_image1),
          u_brightness_low: new e.aI(t2, i2.u_brightness_low),
          u_brightness_high: new e.aI(t2, i2.u_brightness_high),
          u_saturation_factor: new e.aI(t2, i2.u_saturation_factor),
          u_contrast_factor: new e.aI(t2, i2.u_contrast_factor),
          u_spin_weights: new e.aN(t2, i2.u_spin_weights)
        }),
        symbolIcon: (t2, i2) => ({
          u_is_size_zoom_constant: new e.aH(t2, i2.u_is_size_zoom_constant),
          u_is_size_feature_constant: new e.aH(t2, i2.u_is_size_feature_constant),
          u_size_t: new e.aI(t2, i2.u_size_t),
          u_size: new e.aI(t2, i2.u_size),
          u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance),
          u_pitch: new e.aI(t2, i2.u_pitch),
          u_rotate_symbol: new e.aH(t2, i2.u_rotate_symbol),
          u_aspect_ratio: new e.aI(t2, i2.u_aspect_ratio),
          u_fade_change: new e.aI(t2, i2.u_fade_change),
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_label_plane_matrix: new e.aJ(t2, i2.u_label_plane_matrix),
          u_coord_matrix: new e.aJ(t2, i2.u_coord_matrix),
          u_is_text: new e.aH(t2, i2.u_is_text),
          u_pitch_with_map: new e.aH(t2, i2.u_pitch_with_map),
          u_is_along_line: new e.aH(t2, i2.u_is_along_line),
          u_is_variable_anchor: new e.aH(t2, i2.u_is_variable_anchor),
          u_texsize: new e.aO(t2, i2.u_texsize),
          u_texture: new e.aH(t2, i2.u_texture),
          u_translation: new e.aO(t2, i2.u_translation),
          u_pitched_scale: new e.aI(t2, i2.u_pitched_scale)
        }),
        symbolSDF: (t2, i2) => ({
          u_is_size_zoom_constant: new e.aH(t2, i2.u_is_size_zoom_constant),
          u_is_size_feature_constant: new e.aH(t2, i2.u_is_size_feature_constant),
          u_size_t: new e.aI(t2, i2.u_size_t),
          u_size: new e.aI(t2, i2.u_size),
          u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance),
          u_pitch: new e.aI(t2, i2.u_pitch),
          u_rotate_symbol: new e.aH(t2, i2.u_rotate_symbol),
          u_aspect_ratio: new e.aI(t2, i2.u_aspect_ratio),
          u_fade_change: new e.aI(t2, i2.u_fade_change),
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_label_plane_matrix: new e.aJ(t2, i2.u_label_plane_matrix),
          u_coord_matrix: new e.aJ(t2, i2.u_coord_matrix),
          u_is_text: new e.aH(t2, i2.u_is_text),
          u_pitch_with_map: new e.aH(t2, i2.u_pitch_with_map),
          u_is_along_line: new e.aH(t2, i2.u_is_along_line),
          u_is_variable_anchor: new e.aH(t2, i2.u_is_variable_anchor),
          u_texsize: new e.aO(t2, i2.u_texsize),
          u_texture: new e.aH(t2, i2.u_texture),
          u_gamma_scale: new e.aI(t2, i2.u_gamma_scale),
          u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio),
          u_is_halo: new e.aH(t2, i2.u_is_halo),
          u_translation: new e.aO(t2, i2.u_translation),
          u_pitched_scale: new e.aI(t2, i2.u_pitched_scale)
        }),
        symbolTextAndIcon: (t2, i2) => ({
          u_is_size_zoom_constant: new e.aH(t2, i2.u_is_size_zoom_constant),
          u_is_size_feature_constant: new e.aH(t2, i2.u_is_size_feature_constant),
          u_size_t: new e.aI(t2, i2.u_size_t),
          u_size: new e.aI(t2, i2.u_size),
          u_camera_to_center_distance: new e.aI(t2, i2.u_camera_to_center_distance),
          u_pitch: new e.aI(t2, i2.u_pitch),
          u_rotate_symbol: new e.aH(t2, i2.u_rotate_symbol),
          u_aspect_ratio: new e.aI(t2, i2.u_aspect_ratio),
          u_fade_change: new e.aI(t2, i2.u_fade_change),
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_label_plane_matrix: new e.aJ(t2, i2.u_label_plane_matrix),
          u_coord_matrix: new e.aJ(t2, i2.u_coord_matrix),
          u_is_text: new e.aH(t2, i2.u_is_text),
          u_pitch_with_map: new e.aH(t2, i2.u_pitch_with_map),
          u_is_along_line: new e.aH(t2, i2.u_is_along_line),
          u_is_variable_anchor: new e.aH(t2, i2.u_is_variable_anchor),
          u_texsize: new e.aO(t2, i2.u_texsize),
          u_texsize_icon: new e.aO(t2, i2.u_texsize_icon),
          u_texture: new e.aH(t2, i2.u_texture),
          u_texture_icon: new e.aH(t2, i2.u_texture_icon),
          u_gamma_scale: new e.aI(t2, i2.u_gamma_scale),
          u_device_pixel_ratio: new e.aI(t2, i2.u_device_pixel_ratio),
          u_is_halo: new e.aH(t2, i2.u_is_halo),
          u_translation: new e.aO(t2, i2.u_translation),
          u_pitched_scale: new e.aI(t2, i2.u_pitched_scale)
        }),
        background: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_opacity: new e.aI(t2, i2.u_opacity),
          u_color: new e.aL(t2, i2.u_color)
        }),
        backgroundPattern: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_opacity: new e.aI(t2, i2.u_opacity),
          u_image: new e.aH(t2, i2.u_image),
          u_pattern_tl_a: new e.aO(t2, i2.u_pattern_tl_a),
          u_pattern_br_a: new e.aO(t2, i2.u_pattern_br_a),
          u_pattern_tl_b: new e.aO(t2, i2.u_pattern_tl_b),
          u_pattern_br_b: new e.aO(t2, i2.u_pattern_br_b),
          u_texsize: new e.aO(t2, i2.u_texsize),
          u_mix: new e.aI(t2, i2.u_mix),
          u_pattern_size_a: new e.aO(t2, i2.u_pattern_size_a),
          u_pattern_size_b: new e.aO(t2, i2.u_pattern_size_b),
          u_scale_a: new e.aI(t2, i2.u_scale_a),
          u_scale_b: new e.aI(t2, i2.u_scale_b),
          u_pixel_coord_upper: new e.aO(t2, i2.u_pixel_coord_upper),
          u_pixel_coord_lower: new e.aO(t2, i2.u_pixel_coord_lower),
          u_tile_units_to_pixels: new e.aI(t2, i2.u_tile_units_to_pixels)
        }),
        terrain: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_texture: new e.aH(t2, i2.u_texture),
          u_ele_delta: new e.aI(t2, i2.u_ele_delta),
          u_fog_matrix: new e.aJ(t2, i2.u_fog_matrix),
          u_fog_color: new e.aL(t2, i2.u_fog_color),
          u_fog_ground_blend: new e.aI(t2, i2.u_fog_ground_blend),
          u_fog_ground_blend_opacity: new e.aI(t2, i2.u_fog_ground_blend_opacity),
          u_horizon_color: new e.aL(t2, i2.u_horizon_color),
          u_horizon_fog_blend: new e.aI(t2, i2.u_horizon_fog_blend)
        }),
        terrainDepth: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_ele_delta: new e.aI(t2, i2.u_ele_delta)
        }),
        terrainCoords: (t2, i2) => ({
          u_matrix: new e.aJ(t2, i2.u_matrix),
          u_texture: new e.aH(t2, i2.u_texture),
          u_terrain_coords_id: new e.aI(t2, i2.u_terrain_coords_id),
          u_ele_delta: new e.aI(t2, i2.u_ele_delta)
        }),
        sky: (t2, i2) => ({
          u_sky_color: new e.aL(t2, i2.u_sky_color),
          u_horizon_color: new e.aL(t2, i2.u_horizon_color),
          u_horizon: new e.aI(t2, i2.u_horizon),
          u_sky_horizon_blend: new e.aI(t2, i2.u_sky_horizon_blend)
        })
      };

      class $e {
        constructor(t2, e2, i2) {
          this.context = t2;
          const a2 = t2.gl;
          this.buffer = a2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), t2.bindElementBuffer.set(this.buffer), a2.bufferData(a2.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? a2.DYNAMIC_DRAW : a2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(t2) {
          const e2 = this.context.gl;
          if (!this.dynamicDraw)
            throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t2.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Xe = {
        Int8: "BYTE",
        Uint8: "UNSIGNED_BYTE",
        Int16: "SHORT",
        Uint16: "UNSIGNED_SHORT",
        Int32: "INT",
        Uint32: "UNSIGNED_INT",
        Float32: "FLOAT"
      };

      class Ke {
        constructor(t2, e2, i2, a2) {
          this.length = e2.length, this.attributes = i2, this.itemSize = e2.bytesPerElement, this.dynamicDraw = a2, this.context = t2;
          const s2 = t2.gl;
          this.buffer = s2.createBuffer(), t2.bindVertexBuffer.set(this.buffer), s2.bufferData(s2.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? s2.DYNAMIC_DRAW : s2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(t2) {
          if (t2.length !== this.length)
            throw new Error(`Length of new data is ${t2.length}, which doesn't match current length of ${this.length}`);
          const e2 = this.context.gl;
          this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t2.arrayBuffer);
        }
        enableAttributes(t2, e2) {
          for (let i2 = 0;i2 < this.attributes.length; i2++) {
            const a2 = e2.attributes[this.attributes[i2].name];
            a2 !== undefined && t2.enableVertexAttribArray(a2);
          }
        }
        setVertexAttribPointers(t2, e2, i2) {
          for (let a2 = 0;a2 < this.attributes.length; a2++) {
            const s2 = this.attributes[a2], o2 = e2.attributes[s2.name];
            o2 !== undefined && t2.vertexAttribPointer(o2, s2.components, t2[Xe[s2.type]], false, this.itemSize, s2.offset + this.itemSize * (i2 || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Je = new WeakMap;
      function Ye(t2) {
        var e2;
        if (Je.has(t2))
          return Je.get(t2);
        {
          const i2 = (e2 = t2.getParameter(t2.VERSION)) === null || e2 === undefined ? undefined : e2.startsWith("WebGL 2.0");
          return Je.set(t2, i2), i2;
        }
      }

      class Qe {
        constructor(t2) {
          this.gl = t2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
        }
        get() {
          return this.current;
        }
        set(t2) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }

      class ti extends Qe {
        getDefault() {
          return e.aM.transparent;
        }
        set(t2) {
          const e2 = this.current;
          (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.clearColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
        }
      }

      class ei extends Qe {
        getDefault() {
          return 1;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.clearDepth(t2), this.current = t2, this.dirty = false);
        }
      }

      class ii extends Qe {
        getDefault() {
          return 0;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.clearStencil(t2), this.current = t2, this.dirty = false);
        }
      }

      class ai extends Qe {
        getDefault() {
          return [true, true, true, true];
        }
        set(t2) {
          const e2 = this.current;
          (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.colorMask(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
        }
      }

      class si extends Qe {
        getDefault() {
          return true;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.depthMask(t2), this.current = t2, this.dirty = false);
        }
      }

      class oi extends Qe {
        getDefault() {
          return 255;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.stencilMask(t2), this.current = t2, this.dirty = false);
        }
      }

      class ri extends Qe {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(t2) {
          const e2 = this.current;
          (t2.func !== e2.func || t2.ref !== e2.ref || t2.mask !== e2.mask || this.dirty) && (this.gl.stencilFunc(t2.func, t2.ref, t2.mask), this.current = t2, this.dirty = false);
        }
      }

      class ni extends Qe {
        getDefault() {
          const t2 = this.gl;
          return [t2.KEEP, t2.KEEP, t2.KEEP];
        }
        set(t2) {
          const e2 = this.current;
          (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || this.dirty) && (this.gl.stencilOp(t2[0], t2[1], t2[2]), this.current = t2, this.dirty = false);
        }
      }

      class li extends Qe {
        getDefault() {
          return false;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          t2 ? e2.enable(e2.STENCIL_TEST) : e2.disable(e2.STENCIL_TEST), this.current = t2, this.dirty = false;
        }
      }

      class hi extends Qe {
        getDefault() {
          return [0, 1];
        }
        set(t2) {
          const e2 = this.current;
          (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.depthRange(t2[0], t2[1]), this.current = t2, this.dirty = false);
        }
      }

      class ci extends Qe {
        getDefault() {
          return false;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          t2 ? e2.enable(e2.DEPTH_TEST) : e2.disable(e2.DEPTH_TEST), this.current = t2, this.dirty = false;
        }
      }

      class ui extends Qe {
        getDefault() {
          return this.gl.LESS;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.depthFunc(t2), this.current = t2, this.dirty = false);
        }
      }

      class di extends Qe {
        getDefault() {
          return false;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          t2 ? e2.enable(e2.BLEND) : e2.disable(e2.BLEND), this.current = t2, this.dirty = false;
        }
      }

      class _i extends Qe {
        getDefault() {
          const t2 = this.gl;
          return [t2.ONE, t2.ZERO];
        }
        set(t2) {
          const e2 = this.current;
          (t2[0] !== e2[0] || t2[1] !== e2[1] || this.dirty) && (this.gl.blendFunc(t2[0], t2[1]), this.current = t2, this.dirty = false);
        }
      }

      class pi extends Qe {
        getDefault() {
          return e.aM.transparent;
        }
        set(t2) {
          const e2 = this.current;
          (t2.r !== e2.r || t2.g !== e2.g || t2.b !== e2.b || t2.a !== e2.a || this.dirty) && (this.gl.blendColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
        }
      }

      class mi extends Qe {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.blendEquation(t2), this.current = t2, this.dirty = false);
        }
      }

      class fi extends Qe {
        getDefault() {
          return false;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          t2 ? e2.enable(e2.CULL_FACE) : e2.disable(e2.CULL_FACE), this.current = t2, this.dirty = false;
        }
      }

      class gi extends Qe {
        getDefault() {
          return this.gl.BACK;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.cullFace(t2), this.current = t2, this.dirty = false);
        }
      }

      class vi extends Qe {
        getDefault() {
          return this.gl.CCW;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.frontFace(t2), this.current = t2, this.dirty = false);
        }
      }

      class xi extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.useProgram(t2), this.current = t2, this.dirty = false);
        }
      }

      class yi extends Qe {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(t2) {
          (t2 !== this.current || this.dirty) && (this.gl.activeTexture(t2), this.current = t2, this.dirty = false);
        }
      }

      class bi extends Qe {
        getDefault() {
          const t2 = this.gl;
          return [0, 0, t2.drawingBufferWidth, t2.drawingBufferHeight];
        }
        set(t2) {
          const e2 = this.current;
          (t2[0] !== e2[0] || t2[1] !== e2[1] || t2[2] !== e2[2] || t2[3] !== e2[3] || this.dirty) && (this.gl.viewport(t2[0], t2[1], t2[2], t2[3]), this.current = t2, this.dirty = false);
        }
      }

      class wi extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.bindFramebuffer(e2.FRAMEBUFFER, t2), this.current = t2, this.dirty = false;
        }
      }

      class Ti extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.bindRenderbuffer(e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
        }
      }

      class Ii extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.bindTexture(e2.TEXTURE_2D, t2), this.current = t2, this.dirty = false;
        }
      }

      class Ei extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.bindBuffer(e2.ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
        }
      }

      class Pi extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          const e2 = this.gl;
          e2.bindBuffer(e2.ELEMENT_ARRAY_BUFFER, t2), this.current = t2, this.dirty = false;
        }
      }

      class Ci extends Qe {
        getDefault() {
          return null;
        }
        set(t2) {
          var e2;
          if (t2 === this.current && !this.dirty)
            return;
          const i2 = this.gl;
          Ye(i2) ? i2.bindVertexArray(t2) : (e2 = i2.getExtension("OES_vertex_array_object")) === null || e2 === undefined || e2.bindVertexArrayOES(t2), this.current = t2, this.dirty = false;
        }
      }

      class Si extends Qe {
        getDefault() {
          return 4;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.pixelStorei(e2.UNPACK_ALIGNMENT, t2), this.current = t2, this.dirty = false;
        }
      }

      class zi extends Qe {
        getDefault() {
          return false;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.pixelStorei(e2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t2), this.current = t2, this.dirty = false;
        }
      }

      class Di extends Qe {
        getDefault() {
          return false;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          const e2 = this.gl;
          e2.pixelStorei(e2.UNPACK_FLIP_Y_WEBGL, t2), this.current = t2, this.dirty = false;
        }
      }

      class Mi extends Qe {
        constructor(t2, e2) {
          super(t2), this.context = t2, this.parent = e2;
        }
        getDefault() {
          return null;
        }
      }

      class Ai extends Mi {
        setDirty() {
          this.dirty = true;
        }
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const e2 = this.gl;
          e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, t2, 0), this.current = t2, this.dirty = false;
        }
      }

      class Ri extends Mi {
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const e2 = this.gl;
          e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_ATTACHMENT, e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
        }
      }

      class ki extends Mi {
        set(t2) {
          if (t2 === this.current && !this.dirty)
            return;
          this.context.bindFramebuffer.set(this.parent);
          const e2 = this.gl;
          e2.framebufferRenderbuffer(e2.FRAMEBUFFER, e2.DEPTH_STENCIL_ATTACHMENT, e2.RENDERBUFFER, t2), this.current = t2, this.dirty = false;
        }
      }

      class Li {
        constructor(t2, e2, i2, a2, s2) {
          this.context = t2, this.width = e2, this.height = i2;
          const o2 = t2.gl, r2 = this.framebuffer = o2.createFramebuffer();
          if (this.colorAttachment = new Ai(t2, r2), a2)
            this.depthAttachment = s2 ? new ki(t2, r2) : new Ri(t2, r2);
          else if (s2)
            throw new Error("Stencil cannot be set without depth");
          if (o2.checkFramebufferStatus(o2.FRAMEBUFFER) !== o2.FRAMEBUFFER_COMPLETE)
            throw new Error("Framebuffer is not complete");
        }
        destroy() {
          const t2 = this.context.gl, e2 = this.colorAttachment.get();
          if (e2 && t2.deleteTexture(e2), this.depthAttachment) {
            const e3 = this.depthAttachment.get();
            e3 && t2.deleteRenderbuffer(e3);
          }
          t2.deleteFramebuffer(this.framebuffer);
        }
      }

      class Fi {
        constructor(t2, e2, i2) {
          this.blendFunction = t2, this.blendColor = e2, this.mask = i2;
        }
      }
      Fi.Replace = [1, 0], Fi.disabled = new Fi(Fi.Replace, e.aM.transparent, [false, false, false, false]), Fi.unblended = new Fi(Fi.Replace, e.aM.transparent, [true, true, true, true]), Fi.alphaBlended = new Fi([1, 771], e.aM.transparent, [true, true, true, true]);

      class Bi {
        constructor(t2) {
          var e2, i2;
          if (this.gl = t2, this.clearColor = new ti(this), this.clearDepth = new ei(this), this.clearStencil = new ii(this), this.colorMask = new ai(this), this.depthMask = new si(this), this.stencilMask = new oi(this), this.stencilFunc = new ri(this), this.stencilOp = new ni(this), this.stencilTest = new li(this), this.depthRange = new hi(this), this.depthTest = new ci(this), this.depthFunc = new ui(this), this.blend = new di(this), this.blendFunc = new _i(this), this.blendColor = new pi(this), this.blendEquation = new mi(this), this.cullFace = new fi(this), this.cullFaceSide = new gi(this), this.frontFace = new vi(this), this.program = new xi(this), this.activeTexture = new yi(this), this.viewport = new bi(this), this.bindFramebuffer = new wi(this), this.bindRenderbuffer = new Ti(this), this.bindTexture = new Ii(this), this.bindVertexBuffer = new Ei(this), this.bindElementBuffer = new Pi(this), this.bindVertexArray = new Ci(this), this.pixelStoreUnpack = new Si(this), this.pixelStoreUnpackPremultiplyAlpha = new zi(this), this.pixelStoreUnpackFlipY = new Di(this), this.extTextureFilterAnisotropic = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE), Ye(t2)) {
            this.HALF_FLOAT = t2.HALF_FLOAT;
            const a2 = t2.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = (e2 = t2.RGBA16F) !== null && e2 !== undefined ? e2 : a2 == null ? undefined : a2.RGBA16F_EXT, this.RGB16F = (i2 = t2.RGB16F) !== null && i2 !== undefined ? i2 : a2 == null ? undefined : a2.RGB16F_EXT, t2.getExtension("EXT_color_buffer_float");
          } else {
            t2.getExtension("EXT_color_buffer_half_float"), t2.getExtension("OES_texture_half_float_linear");
            const e3 = t2.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = e3 == null ? undefined : e3.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
        }
        createIndexBuffer(t2, e2) {
          return new $e(this, t2, e2);
        }
        createVertexBuffer(t2, e2, i2) {
          return new Ke(this, t2, e2, i2);
        }
        createRenderbuffer(t2, e2, i2) {
          const a2 = this.gl, s2 = a2.createRenderbuffer();
          return this.bindRenderbuffer.set(s2), a2.renderbufferStorage(a2.RENDERBUFFER, t2, e2, i2), this.bindRenderbuffer.set(null), s2;
        }
        createFramebuffer(t2, e2, i2, a2) {
          return new Li(this, t2, e2, i2, a2);
        }
        clear({ color: t2, depth: e2, stencil: i2 }) {
          const a2 = this.gl;
          let s2 = 0;
          t2 && (s2 |= a2.COLOR_BUFFER_BIT, this.clearColor.set(t2), this.colorMask.set([true, true, true, true])), e2 !== undefined && (s2 |= a2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e2), this.depthMask.set(true)), i2 !== undefined && (s2 |= a2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), a2.clear(s2);
        }
        setCullFace(t2) {
          t2.enable === false ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t2.mode), this.frontFace.set(t2.frontFace));
        }
        setDepthMode(t2) {
          t2.func !== this.gl.ALWAYS || t2.mask ? (this.depthTest.set(true), this.depthFunc.set(t2.func), this.depthMask.set(t2.mask), this.depthRange.set(t2.range)) : this.depthTest.set(false);
        }
        setStencilMode(t2) {
          t2.test.func !== this.gl.ALWAYS || t2.mask ? (this.stencilTest.set(true), this.stencilMask.set(t2.mask), this.stencilOp.set([t2.fail, t2.depthFail, t2.pass]), this.stencilFunc.set({
            func: t2.test.func,
            ref: t2.ref,
            mask: t2.test.mask
          })) : this.stencilTest.set(false);
        }
        setColorMode(t2) {
          e.aE(t2.blendFunction, Fi.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t2.blendFunction), this.blendColor.set(t2.blendColor)), this.colorMask.set(t2.mask);
        }
        createVertexArray() {
          var t2;
          return Ye(this.gl) ? this.gl.createVertexArray() : (t2 = this.gl.getExtension("OES_vertex_array_object")) === null || t2 === undefined ? undefined : t2.createVertexArrayOES();
        }
        deleteVertexArray(t2) {
          var e2;
          return Ye(this.gl) ? this.gl.deleteVertexArray(t2) : (e2 = this.gl.getExtension("OES_vertex_array_object")) === null || e2 === undefined ? undefined : e2.deleteVertexArrayOES(t2);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }

      class Oi {
        constructor(t2, e2, i2) {
          this.func = t2, this.mask = e2, this.range = i2;
        }
      }
      Oi.ReadOnly = false, Oi.ReadWrite = true, Oi.disabled = new Oi(519, Oi.ReadOnly, [0, 1]);
      const Ni = 7680;

      class Ui {
        constructor(t2, e2, i2, a2, s2, o2) {
          this.test = t2, this.ref = e2, this.mask = i2, this.fail = a2, this.depthFail = s2, this.pass = o2;
        }
      }
      Ui.disabled = new Ui({ func: 519, mask: 0 }, 0, 0, Ni, Ni, Ni);

      class ji {
        constructor(t2, e2, i2) {
          this.enable = t2, this.mode = e2, this.frontFace = i2;
        }
      }
      let Zi;
      function qi(t2, i2, a2, s2, o2) {
        const r2 = t2.context, n2 = r2.gl, l2 = t2.useProgram("collisionBox"), h2 = [];
        let c2 = 0, u2 = 0;
        for (let _3 = 0;_3 < s2.length; _3++) {
          const p3 = s2[_3], m3 = i2.getTile(p3).getBucket(a2);
          if (!m3)
            continue;
          const f3 = o2 ? m3.textCollisionBox : m3.iconCollisionBox, g3 = m3.collisionCircleArray;
          if (g3.length > 0) {
            const i3 = e.H();
            e.aQ(i3, m3.placementInvProjMatrix, t2.transform.glCoordMatrix), e.aQ(i3, i3, m3.placementViewportMatrix), h2.push({
              circleArray: g3,
              circleOffset: u2,
              transform: p3.posMatrix,
              invTransform: i3,
              coord: p3
            }), c2 += g3.length / 4, u2 = c2;
          }
          f3 && l2.draw(r2, n2.LINES, Oi.disabled, Ui.disabled, t2.colorModeForRenderPass(), ji.disabled, {
            u_matrix: p3.posMatrix,
            u_pixel_extrude_scale: [1 / (d2 = t2.transform).width, 1 / d2.height]
          }, t2.style.map.terrain && t2.style.map.terrain.getTerrainData(p3), a2.id, f3.layoutVertexBuffer, f3.indexBuffer, f3.segments, null, t2.transform.zoom, null, null, f3.collisionVertexBuffer);
        }
        var d2;
        if (!o2 || !h2.length)
          return;
        const _2 = t2.useProgram("collisionCircle"), p2 = new e.aR;
        p2.resize(4 * c2), p2._trim();
        let m2 = 0;
        for (const t3 of h2)
          for (let e2 = 0;e2 < t3.circleArray.length / 4; e2++) {
            const i3 = 4 * e2, a3 = t3.circleArray[i3 + 0], s3 = t3.circleArray[i3 + 1], o3 = t3.circleArray[i3 + 2], r3 = t3.circleArray[i3 + 3];
            p2.emplace(m2++, a3, s3, o3, r3, 0), p2.emplace(m2++, a3, s3, o3, r3, 1), p2.emplace(m2++, a3, s3, o3, r3, 2), p2.emplace(m2++, a3, s3, o3, r3, 3);
          }
        (!Zi || Zi.length < 2 * c2) && (Zi = function(t3) {
          const i3 = 2 * t3, a3 = new e.aT;
          a3.resize(i3), a3._trim();
          for (let t4 = 0;t4 < i3; t4++) {
            const e2 = 6 * t4;
            a3.uint16[e2 + 0] = 4 * t4 + 0, a3.uint16[e2 + 1] = 4 * t4 + 1, a3.uint16[e2 + 2] = 4 * t4 + 2, a3.uint16[e2 + 3] = 4 * t4 + 2, a3.uint16[e2 + 4] = 4 * t4 + 3, a3.uint16[e2 + 5] = 4 * t4 + 0;
          }
          return a3;
        }(c2));
        const f2 = r2.createIndexBuffer(Zi, true), g2 = r2.createVertexBuffer(p2, e.aS.members, true);
        for (const i3 of h2) {
          const s3 = Se(i3.transform, i3.invTransform, t2.transform);
          _2.draw(r2, n2.TRIANGLES, Oi.disabled, Ui.disabled, t2.colorModeForRenderPass(), ji.disabled, s3, t2.style.map.terrain && t2.style.map.terrain.getTerrainData(i3.coord), a2.id, g2, f2, e.a0.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, t2.transform.zoom, null, null, null);
        }
        g2.destroy(), f2.destroy();
      }
      ji.disabled = new ji(false, 1029, 2305), ji.backCCW = new ji(true, 1029, 2305);
      const Vi = e.an(new Float32Array(16));
      function Gi(t2, i2, a2, s2, o2, r2) {
        const { horizontalAlign: n2, verticalAlign: l2 } = e.au(t2);
        return new e.P((-(n2 - 0.5) * i2 / o2 + s2[0]) * r2, (-(l2 - 0.5) * a2 / o2 + s2[1]) * r2);
      }
      function Hi(t2, i2, a2, s2, o2, r2) {
        const n2 = i2.tileAnchorPoint.add(new e.P(i2.translation[0], i2.translation[1]));
        if (i2.pitchWithMap) {
          let t3 = s2.mult(r2);
          a2 || (t3 = t3.rotate(-o2));
          const e2 = n2.add(t3);
          return xt(e2.x, e2.y, i2.labelPlaneMatrix, i2.getElevation).point;
        }
        if (a2) {
          const e2 = St(i2.tileAnchorPoint.x + 1, i2.tileAnchorPoint.y, i2).point.sub(t2), a3 = Math.atan(e2.y / e2.x) + (e2.x < 0 ? Math.PI : 0);
          return t2.add(s2.rotate(a3));
        }
        return t2.add(s2);
      }
      function Wi(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u2, d2, _2, p2) {
        const m2 = t2.text.placedSymbolArray, f2 = t2.text.dynamicLayoutVertexArray, g2 = t2.icon.dynamicLayoutVertexArray, v2 = {};
        f2.clear();
        for (let g3 = 0;g3 < m2.length; g3++) {
          const x2 = m2.get(g3), y2 = x2.hidden || !x2.crossTileID || t2.allowVerticalPlacement && !x2.placedOrientation ? null : s2[x2.crossTileID];
          if (y2) {
            const s3 = new e.P(x2.anchorX, x2.anchorY), m3 = {
              getElevation: p2,
              width: o2.width,
              height: o2.height,
              labelPlaneMatrix: r2,
              lineVertexArray: null,
              pitchWithMap: a2,
              projection: u2,
              projectionCache: null,
              tileAnchorPoint: s3,
              translation: d2,
              unwrappedTileID: _2
            }, g4 = a2 ? xt(s3.x, s3.y, n2, p2) : St(s3.x, s3.y, m3), b2 = yt(o2.cameraToCenterDistance, g4.signedDistanceFromCamera);
            let w2 = e.ai(t2.textSizeData, h2, x2) * b2 / e.ap;
            a2 && (w2 *= t2.tilePixelRatio / l2);
            const {
              width: T2,
              height: I2,
              anchor: E2,
              textOffset: P2,
              textBoxScale: C2
            } = y2, S2 = Gi(E2, T2, I2, P2, C2, w2), z2 = u2.getPitchedTextCorrection(o2, s3.add(new e.P(d2[0], d2[1])), _2), D2 = Hi(g4.point, m3, i2, S2, o2.angle, z2), M2 = t2.allowVerticalPlacement && x2.placedOrientation === e.ah.vertical ? Math.PI / 2 : 0;
            for (let t3 = 0;t3 < x2.numGlyphs; t3++)
              e.aj(f2, D2, M2);
            c2 && x2.associatedIconIndex >= 0 && (v2[x2.associatedIconIndex] = { shiftedAnchor: D2, angle: M2 });
          } else
            Rt(x2.numGlyphs, f2);
        }
        if (c2) {
          g2.clear();
          const i3 = t2.icon.placedSymbolArray;
          for (let t3 = 0;t3 < i3.length; t3++) {
            const a3 = i3.get(t3);
            if (a3.hidden)
              Rt(a3.numGlyphs, g2);
            else {
              const i4 = v2[t3];
              if (i4)
                for (let t4 = 0;t4 < a3.numGlyphs; t4++)
                  e.aj(g2, i4.shiftedAnchor, i4.angle);
              else
                Rt(a3.numGlyphs, g2);
            }
          }
          t2.icon.dynamicLayoutVertexBuffer.updateData(g2);
        }
        t2.text.dynamicLayoutVertexBuffer.updateData(f2);
      }
      function $i(t2, e2, i2) {
        return i2.iconsInText && e2 ? "symbolTextAndIcon" : t2 ? "symbolSDF" : "symbolIcon";
      }
      function Xi(t2, i2, a2, s2, o2, r2, n2, l2, h2, c2, u2, d2) {
        const _2 = t2.context, p2 = _2.gl, m2 = t2.transform, f2 = ie(), g2 = l2 === "map", v2 = h2 === "map", x2 = l2 !== "viewport" && a2.layout.get("symbol-placement") !== "point", y2 = g2 && !v2 && !x2, b2 = !v2 && x2, w2 = !a2.layout.get("symbol-sort-key").isConstant();
        let T2 = false;
        const I2 = t2.depthModeForSublayer(0, Oi.ReadOnly), E2 = a2._unevaluatedLayout.hasValue("text-variable-anchor") || a2._unevaluatedLayout.hasValue("text-variable-anchor-offset"), P2 = [], C2 = f2.getCircleRadiusCorrection(m2);
        for (const l3 of s2) {
          const s3 = i2.getTile(l3), h3 = s3.getBucket(a2);
          if (!h3)
            continue;
          const u3 = o2 ? h3.text : h3.icon;
          if (!u3 || !u3.segments.get().length || !u3.hasVisibleVertices)
            continue;
          const d3 = u3.programConfigurations.get(a2.id), _3 = o2 || h3.sdfIcons, I3 = o2 ? h3.textSizeData : h3.iconSizeData, S2 = v2 || m2.pitch !== 0, z2 = t2.useProgram($i(_3, o2, h3), d3), D2 = e.ag(I3, m2.zoom), M2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(l3);
          let A2, R2, k2, L2, F2 = [0, 0], B2 = null;
          if (o2)
            R2 = s3.glyphAtlasTexture, k2 = p2.LINEAR, A2 = s3.glyphAtlasTexture.size, h3.iconsInText && (F2 = s3.imageAtlasTexture.size, B2 = s3.imageAtlasTexture, L2 = S2 || t2.options.rotating || t2.options.zooming || I3.kind === "composite" || I3.kind === "camera" ? p2.LINEAR : p2.NEAREST);
          else {
            const e2 = a2.layout.get("icon-size").constantOr(0) !== 1 || h3.iconsNeedLinear;
            R2 = s3.imageAtlasTexture, k2 = _3 || t2.options.rotating || t2.options.zooming || e2 || S2 ? p2.LINEAR : p2.NEAREST, A2 = s3.imageAtlasTexture.size;
          }
          const O2 = Bt(s3, 1, t2.transform.zoom), N2 = b2 ? l3.posMatrix : Vi, U2 = gt(N2, v2, g2, t2.transform, O2), j2 = vt(N2, v2, g2, t2.transform, O2), Z2 = vt(l3.posMatrix, v2, g2, t2.transform, O2), q2 = f2.translatePosition(t2.transform, s3, r2, n2), V2 = E2 && h3.hasTextData(), G2 = a2.layout.get("icon-text-fit") !== "none" && V2 && h3.hasIconData();
          if (x2) {
            const e2 = t2.style.map.terrain ? (e3, i4) => t2.style.map.terrain.getElevation(l3, e3, i4) : null, i3 = a2.layout.get("text-rotation-alignment") === "map";
            wt(h3, l3.posMatrix, t2, o2, U2, Z2, v2, c2, i3, f2, l3.toUnwrapped(), m2.width, m2.height, q2, e2);
          }
          const H2 = l3.posMatrix, W2 = o2 && E2 || G2, $2 = x2 || W2 ? Vi : U2, X2 = j2, K2 = _3 && a2.paint.get(o2 ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let J2;
          J2 = _3 ? h3.iconsInText ? Ve(I3.kind, D2, y2, v2, x2, W2, t2, H2, $2, X2, q2, A2, F2, C2) : qe(I3.kind, D2, y2, v2, x2, W2, t2, H2, $2, X2, q2, o2, A2, true, C2) : Ze(I3.kind, D2, y2, v2, x2, W2, t2, H2, $2, X2, q2, o2, A2, C2);
          const Y2 = {
            program: z2,
            buffers: u3,
            uniformValues: J2,
            atlasTexture: R2,
            atlasTextureIcon: B2,
            atlasInterpolation: k2,
            atlasInterpolationIcon: L2,
            isSDF: _3,
            hasHalo: K2
          };
          if (w2 && h3.canOverlap) {
            T2 = true;
            const t3 = u3.segments.get();
            for (const i3 of t3)
              P2.push({
                segments: new e.a0([i3]),
                sortKey: i3.sortKey,
                state: Y2,
                terrainData: M2
              });
          } else
            P2.push({ segments: u3.segments, sortKey: 0, state: Y2, terrainData: M2 });
        }
        T2 && P2.sort((t3, e2) => t3.sortKey - e2.sortKey);
        for (const e2 of P2) {
          const i3 = e2.state;
          if (_2.activeTexture.set(p2.TEXTURE0), i3.atlasTexture.bind(i3.atlasInterpolation, p2.CLAMP_TO_EDGE), i3.atlasTextureIcon && (_2.activeTexture.set(p2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, p2.CLAMP_TO_EDGE)), i3.isSDF) {
            const s3 = i3.uniformValues;
            i3.hasHalo && (s3.u_is_halo = 1, Ki(i3.buffers, e2.segments, a2, t2, i3.program, I2, u2, d2, s3, e2.terrainData)), s3.u_is_halo = 0;
          }
          Ki(i3.buffers, e2.segments, a2, t2, i3.program, I2, u2, d2, i3.uniformValues, e2.terrainData);
        }
      }
      function Ki(t2, e2, i2, a2, s2, o2, r2, n2, l2, h2) {
        const c2 = a2.context;
        s2.draw(c2, c2.gl.TRIANGLES, o2, r2, n2, ji.disabled, l2, h2, i2.id, t2.layoutVertexBuffer, t2.indexBuffer, e2, i2.paint, a2.transform.zoom, t2.programConfigurations.get(i2.id), t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer);
      }
      function Ji(t2, i2, a2, s2) {
        const o2 = t2.context, r2 = o2.gl, n2 = Ui.disabled, l2 = new Fi([r2.ONE, r2.ONE], e.aM.transparent, [true, true, true, true]), h2 = i2.getBucket(a2);
        if (!h2)
          return;
        const c2 = s2.key;
        let u2 = a2.heatmapFbos.get(c2);
        u2 || (u2 = Qi(o2, i2.tileSize, i2.tileSize), a2.heatmapFbos.set(c2, u2)), o2.bindFramebuffer.set(u2.framebuffer), o2.viewport.set([0, 0, i2.tileSize, i2.tileSize]), o2.clear({ color: e.aM.transparent });
        const d2 = h2.programConfigurations.get(a2.id), _2 = t2.useProgram("heatmap", d2), p2 = t2.style.map.terrain.getTerrainData(s2);
        _2.draw(o2, r2.TRIANGLES, Oi.disabled, n2, l2, ji.disabled, Me(s2.posMatrix, i2, t2.transform.zoom, a2.paint.get("heatmap-intensity")), p2, a2.id, h2.layoutVertexBuffer, h2.indexBuffer, h2.segments, a2.paint, t2.transform.zoom, d2);
      }
      function Yi(t2, e2, i2) {
        const a2 = t2.context, s2 = a2.gl;
        a2.setColorMode(t2.colorModeForRenderPass());
        const o2 = ta(a2, e2), r2 = i2.key, n2 = e2.heatmapFbos.get(r2);
        n2 && (a2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, n2.colorAttachment.get()), a2.activeTexture.set(s2.TEXTURE1), o2.bind(s2.LINEAR, s2.CLAMP_TO_EDGE), t2.useProgram("heatmapTexture").draw(a2, s2.TRIANGLES, Oi.disabled, Ui.disabled, t2.colorModeForRenderPass(), ji.disabled, Ae(t2, e2, 0, 1), null, e2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments, e2.paint, t2.transform.zoom), n2.destroy(), e2.heatmapFbos.delete(r2));
      }
      function Qi(t2, e2, i2) {
        var a2, s2;
        const o2 = t2.gl, r2 = o2.createTexture();
        o2.bindTexture(o2.TEXTURE_2D, r2), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_S, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_WRAP_T, o2.CLAMP_TO_EDGE), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MIN_FILTER, o2.LINEAR), o2.texParameteri(o2.TEXTURE_2D, o2.TEXTURE_MAG_FILTER, o2.LINEAR);
        const n2 = (a2 = t2.HALF_FLOAT) !== null && a2 !== undefined ? a2 : o2.UNSIGNED_BYTE, l2 = (s2 = t2.RGBA16F) !== null && s2 !== undefined ? s2 : o2.RGBA;
        o2.texImage2D(o2.TEXTURE_2D, 0, l2, e2, i2, 0, o2.RGBA, n2, null);
        const h2 = t2.createFramebuffer(e2, i2, false, false);
        return h2.colorAttachment.set(r2), h2;
      }
      function ta(t2, e2) {
        return e2.colorRampTexture || (e2.colorRampTexture = new b(t2, e2.colorRamp, t2.gl.RGBA)), e2.colorRampTexture;
      }
      function ea(t2, e2, i2, a2, s2) {
        if (!i2 || !a2 || !a2.imageAtlas)
          return;
        const o2 = a2.imageAtlas.patternPositions;
        let r2 = o2[i2.to.toString()], n2 = o2[i2.from.toString()];
        if (!r2 && n2 && (r2 = n2), !n2 && r2 && (n2 = r2), !r2 || !n2) {
          const t3 = s2.getPaintProperty(e2);
          r2 = o2[t3], n2 = o2[t3];
        }
        r2 && n2 && t2.setConstantPatternPositions(r2, n2);
      }
      function ia(t2, e2, i2, a2, s2, o2, r2) {
        const n2 = t2.context.gl, l2 = "fill-pattern", h2 = i2.paint.get(l2), c2 = h2 && h2.constantOr(1), u2 = i2.getCrossfadeParameters();
        let d2, _2, p2, m2, f2;
        r2 ? (_2 = c2 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", d2 = n2.LINES) : (_2 = c2 ? "fillPattern" : "fill", d2 = n2.TRIANGLES);
        const g2 = h2.constantOr(null);
        for (const h3 of a2) {
          const a3 = e2.getTile(h3);
          if (c2 && !a3.patternsLoaded())
            continue;
          const v2 = a3.getBucket(i2);
          if (!v2)
            continue;
          const x2 = v2.programConfigurations.get(i2.id), y2 = t2.useProgram(_2, x2), b2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(h3);
          c2 && (t2.context.activeTexture.set(n2.TEXTURE0), a3.imageAtlasTexture.bind(n2.LINEAR, n2.CLAMP_TO_EDGE), x2.updatePaintBuffers(u2)), ea(x2, l2, g2, a3, i2);
          const w2 = b2 ? h3 : null, T2 = t2.translatePosMatrix(w2 ? w2.posMatrix : h3.posMatrix, a3, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor"));
          if (r2) {
            m2 = v2.indexBuffer2, f2 = v2.segments2;
            const e3 = [n2.drawingBufferWidth, n2.drawingBufferHeight];
            p2 = _2 === "fillOutlinePattern" && c2 ? Pe(T2, t2, u2, a3, e3) : Ee(T2, e3);
          } else
            m2 = v2.indexBuffer, f2 = v2.segments, p2 = c2 ? Ie(T2, t2, u2, a3) : Te(T2);
          y2.draw(t2.context, d2, s2, t2.stencilModeForClipping(h3), o2, ji.disabled, p2, b2, i2.id, v2.layoutVertexBuffer, m2, f2, i2.paint, t2.transform.zoom, x2);
        }
      }
      function aa(t2, e2, i2, a2, s2, o2, r2) {
        const n2 = t2.context, l2 = n2.gl, h2 = "fill-extrusion-pattern", c2 = i2.paint.get(h2), u2 = c2.constantOr(1), d2 = i2.getCrossfadeParameters(), _2 = i2.paint.get("fill-extrusion-opacity"), p2 = c2.constantOr(null);
        for (const c3 of a2) {
          const a3 = e2.getTile(c3), m2 = a3.getBucket(i2);
          if (!m2)
            continue;
          const f2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(c3), g2 = m2.programConfigurations.get(i2.id), v2 = t2.useProgram(u2 ? "fillExtrusionPattern" : "fillExtrusion", g2);
          u2 && (t2.context.activeTexture.set(l2.TEXTURE0), a3.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), g2.updatePaintBuffers(d2)), ea(g2, h2, p2, a3, i2);
          const x2 = t2.translatePosMatrix(c3.posMatrix, a3, i2.paint.get("fill-extrusion-translate"), i2.paint.get("fill-extrusion-translate-anchor")), y2 = i2.paint.get("fill-extrusion-vertical-gradient"), b2 = u2 ? we(x2, t2, y2, _2, c3, d2, a3) : be(x2, t2, y2, _2);
          v2.draw(n2, n2.gl.TRIANGLES, s2, o2, r2, ji.backCCW, b2, f2, i2.id, m2.layoutVertexBuffer, m2.indexBuffer, m2.segments, i2.paint, t2.transform.zoom, g2, t2.style.map.terrain && m2.centroidVertexBuffer);
        }
      }
      function sa(t2, e2, i2, a2, s2, o2, r2) {
        const n2 = t2.context, l2 = n2.gl, h2 = i2.fbo;
        if (!h2)
          return;
        const c2 = t2.useProgram("hillshade"), u2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(e2);
        n2.activeTexture.set(l2.TEXTURE0), l2.bindTexture(l2.TEXTURE_2D, h2.colorAttachment.get()), c2.draw(n2, l2.TRIANGLES, s2, o2, r2, ji.disabled, ((t3, e3, i3, a3) => {
          const s3 = i3.paint.get("hillshade-shadow-color"), o3 = i3.paint.get("hillshade-highlight-color"), r3 = i3.paint.get("hillshade-accent-color");
          let n3 = i3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          i3.paint.get("hillshade-illumination-anchor") === "viewport" && (n3 -= t3.transform.angle);
          const l3 = !t3.options.moving;
          return {
            u_matrix: a3 ? a3.posMatrix : t3.transform.calculatePosMatrix(e3.tileID.toUnwrapped(), l3),
            u_image: 0,
            u_latrange: Re(0, e3.tileID),
            u_light: [i3.paint.get("hillshade-exaggeration"), n3],
            u_shadow: s3,
            u_highlight: o3,
            u_accent: r3
          };
        })(t2, i2, a2, u2 ? e2 : null), u2, a2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
      }
      function oa(t2, i2, a2, s2, o2, r2) {
        const n2 = t2.context, l2 = n2.gl, h2 = i2.dem;
        if (h2 && h2.data) {
          const { dim: c2, stride: u2 } = h2, d2 = h2.getPixels();
          if (n2.activeTexture.set(l2.TEXTURE1), n2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t2.getTileTexture(u2), i2.demTexture) {
            const t3 = i2.demTexture;
            t3.update(d2, { premultiply: false }), t3.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
          } else
            i2.demTexture = new b(n2, d2, l2.RGBA, { premultiply: false }), i2.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
          n2.activeTexture.set(l2.TEXTURE0);
          let _2 = i2.fbo;
          if (!_2) {
            const t3 = new b(n2, { width: c2, height: c2, data: null }, l2.RGBA);
            t3.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), _2 = i2.fbo = n2.createFramebuffer(c2, c2, true, false), _2.colorAttachment.set(t3.texture);
          }
          n2.bindFramebuffer.set(_2.framebuffer), n2.viewport.set([0, 0, c2, c2]), t2.useProgram("hillshadePrepare").draw(n2, l2.TRIANGLES, s2, o2, r2, ji.disabled, ((t3, i3) => {
            const a3 = i3.stride, s3 = e.H();
            return e.aP(s3, 0, e.X, -e.X, 0, 0, 1), e.J(s3, s3, [0, -e.X, 0]), {
              u_matrix: s3,
              u_image: 1,
              u_dimension: [a3, a3],
              u_zoom: t3.overscaledZ,
              u_unpack: i3.getUnpackVector()
            };
          })(i2.tileID, h2), null, a2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments), i2.needsHillshadePrepare = false;
        }
      }
      function ra(t2, i2, a2, s2, r2, n2) {
        const l2 = s2.paint.get("raster-fade-duration");
        if (!n2 && l2 > 0) {
          const s3 = o.now(), n3 = (s3 - t2.timeAdded) / l2, h2 = i2 ? (s3 - i2.timeAdded) / l2 : -1, c2 = a2.getSource(), u2 = r2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), d2 = !i2 || Math.abs(i2.tileID.overscaledZ - u2) > Math.abs(t2.tileID.overscaledZ - u2), _2 = d2 && t2.refreshedUponExpiration ? 1 : e.ac(d2 ? n3 : 1 - h2, 0, 1);
          return t2.refreshedUponExpiration && n3 >= 1 && (t2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - _2 } : { opacity: _2, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const na = new e.aM(1, 0, 0, 1), la = new e.aM(0, 1, 0, 1), ha = new e.aM(0, 0, 1, 1), ca = new e.aM(1, 0, 1, 1), ua = new e.aM(0, 1, 1, 1);
      function da(t2, e2, i2, a2) {
        pa(t2, 0, e2 + i2 / 2, t2.transform.width, i2, a2);
      }
      function _a(t2, e2, i2, a2) {
        pa(t2, e2 - i2 / 2, 0, i2, t2.transform.height, a2);
      }
      function pa(t2, e2, i2, a2, s2, o2) {
        const r2 = t2.context, n2 = r2.gl;
        n2.enable(n2.SCISSOR_TEST), n2.scissor(e2 * t2.pixelRatio, i2 * t2.pixelRatio, a2 * t2.pixelRatio, s2 * t2.pixelRatio), r2.clear({ color: o2 }), n2.disable(n2.SCISSOR_TEST);
      }
      function ma(t2, i2, a2) {
        const s2 = t2.context, o2 = s2.gl, r2 = a2.posMatrix, n2 = t2.useProgram("debug"), l2 = Oi.disabled, h2 = Ui.disabled, c2 = t2.colorModeForRenderPass(), u2 = "$debug", d2 = t2.style.map.terrain && t2.style.map.terrain.getTerrainData(a2);
        s2.activeTexture.set(o2.TEXTURE0);
        const _2 = i2.getTileByID(a2.key).latestRawTileData, p2 = Math.floor((_2 && _2.byteLength || 0) / 1024), m2 = i2.getTile(a2).tileSize, f2 = 512 / Math.min(m2, 512) * (a2.overscaledZ / t2.transform.zoom) * 0.5;
        let g2 = a2.canonical.toString();
        a2.overscaledZ !== a2.canonical.z && (g2 += ` => ${a2.overscaledZ}`), function(t3, e2) {
          t3.initDebugOverlayCanvas();
          const i3 = t3.debugOverlayCanvas, a3 = t3.context.gl, s3 = t3.debugOverlayCanvas.getContext("2d");
          s3.clearRect(0, 0, i3.width, i3.height), s3.shadowColor = "white", s3.shadowBlur = 2, s3.lineWidth = 1.5, s3.strokeStyle = "white", s3.textBaseline = "top", s3.font = "bold 36px Open Sans, sans-serif", s3.fillText(e2, 5, 5), s3.strokeText(e2, 5, 5), t3.debugOverlayTexture.update(i3), t3.debugOverlayTexture.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
        }(t2, `${g2} ${p2}kB`), n2.draw(s2, o2.TRIANGLES, l2, h2, Fi.alphaBlended, ji.disabled, ze(r2, e.aM.transparent, f2), null, u2, t2.debugBuffer, t2.quadTriangleIndexBuffer, t2.debugSegments), n2.draw(s2, o2.LINE_STRIP, l2, h2, c2, ji.disabled, ze(r2, e.aM.red), d2, u2, t2.debugBuffer, t2.tileBorderIndexBuffer, t2.debugSegments);
      }
      function fa(t2, e2, i2) {
        const a2 = t2.context, s2 = a2.gl, o2 = t2.colorModeForRenderPass(), r2 = new Oi(s2.LEQUAL, Oi.ReadWrite, t2.depthRangeFor3D), n2 = t2.useProgram("terrain"), l2 = e2.getTerrainMesh();
        a2.bindFramebuffer.set(null), a2.viewport.set([0, 0, t2.width, t2.height]);
        for (const h2 of i2) {
          const i3 = t2.renderToTexture.getTexture(h2), c2 = e2.getTerrainData(h2.tileID);
          a2.activeTexture.set(s2.TEXTURE0), s2.bindTexture(s2.TEXTURE_2D, i3.texture);
          const u2 = t2.transform.calculatePosMatrix(h2.tileID.toUnwrapped()), d2 = e2.getMeshFrameDelta(t2.transform.zoom), _2 = t2.transform.calculateFogMatrix(h2.tileID.toUnwrapped()), p2 = ge(u2, d2, _2, t2.style.sky, t2.transform.pitch);
          n2.draw(a2, s2.TRIANGLES, r2, Ui.disabled, o2, ji.backCCW, p2, c2, "terrain", l2.vertexBuffer, l2.indexBuffer, l2.segments);
        }
      }

      class ga {
        constructor(t2, e2, i2) {
          this.vertexBuffer = t2, this.indexBuffer = e2, this.segments = i2;
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
        }
      }

      class va {
        constructor(t2, i2) {
          this.context = new Bi(t2), this.transform = i2, this._tileTextures = {}, this.terrainFacilitator = {
            dirty: true,
            matrix: e.an(new Float64Array(16)),
            renderTime: 0
          }, this.setup(), this.numSublayers = ut.maxUnderzooming + ut.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new he;
        }
        resize(t2, e2, i2) {
          if (this.width = Math.floor(t2 * i2), this.height = Math.floor(e2 * i2), this.pixelRatio = i2, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
            for (const t3 of this.style._order)
              this.style._layers[t3].resize();
        }
        setup() {
          const t2 = this.context, i2 = new e.aX;
          i2.emplaceBack(0, 0), i2.emplaceBack(e.X, 0), i2.emplaceBack(0, e.X), i2.emplaceBack(e.X, e.X), this.tileExtentBuffer = t2.createVertexBuffer(i2, _e.members), this.tileExtentSegments = e.a0.simpleSegment(0, 0, 4, 2);
          const a2 = new e.aX;
          a2.emplaceBack(0, 0), a2.emplaceBack(e.X, 0), a2.emplaceBack(0, e.X), a2.emplaceBack(e.X, e.X), this.debugBuffer = t2.createVertexBuffer(a2, _e.members), this.debugSegments = e.a0.simpleSegment(0, 0, 4, 5);
          const s2 = new e.$;
          s2.emplaceBack(0, 0, 0, 0), s2.emplaceBack(e.X, 0, e.X, 0), s2.emplaceBack(0, e.X, 0, e.X), s2.emplaceBack(e.X, e.X, e.X, e.X), this.rasterBoundsBuffer = t2.createVertexBuffer(s2, Y.members), this.rasterBoundsSegments = e.a0.simpleSegment(0, 0, 4, 2);
          const o2 = new e.aX;
          o2.emplaceBack(0, 0), o2.emplaceBack(1, 0), o2.emplaceBack(0, 1), o2.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(o2, _e.members), this.viewportSegments = e.a0.simpleSegment(0, 0, 4, 2);
          const r2 = new e.aZ;
          r2.emplaceBack(0), r2.emplaceBack(1), r2.emplaceBack(3), r2.emplaceBack(2), r2.emplaceBack(0), this.tileBorderIndexBuffer = t2.createIndexBuffer(r2);
          const n2 = new e.aY;
          n2.emplaceBack(0, 1, 2), n2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(n2);
          const l2 = this.context.gl;
          this.stencilClearMode = new Ui({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO);
        }
        clearStencil() {
          const t2 = this.context, i2 = t2.gl;
          this.nextStencilID = 1, this.currentStencilSource = undefined;
          const a2 = e.H();
          e.aP(a2, 0, this.width, this.height, 0, 0, 1), e.K(a2, a2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(t2, i2.TRIANGLES, Oi.disabled, this.stencilClearMode, Fi.disabled, ji.disabled, De(a2), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(t2, e2) {
          if (this.currentStencilSource === t2.source || !t2.isTileClipped() || !e2 || !e2.length)
            return;
          this.currentStencilSource = t2.source;
          const i2 = this.context, a2 = i2.gl;
          this.nextStencilID + e2.length > 256 && this.clearStencil(), i2.setColorMode(Fi.disabled), i2.setDepthMode(Oi.disabled);
          const s2 = this.useProgram("clippingMask");
          this._tileClippingMaskIDs = {};
          for (const t3 of e2) {
            const e3 = this._tileClippingMaskIDs[t3.key] = this.nextStencilID++, o2 = this.style.map.terrain && this.style.map.terrain.getTerrainData(t3);
            s2.draw(i2, a2.TRIANGLES, Oi.disabled, new Ui({ func: a2.ALWAYS, mask: 0 }, e3, 255, a2.KEEP, a2.KEEP, a2.REPLACE), Fi.disabled, ji.disabled, De(t3.posMatrix), o2, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = undefined, this.nextStencilID + 1 > 256 && this.clearStencil();
          const t2 = this.nextStencilID++, e2 = this.context.gl;
          return new Ui({ func: e2.NOTEQUAL, mask: 255 }, t2, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
        }
        stencilModeForClipping(t2) {
          const e2 = this.context.gl;
          return new Ui({ func: e2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, e2.KEEP, e2.KEEP, e2.REPLACE);
        }
        stencilConfigForOverlap(t2) {
          const e2 = this.context.gl, i2 = t2.sort((t3, e3) => e3.overscaledZ - t3.overscaledZ), a2 = i2[i2.length - 1].overscaledZ, s2 = i2[0].overscaledZ - a2 + 1;
          if (s2 > 1) {
            this.currentStencilSource = undefined, this.nextStencilID + s2 > 256 && this.clearStencil();
            const t3 = {};
            for (let i3 = 0;i3 < s2; i3++)
              t3[i3 + a2] = new Ui({ func: e2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
            return this.nextStencilID += s2, [t3, i2];
          }
          return [{ [a2]: Ui.disabled }, i2];
        }
        colorModeForRenderPass() {
          const t2 = this.context.gl;
          if (this._showOverdrawInspector) {
            const i2 = 1 / 8;
            return new Fi([t2.CONSTANT_COLOR, t2.ONE], new e.aM(i2, i2, i2, 0), [
              true,
              true,
              true,
              true
            ]);
          }
          return this.renderPass === "opaque" ? Fi.unblended : Fi.alphaBlended;
        }
        depthModeForSublayer(t2, e2, i2) {
          if (!this.opaquePassEnabledForLayer())
            return Oi.disabled;
          const a2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
          return new Oi(i2 || this.context.gl.LEQUAL, e2, [a2, a2]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(t2, i2) {
          this.style = t2, this.options = i2, this.lineAtlas = t2.lineAtlas, this.imageManager = t2.imageManager, this.glyphManager = t2.glyphManager, this.symbolFadeChange = t2.placement.symbolFadeChange(o.now()), this.imageManager.beginFrame();
          const a2 = this.style._order, s2 = this.style.sourceCaches, r2 = {}, n2 = {}, l2 = {};
          for (const t3 in s2) {
            const e2 = s2[t3];
            e2.used && e2.prepare(this.context), r2[t3] = e2.getVisibleCoordinates(), n2[t3] = r2[t3].slice().reverse(), l2[t3] = e2.getVisibleCoordinates(true).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let t3 = 0;t3 < a2.length; t3++)
            if (this.style._layers[a2[t3]].is3D()) {
              this.opaquePassCutoff = t3;
              break;
            }
          this.maybeDrawDepthAndCoords(false), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
          for (const t3 of a2) {
            const e2 = this.style._layers[t3];
            if (!e2.hasOffscreenPass() || e2.isHidden(this.transform.zoom))
              continue;
            const i3 = n2[e2.source];
            (e2.type === "custom" || i3.length) && this.renderLayer(this, s2[e2.source], e2, i3);
          }
          if (this.context.bindFramebuffer.set(null), this.context.clear({
            color: i2.showOverdrawInspector ? e.aM.black : e.aM.transparent,
            depth: 1
          }), this.clearStencil(), this.style.sky && function(t3, i3) {
            const a3 = t3.context, s3 = a3.gl, o2 = ((t4, e2, i4) => ({
              u_sky_color: t4.properties.get("sky-color"),
              u_horizon_color: t4.properties.get("horizon-color"),
              u_horizon: (e2.height / 2 + e2.getHorizon()) * i4,
              u_sky_horizon_blend: t4.properties.get("sky-horizon-blend") * e2.height / 2 * i4
            }))(i3, t3.style.map.transform, t3.pixelRatio), r3 = new Oi(s3.LEQUAL, Oi.ReadWrite, [0, 1]), n3 = Ui.disabled, l3 = t3.colorModeForRenderPass(), h2 = t3.useProgram("sky");
            if (!i3.mesh) {
              const t4 = new e.aX;
              t4.emplaceBack(-1, -1), t4.emplaceBack(1, -1), t4.emplaceBack(1, 1), t4.emplaceBack(-1, 1);
              const s4 = new e.aY;
              s4.emplaceBack(0, 1, 2), s4.emplaceBack(0, 2, 3), i3.mesh = new ga(a3.createVertexBuffer(t4, _e.members), a3.createIndexBuffer(s4), e.a0.simpleSegment(0, 0, t4.length, s4.length));
            }
            h2.draw(a3, s3.TRIANGLES, r3, n3, l3, ji.disabled, o2, undefined, "sky", i3.mesh.vertexBuffer, i3.mesh.indexBuffer, i3.mesh.segments);
          }(this, this.style.sky), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [
            0,
            1 - (t2._order.length + 2) * this.numSublayers * this.depthEpsilon
          ], !this.renderToTexture)
            for (this.renderPass = "opaque", this.currentLayer = a2.length - 1;this.currentLayer >= 0; this.currentLayer--) {
              const t3 = this.style._layers[a2[this.currentLayer]], e2 = s2[t3.source], i3 = r2[t3.source];
              this._renderTileClippingMasks(t3, i3), this.renderLayer(this, e2, t3, i3);
            }
          for (this.renderPass = "translucent", this.currentLayer = 0;this.currentLayer < a2.length; this.currentLayer++) {
            const t3 = this.style._layers[a2[this.currentLayer]], e2 = s2[t3.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer(t3))
              continue;
            const i3 = (t3.type === "symbol" ? l2 : n2)[t3.source];
            this._renderTileClippingMasks(t3, r2[t3.source]), this.renderLayer(this, e2, t3, i3);
          }
          if (this.options.showTileBoundaries) {
            const t3 = function(t4, e2) {
              let i3 = null;
              const a3 = Object.values(t4._layers).flatMap((i4) => i4.source && !i4.isHidden(e2) ? [t4.sourceCaches[i4.source]] : []), s3 = a3.filter((t5) => t5.getSource().type === "vector"), o2 = a3.filter((t5) => t5.getSource().type !== "vector"), r3 = (t5) => {
                (!i3 || i3.getSource().maxzoom < t5.getSource().maxzoom) && (i3 = t5);
              };
              return s3.forEach((t5) => r3(t5)), i3 || o2.forEach((t5) => r3(t5)), i3;
            }(this.style, this.transform.zoom);
            t3 && function(t4, e2, i3) {
              for (let a3 = 0;a3 < i3.length; a3++)
                ma(t4, e2, i3[a3]);
            }(this, t3, t3.getVisibleCoordinates());
          }
          this.options.showPadding && function(t3) {
            const e2 = t3.transform.padding;
            da(t3, t3.transform.height - (e2.top || 0), 3, na), da(t3, e2.bottom || 0, 3, la), _a(t3, e2.left || 0, 3, ha), _a(t3, t3.transform.width - (e2.right || 0), 3, ca);
            const i3 = t3.transform.centerPoint;
            (function(t4, e3, i4, a3) {
              pa(t4, e3 - 1, i4 - 10, 2, 20, a3), pa(t4, e3 - 10, i4 - 1, 20, 2, a3);
            })(t3, i3.x, t3.transform.height - i3.y, ua);
          }(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(t2) {
          if (!this.style || !this.style.map || !this.style.map.terrain)
            return;
          const i2 = this.terrainFacilitator.matrix, a2 = this.transform.modelViewProjectionMatrix;
          let s2 = this.terrainFacilitator.dirty;
          s2 || (s2 = t2 ? !e.a_(i2, a2) : !e.a$(i2, a2)), s2 || (s2 = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime).length > 0), s2 && (e.b0(i2, a2), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(t3, i3) {
            const a3 = t3.context, s3 = a3.gl, o2 = Fi.unblended, r2 = new Oi(s3.LEQUAL, Oi.ReadWrite, [0, 1]), n2 = i3.getTerrainMesh(), l2 = i3.sourceCache.getRenderableTiles(), h2 = t3.useProgram("terrainDepth");
            a3.bindFramebuffer.set(i3.getFramebuffer("depth").framebuffer), a3.viewport.set([
              0,
              0,
              t3.width / devicePixelRatio,
              t3.height / devicePixelRatio
            ]), a3.clear({ color: e.aM.transparent, depth: 1 });
            for (const e2 of l2) {
              const l3 = i3.getTerrainData(e2.tileID), c2 = {
                u_matrix: t3.transform.calculatePosMatrix(e2.tileID.toUnwrapped()),
                u_ele_delta: i3.getMeshFrameDelta(t3.transform.zoom)
              };
              h2.draw(a3, s3.TRIANGLES, r2, Ui.disabled, o2, ji.backCCW, c2, l3, "terrain", n2.vertexBuffer, n2.indexBuffer, n2.segments);
            }
            a3.bindFramebuffer.set(null), a3.viewport.set([0, 0, t3.width, t3.height]);
          }(this, this.style.map.terrain), function(t3, i3) {
            const a3 = t3.context, s3 = a3.gl, o2 = Fi.unblended, r2 = new Oi(s3.LEQUAL, Oi.ReadWrite, [0, 1]), n2 = i3.getTerrainMesh(), l2 = i3.getCoordsTexture(), h2 = i3.sourceCache.getRenderableTiles(), c2 = t3.useProgram("terrainCoords");
            a3.bindFramebuffer.set(i3.getFramebuffer("coords").framebuffer), a3.viewport.set([
              0,
              0,
              t3.width / devicePixelRatio,
              t3.height / devicePixelRatio
            ]), a3.clear({ color: e.aM.transparent, depth: 1 }), i3.coordsIndex = [];
            for (const e2 of h2) {
              const h3 = i3.getTerrainData(e2.tileID);
              a3.activeTexture.set(s3.TEXTURE0), s3.bindTexture(s3.TEXTURE_2D, l2.texture);
              const u2 = {
                u_matrix: t3.transform.calculatePosMatrix(e2.tileID.toUnwrapped()),
                u_terrain_coords_id: (255 - i3.coordsIndex.length) / 255,
                u_texture: 0,
                u_ele_delta: i3.getMeshFrameDelta(t3.transform.zoom)
              };
              c2.draw(a3, s3.TRIANGLES, r2, Ui.disabled, o2, ji.backCCW, u2, h3, "terrain", n2.vertexBuffer, n2.indexBuffer, n2.segments), i3.coordsIndex.push(e2.tileID.key);
            }
            a3.bindFramebuffer.set(null), a3.viewport.set([0, 0, t3.width, t3.height]);
          }(this, this.style.map.terrain));
        }
        renderLayer(t2, i2, a2, s2) {
          if (!a2.isHidden(this.transform.zoom) && (a2.type === "background" || a2.type === "custom" || (s2 || []).length))
            switch (this.id = a2.id, a2.type) {
              case "symbol":
                (function(t3, i3, a3, s3, o2) {
                  if (t3.renderPass !== "translucent")
                    return;
                  const r2 = Ui.disabled, n2 = t3.colorModeForRenderPass();
                  (a3._unevaluatedLayout.hasValue("text-variable-anchor") || a3._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(t4, i4, a4, s4, o3, r3, n3, l2, h2) {
                    const c2 = i4.transform, u2 = ie(), d2 = o3 === "map", _2 = r3 === "map";
                    for (const o4 of t4) {
                      const t5 = s4.getTile(o4), r4 = t5.getBucket(a4);
                      if (!r4 || !r4.text || !r4.text.segments.get().length)
                        continue;
                      const p2 = e.ag(r4.textSizeData, c2.zoom), m2 = Bt(t5, 1, i4.transform.zoom), f2 = gt(o4.posMatrix, _2, d2, i4.transform, m2), g2 = a4.layout.get("icon-text-fit") !== "none" && r4.hasIconData();
                      if (p2) {
                        const e2 = Math.pow(2, c2.zoom - t5.tileID.overscaledZ), a5 = i4.style.map.terrain ? (t6, e3) => i4.style.map.terrain.getElevation(o4, t6, e3) : null, s5 = u2.translatePosition(c2, t5, n3, l2);
                        Wi(r4, d2, _2, h2, c2, f2, o4.posMatrix, e2, p2, g2, u2, s5, o4.toUnwrapped(), a5);
                      }
                    }
                  }(s3, t3, a3, i3, a3.layout.get("text-rotation-alignment"), a3.layout.get("text-pitch-alignment"), a3.paint.get("text-translate"), a3.paint.get("text-translate-anchor"), o2), a3.paint.get("icon-opacity").constantOr(1) !== 0 && Xi(t3, i3, a3, s3, false, a3.paint.get("icon-translate"), a3.paint.get("icon-translate-anchor"), a3.layout.get("icon-rotation-alignment"), a3.layout.get("icon-pitch-alignment"), a3.layout.get("icon-keep-upright"), r2, n2), a3.paint.get("text-opacity").constantOr(1) !== 0 && Xi(t3, i3, a3, s3, true, a3.paint.get("text-translate"), a3.paint.get("text-translate-anchor"), a3.layout.get("text-rotation-alignment"), a3.layout.get("text-pitch-alignment"), a3.layout.get("text-keep-upright"), r2, n2), i3.map.showCollisionBoxes && (qi(t3, i3, a3, s3, true), qi(t3, i3, a3, s3, false));
                })(t2, i2, a2, s2, this.style.placement.variableOffsets);
                break;
              case "circle":
                (function(t3, i3, a3, s3) {
                  if (t3.renderPass !== "translucent")
                    return;
                  const o2 = a3.paint.get("circle-opacity"), r2 = a3.paint.get("circle-stroke-width"), n2 = a3.paint.get("circle-stroke-opacity"), l2 = !a3.layout.get("circle-sort-key").isConstant();
                  if (o2.constantOr(1) === 0 && (r2.constantOr(1) === 0 || n2.constantOr(1) === 0))
                    return;
                  const h2 = t3.context, c2 = h2.gl, u2 = t3.depthModeForSublayer(0, Oi.ReadOnly), d2 = Ui.disabled, _2 = t3.colorModeForRenderPass(), p2 = [];
                  for (let o3 = 0;o3 < s3.length; o3++) {
                    const r3 = s3[o3], n3 = i3.getTile(r3), h3 = n3.getBucket(a3);
                    if (!h3)
                      continue;
                    const c3 = h3.programConfigurations.get(a3.id), u3 = t3.useProgram("circle", c3), d3 = h3.layoutVertexBuffer, _3 = h3.indexBuffer, m2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(r3), f2 = {
                      programConfiguration: c3,
                      program: u3,
                      layoutVertexBuffer: d3,
                      indexBuffer: _3,
                      uniformValues: Ce(t3, r3, n3, a3),
                      terrainData: m2
                    };
                    if (l2) {
                      const t4 = h3.segments.get();
                      for (const i4 of t4)
                        p2.push({ segments: new e.a0([i4]), sortKey: i4.sortKey, state: f2 });
                    } else
                      p2.push({ segments: h3.segments, sortKey: 0, state: f2 });
                  }
                  l2 && p2.sort((t4, e2) => t4.sortKey - e2.sortKey);
                  for (const e2 of p2) {
                    const {
                      programConfiguration: i4,
                      program: s4,
                      layoutVertexBuffer: o3,
                      indexBuffer: r3,
                      uniformValues: n3,
                      terrainData: l3
                    } = e2.state;
                    s4.draw(h2, c2.TRIANGLES, u2, d2, _2, ji.disabled, n3, l3, a3.id, o3, r3, e2.segments, a3.paint, t3.transform.zoom, i4);
                  }
                })(t2, i2, a2, s2);
                break;
              case "heatmap":
                (function(t3, i3, a3, s3) {
                  if (a3.paint.get("heatmap-opacity") === 0)
                    return;
                  const o2 = t3.context;
                  if (t3.style.map.terrain) {
                    for (const e2 of s3) {
                      const s4 = i3.getTile(e2);
                      i3.hasRenderableParent(e2) || (t3.renderPass === "offscreen" ? Ji(t3, s4, a3, e2) : t3.renderPass === "translucent" && Yi(t3, a3, e2));
                    }
                    o2.viewport.set([0, 0, t3.width, t3.height]);
                  } else
                    t3.renderPass === "offscreen" ? function(t4, i4, a4, s4) {
                      const o3 = t4.context, r2 = o3.gl, n2 = Ui.disabled, l2 = new Fi([r2.ONE, r2.ONE], e.aM.transparent, [true, true, true, true]);
                      (function(t5, i5, a5) {
                        const s5 = t5.gl;
                        t5.activeTexture.set(s5.TEXTURE1), t5.viewport.set([0, 0, i5.width / 4, i5.height / 4]);
                        let o4 = a5.heatmapFbos.get(e.aU);
                        o4 ? (s5.bindTexture(s5.TEXTURE_2D, o4.colorAttachment.get()), t5.bindFramebuffer.set(o4.framebuffer)) : (o4 = Qi(t5, i5.width / 4, i5.height / 4), a5.heatmapFbos.set(e.aU, o4));
                      })(o3, t4, a4), o3.clear({ color: e.aM.transparent });
                      for (let e2 = 0;e2 < s4.length; e2++) {
                        const h2 = s4[e2];
                        if (i4.hasRenderableParent(h2))
                          continue;
                        const c2 = i4.getTile(h2), u2 = c2.getBucket(a4);
                        if (!u2)
                          continue;
                        const d2 = u2.programConfigurations.get(a4.id), _2 = t4.useProgram("heatmap", d2), { zoom: p2 } = t4.transform;
                        _2.draw(o3, r2.TRIANGLES, Oi.disabled, n2, l2, ji.disabled, Me(h2.posMatrix, c2, p2, a4.paint.get("heatmap-intensity")), null, a4.id, u2.layoutVertexBuffer, u2.indexBuffer, u2.segments, a4.paint, t4.transform.zoom, d2);
                      }
                      o3.viewport.set([0, 0, t4.width, t4.height]);
                    }(t3, i3, a3, s3) : t3.renderPass === "translucent" && function(t4, i4) {
                      const a4 = t4.context, s4 = a4.gl;
                      a4.setColorMode(t4.colorModeForRenderPass());
                      const o3 = i4.heatmapFbos.get(e.aU);
                      o3 && (a4.activeTexture.set(s4.TEXTURE0), s4.bindTexture(s4.TEXTURE_2D, o3.colorAttachment.get()), a4.activeTexture.set(s4.TEXTURE1), ta(a4, i4).bind(s4.LINEAR, s4.CLAMP_TO_EDGE), t4.useProgram("heatmapTexture").draw(a4, s4.TRIANGLES, Oi.disabled, Ui.disabled, t4.colorModeForRenderPass(), ji.disabled, Ae(t4, i4, 0, 1), null, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments, i4.paint, t4.transform.zoom));
                    }(t3, a3);
                })(t2, i2, a2, s2);
                break;
              case "line":
                (function(t3, i3, a3, s3) {
                  if (t3.renderPass !== "translucent")
                    return;
                  const o2 = a3.paint.get("line-opacity"), r2 = a3.paint.get("line-width");
                  if (o2.constantOr(1) === 0 || r2.constantOr(1) === 0)
                    return;
                  const n2 = t3.depthModeForSublayer(0, Oi.ReadOnly), l2 = t3.colorModeForRenderPass(), h2 = a3.paint.get("line-dasharray"), c2 = a3.paint.get("line-pattern"), u2 = c2.constantOr(1), d2 = a3.paint.get("line-gradient"), _2 = a3.getCrossfadeParameters(), p2 = u2 ? "linePattern" : h2 ? "lineSDF" : d2 ? "lineGradient" : "line", m2 = t3.context, f2 = m2.gl;
                  let g2 = true;
                  for (const o3 of s3) {
                    const s4 = i3.getTile(o3);
                    if (u2 && !s4.patternsLoaded())
                      continue;
                    const r3 = s4.getBucket(a3);
                    if (!r3)
                      continue;
                    const v2 = r3.programConfigurations.get(a3.id), x2 = t3.context.program.get(), y2 = t3.useProgram(p2, v2), w2 = g2 || y2.program !== x2, T2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(o3), I2 = c2.constantOr(null);
                    if (I2 && s4.imageAtlas) {
                      const t4 = s4.imageAtlas, e2 = t4.patternPositions[I2.to.toString()], i4 = t4.patternPositions[I2.from.toString()];
                      e2 && i4 && v2.setConstantPatternPositions(e2, i4);
                    }
                    const E2 = T2 ? o3 : null, P2 = u2 ? Fe(t3, s4, a3, _2, E2) : h2 ? Be(t3, s4, a3, h2, _2, E2) : d2 ? Le(t3, s4, a3, r3.lineClipsArray.length, E2) : ke(t3, s4, a3, E2);
                    if (u2)
                      m2.activeTexture.set(f2.TEXTURE0), s4.imageAtlasTexture.bind(f2.LINEAR, f2.CLAMP_TO_EDGE), v2.updatePaintBuffers(_2);
                    else if (h2 && (w2 || t3.lineAtlas.dirty))
                      m2.activeTexture.set(f2.TEXTURE0), t3.lineAtlas.bind(m2);
                    else if (d2) {
                      const s5 = r3.gradients[a3.id];
                      let n3 = s5.texture;
                      if (a3.gradientVersion !== s5.version) {
                        let l3 = 256;
                        if (a3.stepInterpolant) {
                          const a4 = i3.getSource().maxzoom, s6 = o3.canonical.z === a4 ? Math.ceil(1 << t3.transform.maxZoom - o3.canonical.z) : 1;
                          l3 = e.ac(e.aV(r3.maxLineLength / e.X * 1024 * s6), 256, m2.maxTextureSize);
                        }
                        s5.gradient = e.aW({
                          expression: a3.gradientExpression(),
                          evaluationKey: "lineProgress",
                          resolution: l3,
                          image: s5.gradient || undefined,
                          clips: r3.lineClipsArray
                        }), s5.texture ? s5.texture.update(s5.gradient) : s5.texture = new b(m2, s5.gradient, f2.RGBA), s5.version = a3.gradientVersion, n3 = s5.texture;
                      }
                      m2.activeTexture.set(f2.TEXTURE0), n3.bind(a3.stepInterpolant ? f2.NEAREST : f2.LINEAR, f2.CLAMP_TO_EDGE);
                    }
                    y2.draw(m2, f2.TRIANGLES, n2, t3.stencilModeForClipping(o3), l2, ji.disabled, P2, T2, a3.id, r3.layoutVertexBuffer, r3.indexBuffer, r3.segments, a3.paint, t3.transform.zoom, v2, r3.layoutVertexBuffer2), g2 = false;
                  }
                })(t2, i2, a2, s2);
                break;
              case "fill":
                (function(t3, i3, a3, s3) {
                  const o2 = a3.paint.get("fill-color"), r2 = a3.paint.get("fill-opacity");
                  if (r2.constantOr(1) === 0)
                    return;
                  const n2 = t3.colorModeForRenderPass(), l2 = a3.paint.get("fill-pattern"), h2 = t3.opaquePassEnabledForLayer() && !l2.constantOr(1) && o2.constantOr(e.aM.transparent).a === 1 && r2.constantOr(0) === 1 ? "opaque" : "translucent";
                  if (t3.renderPass === h2) {
                    const e2 = t3.depthModeForSublayer(1, t3.renderPass === "opaque" ? Oi.ReadWrite : Oi.ReadOnly);
                    ia(t3, i3, a3, s3, e2, n2, false);
                  }
                  if (t3.renderPass === "translucent" && a3.paint.get("fill-antialias")) {
                    const e2 = t3.depthModeForSublayer(a3.getPaintProperty("fill-outline-color") ? 2 : 0, Oi.ReadOnly);
                    ia(t3, i3, a3, s3, e2, n2, true);
                  }
                })(t2, i2, a2, s2);
                break;
              case "fill-extrusion":
                (function(t3, e2, i3, a3) {
                  const s3 = i3.paint.get("fill-extrusion-opacity");
                  if (s3 !== 0 && t3.renderPass === "translucent") {
                    const o2 = new Oi(t3.context.gl.LEQUAL, Oi.ReadWrite, t3.depthRangeFor3D);
                    if (s3 !== 1 || i3.paint.get("fill-extrusion-pattern").constantOr(1))
                      aa(t3, e2, i3, a3, o2, Ui.disabled, Fi.disabled), aa(t3, e2, i3, a3, o2, t3.stencilModeFor3D(), t3.colorModeForRenderPass());
                    else {
                      const s4 = t3.colorModeForRenderPass();
                      aa(t3, e2, i3, a3, o2, Ui.disabled, s4);
                    }
                  }
                })(t2, i2, a2, s2);
                break;
              case "hillshade":
                (function(t3, e2, i3, a3) {
                  if (t3.renderPass !== "offscreen" && t3.renderPass !== "translucent")
                    return;
                  const s3 = t3.context, o2 = t3.depthModeForSublayer(0, Oi.ReadOnly), r2 = t3.colorModeForRenderPass(), [n2, l2] = t3.renderPass === "translucent" ? t3.stencilConfigForOverlap(a3) : [{}, a3];
                  for (const a4 of l2) {
                    const s4 = e2.getTile(a4);
                    s4.needsHillshadePrepare !== undefined && s4.needsHillshadePrepare && t3.renderPass === "offscreen" ? oa(t3, s4, i3, o2, Ui.disabled, r2) : t3.renderPass === "translucent" && sa(t3, a4, s4, i3, o2, n2[a4.overscaledZ], r2);
                  }
                  s3.viewport.set([0, 0, t3.width, t3.height]);
                })(t2, i2, a2, s2);
                break;
              case "raster":
                (function(t3, e2, i3, a3) {
                  if (t3.renderPass !== "translucent")
                    return;
                  if (i3.paint.get("raster-opacity") === 0)
                    return;
                  if (!a3.length)
                    return;
                  const s3 = t3.context, o2 = s3.gl, r2 = e2.getSource(), n2 = t3.useProgram("raster"), l2 = t3.colorModeForRenderPass(), [h2, c2] = r2 instanceof Q ? [{}, a3] : t3.stencilConfigForOverlap(a3), u2 = c2[c2.length - 1].overscaledZ, d2 = !t3.options.moving;
                  for (const a4 of c2) {
                    const c3 = t3.depthModeForSublayer(a4.overscaledZ - u2, i3.paint.get("raster-opacity") === 1 ? Oi.ReadWrite : Oi.ReadOnly, o2.LESS), _2 = e2.getTile(a4);
                    _2.registerFadeDuration(i3.paint.get("raster-fade-duration"));
                    const p2 = e2.findLoadedParent(a4, 0), m2 = e2.findLoadedSibling(a4), f2 = ra(_2, p2 || m2 || null, e2, i3, t3.transform, t3.style.map.terrain);
                    let g2, v2;
                    const x2 = i3.paint.get("raster-resampling") === "nearest" ? o2.NEAREST : o2.LINEAR;
                    s3.activeTexture.set(o2.TEXTURE0), _2.texture.bind(x2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), s3.activeTexture.set(o2.TEXTURE1), p2 ? (p2.texture.bind(x2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), g2 = Math.pow(2, p2.tileID.overscaledZ - _2.tileID.overscaledZ), v2 = [
                      _2.tileID.canonical.x * g2 % 1,
                      _2.tileID.canonical.y * g2 % 1
                    ]) : _2.texture.bind(x2, o2.CLAMP_TO_EDGE, o2.LINEAR_MIPMAP_NEAREST), _2.texture.useMipmap && s3.extTextureFilterAnisotropic && t3.transform.pitch > 20 && o2.texParameterf(o2.TEXTURE_2D, s3.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s3.extTextureFilterAnisotropicMax);
                    const y2 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(a4), b2 = y2 ? a4 : null, w2 = b2 ? b2.posMatrix : t3.transform.calculatePosMatrix(a4.toUnwrapped(), d2), T2 = Ue(w2, v2 || [0, 0], g2 || 1, f2, i3);
                    r2 instanceof Q ? n2.draw(s3, o2.TRIANGLES, c3, Ui.disabled, l2, ji.disabled, T2, y2, i3.id, r2.boundsBuffer, t3.quadTriangleIndexBuffer, r2.boundsSegments) : n2.draw(s3, o2.TRIANGLES, c3, h2[a4.overscaledZ], l2, ji.disabled, T2, y2, i3.id, t3.rasterBoundsBuffer, t3.quadTriangleIndexBuffer, t3.rasterBoundsSegments);
                  }
                })(t2, i2, a2, s2);
                break;
              case "background":
                (function(t3, e2, i3, a3) {
                  const s3 = i3.paint.get("background-color"), o2 = i3.paint.get("background-opacity");
                  if (o2 === 0)
                    return;
                  const r2 = t3.context, n2 = r2.gl, l2 = t3.transform, h2 = l2.tileSize, c2 = i3.paint.get("background-pattern");
                  if (t3.isPatternMissing(c2))
                    return;
                  const u2 = !c2 && s3.a === 1 && o2 === 1 && t3.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                  if (t3.renderPass !== u2)
                    return;
                  const d2 = Ui.disabled, _2 = t3.depthModeForSublayer(0, u2 === "opaque" ? Oi.ReadWrite : Oi.ReadOnly), p2 = t3.colorModeForRenderPass(), m2 = t3.useProgram(c2 ? "backgroundPattern" : "background"), f2 = a3 || l2.coveringTiles({ tileSize: h2, terrain: t3.style.map.terrain });
                  c2 && (r2.activeTexture.set(n2.TEXTURE0), t3.imageManager.bind(t3.context));
                  const g2 = i3.getCrossfadeParameters();
                  for (const e3 of f2) {
                    const l3 = a3 ? e3.posMatrix : t3.transform.calculatePosMatrix(e3.toUnwrapped()), u3 = c2 ? He(l3, o2, t3, c2, { tileID: e3, tileSize: h2 }, g2) : Ge(l3, o2, s3), f3 = t3.style.map.terrain && t3.style.map.terrain.getTerrainData(e3);
                    m2.draw(r2, n2.TRIANGLES, _2, d2, p2, ji.disabled, u3, f3, i3.id, t3.tileExtentBuffer, t3.quadTriangleIndexBuffer, t3.tileExtentSegments);
                  }
                })(t2, 0, a2, s2);
                break;
              case "custom":
                (function(t3, e2, i3) {
                  const a3 = t3.context, s3 = i3.implementation;
                  if (t3.renderPass === "offscreen") {
                    const e3 = s3.prerender;
                    e3 && (t3.setCustomLayerDefaults(), a3.setColorMode(t3.colorModeForRenderPass()), e3.call(s3, a3.gl, t3.transform.customLayerMatrix()), a3.setDirty(), t3.setBaseState());
                  } else if (t3.renderPass === "translucent") {
                    t3.setCustomLayerDefaults(), a3.setColorMode(t3.colorModeForRenderPass()), a3.setStencilMode(Ui.disabled);
                    const e3 = s3.renderingMode === "3d" ? new Oi(t3.context.gl.LEQUAL, Oi.ReadWrite, t3.depthRangeFor3D) : t3.depthModeForSublayer(0, Oi.ReadOnly);
                    a3.setDepthMode(e3), s3.render(a3.gl, t3.transform.customLayerMatrix(), {
                      farZ: t3.transform.farZ,
                      nearZ: t3.transform.nearZ,
                      fov: t3.transform._fov,
                      modelViewProjectionMatrix: t3.transform.modelViewProjectionMatrix,
                      projectionMatrix: t3.transform.projectionMatrix
                    }), a3.setDirty(), t3.setBaseState(), a3.bindFramebuffer.set(null);
                  }
                })(t2, 0, a2);
            }
        }
        translatePosMatrix(t2, i2, a2, s2, o2) {
          if (!a2[0] && !a2[1])
            return t2;
          const r2 = o2 ? s2 === "map" ? this.transform.angle : 0 : s2 === "viewport" ? -this.transform.angle : 0;
          if (r2) {
            const t3 = Math.sin(r2), e2 = Math.cos(r2);
            a2 = [a2[0] * e2 - a2[1] * t3, a2[0] * t3 + a2[1] * e2];
          }
          const n2 = [
            o2 ? a2[0] : Bt(i2, a2[0], this.transform.zoom),
            o2 ? a2[1] : Bt(i2, a2[1], this.transform.zoom),
            0
          ], l2 = new Float32Array(16);
          return e.J(l2, t2, n2), l2;
        }
        saveTileTexture(t2) {
          const e2 = this._tileTextures[t2.size[0]];
          e2 ? e2.push(t2) : this._tileTextures[t2.size[0]] = [t2];
        }
        getTileTexture(t2) {
          const e2 = this._tileTextures[t2];
          return e2 && e2.length > 0 ? e2.pop() : null;
        }
        isPatternMissing(t2) {
          if (!t2)
            return false;
          if (!t2.from || !t2.to)
            return true;
          const e2 = this.imageManager.getPattern(t2.from.toString()), i2 = this.imageManager.getPattern(t2.to.toString());
          return !e2 || !i2;
        }
        useProgram(t2, e2) {
          this.cache = this.cache || {};
          const i2 = t2 + (e2 ? e2.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
          return this.cache[i2] || (this.cache[i2] = new xe(this.context, pe[t2], e2, We[t2], this._showOverdrawInspector, this.style.map.terrain)), this.cache[i2];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const t2 = this.context.gl;
          this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t2.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new b(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: t2, drawingBufferHeight: e2 } = this.context.gl;
          return this.width !== t2 || this.height !== e2;
        }
      }

      class xa {
        constructor(t2, e2) {
          this.points = t2, this.planes = e2;
        }
        static fromInvProjectionMatrix(t2, i2, a2) {
          const s2 = Math.pow(2, a2), o2 = [
            [-1, 1, -1, 1],
            [1, 1, -1, 1],
            [1, -1, -1, 1],
            [-1, -1, -1, 1],
            [-1, 1, 1, 1],
            [1, 1, 1, 1],
            [1, -1, 1, 1],
            [-1, -1, 1, 1]
          ].map((a3) => {
            const o3 = 1 / (a3 = e.af([], a3, t2))[3] / i2 * s2;
            return e.b1(a3, a3, [o3, o3, 1 / a3[3], o3]);
          }), r2 = [
            [0, 1, 2],
            [6, 5, 4],
            [0, 3, 7],
            [2, 1, 5],
            [3, 2, 6],
            [0, 4, 5]
          ].map((t3) => {
            const e2 = function(t4, e3) {
              var i4 = e3[0], a4 = e3[1], s4 = e3[2], o3 = i4 * i4 + a4 * a4 + s4 * s4;
              return o3 > 0 && (o3 = 1 / Math.sqrt(o3)), t4[0] = e3[0] * o3, t4[1] = e3[1] * o3, t4[2] = e3[2] * o3, t4;
            }([], function(t4, e3, i4) {
              var a4 = e3[0], s4 = e3[1], o3 = e3[2], r3 = i4[0], n2 = i4[1], l2 = i4[2];
              return t4[0] = s4 * l2 - o3 * n2, t4[1] = o3 * r3 - a4 * l2, t4[2] = a4 * n2 - s4 * r3, t4;
            }([], g([], o2[t3[0]], o2[t3[1]]), g([], o2[t3[2]], o2[t3[1]]))), i3 = -((a3 = e2)[0] * (s3 = o2[t3[1]])[0] + a3[1] * s3[1] + a3[2] * s3[2]);
            var a3, s3;
            return e2.concat(i3);
          });
          return new xa(o2, r2);
        }
      }

      class ya {
        constructor(t2, e2) {
          this.min = t2, this.max = e2, this.center = function(t3, e3, i2) {
            return t3[0] = 0.5 * e3[0], t3[1] = 0.5 * e3[1], t3[2] = 0.5 * e3[2], t3;
          }([], function(t3, e3, i2) {
            return t3[0] = e3[0] + i2[0], t3[1] = e3[1] + i2[1], t3[2] = e3[2] + i2[2], t3;
          }([], this.min, this.max));
        }
        quadrant(t2) {
          const e2 = [t2 % 2 == 0, t2 < 2], i2 = m(this.min), a2 = m(this.max);
          for (let t3 = 0;t3 < e2.length; t3++)
            i2[t3] = e2[t3] ? this.min[t3] : this.center[t3], a2[t3] = e2[t3] ? this.center[t3] : this.max[t3];
          return a2[2] = this.max[2], new ya(i2, a2);
        }
        distanceX(t2) {
          return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
        }
        distanceY(t2) {
          return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
        }
        intersects(t2) {
          const i2 = [
            [this.min[0], this.min[1], this.min[2], 1],
            [this.max[0], this.min[1], this.min[2], 1],
            [this.max[0], this.max[1], this.min[2], 1],
            [this.min[0], this.max[1], this.min[2], 1],
            [this.min[0], this.min[1], this.max[2], 1],
            [this.max[0], this.min[1], this.max[2], 1],
            [this.max[0], this.max[1], this.max[2], 1],
            [this.min[0], this.max[1], this.max[2], 1]
          ];
          let a2 = true;
          for (let s2 = 0;s2 < t2.planes.length; s2++) {
            const o2 = t2.planes[s2];
            let r2 = 0;
            for (let t3 = 0;t3 < i2.length; t3++)
              e.b2(o2, i2[t3]) >= 0 && r2++;
            if (r2 === 0)
              return 0;
            r2 !== i2.length && (a2 = false);
          }
          if (a2)
            return 2;
          for (let e2 = 0;e2 < 3; e2++) {
            let i3 = Number.MAX_VALUE, a3 = -Number.MAX_VALUE;
            for (let s2 = 0;s2 < t2.points.length; s2++) {
              const o2 = t2.points[s2][e2] - this.min[e2];
              i3 = Math.min(i3, o2), a3 = Math.max(a3, o2);
            }
            if (a3 < 0 || i3 > this.max[e2] - this.min[e2])
              return 0;
          }
          return 1;
        }
      }

      class ba {
        constructor(t2 = 0, e2 = 0, i2 = 0, a2 = 0) {
          if (isNaN(t2) || t2 < 0 || isNaN(e2) || e2 < 0 || isNaN(i2) || i2 < 0 || isNaN(a2) || a2 < 0)
            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = t2, this.bottom = e2, this.left = i2, this.right = a2;
        }
        interpolate(t2, i2, a2) {
          return i2.top != null && t2.top != null && (this.top = e.y.number(t2.top, i2.top, a2)), i2.bottom != null && t2.bottom != null && (this.bottom = e.y.number(t2.bottom, i2.bottom, a2)), i2.left != null && t2.left != null && (this.left = e.y.number(t2.left, i2.left, a2)), i2.right != null && t2.right != null && (this.right = e.y.number(t2.right, i2.right, a2)), this;
        }
        getCenter(t2, i2) {
          const a2 = e.ac((this.left + t2 - this.right) / 2, 0, t2), s2 = e.ac((this.top + i2 - this.bottom) / 2, 0, i2);
          return new e.P(a2, s2);
        }
        equals(t2) {
          return this.top === t2.top && this.bottom === t2.bottom && this.left === t2.left && this.right === t2.right;
        }
        clone() {
          return new ba(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return {
            top: this.top,
            bottom: this.bottom,
            left: this.left,
            right: this.right
          };
        }
      }
      const wa = 85.051129;

      class Ta {
        constructor(t2, i2, a2, s2, o2) {
          this.tileSize = 512, this._renderWorldCopies = o2 === undefined || !!o2, this._minZoom = t2 || 0, this._maxZoom = i2 || 22, this._minPitch = a2 == null ? 0 : a2, this._maxPitch = s2 == null ? 60 : s2, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new e.N(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new ba, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {}, this.minElevationForCurrentTile = 0;
        }
        clone() {
          const t2 = new Ta(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
          return t2.apply(this), t2;
        }
        apply(t2) {
          this.tileSize = t2.tileSize, this.latRange = t2.latRange, this.lngRange = t2.lngRange, this.width = t2.width, this.height = t2.height, this._center = t2._center, this._elevation = t2._elevation, this.minElevationForCurrentTile = t2.minElevationForCurrentTile, this.zoom = t2.zoom, this.angle = t2.angle, this._fov = t2._fov, this._pitch = t2._pitch, this._unmodified = t2._unmodified, this._edgeInsets = t2._edgeInsets.clone(), this._calcMatrices();
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(t2) {
          this._minZoom !== t2 && (this._minZoom = t2, this.zoom = Math.max(this.zoom, t2));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(t2) {
          this._maxZoom !== t2 && (this._maxZoom = t2, this.zoom = Math.min(this.zoom, t2));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(t2) {
          this._minPitch !== t2 && (this._minPitch = t2, this.pitch = Math.max(this.pitch, t2));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(t2) {
          this._maxPitch !== t2 && (this._maxPitch = t2, this.pitch = Math.min(this.pitch, t2));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        set renderWorldCopies(t2) {
          t2 === undefined ? t2 = true : t2 === null && (t2 = false), this._renderWorldCopies = t2;
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new e.P(this.width, this.height);
        }
        get bearing() {
          return -this.angle / Math.PI * 180;
        }
        set bearing(t2) {
          const i2 = -e.b3(t2, -180, 180) * Math.PI / 180;
          this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = function() {
            var t3 = new e.A(4);
            return e.A != Float32Array && (t3[1] = 0, t3[2] = 0), t3[0] = 1, t3[3] = 1, t3;
          }(), function(t3, e2, i3) {
            var a2 = e2[0], s2 = e2[1], o2 = e2[2], r2 = e2[3], n2 = Math.sin(i3), l2 = Math.cos(i3);
            t3[0] = a2 * l2 + o2 * n2, t3[1] = s2 * l2 + r2 * n2, t3[2] = a2 * -n2 + o2 * l2, t3[3] = s2 * -n2 + r2 * l2;
          }(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return this._pitch / Math.PI * 180;
        }
        set pitch(t2) {
          const i2 = e.ac(t2, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
        }
        get fov() {
          return this._fov / Math.PI * 180;
        }
        set fov(t2) {
          t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = t2 / 180 * Math.PI, this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(t2) {
          const e2 = Math.min(Math.max(t2, this.minZoom), this.maxZoom);
          this._zoom !== e2 && (this._unmodified = false, this._zoom = e2, this.tileZoom = Math.max(0, Math.floor(e2)), this.scale = this.zoomScale(e2), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        set center(t2) {
          t2.lat === this._center.lat && t2.lng === this._center.lng || (this._unmodified = false, this._center = t2, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(t2) {
          t2 !== this._elevation && (this._elevation = t2, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(t2) {
          this._edgeInsets.equals(t2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t2, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        isPaddingEqual(t2) {
          return this._edgeInsets.equals(t2);
        }
        interpolatePadding(t2, e2, i2) {
          this._unmodified = false, this._edgeInsets.interpolate(t2, e2, i2), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(t2) {
          const e2 = (t2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t2.tileSize));
          return Math.max(0, e2);
        }
        getVisibleUnwrappedCoordinates(t2) {
          const i2 = [new e.b4(0, t2)];
          if (this._renderWorldCopies) {
            const a2 = this.pointCoordinate(new e.P(0, 0)), s2 = this.pointCoordinate(new e.P(this.width, 0)), o2 = this.pointCoordinate(new e.P(this.width, this.height)), r2 = this.pointCoordinate(new e.P(0, this.height)), n2 = Math.floor(Math.min(a2.x, s2.x, o2.x, r2.x)), l2 = Math.floor(Math.max(a2.x, s2.x, o2.x, r2.x)), h2 = 1;
            for (let a3 = n2 - h2;a3 <= l2 + h2; a3++)
              a3 !== 0 && i2.push(new e.b4(a3, t2));
          }
          return i2;
        }
        coveringTiles(t2) {
          var i2, a2;
          let s2 = this.coveringZoomLevel(t2);
          const o2 = s2;
          if (t2.minzoom !== undefined && s2 < t2.minzoom)
            return [];
          t2.maxzoom !== undefined && s2 > t2.maxzoom && (s2 = t2.maxzoom);
          const r2 = this.pointCoordinate(this.getCameraPoint()), n2 = e.Z.fromLngLat(this.center), l2 = Math.pow(2, s2), h2 = [l2 * r2.x, l2 * r2.y, 0], c2 = [l2 * n2.x, l2 * n2.y, 0], u2 = xa.fromInvProjectionMatrix(this.invModelViewProjectionMatrix, this.worldSize, s2);
          let d2 = t2.minzoom || 0;
          !t2.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (d2 = s2);
          const _2 = t2.terrain ? 2 / Math.min(this.tileSize, t2.tileSize) * this.tileSize : 3, p2 = (t3) => ({
            aabb: new ya([t3 * l2, 0, 0], [(t3 + 1) * l2, l2, 0]),
            zoom: 0,
            x: 0,
            y: 0,
            wrap: t3,
            fullyVisible: false
          }), m2 = [], f2 = [], g2 = s2, x2 = t2.reparseOverscaled ? o2 : s2;
          if (this._renderWorldCopies)
            for (let t3 = 1;t3 <= 3; t3++)
              m2.push(p2(-t3)), m2.push(p2(t3));
          for (m2.push(p2(0));m2.length > 0; ) {
            const s3 = m2.pop(), o3 = s3.x, r3 = s3.y;
            let n3 = s3.fullyVisible;
            if (!n3) {
              const t3 = s3.aabb.intersects(u2);
              if (t3 === 0)
                continue;
              n3 = t3 === 2;
            }
            const l3 = t2.terrain ? h2 : c2, p3 = s3.aabb.distanceX(l3), y2 = s3.aabb.distanceY(l3), b2 = Math.max(Math.abs(p3), Math.abs(y2));
            if (s3.zoom === g2 || b2 > _2 + (1 << g2 - s3.zoom) - 2 && s3.zoom >= d2) {
              const t3 = g2 - s3.zoom, i3 = h2[0] - 0.5 - (o3 << t3), a3 = h2[1] - 0.5 - (r3 << t3);
              f2.push({
                tileID: new e.S(s3.zoom === g2 ? x2 : s3.zoom, s3.wrap, s3.zoom, o3, r3),
                distanceSq: v([c2[0] - 0.5 - o3, c2[1] - 0.5 - r3]),
                tileDistanceToCamera: Math.sqrt(i3 * i3 + a3 * a3)
              });
            } else
              for (let l4 = 0;l4 < 4; l4++) {
                const h3 = (o3 << 1) + l4 % 2, c3 = (r3 << 1) + (l4 >> 1), u3 = s3.zoom + 1;
                let d3 = s3.aabb.quadrant(l4);
                if (t2.terrain) {
                  const o4 = new e.S(u3, s3.wrap, u3, h3, c3), r4 = t2.terrain.getMinMaxElevation(o4), n4 = (i2 = r4.minElevation) !== null && i2 !== undefined ? i2 : this.elevation, l5 = (a2 = r4.maxElevation) !== null && a2 !== undefined ? a2 : this.elevation;
                  d3 = new ya([d3.min[0], d3.min[1], n4], [d3.max[0], d3.max[1], l5]);
                }
                m2.push({ aabb: d3, zoom: u3, x: h3, y: c3, wrap: s3.wrap, fullyVisible: n3 });
              }
          }
          return f2.sort((t3, e2) => t3.distanceSq - e2.distanceSq).map((t3) => t3.tileID);
        }
        resize(t2, e2) {
          this.width = t2, this.height = e2, this.pixelsToGLUnits = [2 / t2, -2 / e2], this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(t2) {
          return Math.pow(2, t2);
        }
        scaleZoom(t2) {
          return Math.log(t2) / Math.LN2;
        }
        project(t2) {
          const i2 = e.ac(t2.lat, -85.051129, wa);
          return new e.P(e.O(t2.lng) * this.worldSize, e.Q(i2) * this.worldSize);
        }
        unproject(t2) {
          return new e.Z(t2.x / this.worldSize, t2.y / this.worldSize).toLngLat();
        }
        get point() {
          return this.project(this.center);
        }
        getCameraPosition() {
          return {
            lngLat: this.pointLocation(this.getCameraPoint()),
            altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation
          };
        }
        recalculateZoom(t2) {
          const i2 = this.elevation, a2 = Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter, s2 = this.pointLocation(this.centerPoint, t2), o2 = t2.getElevationForLngLatZoom(s2, this.tileZoom);
          if (!(this.elevation - o2))
            return;
          const r2 = a2 + i2 - o2, n2 = Math.cos(this._pitch) * this.cameraToCenterDistance / r2 / e.b5(1, s2.lat), l2 = this.scaleZoom(n2 / this.tileSize);
          this._elevation = o2, this._center = s2, this.zoom = l2;
        }
        setLocationAtPoint(t2, i2) {
          const a2 = this.pointCoordinate(i2), s2 = this.pointCoordinate(this.centerPoint), o2 = this.locationCoordinate(t2), r2 = new e.Z(o2.x - (a2.x - s2.x), o2.y - (a2.y - s2.y));
          this.center = this.coordinateLocation(r2), this._renderWorldCopies && (this.center = this.center.wrap());
        }
        locationPoint(t2, e2) {
          return e2 ? this.coordinatePoint(this.locationCoordinate(t2), e2.getElevationForLngLatZoom(t2, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t2));
        }
        pointLocation(t2, e2) {
          return this.coordinateLocation(this.pointCoordinate(t2, e2));
        }
        locationCoordinate(t2) {
          return e.Z.fromLngLat(t2);
        }
        coordinateLocation(t2) {
          return t2 && t2.toLngLat();
        }
        pointCoordinate(t2, i2) {
          if (i2) {
            const e2 = i2.pointCoordinate(t2);
            if (e2 != null)
              return e2;
          }
          const a2 = [t2.x, t2.y, 0, 1], s2 = [t2.x, t2.y, 1, 1];
          e.af(a2, a2, this.pixelMatrixInverse), e.af(s2, s2, this.pixelMatrixInverse);
          const o2 = a2[3], r2 = s2[3], n2 = a2[1] / o2, l2 = s2[1] / r2, h2 = a2[2] / o2, c2 = s2[2] / r2, u2 = h2 === c2 ? 0 : (0 - h2) / (c2 - h2);
          return new e.Z(e.y.number(a2[0] / o2, s2[0] / r2, u2) / this.worldSize, e.y.number(n2, l2, u2) / this.worldSize);
        }
        coordinatePoint(t2, i2 = 0, a2 = this.pixelMatrix) {
          const s2 = [t2.x * this.worldSize, t2.y * this.worldSize, i2, 1];
          return e.af(s2, s2, a2), new e.P(s2[0] / s2[3], s2[1] / s2[3]);
        }
        getBounds() {
          const t2 = Math.max(0, this.height / 2 - this.getHorizon());
          return new H().extend(this.pointLocation(new e.P(0, t2))).extend(this.pointLocation(new e.P(this.width, t2))).extend(this.pointLocation(new e.P(this.width, this.height))).extend(this.pointLocation(new e.P(0, this.height)));
        }
        getMaxBounds() {
          return this.latRange && this.latRange.length === 2 && this.lngRange && this.lngRange.length === 2 ? new H([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
        }
        getHorizon() {
          return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
        }
        setMaxBounds(t2) {
          t2 ? (this.lngRange = [t2.getWest(), t2.getEast()], this.latRange = [t2.getSouth(), t2.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-85.051129, wa]);
        }
        calculateTileMatrix(t2) {
          const i2 = t2.canonical, a2 = this.worldSize / this.zoomScale(i2.z), s2 = i2.x + Math.pow(2, i2.z) * t2.wrap, o2 = e.an(new Float64Array(16));
          return e.J(o2, o2, [s2 * a2, i2.y * a2, 0]), e.K(o2, o2, [a2 / e.X, a2 / e.X, 1]), o2;
        }
        calculatePosMatrix(t2, i2 = false) {
          const a2 = t2.key, s2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (s2[a2])
            return s2[a2];
          const o2 = this.calculateTileMatrix(t2);
          return e.L(o2, i2 ? this.alignedModelViewProjectionMatrix : this.modelViewProjectionMatrix, o2), s2[a2] = new Float32Array(o2), s2[a2];
        }
        calculateFogMatrix(t2) {
          const i2 = t2.key, a2 = this._fogMatrixCache;
          if (a2[i2])
            return a2[i2];
          const s2 = this.calculateTileMatrix(t2);
          return e.L(s2, this.fogMatrix, s2), a2[i2] = new Float32Array(s2), a2[i2];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        getConstrained(t2, i2) {
          i2 = e.ac(+i2, this.minZoom, this.maxZoom);
          const a2 = { center: new e.N(t2.lng, t2.lat), zoom: i2 };
          let s2 = this.lngRange;
          if (!this._renderWorldCopies && s2 === null) {
            const t3 = 180 - 0.0000000001;
            s2 = [-t3, t3];
          }
          const o2 = this.tileSize * this.zoomScale(a2.zoom);
          let r2 = 0, n2 = o2, l2 = 0, h2 = o2, c2 = 0, u2 = 0;
          const { x: d2, y: _2 } = this.size;
          if (this.latRange) {
            const t3 = this.latRange;
            r2 = e.Q(t3[1]) * o2, n2 = e.Q(t3[0]) * o2, n2 - r2 < _2 && (c2 = _2 / (n2 - r2));
          }
          s2 && (l2 = e.b3(e.O(s2[0]) * o2, 0, o2), h2 = e.b3(e.O(s2[1]) * o2, 0, o2), h2 < l2 && (h2 += o2), h2 - l2 < d2 && (u2 = d2 / (h2 - l2)));
          const { x: p2, y: m2 } = this.project.call({ worldSize: o2 }, t2);
          let f2, g2;
          const v2 = Math.max(u2 || 0, c2 || 0);
          if (v2) {
            const t3 = new e.P(u2 ? (h2 + l2) / 2 : p2, c2 ? (n2 + r2) / 2 : m2);
            return a2.center = this.unproject.call({ worldSize: o2 }, t3).wrap(), a2.zoom += this.scaleZoom(v2), a2;
          }
          if (this.latRange) {
            const t3 = _2 / 2;
            m2 - t3 < r2 && (g2 = r2 + t3), m2 + t3 > n2 && (g2 = n2 - t3);
          }
          if (s2) {
            const t3 = (l2 + h2) / 2;
            let i3 = p2;
            this._renderWorldCopies && (i3 = e.b3(p2, t3 - o2 / 2, t3 + o2 / 2));
            const a3 = d2 / 2;
            i3 - a3 < l2 && (f2 = l2 + a3), i3 + a3 > h2 && (f2 = h2 - a3);
          }
          if (f2 !== undefined || g2 !== undefined) {
            const t3 = new e.P(f2 != null ? f2 : p2, g2 != null ? g2 : m2);
            a2.center = this.unproject.call({ worldSize: o2 }, t3).wrap();
          }
          return a2;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining)
            return;
          this._constraining = true;
          const t2 = this._unmodified, { center: e2, zoom: i2 } = this.getConstrained(this.center, this.zoom);
          this.center = e2, this.zoom = i2, this._unmodified = t2, this._constraining = false;
        }
        _calcMatrices() {
          if (!this.height)
            return;
          const t2 = this.centerOffset, i2 = this.point.x, a2 = this.point.y;
          this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = e.b5(1, this.center.lat) * this.worldSize;
          let s2 = e.an(new Float64Array(16));
          e.K(s2, s2, [this.width / 2, -this.height / 2, 1]), e.J(s2, s2, [1, -1, 0]), this.labelPlaneMatrix = s2, s2 = e.an(new Float64Array(16)), e.K(s2, s2, [1, -1, 1]), e.J(s2, s2, [-1, -1, 0]), e.K(s2, s2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = s2;
          const o2 = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), r2 = Math.min(this.elevation, this.minElevationForCurrentTile), n2 = o2 - r2 * this._pixelPerMeter / Math.cos(this._pitch), l2 = r2 < 0 ? n2 : o2, h2 = Math.PI / 2 + this._pitch, c2 = this._fov * (0.5 + t2.y / this.height), u2 = Math.sin(c2) * l2 / Math.sin(e.ac(Math.PI - h2 - c2, 0.01, Math.PI - 0.01)), d2 = this.getHorizon(), _2 = 2 * Math.atan(d2 / this.cameraToCenterDistance) * (0.5 + t2.y / (2 * d2)), p2 = Math.sin(_2) * l2 / Math.sin(e.ac(Math.PI - h2 - _2, 0.01, Math.PI - 0.01)), m2 = Math.min(u2, p2);
          this.farZ = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * m2 + l2), this.nearZ = this.height / 50, s2 = new Float64Array(16), e.b6(s2, this._fov, this.width / this.height, this.nearZ, this.farZ), s2[8] = 2 * -t2.x / this.width, s2[9] = 2 * t2.y / this.height, this.projectionMatrix = e.ae(s2), e.K(s2, s2, [1, -1, 1]), e.J(s2, s2, [0, 0, -this.cameraToCenterDistance]), e.b7(s2, s2, this._pitch), e.ad(s2, s2, this.angle), e.J(s2, s2, [-i2, -a2, 0]), this.mercatorMatrix = e.K([], s2, [
            this.worldSize,
            this.worldSize,
            this.worldSize
          ]), e.K(s2, s2, [1, 1, this._pixelPerMeter]), this.pixelMatrix = e.L(new Float64Array(16), this.labelPlaneMatrix, s2), e.J(s2, s2, [0, 0, -this.elevation]), this.modelViewProjectionMatrix = s2, this.invModelViewProjectionMatrix = e.as([], s2), this.fogMatrix = new Float64Array(16), e.b6(this.fogMatrix, this._fov, this.width / this.height, o2, this.farZ), this.fogMatrix[8] = 2 * -t2.x / this.width, this.fogMatrix[9] = 2 * t2.y / this.height, e.K(this.fogMatrix, this.fogMatrix, [1, -1, 1]), e.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.cameraToCenterDistance]), e.b7(this.fogMatrix, this.fogMatrix, this._pitch), e.ad(this.fogMatrix, this.fogMatrix, this.angle), e.J(this.fogMatrix, this.fogMatrix, [-i2, -a2, 0]), e.K(this.fogMatrix, this.fogMatrix, [1, 1, this._pixelPerMeter]), e.J(this.fogMatrix, this.fogMatrix, [0, 0, -this.elevation]), this.pixelMatrix3D = e.L(new Float64Array(16), this.labelPlaneMatrix, s2);
          const f2 = this.width % 2 / 2, g2 = this.height % 2 / 2, v2 = Math.cos(this.angle), x2 = Math.sin(this.angle), y2 = i2 - Math.round(i2) + v2 * f2 + x2 * g2, b2 = a2 - Math.round(a2) + v2 * g2 + x2 * f2, w2 = new Float64Array(s2);
          if (e.J(w2, w2, [y2 > 0.5 ? y2 - 1 : y2, b2 > 0.5 ? b2 - 1 : b2, 0]), this.alignedModelViewProjectionMatrix = w2, s2 = e.as(new Float64Array(16), this.pixelMatrix), !s2)
            throw new Error("failed to invert matrix");
          this.pixelMatrixInverse = s2, this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._fogMatrixCache = {};
        }
        maxPitchScaleFactor() {
          if (!this.pixelMatrixInverse)
            return 1;
          const t2 = this.pointCoordinate(new e.P(0, 0)), i2 = [t2.x * this.worldSize, t2.y * this.worldSize, 0, 1];
          return e.af(i2, i2, this.pixelMatrix)[3] / this.cameraToCenterDistance;
        }
        getCameraPoint() {
          const t2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new e.P(0, t2));
        }
        getCameraQueryGeometry(t2) {
          const i2 = this.getCameraPoint();
          if (t2.length === 1)
            return [t2[0], i2];
          {
            let { x: a2, y: s2, x: o2, y: r2 } = i2;
            for (const e2 of t2)
              a2 = Math.min(a2, e2.x), s2 = Math.min(s2, e2.y), o2 = Math.max(o2, e2.x), r2 = Math.max(r2, e2.y);
            return [
              new e.P(a2, s2),
              new e.P(o2, s2),
              new e.P(o2, r2),
              new e.P(a2, r2),
              new e.P(a2, s2)
            ];
          }
        }
        lngLatToCameraDepth(t2, i2) {
          const a2 = this.locationCoordinate(t2), s2 = [a2.x * this.worldSize, a2.y * this.worldSize, i2, 1];
          return e.af(s2, s2, this.modelViewProjectionMatrix), s2[2] / s2[3];
        }
      }
      function Ia(t2, e2) {
        let i2, a2 = false, s2 = null, o2 = null;
        const r2 = () => {
          s2 = null, a2 && (t2.apply(o2, i2), s2 = setTimeout(r2, e2), a2 = false);
        };
        return (...t3) => (a2 = true, o2 = this, i2 = t3, s2 || r2(), s2);
      }

      class Ea {
        constructor(t2) {
          this._getCurrentHash = () => {
            const t3 = window.location.hash.replace("#", "");
            if (this._hashName) {
              let e2;
              return t3.split("&").map((t4) => t4.split("=")).forEach((t4) => {
                t4[0] === this._hashName && (e2 = t4);
              }), (e2 && e2[1] || "").split("/");
            }
            return t3.split("/");
          }, this._onHashChange = () => {
            const t3 = this._getCurrentHash();
            if (t3.length >= 3 && !t3.some((t4) => isNaN(t4))) {
              const e2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t3[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({
                center: [+t3[2], +t3[1]],
                zoom: +t3[0],
                bearing: e2,
                pitch: +(t3[4] || 0)
              }), true;
            }
            return false;
          }, this._updateHashUnthrottled = () => {
            const t3 = window.location.href.replace(/(#.+)?$/, this.getHashString());
            window.history.replaceState(window.history.state, null, t3);
          }, this._removeHash = () => {
            const t3 = this._getCurrentHash();
            if (t3.length === 0)
              return;
            const e2 = t3.join("/");
            let i2 = e2;
            i2.split("&").length > 0 && (i2 = i2.split("&")[0]), this._hashName && (i2 = `${this._hashName}=${e2}`);
            let a2 = window.location.hash.replace(i2, "");
            a2.startsWith("#&") ? a2 = a2.slice(0, 1) + a2.slice(2) : a2 === "#" && (a2 = "");
            let s2 = window.location.href.replace(/(#.+)?$/, a2);
            s2 = s2.replace("&&", "&"), window.history.replaceState(window.history.state, null, s2);
          }, this._updateHash = Ia(this._updateHashUnthrottled, 300), this._hashName = t2 && encodeURIComponent(t2);
        }
        addTo(t2) {
          return this._map = t2, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
        }
        getHashString(t2) {
          const e2 = this._map.getCenter(), i2 = Math.round(100 * this._map.getZoom()) / 100, a2 = Math.ceil((i2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), s2 = Math.pow(10, a2), o2 = Math.round(e2.lng * s2) / s2, r2 = Math.round(e2.lat * s2) / s2, n2 = this._map.getBearing(), l2 = this._map.getPitch();
          let h2 = "";
          if (h2 += t2 ? `/${o2}/${r2}/${i2}` : `${i2}/${r2}/${o2}`, (n2 || l2) && (h2 += "/" + Math.round(10 * n2) / 10), l2 && (h2 += `/${Math.round(l2)}`), this._hashName) {
            const t3 = this._hashName;
            let e3 = false;
            const i3 = window.location.hash.slice(1).split("&").map((i4) => {
              const a3 = i4.split("=")[0];
              return a3 === t3 ? (e3 = true, `${a3}=${h2}`) : i4;
            }).filter((t4) => t4);
            return e3 || i3.push(`${t3}=${h2}`), `#${i3.join("&")}`;
          }
          return `#${h2}`;
        }
      }
      const Pa = { linearity: 0.3, easing: e.b8(0, 0, 0.3, 1) }, Ca = e.e({ deceleration: 2500, maxSpeed: 1400 }, Pa), Sa = e.e({ deceleration: 20, maxSpeed: 1400 }, Pa), za = e.e({ deceleration: 1000, maxSpeed: 360 }, Pa), Da = e.e({ deceleration: 1000, maxSpeed: 90 }, Pa);

      class Ma {
        constructor(t2) {
          this._map = t2, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t2) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: o.now(), settings: t2 });
        }
        _drainInertiaBuffer() {
          const t2 = this._inertiaBuffer, e2 = o.now();
          for (;t2.length > 0 && e2 - t2[0].time > 160; )
            t2.shift();
        }
        _onMoveEnd(t2) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
            return;
          const i2 = {
            zoom: 0,
            bearing: 0,
            pitch: 0,
            pan: new e.P(0, 0),
            pinchAround: undefined,
            around: undefined
          };
          for (const { settings: t3 } of this._inertiaBuffer)
            i2.zoom += t3.zoomDelta || 0, i2.bearing += t3.bearingDelta || 0, i2.pitch += t3.pitchDelta || 0, t3.panDelta && i2.pan._add(t3.panDelta), t3.around && (i2.around = t3.around), t3.pinchAround && (i2.pinchAround = t3.pinchAround);
          const a2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s2 = {};
          if (i2.pan.mag()) {
            const o2 = Ra(i2.pan.mag(), a2, e.e({}, Ca, t2 || {}));
            s2.offset = i2.pan.mult(o2.amount / i2.pan.mag()), s2.center = this._map.transform.center, Aa(s2, o2);
          }
          if (i2.zoom) {
            const t3 = Ra(i2.zoom, a2, Sa);
            s2.zoom = this._map.transform.zoom + t3.amount, Aa(s2, t3);
          }
          if (i2.bearing) {
            const t3 = Ra(i2.bearing, a2, za);
            s2.bearing = this._map.transform.bearing + e.ac(t3.amount, -179, 179), Aa(s2, t3);
          }
          if (i2.pitch) {
            const t3 = Ra(i2.pitch, a2, Da);
            s2.pitch = this._map.transform.pitch + t3.amount, Aa(s2, t3);
          }
          if (s2.zoom || s2.bearing) {
            const t3 = i2.pinchAround === undefined ? i2.around : i2.pinchAround;
            s2.around = t3 ? this._map.unproject(t3) : this._map.getCenter();
          }
          return this.clear(), e.e(s2, { noMoveStart: true });
        }
      }
      function Aa(t2, e2) {
        (!t2.duration || t2.duration < e2.duration) && (t2.duration = e2.duration, t2.easing = e2.easing);
      }
      function Ra(t2, i2, a2) {
        const { maxSpeed: s2, linearity: o2, deceleration: r2 } = a2, n2 = e.ac(t2 * o2 / (i2 / 1000), -s2, s2), l2 = Math.abs(n2) / (r2 * o2);
        return { easing: a2.easing, duration: 1000 * l2, amount: n2 * (l2 / 2) };
      }

      class ka extends e.k {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t2, i2, a2, s2 = {}) {
          const o2 = r.mousePos(i2.getCanvas(), a2), n2 = i2.unproject(o2);
          super(t2, e.e({ point: o2, lngLat: n2, originalEvent: a2 }, s2)), this._defaultPrevented = false, this.target = i2;
        }
      }

      class La extends e.k {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t2, i2, a2) {
          const s2 = t2 === "touchend" ? a2.changedTouches : a2.touches, o2 = r.touchPos(i2.getCanvasContainer(), s2), n2 = o2.map((t3) => i2.unproject(t3)), l2 = o2.reduce((t3, e2, i3, a3) => t3.add(e2.div(a3.length)), new e.P(0, 0));
          super(t2, {
            points: o2,
            point: l2,
            lngLats: n2,
            lngLat: i2.unproject(l2),
            originalEvent: a2
          }), this._defaultPrevented = false;
        }
      }

      class Fa extends e.k {
        preventDefault() {
          this._defaultPrevented = true;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t2, e2, i2) {
          super(t2, { originalEvent: i2 }), this._defaultPrevented = false;
        }
      }

      class Ba {
        constructor(t2, e2) {
          this._map = t2, this._clickTolerance = e2.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(t2) {
          return this._firePreventable(new Fa(t2.type, this._map, t2));
        }
        mousedown(t2, e2) {
          return this._mousedownPos = e2, this._firePreventable(new ka(t2.type, this._map, t2));
        }
        mouseup(t2) {
          this._map.fire(new ka(t2.type, this._map, t2));
        }
        click(t2, e2) {
          this._mousedownPos && this._mousedownPos.dist(e2) >= this._clickTolerance || this._map.fire(new ka(t2.type, this._map, t2));
        }
        dblclick(t2) {
          return this._firePreventable(new ka(t2.type, this._map, t2));
        }
        mouseover(t2) {
          this._map.fire(new ka(t2.type, this._map, t2));
        }
        mouseout(t2) {
          this._map.fire(new ka(t2.type, this._map, t2));
        }
        touchstart(t2) {
          return this._firePreventable(new La(t2.type, this._map, t2));
        }
        touchmove(t2) {
          this._map.fire(new La(t2.type, this._map, t2));
        }
        touchend(t2) {
          this._map.fire(new La(t2.type, this._map, t2));
        }
        touchcancel(t2) {
          this._map.fire(new La(t2.type, this._map, t2));
        }
        _firePreventable(t2) {
          if (this._map.fire(t2), t2.defaultPrevented)
            return {};
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }

      class Oa {
        constructor(t2) {
          this._map = t2;
        }
        reset() {
          this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
        }
        mousemove(t2) {
          this._map.fire(new ka(t2.type, this._map, t2));
        }
        mousedown() {
          this._delayContextMenu = true, this._ignoreContextMenu = false;
        }
        mouseup() {
          this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new ka("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(t2) {
          this._delayContextMenu ? this._contextMenuEvent = t2 : this._ignoreContextMenu || this._map.fire(new ka(t2.type, this._map, t2)), this._map.listens("contextmenu") && t2.preventDefault();
        }
        isEnabled() {
          return true;
        }
        isActive() {
          return false;
        }
        enable() {
        }
        disable() {
        }
      }

      class Na {
        constructor(t2) {
          this._map = t2;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(t2) {
          return this.transform.pointLocation(e.P.convert(t2), this._map.terrain);
        }
      }

      class Ua {
        constructor(t2, e2) {
          this._map = t2, this._tr = new Na(t2), this._el = t2.getCanvasContainer(), this._container = t2.getContainer(), this._clickTolerance = e2.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = true);
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        mousedown(t2, e2) {
          this.isEnabled() && t2.shiftKey && t2.button === 0 && (r.disableDrag(), this._startPos = this._lastPos = e2, this._active = true);
        }
        mousemoveWindow(t2, e2) {
          if (!this._active)
            return;
          const i2 = e2;
          if (this._lastPos.equals(i2) || !this._box && i2.dist(this._startPos) < this._clickTolerance)
            return;
          const a2 = this._startPos;
          this._lastPos = i2, this._box || (this._box = r.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t2));
          const s2 = Math.min(a2.x, i2.x), o2 = Math.max(a2.x, i2.x), n2 = Math.min(a2.y, i2.y), l2 = Math.max(a2.y, i2.y);
          r.setTransform(this._box, `translate(${s2}px,${n2}px)`), this._box.style.width = o2 - s2 + "px", this._box.style.height = l2 - n2 + "px";
        }
        mouseupWindow(t2, i2) {
          if (!this._active)
            return;
          if (t2.button !== 0)
            return;
          const a2 = this._startPos, s2 = i2;
          if (this.reset(), r.suppressClick(), a2.x !== s2.x || a2.y !== s2.y)
            return this._map.fire(new e.k("boxzoomend", { originalEvent: t2 })), {
              cameraAnimation: (t3) => t3.fitScreenCoordinates(a2, s2, this._tr.bearing, { linear: true })
            };
          this._fireEvent("boxzoomcancel", t2);
        }
        keydown(t2) {
          this._active && t2.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", t2));
        }
        reset() {
          this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (r.remove(this._box), this._box = null), r.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t2, i2) {
          return this._map.fire(new e.k(t2, { originalEvent: i2 }));
        }
      }
      function ja(t2, e2) {
        if (t2.length !== e2.length)
          throw new Error(`The number of touches and points are not equal - touches ${t2.length}, points ${e2.length}`);
        const i2 = {};
        for (let a2 = 0;a2 < t2.length; a2++)
          i2[t2[a2].identifier] = e2[a2];
        return i2;
      }

      class Za {
        constructor(t2) {
          this.reset(), this.numTouches = t2.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
        }
        touchstart(t2, i2, a2) {
          (this.centroid || a2.length > this.numTouches) && (this.aborted = true), this.aborted || (this.startTime === undefined && (this.startTime = t2.timeStamp), a2.length === this.numTouches && (this.centroid = function(t3) {
            const i3 = new e.P(0, 0);
            for (const e2 of t3)
              i3._add(e2);
            return i3.div(t3.length);
          }(i2), this.touches = ja(a2, i2)));
        }
        touchmove(t2, e2, i2) {
          if (this.aborted || !this.centroid)
            return;
          const a2 = ja(i2, e2);
          for (const t3 in this.touches) {
            const e3 = a2[t3];
            (!e3 || e3.dist(this.touches[t3]) > 30) && (this.aborted = true);
          }
        }
        touchend(t2, e2, i2) {
          if ((!this.centroid || t2.timeStamp - this.startTime > 500) && (this.aborted = true), i2.length === 0) {
            const t3 = !this.aborted && this.centroid;
            if (this.reset(), t3)
              return t3;
          }
        }
      }

      class qa {
        constructor(t2) {
          this.singleTap = new Za(t2), this.numTaps = t2.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(t2, e2, i2) {
          this.singleTap.touchstart(t2, e2, i2);
        }
        touchmove(t2, e2, i2) {
          this.singleTap.touchmove(t2, e2, i2);
        }
        touchend(t2, e2, i2) {
          const a2 = this.singleTap.touchend(t2, e2, i2);
          if (a2) {
            const e3 = t2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(a2) < 30;
            if (e3 && i3 || this.reset(), this.count++, this.lastTime = t2.timeStamp, this.lastTap = a2, this.count === this.numTaps)
              return this.reset(), a2;
          }
        }
      }

      class Va {
        constructor(t2) {
          this._tr = new Na(t2), this._zoomIn = new qa({ numTouches: 1, numTaps: 2 }), this._zoomOut = new qa({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(t2, e2, i2) {
          this._zoomIn.touchstart(t2, e2, i2), this._zoomOut.touchstart(t2, e2, i2);
        }
        touchmove(t2, e2, i2) {
          this._zoomIn.touchmove(t2, e2, i2), this._zoomOut.touchmove(t2, e2, i2);
        }
        touchend(t2, e2, i2) {
          const a2 = this._zoomIn.touchend(t2, e2, i2), s2 = this._zoomOut.touchend(t2, e2, i2), o2 = this._tr;
          return a2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), {
            cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o2.zoom + 1, around: o2.unproject(a2) }, { originalEvent: t2 })
          }) : s2 ? (this._active = true, t2.preventDefault(), setTimeout(() => this.reset(), 0), {
            cameraAnimation: (e3) => e3.easeTo({ duration: 300, zoom: o2.zoom - 1, around: o2.unproject(s2) }, { originalEvent: t2 })
          }) : undefined;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }

      class Ga {
        constructor(t2) {
          this._enabled = !!t2.enable, this._moveStateManager = t2.moveStateManager, this._clickTolerance = t2.clickTolerance || 1, this._moveFunction = t2.move, this._activateOnStart = !!t2.activateOnStart, t2.assignEvents(this), this.reset();
        }
        reset(t2) {
          this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(t2);
        }
        _move(...t2) {
          const e2 = this._moveFunction(...t2);
          if (e2.bearingDelta || e2.pitchDelta || e2.around || e2.panDelta)
            return this._active = true, e2;
        }
        dragStart(t2, e2) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t2) && (this._moveStateManager.startMove(t2), this._lastPoint = e2.length ? e2[0] : e2, this._activateOnStart && this._lastPoint && (this._active = true));
        }
        dragMove(t2, e2) {
          if (!this.isEnabled())
            return;
          const i2 = this._lastPoint;
          if (!i2)
            return;
          if (t2.preventDefault(), !this._moveStateManager.isValidMoveEvent(t2))
            return void this.reset(t2);
          const a2 = e2.length ? e2[0] : e2;
          return !this._moved && a2.dist(i2) < this._clickTolerance ? undefined : (this._moved = true, this._lastPoint = a2, this._move(i2, a2));
        }
        dragEnd(t2) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t2) && (this._moved && r.suppressClick(), this.reset(t2));
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const Ha = { 0: 1, 2: 2 };

      class Wa {
        constructor(t2) {
          this._correctEvent = t2.checkCorrectEvent;
        }
        startMove(t2) {
          const e2 = r.mouseButton(t2);
          this._eventButton = e2;
        }
        endMove(t2) {
          delete this._eventButton;
        }
        isValidStartEvent(t2) {
          return this._correctEvent(t2);
        }
        isValidMoveEvent(t2) {
          return !function(t3, e2) {
            const i2 = Ha[e2];
            return t3.buttons === undefined || (t3.buttons & i2) !== i2;
          }(t2, this._eventButton);
        }
        isValidEndEvent(t2) {
          return r.mouseButton(t2) === this._eventButton;
        }
      }

      class $a {
        constructor() {
          this._firstTouch = undefined;
        }
        _isOneFingerTouch(t2) {
          return t2.targetTouches.length === 1;
        }
        _isSameTouchEvent(t2) {
          return t2.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(t2) {
          this._firstTouch = t2.targetTouches[0].identifier;
        }
        endMove(t2) {
          delete this._firstTouch;
        }
        isValidStartEvent(t2) {
          return this._isOneFingerTouch(t2);
        }
        isValidMoveEvent(t2) {
          return this._isOneFingerTouch(t2) && this._isSameTouchEvent(t2);
        }
        isValidEndEvent(t2) {
          return this._isOneFingerTouch(t2) && this._isSameTouchEvent(t2);
        }
      }
      const Xa = (t2) => {
        t2.mousedown = t2.dragStart, t2.mousemoveWindow = t2.dragMove, t2.mouseup = t2.dragEnd, t2.contextmenu = (t3) => {
          t3.preventDefault();
        };
      }, Ka = ({
        enable: t2,
        clickTolerance: e2,
        bearingDegreesPerPixelMoved: i2 = 0.8
      }) => {
        const a2 = new Wa({
          checkCorrectEvent: (t3) => r.mouseButton(t3) === 0 && t3.ctrlKey || r.mouseButton(t3) === 2
        });
        return new Ga({
          clickTolerance: e2,
          move: (t3, e3) => ({ bearingDelta: (e3.x - t3.x) * i2 }),
          moveStateManager: a2,
          enable: t2,
          assignEvents: Xa
        });
      }, Ja = ({
        enable: t2,
        clickTolerance: e2,
        pitchDegreesPerPixelMoved: i2 = -0.5
      }) => {
        const a2 = new Wa({
          checkCorrectEvent: (t3) => r.mouseButton(t3) === 0 && t3.ctrlKey || r.mouseButton(t3) === 2
        });
        return new Ga({
          clickTolerance: e2,
          move: (t3, e3) => ({ pitchDelta: (e3.y - t3.y) * i2 }),
          moveStateManager: a2,
          enable: t2,
          assignEvents: Xa
        });
      };

      class Ya {
        constructor(t2, e2) {
          this._clickTolerance = t2.clickTolerance || 1, this._map = e2, this.reset();
        }
        reset() {
          this._active = false, this._touches = {}, this._sum = new e.P(0, 0);
        }
        _shouldBePrevented(t2) {
          return t2 < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
        }
        touchstart(t2, e2, i2) {
          return this._calculateTransform(t2, e2, i2);
        }
        touchmove(t2, e2, i2) {
          if (this._active) {
            if (!this._shouldBePrevented(i2.length))
              return t2.preventDefault(), this._calculateTransform(t2, e2, i2);
            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", t2);
          }
        }
        touchend(t2, e2, i2) {
          this._calculateTransform(t2, e2, i2), this._active && this._shouldBePrevented(i2.length) && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t2, i2, a2) {
          a2.length > 0 && (this._active = true);
          const s2 = ja(a2, i2), o2 = new e.P(0, 0), r2 = new e.P(0, 0);
          let n2 = 0;
          for (const t3 in s2) {
            const e2 = s2[t3], i3 = this._touches[t3];
            i3 && (o2._add(e2), r2._add(e2.sub(i3)), n2++, s2[t3] = e2);
          }
          if (this._touches = s2, this._shouldBePrevented(n2) || !r2.mag())
            return;
          const l2 = r2.div(n2);
          return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? undefined : { around: o2.div(n2), panDelta: l2 };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }

      class Qa {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = false, delete this._firstTwoTouches;
        }
        touchstart(t2, e2, i2) {
          this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([e2[0], e2[1]]));
        }
        touchmove(t2, e2, i2) {
          if (!this._firstTwoTouches)
            return;
          t2.preventDefault();
          const [a2, s2] = this._firstTwoTouches, o2 = ts(i2, e2, a2), r2 = ts(i2, e2, s2);
          if (!o2 || !r2)
            return;
          const n2 = this._aroundCenter ? null : o2.add(r2).div(2);
          return this._move([o2, r2], n2, t2);
        }
        touchend(t2, e2, i2) {
          if (!this._firstTwoTouches)
            return;
          const [a2, s2] = this._firstTwoTouches, o2 = ts(i2, e2, a2), n2 = ts(i2, e2, s2);
          o2 && n2 || (this._active && r.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(t2) {
          this._enabled = true, this._aroundCenter = !!t2 && t2.around === "center";
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function ts(t2, e2, i2) {
        for (let a2 = 0;a2 < t2.length; a2++)
          if (t2[a2].identifier === i2)
            return e2[a2];
      }
      function es(t2, e2) {
        return Math.log(t2 / e2) / Math.LN2;
      }

      class is extends Qa {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(t2) {
          this._startDistance = this._distance = t2[0].dist(t2[1]);
        }
        _move(t2, e2) {
          const i2 = this._distance;
          if (this._distance = t2[0].dist(t2[1]), this._active || !(Math.abs(es(this._distance, this._startDistance)) < 0.1))
            return this._active = true, { zoomDelta: es(this._distance, i2), pinchAround: e2 };
        }
      }
      function as(t2, e2) {
        return 180 * t2.angleWith(e2) / Math.PI;
      }

      class ss extends Qa {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(t2) {
          this._startVector = this._vector = t2[0].sub(t2[1]), this._minDiameter = t2[0].dist(t2[1]);
        }
        _move(t2, e2, i2) {
          const a2 = this._vector;
          if (this._vector = t2[0].sub(t2[1]), this._active || !this._isBelowThreshold(this._vector))
            return this._active = true, { bearingDelta: as(this._vector, a2), pinchAround: e2 };
        }
        _isBelowThreshold(t2) {
          this._minDiameter = Math.min(this._minDiameter, t2.mag());
          const e2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = as(t2, this._startVector);
          return Math.abs(i2) < e2;
        }
      }
      function os(t2) {
        return Math.abs(t2.y) > Math.abs(t2.x);
      }

      class rs extends Qa {
        constructor(t2) {
          super(), this._currentTouchCount = 0, this._map = t2;
        }
        reset() {
          super.reset(), this._valid = undefined, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(t2, e2, i2) {
          super.touchstart(t2, e2, i2), this._currentTouchCount = i2.length;
        }
        _start(t2) {
          this._lastPoints = t2, os(t2[0].sub(t2[1])) && (this._valid = false);
        }
        _move(t2, e2, i2) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3)
            return;
          const a2 = t2[0].sub(this._lastPoints[0]), s2 = t2[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(a2, s2, i2.timeStamp), this._valid ? (this._lastPoints = t2, this._active = true, { pitchDelta: (a2.y + s2.y) / 2 * -0.5 }) : undefined;
        }
        gestureBeginsVertically(t2, e2, i2) {
          if (this._valid !== undefined)
            return this._valid;
          const a2 = t2.mag() >= 2, s2 = e2.mag() >= 2;
          if (!a2 && !s2)
            return;
          if (!a2 || !s2)
            return this._firstMove === undefined && (this._firstMove = i2), i2 - this._firstMove < 100 && undefined;
          const o2 = t2.y > 0 == e2.y > 0;
          return os(t2) && os(e2) && o2;
        }
      }
      const ns = { panStep: 100, bearingStep: 15, pitchStep: 10 };

      class ls {
        constructor(t2) {
          this._tr = new Na(t2);
          const e2 = ns;
          this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
        }
        reset() {
          this._active = false;
        }
        keydown(t2) {
          if (t2.altKey || t2.ctrlKey || t2.metaKey)
            return;
          let e2 = 0, i2 = 0, a2 = 0, s2 = 0, o2 = 0;
          switch (t2.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              e2 = 1;
              break;
            case 189:
            case 109:
            case 173:
              e2 = -1;
              break;
            case 37:
              t2.shiftKey ? i2 = -1 : (t2.preventDefault(), s2 = -1);
              break;
            case 39:
              t2.shiftKey ? i2 = 1 : (t2.preventDefault(), s2 = 1);
              break;
            case 38:
              t2.shiftKey ? a2 = 1 : (t2.preventDefault(), o2 = -1);
              break;
            case 40:
              t2.shiftKey ? a2 = -1 : (t2.preventDefault(), o2 = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (i2 = 0, a2 = 0), {
            cameraAnimation: (r2) => {
              const n2 = this._tr;
              r2.easeTo({
                duration: 300,
                easeId: "keyboardHandler",
                easing: hs,
                zoom: e2 ? Math.round(n2.zoom) + e2 * (t2.shiftKey ? 2 : 1) : n2.zoom,
                bearing: n2.bearing + i2 * this._bearingStep,
                pitch: n2.pitch + a2 * this._pitchStep,
                offset: [-s2 * this._panStep, -o2 * this._panStep],
                center: n2.center
              }, { originalEvent: t2 });
            }
          };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = true;
        }
        enableRotation() {
          this._rotationDisabled = false;
        }
      }
      function hs(t2) {
        return t2 * (2 - t2);
      }
      const cs = 4.000244140625;

      class us {
        constructor(t2, e2) {
          this._onTimeout = (t3) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t3);
          }, this._map = t2, this._tr = new Na(t2), this._triggerRenderFrame = e2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(t2) {
          this._defaultZoomRate = t2;
        }
        setWheelZoomRate(t2) {
          this._wheelZoomRate = t2;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== undefined;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(t2) {
          this.isEnabled() || (this._enabled = true, this._aroundCenter = !!t2 && t2.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = false);
        }
        _shouldBePrevented(t2) {
          return !!this._map.cooperativeGestures.isEnabled() && !(t2.ctrlKey || this._map.cooperativeGestures.isBypassed(t2));
        }
        wheel(t2) {
          if (!this.isEnabled())
            return;
          if (this._shouldBePrevented(t2))
            return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", t2);
          let e2 = t2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
          const i2 = o.now(), a2 = i2 - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = i2, e2 !== 0 && e2 % cs == 0 ? this._type = "wheel" : e2 !== 0 && Math.abs(e2) < 4 ? this._type = "trackpad" : a2 > 400 ? (this._type = null, this._lastValue = e2, this._timeout = setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(a2 * e2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, e2 += this._lastValue)), t2.shiftKey && e2 && (e2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= e2, this._active || this._start(t2)), t2.preventDefault();
        }
        _start(t2) {
          if (!this._delta)
            return;
          this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const i2 = r.mousePos(this._map.getCanvas(), t2), a2 = this._tr;
          this._around = i2.y > a2.transform.height / 2 - a2.transform.getHorizon() ? e.N.convert(this._aroundCenter ? a2.center : a2.unproject(i2)) : e.N.convert(a2.center), this._aroundPoint = a2.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId)
            return;
          if (this._frameId = null, !this.isActive())
            return;
          const t2 = this._tr.transform;
          if (this._delta !== 0) {
            const e2 = this._type === "wheel" && Math.abs(this._delta) > cs ? this._wheelZoomRate : this._defaultZoomRate;
            let i3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e2)));
            this._delta < 0 && i3 !== 0 && (i3 = 1 / i3);
            const a3 = typeof this._targetZoom == "number" ? t2.zoomScale(this._targetZoom) : t2.scale;
            this._targetZoom = Math.min(t2.maxZoom, Math.max(t2.minZoom, t2.scaleZoom(a3 * i3))), this._type === "wheel" && (this._startZoom = t2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const i2 = typeof this._targetZoom == "number" ? this._targetZoom : t2.zoom, a2 = this._startZoom, s2 = this._easing;
          let r2, n2 = false;
          const l2 = o.now() - this._lastWheelEventTime;
          if (this._type === "wheel" && a2 && s2 && l2) {
            const t3 = Math.min(l2 / 200, 1), o2 = s2(t3);
            r2 = e.y.number(a2, i2, o2), t3 < 1 ? this._frameId || (this._frameId = true) : n2 = true;
          } else
            r2 = i2, n2 = true;
          return this._active = true, n2 && (this._active = false, this._finishTimeout = setTimeout(() => {
            this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
          }, 200)), {
            noInertia: true,
            needsRenderFrame: !n2,
            zoomDelta: r2 - t2.zoom,
            around: this._aroundPoint,
            originalEvent: this._lastWheelEvent
          };
        }
        _smoothOutEasing(t2) {
          let i2 = e.b9;
          if (this._prevEase) {
            const t3 = this._prevEase, a2 = (o.now() - t3.start) / t3.duration, s2 = t3.easing(a2 + 0.01) - t3.easing(a2), r2 = 0.27 / Math.sqrt(s2 * s2 + 0.0001) * 0.01, n2 = Math.sqrt(0.0729 - r2 * r2);
            i2 = e.b8(r2, n2, 0.25, 1);
          }
          return this._prevEase = { start: o.now(), duration: t2, easing: i2 }, i2;
        }
        reset() {
          this._active = false, this._zooming = false, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }

      class ds {
        constructor(t2, e2) {
          this._clickZoom = t2, this._tapZoom = e2;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }

      class _s {
        constructor(t2) {
          this._tr = new Na(t2), this.reset();
        }
        reset() {
          this._active = false;
        }
        dblclick(t2, e2) {
          return t2.preventDefault(), {
            cameraAnimation: (i2) => {
              i2.easeTo({
                duration: 300,
                zoom: this._tr.zoom + (t2.shiftKey ? -1 : 1),
                around: this._tr.unproject(e2)
              }, { originalEvent: t2 });
            }
          };
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }

      class ps {
        constructor() {
          this._tap = new qa({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(t2, e2, i2) {
          if (!this._swipePoint)
            if (this._tapTime) {
              const a2 = e2[0], s2 = t2.timeStamp - this._tapTime < 500, o2 = this._tapPoint.dist(a2) < 30;
              s2 && o2 ? i2.length > 0 && (this._swipePoint = a2, this._swipeTouch = i2[0].identifier) : this.reset();
            } else
              this._tap.touchstart(t2, e2, i2);
        }
        touchmove(t2, e2, i2) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (i2[0].identifier !== this._swipeTouch)
                return;
              const a2 = e2[0], s2 = a2.y - this._swipePoint.y;
              return this._swipePoint = a2, t2.preventDefault(), this._active = true, { zoomDelta: s2 / 128 };
            }
          } else
            this._tap.touchmove(t2, e2, i2);
        }
        touchend(t2, e2, i2) {
          if (this._tapTime)
            this._swipePoint && i2.length === 0 && this.reset();
          else {
            const a2 = this._tap.touchend(t2, e2, i2);
            a2 && (this._tapTime = t2.timeStamp, this._tapPoint = a2);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = true;
        }
        disable() {
          this._enabled = false, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }

      class ms {
        constructor(t2, e2, i2) {
          this._el = t2, this._mousePan = e2, this._touchPan = i2;
        }
        enable(t2) {
          this._inertiaOptions = t2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }

      class fs {
        constructor(t2, e2, i2) {
          this._pitchWithRotate = t2.pitchWithRotate, this._mouseRotate = e2, this._mousePitch = i2;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }

      class gs {
        constructor(t2, e2, i2, a2) {
          this._el = t2, this._touchZoom = e2, this._touchRotate = i2, this._tapDragZoom = a2, this._rotationDisabled = false, this._enabled = true;
        }
        enable(t2) {
          this._touchZoom.enable(t2), this._rotationDisabled || this._touchRotate.enable(t2), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = true, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }

      class vs {
        constructor(t2, e2) {
          this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = t2, this._options = e2, this._enabled = false;
        }
        isActive() {
          return false;
        }
        reset() {
        }
        _setupUI() {
          if (this._container)
            return;
          const t2 = this._map.getCanvasContainer();
          t2.classList.add("maplibregl-cooperative-gestures"), this._container = r.create("div", "maplibregl-cooperative-gesture-screen", t2);
          let e2 = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
          this._bypassKey === "metaKey" && (e2 = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
          const i2 = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), a2 = document.createElement("div");
          a2.className = "maplibregl-desktop-message", a2.textContent = e2, this._container.appendChild(a2);
          const s2 = document.createElement("div");
          s2.className = "maplibregl-mobile-message", s2.textContent = i2, this._container.appendChild(s2), this._container.setAttribute("aria-hidden", "true");
        }
        _destroyUI() {
          this._container && (r.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = true;
        }
        disable() {
          this._enabled = false, this._destroyUI();
        }
        isEnabled() {
          return this._enabled;
        }
        isBypassed(t2) {
          return t2[this._bypassKey];
        }
        notifyGestureBlocked(t2, i2) {
          this._enabled && (this._map.fire(new e.k("cooperativegestureprevented", {
            gestureType: t2,
            originalEvent: i2
          })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
            this._container.classList.remove("maplibregl-show");
          }, 100));
        }
      }
      const xs = (t2) => t2.zoom || t2.drag || t2.pitch || t2.rotate;

      class ys extends e.k {
      }
      function bs(t2) {
        return t2.panDelta && t2.panDelta.mag() || t2.zoomDelta || t2.bearingDelta || t2.pitchDelta;
      }

      class ws {
        constructor(t2, e2) {
          this.handleWindowEvent = (t3) => {
            this.handleEvent(t3, `${t3.type}Window`);
          }, this.handleEvent = (t3, e3) => {
            if (t3.type === "blur")
              return void this.stop(true);
            this._updatingCamera = true;
            const i3 = t3.type === "renderFrame" ? undefined : t3, a2 = { needsRenderFrame: false }, s2 = {}, o2 = {}, n2 = t3.touches, l2 = n2 ? this._getMapTouches(n2) : undefined, h2 = l2 ? r.touchPos(this._map.getCanvas(), l2) : r.mousePos(this._map.getCanvas(), t3);
            for (const { handlerName: r2, handler: n3, allowed: c3 } of this._handlers) {
              if (!n3.isEnabled())
                continue;
              let u3;
              this._blockedByActive(o2, c3, r2) ? n3.reset() : n3[e3 || t3.type] && (u3 = n3[e3 || t3.type](t3, h2, l2), this.mergeHandlerResult(a2, s2, u3, r2, i3), u3 && u3.needsRenderFrame && this._triggerRenderFrame()), (u3 || n3.isActive()) && (o2[r2] = n3);
            }
            const c2 = {};
            for (const t4 in this._previousActiveHandlers)
              o2[t4] || (c2[t4] = i3);
            this._previousActiveHandlers = o2, (Object.keys(c2).length || bs(a2)) && (this._changes.push([a2, s2, c2]), this._triggerRenderFrame()), (Object.keys(o2).length || bs(a2)) && this._map._stop(true), this._updatingCamera = false;
            const { cameraAnimation: u2 } = a2;
            u2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u2(this._map));
          }, this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ma(t2), this._bearingSnap = e2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(e2);
          const i2 = this._el;
          this._listeners = [
            [i2, "touchstart", { passive: true }],
            [i2, "touchmove", { passive: false }],
            [i2, "touchend", undefined],
            [i2, "touchcancel", undefined],
            [i2, "mousedown", undefined],
            [i2, "mousemove", undefined],
            [i2, "mouseup", undefined],
            [document, "mousemove", { capture: true }],
            [document, "mouseup", undefined],
            [i2, "mouseover", undefined],
            [i2, "mouseout", undefined],
            [i2, "dblclick", undefined],
            [i2, "click", undefined],
            [i2, "keydown", { capture: false }],
            [i2, "keyup", undefined],
            [i2, "wheel", { passive: false }],
            [i2, "contextmenu", undefined],
            [window, "blur", undefined]
          ];
          for (const [t3, e3, i3] of this._listeners)
            r.addEventListener(t3, e3, t3 === document ? this.handleWindowEvent : this.handleEvent, i3);
        }
        destroy() {
          for (const [t2, e2, i2] of this._listeners)
            r.removeEventListener(t2, e2, t2 === document ? this.handleWindowEvent : this.handleEvent, i2);
        }
        _addDefaultHandlers(t2) {
          const e2 = this._map, i2 = e2.getCanvasContainer();
          this._add("mapEvent", new Ba(e2, t2));
          const a2 = e2.boxZoom = new Ua(e2, t2);
          this._add("boxZoom", a2), t2.interactive && t2.boxZoom && a2.enable();
          const s2 = e2.cooperativeGestures = new vs(e2, t2.cooperativeGestures);
          this._add("cooperativeGestures", s2), t2.cooperativeGestures && s2.enable();
          const o2 = new Va(e2), n2 = new _s(e2);
          e2.doubleClickZoom = new ds(n2, o2), this._add("tapZoom", o2), this._add("clickZoom", n2), t2.interactive && t2.doubleClickZoom && e2.doubleClickZoom.enable();
          const l2 = new ps;
          this._add("tapDragZoom", l2);
          const h2 = e2.touchPitch = new rs(e2);
          this._add("touchPitch", h2), t2.interactive && t2.touchPitch && e2.touchPitch.enable(t2.touchPitch);
          const c2 = Ka(t2), u2 = Ja(t2);
          e2.dragRotate = new fs(t2, c2, u2), this._add("mouseRotate", c2, ["mousePitch"]), this._add("mousePitch", u2, ["mouseRotate"]), t2.interactive && t2.dragRotate && e2.dragRotate.enable();
          const d2 = (({ enable: t3, clickTolerance: e3 }) => {
            const i3 = new Wa({
              checkCorrectEvent: (t4) => r.mouseButton(t4) === 0 && !t4.ctrlKey
            });
            return new Ga({
              clickTolerance: e3,
              move: (t4, e4) => ({ around: e4, panDelta: e4.sub(t4) }),
              activateOnStart: true,
              moveStateManager: i3,
              enable: t3,
              assignEvents: Xa
            });
          })(t2), _2 = new Ya(t2, e2);
          e2.dragPan = new ms(i2, d2, _2), this._add("mousePan", d2), this._add("touchPan", _2, ["touchZoom", "touchRotate"]), t2.interactive && t2.dragPan && e2.dragPan.enable(t2.dragPan);
          const p2 = new ss, m2 = new is;
          e2.touchZoomRotate = new gs(i2, m2, p2, l2), this._add("touchRotate", p2, ["touchPan", "touchZoom"]), this._add("touchZoom", m2, ["touchPan", "touchRotate"]), t2.interactive && t2.touchZoomRotate && e2.touchZoomRotate.enable(t2.touchZoomRotate);
          const f2 = e2.scrollZoom = new us(e2, () => this._triggerRenderFrame());
          this._add("scrollZoom", f2, ["mousePan"]), t2.interactive && t2.scrollZoom && e2.scrollZoom.enable(t2.scrollZoom);
          const g2 = e2.keyboard = new ls(e2);
          this._add("keyboard", g2), t2.interactive && t2.keyboard && e2.keyboard.enable(), this._add("blockableMapEvent", new Oa(e2));
        }
        _add(t2, e2, i2) {
          this._handlers.push({ handlerName: t2, handler: e2, allowed: i2 }), this._handlersById[t2] = e2;
        }
        stop(t2) {
          if (!this._updatingCamera) {
            for (const { handler: t3 } of this._handlers)
              t3.reset();
            this._inertia.clear(), this._fireEvents({}, {}, t2), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: t2 } of this._handlers)
            if (t2.isActive())
              return true;
          return false;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return Boolean(xs(this._eventsInProgress)) || this.isZooming();
        }
        _blockedByActive(t2, e2, i2) {
          for (const a2 in t2)
            if (a2 !== i2 && (!e2 || e2.indexOf(a2) < 0))
              return true;
          return false;
        }
        _getMapTouches(t2) {
          const e2 = [];
          for (const i2 of t2)
            this._el.contains(i2.target) && e2.push(i2);
          return e2;
        }
        mergeHandlerResult(t2, i2, a2, s2, o2) {
          if (!a2)
            return;
          e.e(t2, a2);
          const r2 = { handlerName: s2, originalEvent: a2.originalEvent || o2 };
          a2.zoomDelta !== undefined && (i2.zoom = r2), a2.panDelta !== undefined && (i2.drag = r2), a2.pitchDelta !== undefined && (i2.pitch = r2), a2.bearingDelta !== undefined && (i2.rotate = r2);
        }
        _applyChanges() {
          const t2 = {}, i2 = {}, a2 = {};
          for (const [s2, o2, r2] of this._changes)
            s2.panDelta && (t2.panDelta = (t2.panDelta || new e.P(0, 0))._add(s2.panDelta)), s2.zoomDelta && (t2.zoomDelta = (t2.zoomDelta || 0) + s2.zoomDelta), s2.bearingDelta && (t2.bearingDelta = (t2.bearingDelta || 0) + s2.bearingDelta), s2.pitchDelta && (t2.pitchDelta = (t2.pitchDelta || 0) + s2.pitchDelta), s2.around !== undefined && (t2.around = s2.around), s2.pinchAround !== undefined && (t2.pinchAround = s2.pinchAround), s2.noInertia && (t2.noInertia = s2.noInertia), e.e(i2, o2), e.e(a2, r2);
          this._updateMapTransform(t2, i2, a2), this._changes = [];
        }
        _updateMapTransform(t2, e2, i2) {
          const a2 = this._map, s2 = a2._getTransformForUpdate(), o2 = a2.terrain;
          if (!(bs(t2) || o2 && this._terrainMovement))
            return this._fireEvents(e2, i2, true);
          let {
            panDelta: r2,
            zoomDelta: n2,
            bearingDelta: l2,
            pitchDelta: h2,
            around: c2,
            pinchAround: u2
          } = t2;
          u2 !== undefined && (c2 = u2), a2._stop(true), c2 = c2 || a2.transform.centerPoint;
          const d2 = s2.pointLocation(r2 ? c2.sub(r2) : c2);
          l2 && (s2.bearing += l2), h2 && (s2.pitch += h2), n2 && (s2.zoom += n2), o2 ? this._terrainMovement || !e2.drag && !e2.zoom ? e2.drag && this._terrainMovement ? s2.center = s2.pointLocation(s2.centerPoint.sub(r2)) : s2.setLocationAtPoint(d2, c2) : (this._terrainMovement = true, this._map._elevationFreeze = true, s2.setLocationAtPoint(d2, c2)) : s2.setLocationAtPoint(d2, c2), a2._applyUpdatedTransform(s2), this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(e2, i2, true);
        }
        _fireEvents(t2, i2, a2) {
          const s2 = xs(this._eventsInProgress), r2 = xs(t2), n2 = {};
          for (const e2 in t2) {
            const { originalEvent: i3 } = t2[e2];
            this._eventsInProgress[e2] || (n2[`${e2}start`] = i3), this._eventsInProgress[e2] = t2[e2];
          }
          !s2 && r2 && this._fireEvent("movestart", r2.originalEvent);
          for (const t3 in n2)
            this._fireEvent(t3, n2[t3]);
          r2 && this._fireEvent("move", r2.originalEvent);
          for (const e2 in t2) {
            const { originalEvent: i3 } = t2[e2];
            this._fireEvent(e2, i3);
          }
          const l2 = {};
          let h2;
          for (const t3 in this._eventsInProgress) {
            const { handlerName: e2, originalEvent: a3 } = this._eventsInProgress[t3];
            this._handlersById[e2].isActive() || (delete this._eventsInProgress[t3], h2 = i2[e2] || a3, l2[`${t3}end`] = h2);
          }
          for (const t3 in l2)
            this._fireEvent(t3, l2[t3]);
          const c2 = xs(this._eventsInProgress), u2 = (s2 || r2) && !c2;
          if (u2 && this._terrainMovement) {
            this._map._elevationFreeze = false, this._terrainMovement = false;
            const t3 = this._map._getTransformForUpdate();
            t3.recalculateZoom(this._map.terrain), this._map._applyUpdatedTransform(t3);
          }
          if (a2 && u2) {
            this._updatingCamera = true;
            const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (t4) => t4 !== 0 && -this._bearingSnap < t4 && t4 < this._bearingSnap;
            !t3 || !t3.essential && o.prefersReducedMotion ? (this._map.fire(new e.k("moveend", { originalEvent: h2 })), i3(this._map.getBearing()) && this._map.resetNorth()) : (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), t3.freezeElevation = true, this._map.easeTo(t3, { originalEvent: h2 })), this._updatingCamera = false;
          }
        }
        _fireEvent(t2, i2) {
          this._map.fire(new e.k(t2, i2 ? { originalEvent: i2 } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t2) => {
            delete this._frameId, this.handleEvent(new ys("renderFrame", { timeStamp: t2 })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === undefined && (this._frameId = this._requestFrame());
        }
      }

      class Ts extends e.E {
        constructor(t2, e2) {
          super(), this._renderFrameCallback = () => {
            const t3 = Math.min((o.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(t3)), t3 < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = false, this._zooming = false, this.transform = t2, this._bearingSnap = e2.bearingSnap, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        getCenter() {
          return new e.N(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(t2, e2) {
          return this.jumpTo({ center: t2 }, e2);
        }
        panBy(t2, i2, a2) {
          return t2 = e.P.convert(t2).mult(-1), this.panTo(this.transform.center, e.e({ offset: t2 }, i2), a2);
        }
        panTo(t2, i2, a2) {
          return this.easeTo(e.e({ center: t2 }, i2), a2);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(t2, e2) {
          return this.jumpTo({ zoom: t2 }, e2), this;
        }
        zoomTo(t2, i2, a2) {
          return this.easeTo(e.e({ zoom: t2 }, i2), a2);
        }
        zoomIn(t2, e2) {
          return this.zoomTo(this.getZoom() + 1, t2, e2), this;
        }
        zoomOut(t2, e2) {
          return this.zoomTo(this.getZoom() - 1, t2, e2), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(t2, e2) {
          return this.jumpTo({ bearing: t2 }, e2), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(t2, e2) {
          return this.jumpTo({ padding: t2 }, e2), this;
        }
        rotateTo(t2, i2, a2) {
          return this.easeTo(e.e({ bearing: t2 }, i2), a2);
        }
        resetNorth(t2, i2) {
          return this.rotateTo(0, e.e({ duration: 1000 }, t2), i2), this;
        }
        resetNorthPitch(t2, i2) {
          return this.easeTo(e.e({ bearing: 0, pitch: 0, duration: 1000 }, t2), i2), this;
        }
        snapToNorth(t2, e2) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t2, e2) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(t2, e2) {
          return this.jumpTo({ pitch: t2 }, e2), this;
        }
        cameraForBounds(t2, e2) {
          t2 = H.convert(t2).adjustAntiMeridian();
          const i2 = e2 && e2.bearing || 0;
          return this._cameraForBoxAndBearing(t2.getNorthWest(), t2.getSouthEast(), i2, e2);
        }
        _cameraForBoxAndBearing(t2, i2, a2, s2) {
          const o2 = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (s2 = e.e({ padding: o2, offset: [0, 0], maxZoom: this.transform.maxZoom }, s2)).padding == "number") {
            const t3 = s2.padding;
            s2.padding = { top: t3, bottom: t3, right: t3, left: t3 };
          }
          s2.padding = e.e(o2, s2.padding);
          const r2 = this.transform, n2 = r2.padding, l2 = new H(t2, i2), h2 = r2.project(l2.getNorthWest()), c2 = r2.project(l2.getNorthEast()), u2 = r2.project(l2.getSouthEast()), d2 = r2.project(l2.getSouthWest()), _2 = e.ba(-a2), p2 = h2.rotate(_2), m2 = c2.rotate(_2), f2 = u2.rotate(_2), g2 = d2.rotate(_2), v2 = new e.P(Math.max(p2.x, m2.x, g2.x, f2.x), Math.max(p2.y, m2.y, g2.y, f2.y)), x2 = new e.P(Math.min(p2.x, m2.x, g2.x, f2.x), Math.min(p2.y, m2.y, g2.y, f2.y)), y2 = v2.sub(x2), b2 = (r2.width - (n2.left + n2.right + s2.padding.left + s2.padding.right)) / y2.x, w2 = (r2.height - (n2.top + n2.bottom + s2.padding.top + s2.padding.bottom)) / y2.y;
          if (w2 < 0 || b2 < 0)
            return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
          const T2 = Math.min(r2.scaleZoom(r2.scale * Math.min(b2, w2)), s2.maxZoom), I2 = e.P.convert(s2.offset), E2 = new e.P((s2.padding.left - s2.padding.right) / 2, (s2.padding.top - s2.padding.bottom) / 2).rotate(e.ba(a2)), P2 = I2.add(E2).mult(r2.scale / r2.zoomScale(T2));
          return { center: r2.unproject(h2.add(u2).div(2).sub(P2)), zoom: T2, bearing: a2 };
        }
        fitBounds(t2, e2, i2) {
          return this._fitInternal(this.cameraForBounds(t2, e2), e2, i2);
        }
        fitScreenCoordinates(t2, i2, a2, s2, o2) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(e.P.convert(t2)), this.transform.pointLocation(e.P.convert(i2)), a2, s2), s2, o2);
        }
        _fitInternal(t2, i2, a2) {
          return t2 ? (delete (i2 = e.e(t2, i2)).padding, i2.linear ? this.easeTo(i2, a2) : this.flyTo(i2, a2)) : this;
        }
        jumpTo(t2, i2) {
          this.stop();
          const a2 = this._getTransformForUpdate();
          let s2 = false, o2 = false, r2 = false;
          return "zoom" in t2 && a2.zoom !== +t2.zoom && (s2 = true, a2.zoom = +t2.zoom), t2.center !== undefined && (a2.center = e.N.convert(t2.center)), "bearing" in t2 && a2.bearing !== +t2.bearing && (o2 = true, a2.bearing = +t2.bearing), "pitch" in t2 && a2.pitch !== +t2.pitch && (r2 = true, a2.pitch = +t2.pitch), t2.padding == null || a2.isPaddingEqual(t2.padding) || (a2.padding = t2.padding), this._applyUpdatedTransform(a2), this.fire(new e.k("movestart", i2)).fire(new e.k("move", i2)), s2 && this.fire(new e.k("zoomstart", i2)).fire(new e.k("zoom", i2)).fire(new e.k("zoomend", i2)), o2 && this.fire(new e.k("rotatestart", i2)).fire(new e.k("rotate", i2)).fire(new e.k("rotateend", i2)), r2 && this.fire(new e.k("pitchstart", i2)).fire(new e.k("pitch", i2)).fire(new e.k("pitchend", i2)), this.fire(new e.k("moveend", i2));
        }
        calculateCameraOptionsFromTo(t2, i2, a2, s2 = 0) {
          const o2 = e.Z.fromLngLat(t2, i2), r2 = e.Z.fromLngLat(a2, s2), n2 = r2.x - o2.x, l2 = r2.y - o2.y, h2 = r2.z - o2.z, c2 = Math.hypot(n2, l2, h2);
          if (c2 === 0)
            throw new Error("Can't calculate camera options with same From and To");
          const u2 = Math.hypot(n2, l2), d2 = this.transform.scaleZoom(this.transform.cameraToCenterDistance / c2 / this.transform.tileSize), _2 = 180 * Math.atan2(n2, -l2) / Math.PI;
          let p2 = 180 * Math.acos(u2 / c2) / Math.PI;
          return p2 = h2 < 0 ? 90 - p2 : 90 + p2, { center: r2.toLngLat(), zoom: d2, pitch: p2, bearing: _2 };
        }
        easeTo(t2, i2) {
          var a2;
          this._stop(false, t2.easeId), ((t2 = e.e({ offset: [0, 0], duration: 500, easing: e.b9 }, t2)).animate === false || !t2.essential && o.prefersReducedMotion) && (t2.duration = 0);
          const s2 = this._getTransformForUpdate(), r2 = s2.zoom, n2 = s2.bearing, l2 = s2.pitch, h2 = s2.padding, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, u2 = "pitch" in t2 ? +t2.pitch : l2, d2 = "padding" in t2 ? t2.padding : s2.padding, _2 = e.P.convert(t2.offset);
          let p2 = s2.centerPoint.add(_2);
          const m2 = s2.pointLocation(p2), { center: f2, zoom: g2 } = s2.getConstrained(e.N.convert(t2.center || m2), (a2 = t2.zoom) !== null && a2 !== undefined ? a2 : r2);
          this._normalizeCenter(f2, s2);
          const v2 = s2.project(m2), x2 = s2.project(f2).sub(v2), y2 = s2.zoomScale(g2 - r2);
          let b2, w2;
          t2.around && (b2 = e.N.convert(t2.around), w2 = s2.locationPoint(b2));
          const T2 = {
            moving: this._moving,
            zooming: this._zooming,
            rotating: this._rotating,
            pitching: this._pitching
          };
          return this._zooming = this._zooming || g2 !== r2, this._rotating = this._rotating || n2 !== c2, this._pitching = this._pitching || u2 !== l2, this._padding = !s2.isPaddingEqual(d2), this._easeId = t2.easeId, this._prepareEase(i2, t2.noMoveStart, T2), this.terrain && this._prepareElevation(f2), this._ease((a3) => {
            if (this._zooming && (s2.zoom = e.y.number(r2, g2, a3)), this._rotating && (s2.bearing = e.y.number(n2, c2, a3)), this._pitching && (s2.pitch = e.y.number(l2, u2, a3)), this._padding && (s2.interpolatePadding(h2, d2, a3), p2 = s2.centerPoint.add(_2)), this.terrain && !t2.freezeElevation && this._updateElevation(a3), b2)
              s2.setLocationAtPoint(b2, w2);
            else {
              const t3 = s2.zoomScale(s2.zoom - r2), e2 = g2 > r2 ? Math.min(2, y2) : Math.max(0.5, y2), i3 = Math.pow(e2, 1 - a3), o2 = s2.unproject(v2.add(x2.mult(a3 * i3)).mult(t3));
              s2.setLocationAtPoint(s2.renderWorldCopies ? o2.wrap() : o2, p2);
            }
            this._applyUpdatedTransform(s2), this._fireMoveEvents(i2);
          }, (e2) => {
            this.terrain && t2.freezeElevation && this._finalizeElevation(), this._afterEase(i2, e2);
          }, t2), this;
        }
        _prepareEase(t2, i2, a2 = {}) {
          this._moving = true, i2 || a2.moving || this.fire(new e.k("movestart", t2)), this._zooming && !a2.zooming && this.fire(new e.k("zoomstart", t2)), this._rotating && !a2.rotating && this.fire(new e.k("rotatestart", t2)), this._pitching && !a2.pitching && this.fire(new e.k("pitchstart", t2));
        }
        _prepareElevation(t2) {
          this._elevationCenter = t2, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t2, this.transform.tileZoom), this._elevationFreeze = true;
        }
        _updateElevation(t2) {
          this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          const i2 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (t2 < 1 && i2 !== this._elevationTarget) {
            const e2 = this._elevationTarget - this._elevationStart;
            this._elevationStart += t2 * (e2 - (i2 - (e2 * t2 + this._elevationStart)) / (1 - t2)), this._elevationTarget = i2;
          }
          this.transform.elevation = e.y.number(this._elevationStart, this._elevationTarget, t2);
        }
        _finalizeElevation() {
          this._elevationFreeze = false, this.transform.recalculateZoom(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _elevateCameraIfInsideTerrain(t2) {
          const e2 = t2.getCameraPosition(), i2 = this.terrain.getElevationForLngLatZoom(e2.lngLat, t2.zoom);
          if (e2.altitude < i2) {
            const a2 = this.calculateCameraOptionsFromTo(e2.lngLat, i2, t2.center, t2.elevation);
            return { pitch: a2.pitch, zoom: a2.zoom };
          }
          return {};
        }
        _applyUpdatedTransform(t2) {
          const e2 = [];
          if (this.terrain && e2.push((t3) => this._elevateCameraIfInsideTerrain(t3)), this.transformCameraUpdate && e2.push((t3) => this.transformCameraUpdate(t3)), !e2.length)
            return;
          const i2 = t2.clone();
          for (const t3 of e2) {
            const e3 = i2.clone(), { center: a2, zoom: s2, pitch: o2, bearing: r2, elevation: n2 } = t3(e3);
            a2 && (e3.center = a2), s2 !== undefined && (e3.zoom = s2), o2 !== undefined && (e3.pitch = o2), r2 !== undefined && (e3.bearing = r2), n2 !== undefined && (e3.elevation = n2), i2.apply(e3);
          }
          this.transform.apply(i2);
        }
        _fireMoveEvents(t2) {
          this.fire(new e.k("move", t2)), this._zooming && this.fire(new e.k("zoom", t2)), this._rotating && this.fire(new e.k("rotate", t2)), this._pitching && this.fire(new e.k("pitch", t2));
        }
        _afterEase(t2, i2) {
          if (this._easeId && i2 && this._easeId === i2)
            return;
          delete this._easeId;
          const a2 = this._zooming, s2 = this._rotating, o2 = this._pitching;
          this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, a2 && this.fire(new e.k("zoomend", t2)), s2 && this.fire(new e.k("rotateend", t2)), o2 && this.fire(new e.k("pitchend", t2)), this.fire(new e.k("moveend", t2));
        }
        flyTo(t2, i2) {
          var a2;
          if (!t2.essential && o.prefersReducedMotion) {
            const a3 = e.M(t2, ["center", "zoom", "bearing", "pitch", "around"]);
            return this.jumpTo(a3, i2);
          }
          this.stop(), t2 = e.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.b9 }, t2);
          const s2 = this._getTransformForUpdate(), r2 = s2.zoom, n2 = s2.bearing, l2 = s2.pitch, h2 = s2.padding, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, n2) : n2, u2 = "pitch" in t2 ? +t2.pitch : l2, d2 = "padding" in t2 ? t2.padding : s2.padding, _2 = e.P.convert(t2.offset);
          let p2 = s2.centerPoint.add(_2);
          const m2 = s2.pointLocation(p2), { center: f2, zoom: g2 } = s2.getConstrained(e.N.convert(t2.center || m2), (a2 = t2.zoom) !== null && a2 !== undefined ? a2 : r2);
          this._normalizeCenter(f2, s2);
          const v2 = s2.zoomScale(g2 - r2), x2 = s2.project(m2), y2 = s2.project(f2).sub(x2);
          let b2 = t2.curve;
          const w2 = Math.max(s2.width, s2.height), T2 = w2 / v2, I2 = y2.mag();
          if ("minZoom" in t2) {
            const i3 = e.ac(Math.min(t2.minZoom, r2, g2), s2.minZoom, s2.maxZoom), a3 = w2 / s2.zoomScale(i3 - r2);
            b2 = Math.sqrt(a3 / I2 * 2);
          }
          const E2 = b2 * b2;
          function P2(t3) {
            const e2 = (T2 * T2 - w2 * w2 + (t3 ? -1 : 1) * E2 * E2 * I2 * I2) / (2 * (t3 ? T2 : w2) * E2 * I2);
            return Math.log(Math.sqrt(e2 * e2 + 1) - e2);
          }
          function C2(t3) {
            return (Math.exp(t3) - Math.exp(-t3)) / 2;
          }
          function S2(t3) {
            return (Math.exp(t3) + Math.exp(-t3)) / 2;
          }
          const z2 = P2(false);
          let D2 = function(t3) {
            return S2(z2) / S2(z2 + b2 * t3);
          }, M2 = function(t3) {
            return w2 * ((S2(z2) * (C2(e2 = z2 + b2 * t3) / S2(e2)) - C2(z2)) / E2) / I2;
            var e2;
          }, A2 = (P2(true) - z2) / b2;
          if (Math.abs(I2) < 0.000001 || !isFinite(A2)) {
            if (Math.abs(w2 - T2) < 0.000001)
              return this.easeTo(t2, i2);
            const e2 = T2 < w2 ? -1 : 1;
            A2 = Math.abs(Math.log(T2 / w2)) / b2, M2 = () => 0, D2 = (t3) => Math.exp(e2 * b2 * t3);
          }
          return t2.duration = "duration" in t2 ? +t2.duration : 1000 * A2 / ("screenSpeed" in t2 ? +t2.screenSpeed / b2 : +t2.speed), t2.maxDuration && t2.duration > t2.maxDuration && (t2.duration = 0), this._zooming = true, this._rotating = n2 !== c2, this._pitching = u2 !== l2, this._padding = !s2.isPaddingEqual(d2), this._prepareEase(i2, false), this.terrain && this._prepareElevation(f2), this._ease((a3) => {
            const o2 = a3 * A2, m3 = 1 / D2(o2);
            s2.zoom = a3 === 1 ? g2 : r2 + s2.scaleZoom(m3), this._rotating && (s2.bearing = e.y.number(n2, c2, a3)), this._pitching && (s2.pitch = e.y.number(l2, u2, a3)), this._padding && (s2.interpolatePadding(h2, d2, a3), p2 = s2.centerPoint.add(_2)), this.terrain && !t2.freezeElevation && this._updateElevation(a3);
            const v3 = a3 === 1 ? f2 : s2.unproject(x2.add(y2.mult(M2(o2))).mult(m3));
            s2.setLocationAtPoint(s2.renderWorldCopies ? v3.wrap() : v3, p2), this._applyUpdatedTransform(s2), this._fireMoveEvents(i2);
          }, () => {
            this.terrain && t2.freezeElevation && this._finalizeElevation(), this._afterEase(i2);
          }, t2), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(t2, e2) {
          var i2;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const t3 = this._onEaseEnd;
            delete this._onEaseEnd, t3.call(this, e2);
          }
          return t2 || (i2 = this.handlers) === null || i2 === undefined || i2.stop(false), this;
        }
        _ease(t2, e2, i2) {
          i2.animate === false || i2.duration === 0 ? (t2(1), e2()) : (this._easeStart = o.now(), this._easeOptions = i2, this._onEaseFrame = t2, this._onEaseEnd = e2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(t2, i2) {
          t2 = e.b3(t2, -180, 180);
          const a2 = Math.abs(t2 - i2);
          return Math.abs(t2 - 360 - i2) < a2 && (t2 -= 360), Math.abs(t2 + 360 - i2) < a2 && (t2 += 360), t2;
        }
        _normalizeCenter(t2, e2) {
          if (!e2.renderWorldCopies || e2.lngRange)
            return;
          const i2 = t2.lng - e2.center.lng;
          t2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
        }
        queryTerrainElevation(t2) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(e.N.convert(t2), this.transform.tileZoom) - this.transform.elevation : null;
        }
      }
      const Is = {
        compact: true,
        customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
      };

      class Es {
        constructor(t2 = Is) {
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (t3) => {
            !t3 || t3.sourceDataType !== "metadata" && t3.sourceDataType !== "visibility" && t3.dataType !== "style" && t3.type !== "terrain" || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === false ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = t2;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(t2) {
          return this._map = t2, this._compact = this.options.compact, this._container = r.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = r.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = r.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          r.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = undefined, this._compact = undefined, this._attribHTML = undefined;
        }
        _setElementTitle(t2, e2) {
          const i2 = this._map._getUIString(`AttributionControl.${e2}`);
          t2.title = i2, t2.setAttribute("aria-label", i2);
        }
        _updateAttributions() {
          if (!this._map.style)
            return;
          let t2 = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t2 = t2.concat(this.options.customAttribution.map((t3) => typeof t3 != "string" ? "" : t3)) : typeof this.options.customAttribution == "string" && t2.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const t3 = this._map.style.stylesheet;
            this.styleOwner = t3.owner, this.styleId = t3.id;
          }
          const e2 = this._map.style.sourceCaches;
          for (const i3 in e2) {
            const a2 = e2[i3];
            if (a2.used || a2.usedForTerrain) {
              const e3 = a2.getSource();
              e3.attribution && t2.indexOf(e3.attribution) < 0 && t2.push(e3.attribution);
            }
          }
          t2 = t2.filter((t3) => String(t3).trim()), t2.sort((t3, e3) => t3.length - e3.length), t2 = t2.filter((e3, i3) => {
            for (let a2 = i3 + 1;a2 < t2.length; a2++)
              if (t2[a2].indexOf(e3) >= 0)
                return false;
            return true;
          });
          const i2 = t2.join(" | ");
          i2 !== this._attribHTML && (this._attribHTML = i2, t2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }

      class Ps {
        constructor(t2 = {}) {
          this._updateCompact = () => {
            const t3 = this._container.children;
            if (t3.length) {
              const e2 = t3[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== false && e2.classList.add("maplibregl-compact") : e2.classList.remove("maplibregl-compact");
            }
          }, this.options = t2;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(t2) {
          this._map = t2, this._compact = this.options && this.options.compact, this._container = r.create("div", "maplibregl-ctrl");
          const e2 = r.create("a", "maplibregl-ctrl-logo");
          return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://maplibre.org/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          r.remove(this._container), this._map.off("resize", this._updateCompact), this._map = undefined, this._compact = undefined;
        }
      }

      class Cs {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
        }
        add(t2) {
          const e2 = ++this._id;
          return this._queue.push({ callback: t2, id: e2, cancelled: false }), e2;
        }
        remove(t2) {
          const e2 = this._currentlyRunning, i2 = e2 ? this._queue.concat(e2) : this._queue;
          for (const e3 of i2)
            if (e3.id === t2)
              return void (e3.cancelled = true);
        }
        run(t2 = 0) {
          if (this._currentlyRunning)
            throw new Error("Attempting to run(), but is already running.");
          const e2 = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const i2 of e2)
            if (!i2.cancelled && (i2.callback(t2), this._cleared))
              break;
          this._cleared = false, this._currentlyRunning = false;
        }
        clear() {
          this._currentlyRunning && (this._cleared = true), this._queue = [];
        }
      }
      var Ss = e.Y([{ name: "a_pos3d", type: "Int16", components: 3 }]);

      class zs extends e.E {
        constructor(t2) {
          super(), this.sourceCache = t2, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, t2.usedForTerrain = true, t2.tileSize = this.tileSize * 2 ** this.deltaZoom;
        }
        destruct() {
          this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
        }
        update(t2, i2) {
          this.sourceCache.update(t2, i2), this._renderableTilesKeys = [];
          const a2 = {};
          for (const s2 of t2.coveringTiles({
            tileSize: this.tileSize,
            minzoom: this.minzoom,
            maxzoom: this.maxzoom,
            reparseOverscaled: false,
            terrain: i2
          }))
            a2[s2.key] = true, this._renderableTilesKeys.push(s2.key), this._tiles[s2.key] || (s2.posMatrix = new Float64Array(16), e.aP(s2.posMatrix, 0, e.X, 0, e.X, 0, 1), this._tiles[s2.key] = new lt(s2, this.tileSize));
          for (const t3 in this._tiles)
            a2[t3] || delete this._tiles[t3];
        }
        freeRtt(t2) {
          for (const e2 in this._tiles) {
            const i2 = this._tiles[e2];
            (!t2 || i2.tileID.equals(t2) || i2.tileID.isChildOf(t2) || t2.isChildOf(i2.tileID)) && (i2.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((t2) => this.getTileByID(t2));
        }
        getTileByID(t2) {
          return this._tiles[t2];
        }
        getTerrainCoords(t2) {
          const i2 = {};
          for (const a2 of this._renderableTilesKeys) {
            const s2 = this._tiles[a2].tileID;
            if (s2.canonical.equals(t2.canonical)) {
              const s3 = t2.clone();
              s3.posMatrix = new Float64Array(16), e.aP(s3.posMatrix, 0, e.X, 0, e.X, 0, 1), i2[a2] = s3;
            } else if (s2.canonical.isChildOf(t2.canonical)) {
              const o2 = t2.clone();
              o2.posMatrix = new Float64Array(16);
              const r2 = s2.canonical.z - t2.canonical.z, n2 = s2.canonical.x - (s2.canonical.x >> r2 << r2), l2 = s2.canonical.y - (s2.canonical.y >> r2 << r2), h2 = e.X >> r2;
              e.aP(o2.posMatrix, 0, h2, 0, h2, 0, 1), e.J(o2.posMatrix, o2.posMatrix, [-n2 * h2, -l2 * h2, 0]), i2[a2] = o2;
            } else if (t2.canonical.isChildOf(s2.canonical)) {
              const o2 = t2.clone();
              o2.posMatrix = new Float64Array(16);
              const r2 = t2.canonical.z - s2.canonical.z, n2 = t2.canonical.x - (t2.canonical.x >> r2 << r2), l2 = t2.canonical.y - (t2.canonical.y >> r2 << r2), h2 = e.X >> r2;
              e.aP(o2.posMatrix, 0, e.X, 0, e.X, 0, 1), e.J(o2.posMatrix, o2.posMatrix, [n2 * h2, l2 * h2, 0]), e.K(o2.posMatrix, o2.posMatrix, [1 / 2 ** r2, 1 / 2 ** r2, 0]), i2[a2] = o2;
            }
          }
          return i2;
        }
        getSourceTile(t2, e2) {
          const i2 = this.sourceCache._source;
          let a2 = t2.overscaledZ - this.deltaZoom;
          if (a2 > i2.maxzoom && (a2 = i2.maxzoom), a2 < i2.minzoom)
            return null;
          this._sourceTileCache[t2.key] || (this._sourceTileCache[t2.key] = t2.scaledTo(a2).key);
          let s2 = this.sourceCache.getTileByID(this._sourceTileCache[t2.key]);
          if ((!s2 || !s2.dem) && e2)
            for (;a2 >= i2.minzoom && (!s2 || !s2.dem); )
              s2 = this.sourceCache.getTileByID(t2.scaledTo(a2--).key);
          return s2;
        }
        tilesAfterTime(t2 = Date.now()) {
          return Object.values(this._tiles).filter((e2) => e2.timeAdded >= t2);
        }
      }

      class Ds {
        constructor(t2, e2, i2) {
          this.painter = t2, this.sourceCache = new zs(e2), this.options = i2, this.exaggeration = typeof i2.exaggeration == "number" ? i2.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(t2, i2, a2, s2 = e.X) {
          var o2;
          if (!(i2 >= 0 && i2 < s2 && a2 >= 0 && a2 < s2))
            return 0;
          const r2 = this.getTerrainData(t2), n2 = (o2 = r2.tile) === null || o2 === undefined ? undefined : o2.dem;
          if (!n2)
            return 0;
          const l2 = function(t3, e2, i3) {
            var a3 = e2[0], s3 = e2[1];
            return t3[0] = i3[0] * a3 + i3[4] * s3 + i3[12], t3[1] = i3[1] * a3 + i3[5] * s3 + i3[13], t3;
          }([], [i2 / s2 * e.X, a2 / s2 * e.X], r2.u_terrain_matrix), h2 = [l2[0] * n2.dim, l2[1] * n2.dim], c2 = Math.floor(h2[0]), u2 = Math.floor(h2[1]), d2 = h2[0] - c2, _2 = h2[1] - u2;
          return n2.get(c2, u2) * (1 - d2) * (1 - _2) + n2.get(c2 + 1, u2) * d2 * (1 - _2) + n2.get(c2, u2 + 1) * (1 - d2) * _2 + n2.get(c2 + 1, u2 + 1) * d2 * _2;
        }
        getElevationForLngLatZoom(t2, i2) {
          if (!e.bb(i2, t2.wrap()))
            return 0;
          const {
            tileID: a2,
            mercatorX: s2,
            mercatorY: o2
          } = this._getOverscaledTileIDFromLngLatZoom(t2, i2);
          return this.getElevation(a2, s2 % e.X, o2 % e.X, e.X);
        }
        getElevation(t2, i2, a2, s2 = e.X) {
          return this.getDEMElevation(t2, i2, a2, s2) * this.exaggeration;
        }
        getTerrainData(t2) {
          if (!this._emptyDemTexture) {
            const t3 = this.painter.context, i3 = new e.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new b(t3, i3, t3.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new b(t3, new e.R({ width: 1, height: 1 }), t3.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(t3.gl.NEAREST, t3.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = e.an([]);
          }
          const i2 = this.sourceCache.getSourceTile(t2, true);
          if (i2 && i2.dem && (!i2.demTexture || i2.needsTerrainPrepare)) {
            const t3 = this.painter.context;
            i2.demTexture = this.painter.getTileTexture(i2.dem.stride), i2.demTexture ? i2.demTexture.update(i2.dem.getPixels(), { premultiply: false }) : i2.demTexture = new b(t3, i2.dem.getPixels(), t3.gl.RGBA, {
              premultiply: false
            }), i2.demTexture.bind(t3.gl.NEAREST, t3.gl.CLAMP_TO_EDGE), i2.needsTerrainPrepare = false;
          }
          const a2 = i2 && i2 + i2.tileID.key + t2.key;
          if (a2 && !this._demMatrixCache[a2]) {
            const a3 = this.sourceCache.sourceCache._source.maxzoom;
            let s2 = t2.canonical.z - i2.tileID.canonical.z;
            t2.overscaledZ > t2.canonical.z && (t2.canonical.z >= a3 ? s2 = t2.canonical.z - a3 : e.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const o2 = t2.canonical.x - (t2.canonical.x >> s2 << s2), r2 = t2.canonical.y - (t2.canonical.y >> s2 << s2), n2 = e.bc(new Float64Array(16), [1 / (e.X << s2), 1 / (e.X << s2), 0]);
            e.J(n2, n2, [o2 * e.X, r2 * e.X, 0]), this._demMatrixCache[t2.key] = { matrix: n2, coord: t2 };
          }
          return {
            u_depth: 2,
            u_terrain: 3,
            u_terrain_dim: i2 && i2.dem && i2.dem.dim || 1,
            u_terrain_matrix: a2 ? this._demMatrixCache[t2.key].matrix : this._emptyDemMatrix,
            u_terrain_unpack: i2 && i2.dem && i2.dem.getUnpackVector() || this._emptyDemUnpack,
            u_terrain_exaggeration: this.exaggeration,
            texture: (i2 && i2.demTexture || this._emptyDemTexture).texture,
            depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
            tile: i2
          };
        }
        getFramebuffer(t2) {
          const e2 = this.painter, i2 = e2.width / devicePixelRatio, a2 = e2.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === i2 && this._fbo.height === a2 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new b(e2.context, { width: i2, height: a2, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new b(e2.context, { width: i2, height: a2, data: null }, e2.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(e2.context.gl.NEAREST, e2.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e2.context.createFramebuffer(i2, a2, true, false), this._fbo.depthAttachment.set(e2.context.createRenderbuffer(e2.context.gl.DEPTH_COMPONENT16, i2, a2))), this._fbo.colorAttachment.set(t2 === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const t2 = this.painter.context;
          if (this._coordsTexture)
            return this._coordsTexture;
          const i2 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let t3 = 0, e2 = 0;t3 < this._coordsTextureSize; t3++)
            for (let a3 = 0;a3 < this._coordsTextureSize; a3++, e2 += 4)
              i2[e2 + 0] = 255 & a3, i2[e2 + 1] = 255 & t3, i2[e2 + 2] = a3 >> 8 << 4 | t3 >> 8, i2[e2 + 3] = 0;
          const a2 = new e.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i2.buffer)), s2 = new b(t2, a2, t2.gl.RGBA, { premultiply: false });
          return s2.bind(t2.gl.NEAREST, t2.gl.CLAMP_TO_EDGE), this._coordsTexture = s2, s2;
        }
        pointCoordinate(t2) {
          this.painter.maybeDrawDepthAndCoords(true);
          const i2 = new Uint8Array(4), a2 = this.painter.context, s2 = a2.gl, o2 = Math.round(t2.x * this.painter.pixelRatio / devicePixelRatio), r2 = Math.round(t2.y * this.painter.pixelRatio / devicePixelRatio), n2 = Math.round(this.painter.height / devicePixelRatio);
          a2.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), s2.readPixels(o2, n2 - r2 - 1, 1, 1, s2.RGBA, s2.UNSIGNED_BYTE, i2), a2.bindFramebuffer.set(null);
          const l2 = i2[0] + (i2[2] >> 4 << 8), h2 = i2[1] + ((15 & i2[2]) << 8), c2 = this.coordsIndex[255 - i2[3]], u2 = c2 && this.sourceCache.getTileByID(c2);
          if (!u2)
            return null;
          const d2 = this._coordsTextureSize, _2 = (1 << u2.tileID.canonical.z) * d2;
          return new e.Z((u2.tileID.canonical.x * d2 + l2) / _2 + u2.tileID.wrap, (u2.tileID.canonical.y * d2 + h2) / _2, this.getElevation(u2.tileID, l2, h2, d2));
        }
        depthAtPoint(t2) {
          const e2 = new Uint8Array(4), i2 = this.painter.context, a2 = i2.gl;
          return i2.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), a2.readPixels(t2.x, this.painter.height / devicePixelRatio - t2.y - 1, 1, 1, a2.RGBA, a2.UNSIGNED_BYTE, e2), i2.bindFramebuffer.set(null), (e2[0] / 16777216 + e2[1] / 65536 + e2[2] / 256 + e2[3]) / 256;
        }
        getTerrainMesh() {
          if (this._mesh)
            return this._mesh;
          const t2 = this.painter.context, i2 = new e.bd, a2 = new e.aY, s2 = this.meshSize, o2 = e.X / s2, r2 = s2 * s2;
          for (let t3 = 0;t3 <= s2; t3++)
            for (let e2 = 0;e2 <= s2; e2++)
              i2.emplaceBack(e2 * o2, t3 * o2, 0);
          for (let t3 = 0;t3 < r2; t3 += s2 + 1)
            for (let e2 = 0;e2 < s2; e2++)
              a2.emplaceBack(e2 + t3, s2 + e2 + t3 + 1, s2 + e2 + t3 + 2), a2.emplaceBack(e2 + t3, s2 + e2 + t3 + 2, e2 + t3 + 1);
          const n2 = i2.length, l2 = n2 + 2 * (s2 + 1);
          for (const t3 of [0, 1])
            for (let a3 = 0;a3 <= s2; a3++)
              for (const s3 of [0, 1])
                i2.emplaceBack(a3 * o2, t3 * e.X, s3);
          for (let t3 = 0;t3 < 2 * s2; t3 += 2)
            a2.emplaceBack(l2 + t3, l2 + t3 + 1, l2 + t3 + 3), a2.emplaceBack(l2 + t3, l2 + t3 + 3, l2 + t3 + 2), a2.emplaceBack(n2 + t3, n2 + t3 + 3, n2 + t3 + 1), a2.emplaceBack(n2 + t3, n2 + t3 + 2, n2 + t3 + 3);
          const h2 = i2.length, c2 = h2 + 2 * (s2 + 1);
          for (const t3 of [0, 1])
            for (let a3 = 0;a3 <= s2; a3++)
              for (const s3 of [0, 1])
                i2.emplaceBack(t3 * e.X, a3 * o2, s3);
          for (let t3 = 0;t3 < 2 * s2; t3 += 2)
            a2.emplaceBack(h2 + t3, h2 + t3 + 1, h2 + t3 + 3), a2.emplaceBack(h2 + t3, h2 + t3 + 3, h2 + t3 + 2), a2.emplaceBack(c2 + t3, c2 + t3 + 3, c2 + t3 + 1), a2.emplaceBack(c2 + t3, c2 + t3 + 2, c2 + t3 + 3);
          return this._mesh = new ga(t2.createVertexBuffer(i2, Ss.members), t2.createIndexBuffer(a2), e.a0.simpleSegment(0, 0, i2.length, a2.length)), this._mesh;
        }
        getMeshFrameDelta(t2) {
          return 2 * Math.PI * e.be / Math.pow(2, t2) / 5;
        }
        getMinTileElevationForLngLatZoom(t2, e2) {
          var i2;
          const { tileID: a2 } = this._getOverscaledTileIDFromLngLatZoom(t2, e2);
          return (i2 = this.getMinMaxElevation(a2).minElevation) !== null && i2 !== undefined ? i2 : 0;
        }
        getMinMaxElevation(t2) {
          const e2 = this.getTerrainData(t2).tile, i2 = { minElevation: null, maxElevation: null };
          return e2 && e2.dem && (i2.minElevation = e2.dem.min * this.exaggeration, i2.maxElevation = e2.dem.max * this.exaggeration), i2;
        }
        _getOverscaledTileIDFromLngLatZoom(t2, i2) {
          const a2 = e.Z.fromLngLat(t2.wrap()), s2 = (1 << i2) * e.X, o2 = a2.x * s2, r2 = a2.y * s2, n2 = Math.floor(o2 / e.X), l2 = Math.floor(r2 / e.X);
          return { tileID: new e.S(i2, 0, i2, n2, l2), mercatorX: o2, mercatorY: r2 };
        }
      }

      class Ms {
        constructor(t2, e2, i2) {
          this._context = t2, this._size = e2, this._tileSize = i2, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const t2 of this._objects)
            t2.texture.destroy(), t2.fbo.destroy();
        }
        _createObject(t2) {
          const e2 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i2 = new b(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return i2.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), e2.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), e2.colorAttachment.set(i2.texture), { id: t2, fbo: e2, texture: i2, stamp: -1, inUse: false };
        }
        getObjectForId(t2) {
          return this._objects[t2];
        }
        useObject(t2) {
          t2.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((e2) => t2.id !== e2), this._recentlyUsed.push(t2.id);
        }
        stampObject(t2) {
          t2.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const t3 of this._recentlyUsed)
            if (!this._objects[t3].inUse)
              return this._objects[t3];
          if (this._objects.length >= this._size)
            throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const t2 = this._createObject(this._objects.length);
          return this._objects.push(t2), t2;
        }
        freeObject(t2) {
          t2.inUse = false;
        }
        freeAllObjects() {
          for (const t2 of this._objects)
            this.freeObject(t2);
        }
        isFull() {
          return !(this._objects.length < this._size) && this._objects.some((t2) => !t2.inUse) === false;
        }
      }
      const As = { background: true, fill: true, line: true, raster: true, hillshade: true };

      class Rs {
        constructor(t2, e2) {
          this.painter = t2, this.terrain = e2, this.pool = new Ms(t2.context, 30, e2.sourceCache.tileSize * e2.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(t2) {
          return this.pool.getObjectForId(t2.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(t2, e2) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t2._order.filter((i2) => !t2._layers[i2].isHidden(e2)), this._coordsDescendingInv = {};
          for (const e3 in t2.sourceCaches) {
            this._coordsDescendingInv[e3] = {};
            const i2 = t2.sourceCaches[e3].getVisibleCoordinates();
            for (const t3 of i2) {
              const i3 = this.terrain.sourceCache.getTerrainCoords(t3);
              for (const t4 in i3)
                this._coordsDescendingInv[e3][t4] || (this._coordsDescendingInv[e3][t4] = []), this._coordsDescendingInv[e3][t4].push(i3[t4]);
            }
          }
          this._coordsDescendingInvStr = {};
          for (const e3 of t2._order) {
            const i2 = t2._layers[e3], a2 = i2.source;
            if (As[i2.type] && !this._coordsDescendingInvStr[a2]) {
              this._coordsDescendingInvStr[a2] = {};
              for (const t3 in this._coordsDescendingInv[a2])
                this._coordsDescendingInvStr[a2][t3] = this._coordsDescendingInv[a2][t3].map((t4) => t4.key).sort().join();
            }
          }
          for (const t3 of this._renderableTiles)
            for (const e3 in this._coordsDescendingInvStr) {
              const i2 = this._coordsDescendingInvStr[e3][t3.tileID.key];
              i2 && i2 !== t3.rttCoords[e3] && (t3.rtt = []);
            }
        }
        renderLayer(t2) {
          if (t2.isHidden(this.painter.transform.zoom))
            return false;
          const i2 = t2.type, a2 = this.painter, s2 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === t2.id;
          if (As[i2] && (this._prevType && As[this._prevType] || this._stacks.push([]), this._prevType = i2, this._stacks[this._stacks.length - 1].push(t2.id), !s2))
            return true;
          if (As[this._prevType] || As[i2] && s2) {
            this._prevType = i2;
            const t3 = this._stacks.length - 1, s3 = this._stacks[t3] || [];
            for (const i3 of this._renderableTiles) {
              if (this.pool.isFull() && (fa(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(i3), i3.rtt[t3]) {
                const e2 = this.pool.getObjectForId(i3.rtt[t3].id);
                if (e2.stamp === i3.rtt[t3].stamp) {
                  this.pool.useObject(e2);
                  continue;
                }
              }
              const o2 = this.pool.getOrCreateFreeObject();
              this.pool.useObject(o2), this.pool.stampObject(o2), i3.rtt[t3] = { id: o2.id, stamp: o2.stamp }, a2.context.bindFramebuffer.set(o2.fbo.framebuffer), a2.context.clear({ color: e.aM.transparent, stencil: 0 }), a2.currentStencilSource = undefined;
              for (let t4 = 0;t4 < s3.length; t4++) {
                const e2 = a2.style._layers[s3[t4]], r2 = e2.source ? this._coordsDescendingInv[e2.source][i3.tileID.key] : [i3.tileID];
                a2.context.viewport.set([0, 0, o2.fbo.width, o2.fbo.height]), a2._renderTileClippingMasks(e2, r2), a2.renderLayer(a2, a2.style.sourceCaches[e2.source], e2, r2), e2.source && (i3.rttCoords[e2.source] = this._coordsDescendingInvStr[e2.source][i3.tileID.key]);
              }
            }
            return fa(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), As[i2];
          }
          return false;
        }
      }
      const ks = {
        "AttributionControl.ToggleAttribution": "Toggle attribution",
        "AttributionControl.MapFeedback": "Map feedback",
        "FullscreenControl.Enter": "Enter fullscreen",
        "FullscreenControl.Exit": "Exit fullscreen",
        "GeolocateControl.FindMyLocation": "Find my location",
        "GeolocateControl.LocationNotAvailable": "Location not available",
        "LogoControl.Title": "MapLibre logo",
        "Map.Title": "Map",
        "Marker.Title": "Map marker",
        "NavigationControl.ResetBearing": "Reset bearing to north",
        "NavigationControl.ZoomIn": "Zoom in",
        "NavigationControl.ZoomOut": "Zoom out",
        "Popup.Close": "Close popup",
        "ScaleControl.Feet": "ft",
        "ScaleControl.Meters": "m",
        "ScaleControl.Kilometers": "km",
        "ScaleControl.Miles": "mi",
        "ScaleControl.NauticalMiles": "nm",
        "TerrainControl.Enable": "Enable terrain",
        "TerrainControl.Disable": "Disable terrain",
        "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
        "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map",
        "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
      }, Ls = i, Fs = {
        hash: false,
        interactive: true,
        bearingSnap: 7,
        attributionControl: Is,
        maplibreLogo: false,
        failIfMajorPerformanceCaveat: false,
        preserveDrawingBuffer: false,
        refreshExpiredTiles: true,
        scrollZoom: true,
        minZoom: -2,
        maxZoom: 22,
        minPitch: 0,
        maxPitch: 60,
        boxZoom: true,
        dragRotate: true,
        dragPan: true,
        keyboard: true,
        doubleClickZoom: true,
        touchZoomRotate: true,
        touchPitch: true,
        cooperativeGestures: false,
        trackResize: true,
        center: [0, 0],
        zoom: 0,
        bearing: 0,
        pitch: 0,
        renderWorldCopies: true,
        maxTileCacheSize: null,
        maxTileCacheZoomLevels: e.a.MAX_TILE_CACHE_ZOOM_LEVELS,
        transformRequest: null,
        transformCameraUpdate: null,
        fadeDuration: 300,
        crossSourceCollisions: true,
        clickTolerance: 3,
        localIdeographFontFamily: "sans-serif",
        pitchWithRotate: true,
        validateStyle: true,
        maxCanvasSize: [4096, 4096],
        cancelPendingTileRequestsWhileZooming: true
      }, Bs = (t2) => {
        t2.touchstart = t2.dragStart, t2.touchmoveWindow = t2.dragMove, t2.touchend = t2.dragEnd;
      }, Os = { showCompass: true, showZoom: true, visualizePitch: false };

      class Ns {
        constructor(t2, i2, a2 = false) {
          this.mousedown = (t3) => {
            this.startMouse(e.e({}, t3, { ctrlKey: true, preventDefault: () => t3.preventDefault() }), r.mousePos(this.element, t3)), r.addEventListener(window, "mousemove", this.mousemove), r.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (t3) => {
            this.moveMouse(t3, r.mousePos(this.element, t3));
          }, this.mouseup = (t3) => {
            this.mouseRotate.dragEnd(t3), this.mousePitch && this.mousePitch.dragEnd(t3), this.offTemp();
          }, this.touchstart = (t3) => {
            t3.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = r.touchPos(this.element, t3.targetTouches)[0], this.startTouch(t3, this._startPos), r.addEventListener(window, "touchmove", this.touchmove, {
              passive: false
            }), r.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (t3) => {
            t3.targetTouches.length !== 1 ? this.reset() : (this._lastPos = r.touchPos(this.element, t3.targetTouches)[0], this.moveTouch(t3, this._lastPos));
          }, this.touchend = (t3) => {
            t3.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10;
          const s2 = t2.dragRotate._mouseRotate.getClickTolerance(), o2 = t2.dragRotate._mousePitch.getClickTolerance();
          this.element = i2, this.mouseRotate = Ka({ clickTolerance: s2, enable: true }), this.touchRotate = (({
            enable: t3,
            clickTolerance: e2,
            bearingDegreesPerPixelMoved: i3 = 0.8
          }) => {
            const a3 = new $a;
            return new Ga({
              clickTolerance: e2,
              move: (t4, e3) => ({ bearingDelta: (e3.x - t4.x) * i3 }),
              moveStateManager: a3,
              enable: t3,
              assignEvents: Bs
            });
          })({ clickTolerance: s2, enable: true }), this.map = t2, a2 && (this.mousePitch = Ja({ clickTolerance: o2, enable: true }), this.touchPitch = (({
            enable: t3,
            clickTolerance: e2,
            pitchDegreesPerPixelMoved: i3 = -0.5
          }) => {
            const a3 = new $a;
            return new Ga({
              clickTolerance: e2,
              move: (t4, e3) => ({ pitchDelta: (e3.y - t4.y) * i3 }),
              moveStateManager: a3,
              enable: t3,
              assignEvents: Bs
            });
          })({ clickTolerance: o2, enable: true })), r.addEventListener(i2, "mousedown", this.mousedown), r.addEventListener(i2, "touchstart", this.touchstart, { passive: false }), r.addEventListener(i2, "touchcancel", this.reset);
        }
        startMouse(t2, e2) {
          this.mouseRotate.dragStart(t2, e2), this.mousePitch && this.mousePitch.dragStart(t2, e2), r.disableDrag();
        }
        startTouch(t2, e2) {
          this.touchRotate.dragStart(t2, e2), this.touchPitch && this.touchPitch.dragStart(t2, e2), r.disableDrag();
        }
        moveMouse(t2, e2) {
          const i2 = this.map, { bearingDelta: a2 } = this.mouseRotate.dragMove(t2, e2) || {};
          if (a2 && i2.setBearing(i2.getBearing() + a2), this.mousePitch) {
            const { pitchDelta: a3 } = this.mousePitch.dragMove(t2, e2) || {};
            a3 && i2.setPitch(i2.getPitch() + a3);
          }
        }
        moveTouch(t2, e2) {
          const i2 = this.map, { bearingDelta: a2 } = this.touchRotate.dragMove(t2, e2) || {};
          if (a2 && i2.setBearing(i2.getBearing() + a2), this.touchPitch) {
            const { pitchDelta: a3 } = this.touchPitch.dragMove(t2, e2) || {};
            a3 && i2.setPitch(i2.getPitch() + a3);
          }
        }
        off() {
          const t2 = this.element;
          r.removeEventListener(t2, "mousedown", this.mousedown), r.removeEventListener(t2, "touchstart", this.touchstart, { passive: false }), r.removeEventListener(window, "touchmove", this.touchmove, {
            passive: false
          }), r.removeEventListener(window, "touchend", this.touchend), r.removeEventListener(t2, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          r.enableDrag(), r.removeEventListener(window, "mousemove", this.mousemove), r.removeEventListener(window, "mouseup", this.mouseup), r.removeEventListener(window, "touchmove", this.touchmove, {
            passive: false
          }), r.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let Us;
      function js(t2, i2, a2) {
        const s2 = new e.N(t2.lng, t2.lat);
        if (t2 = new e.N(t2.lng, t2.lat), i2) {
          const s3 = new e.N(t2.lng - 360, t2.lat), o2 = new e.N(t2.lng + 360, t2.lat), r2 = a2.locationPoint(t2).distSqr(i2);
          a2.locationPoint(s3).distSqr(i2) < r2 ? t2 = s3 : a2.locationPoint(o2).distSqr(i2) < r2 && (t2 = o2);
        }
        for (;Math.abs(t2.lng - a2.center.lng) > 180; ) {
          const e2 = a2.locationPoint(t2);
          if (e2.x >= 0 && e2.y >= 0 && e2.x <= a2.width && e2.y <= a2.height)
            break;
          t2.lng > a2.center.lng ? t2.lng -= 360 : t2.lng += 360;
        }
        return t2.lng !== s2.lng && a2.locationPoint(t2).y > a2.height / 2 - a2.getHorizon() ? t2 : s2;
      }
      const Zs = {
        center: "translate(-50%,-50%)",
        top: "translate(-50%,0)",
        "top-left": "translate(0,0)",
        "top-right": "translate(-100%,0)",
        bottom: "translate(-50%,-100%)",
        "bottom-left": "translate(0,-100%)",
        "bottom-right": "translate(-100%,-100%)",
        left: "translate(0,-50%)",
        right: "translate(-100%,-50%)"
      };
      function qs(t2, e2, i2) {
        const a2 = t2.classList;
        for (const t3 in Zs)
          a2.remove(`maplibregl-${i2}-anchor-${t3}`);
        a2.add(`maplibregl-${i2}-anchor-${e2}`);
      }

      class Vs extends e.E {
        constructor(t2) {
          if (super(), this._onKeyPress = (t3) => {
            const e2 = t3.code, i2 = t3.charCode || t3.keyCode;
            e2 !== "Space" && e2 !== "Enter" && i2 !== 32 && i2 !== 13 || this.togglePopup();
          }, this._onMapClick = (t3) => {
            const e2 = t3.originalEvent.target, i2 = this._element;
            this._popup && (e2 === i2 || i2.contains(e2)) && this.togglePopup();
          }, this._update = (t3) => {
            var e2;
            if (!this._map)
              return;
            const i2 = this._map.loaded() && !this._map.isMoving();
            ((t3 == null ? undefined : t3.type) === "terrain" || (t3 == null ? undefined : t3.type) === "render" && !i2) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? js(this._lngLat, this._flatPos, this._map.transform) : (e2 = this._lngLat) === null || e2 === undefined ? undefined : e2.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationPoint(this._lngLat)._add(this._offset));
            let a2 = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? a2 = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (a2 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let s2 = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? s2 = "rotateX(0deg)" : this._pitchAlignment === "map" && (s2 = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || t3 && t3.type !== "moveend" || (this._pos = this._pos.round()), r.setTransform(this._element, `${Zs[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${s2} ${a2}`), o.frameAsync(new AbortController).then(() => {
              this._updateOpacity(t3 && t3.type === "moveend");
            }).catch(() => {
            });
          }, this._onMove = (t3) => {
            if (!this._isDragging) {
              const e2 = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = t3.point.dist(this._pointerdownPos) >= e2;
            }
            this._isDragging && (this._pos = t3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new e.k("dragstart"))), this.fire(new e.k("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new e.k("dragend")), this._state = "inactive";
          }, this._addDragHandler = (t3) => {
            this._element.contains(t3.originalEvent.target) && (t3.preventDefault(), this._positionDelta = t3.point.sub(this._pos).add(this._offset), this._pointerdownPos = t3.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = t2 && t2.anchor || "center", this._color = t2 && t2.color || "#3FB1CE", this._scale = t2 && t2.scale || 1, this._draggable = t2 && t2.draggable || false, this._clickTolerance = t2 && t2.clickTolerance || 0, this._subpixelPositioning = t2 && t2.subpixelPositioning || false, this._isDragging = false, this._state = "inactive", this._rotation = t2 && t2.rotation || 0, this._rotationAlignment = t2 && t2.rotationAlignment || "auto", this._pitchAlignment = t2 && t2.pitchAlignment && t2.pitchAlignment !== "auto" ? t2.pitchAlignment : this._rotationAlignment, this.setOpacity(), this.setOpacity(t2 == null ? undefined : t2.opacity, t2 == null ? undefined : t2.opacityWhenCovered), t2 && t2.element)
            this._element = t2.element, this._offset = e.P.convert(t2 && t2.offset || [0, 0]);
          else {
            this._defaultMarker = true, this._element = r.create("div");
            const i2 = r.createNS("http://www.w3.org/2000/svg", "svg"), a2 = 41, s2 = 27;
            i2.setAttributeNS(null, "display", "block"), i2.setAttributeNS(null, "height", `${a2}px`), i2.setAttributeNS(null, "width", `${s2}px`), i2.setAttributeNS(null, "viewBox", `0 0 ${s2} ${a2}`);
            const o2 = r.createNS("http://www.w3.org/2000/svg", "g");
            o2.setAttributeNS(null, "stroke", "none"), o2.setAttributeNS(null, "stroke-width", "1"), o2.setAttributeNS(null, "fill", "none"), o2.setAttributeNS(null, "fill-rule", "evenodd");
            const n2 = r.createNS("http://www.w3.org/2000/svg", "g");
            n2.setAttributeNS(null, "fill-rule", "nonzero");
            const l2 = r.createNS("http://www.w3.org/2000/svg", "g");
            l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
            const h2 = [
              { rx: "10.5", ry: "5.25002273" },
              { rx: "10.5", ry: "5.25002273" },
              { rx: "9.5", ry: "4.77275007" },
              { rx: "8.5", ry: "4.29549936" },
              { rx: "7.5", ry: "3.81822308" },
              { rx: "6.5", ry: "3.34094679" },
              { rx: "5.5", ry: "2.86367051" },
              { rx: "4.5", ry: "2.38636864" }
            ];
            for (const t3 of h2) {
              const e2 = r.createNS("http://www.w3.org/2000/svg", "ellipse");
              e2.setAttributeNS(null, "opacity", "0.04"), e2.setAttributeNS(null, "cx", "10.5"), e2.setAttributeNS(null, "cy", "5.80029008"), e2.setAttributeNS(null, "rx", t3.rx), e2.setAttributeNS(null, "ry", t3.ry), l2.appendChild(e2);
            }
            const c2 = r.createNS("http://www.w3.org/2000/svg", "g");
            c2.setAttributeNS(null, "fill", this._color);
            const u2 = r.createNS("http://www.w3.org/2000/svg", "path");
            u2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), c2.appendChild(u2);
            const d2 = r.createNS("http://www.w3.org/2000/svg", "g");
            d2.setAttributeNS(null, "opacity", "0.25"), d2.setAttributeNS(null, "fill", "#000000");
            const _2 = r.createNS("http://www.w3.org/2000/svg", "path");
            _2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d2.appendChild(_2);
            const p2 = r.createNS("http://www.w3.org/2000/svg", "g");
            p2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), p2.setAttributeNS(null, "fill", "#FFFFFF");
            const m2 = r.createNS("http://www.w3.org/2000/svg", "g");
            m2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const f2 = r.createNS("http://www.w3.org/2000/svg", "circle");
            f2.setAttributeNS(null, "fill", "#000000"), f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "cx", "5.5"), f2.setAttributeNS(null, "cy", "5.5"), f2.setAttributeNS(null, "r", "5.4999962");
            const g2 = r.createNS("http://www.w3.org/2000/svg", "circle");
            g2.setAttributeNS(null, "fill", "#FFFFFF"), g2.setAttributeNS(null, "cx", "5.5"), g2.setAttributeNS(null, "cy", "5.5"), g2.setAttributeNS(null, "r", "5.4999962"), m2.appendChild(f2), m2.appendChild(g2), n2.appendChild(l2), n2.appendChild(c2), n2.appendChild(d2), n2.appendChild(p2), n2.appendChild(m2), i2.appendChild(n2), i2.setAttributeNS(null, "height", a2 * this._scale + "px"), i2.setAttributeNS(null, "width", s2 * this._scale + "px"), this._element.appendChild(i2), this._offset = e.P.convert(t2 && t2.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (t3) => {
            t3.preventDefault();
          }), this._element.addEventListener("mousedown", (t3) => {
            t3.preventDefault();
          }), qs(this._element, this._anchor, "marker"), t2 && t2.className)
            for (const e2 of t2.className.split(" "))
              this._element.classList.add(e2);
          this._popup = null;
        }
        addTo(t2) {
          return this.remove(), this._map = t2, this._element.setAttribute("aria-label", t2._getUIString("Marker.Title")), t2.getCanvasContainer().appendChild(this._element), t2.on("move", this._update), t2.on("moveend", this._update), t2.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), r.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t2) {
          return this._lngLat = e.N.convert(t2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(t2) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t2) {
            if (!("offset" in t2.options)) {
              const e2 = 38.1, i2 = 13.5, a2 = Math.abs(i2) / Math.SQRT2;
              t2.options.offset = this._defaultMarker ? {
                top: [0, 0],
                "top-left": [0, 0],
                "top-right": [0, 0],
                bottom: [0, -e2],
                "bottom-left": [a2, -1 * (e2 - i2 + a2)],
                "bottom-right": [-a2, -1 * (e2 - i2 + a2)],
                left: [i2, -1 * (e2 - i2)],
                right: [-i2, -1 * (e2 - i2)]
              } : this._offset;
            }
            this._popup = t2, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        setSubpixelPositioning(t2) {
          return this._subpixelPositioning = t2, this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const t2 = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered ? this : t2 ? (t2.isOpen() ? t2.remove() : (t2.setLngLat(this._lngLat), t2.addTo(this._map)), this) : this;
        }
        _updateOpacity(t2 = false) {
          var i2, a2;
          if (!((i2 = this._map) === null || i2 === undefined ? undefined : i2.terrain))
            return void (this._element.style.opacity !== this._opacity && (this._element.style.opacity = this._opacity));
          if (t2)
            this._opacityTimeout = null;
          else {
            if (this._opacityTimeout)
              return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const s2 = this._map, o2 = s2.terrain.depthAtPoint(this._pos), r2 = s2.terrain.getElevationForLngLatZoom(this._lngLat, s2.transform.tileZoom);
          if (s2.transform.lngLatToCameraDepth(this._lngLat, r2) - o2 < 0.006)
            return void (this._element.style.opacity = this._opacity);
          const n2 = -this._offset.y / s2.transform._pixelPerMeter, l2 = Math.sin(s2.getPitch() * Math.PI / 180) * n2, h2 = s2.terrain.depthAtPoint(new e.P(this._pos.x, this._pos.y - this._offset.y)), c2 = s2.transform.lngLatToCameraDepth(this._lngLat, r2 + l2) - h2 > 0.006;
          ((a2 = this._popup) === null || a2 === undefined ? undefined : a2.isOpen()) && c2 && this._popup.remove(), this._element.style.opacity = c2 ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t2) {
          return this._offset = e.P.convert(t2), this._update(), this;
        }
        addClassName(t2) {
          this._element.classList.add(t2);
        }
        removeClassName(t2) {
          this._element.classList.remove(t2);
        }
        toggleClassName(t2) {
          return this._element.classList.toggle(t2);
        }
        setDraggable(t2) {
          return this._draggable = !!t2, this._map && (t2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(t2) {
          return this._rotation = t2 || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(t2) {
          return this._rotationAlignment = t2 || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(t2) {
          return this._pitchAlignment = t2 && t2 !== "auto" ? t2 : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(t2, e2) {
          return t2 === undefined && e2 === undefined && (this._opacity = "1", this._opacityWhenCovered = "0.2"), t2 !== undefined && (this._opacity = t2), e2 !== undefined && (this._opacityWhenCovered = e2), this._map && this._updateOpacity(true), this;
        }
      }
      const Gs = {
        positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6000 },
        fitBoundsOptions: { maxZoom: 15 },
        trackUserLocation: false,
        showAccuracyCircle: true,
        showUserLocation: true
      };
      let Hs = 0, Ws = false;
      const $s = { maxWidth: 100, unit: "metric" };
      function Xs(t2, e2, i2) {
        const a2 = i2 && i2.maxWidth || 100, s2 = t2._container.clientHeight / 2, o2 = t2.unproject([0, s2]), r2 = t2.unproject([a2, s2]), n2 = o2.distanceTo(r2);
        if (i2 && i2.unit === "imperial") {
          const i3 = 3.2808 * n2;
          i3 > 5280 ? Ks(e2, a2, i3 / 5280, t2._getUIString("ScaleControl.Miles")) : Ks(e2, a2, i3, t2._getUIString("ScaleControl.Feet"));
        } else
          i2 && i2.unit === "nautical" ? Ks(e2, a2, n2 / 1852, t2._getUIString("ScaleControl.NauticalMiles")) : n2 >= 1000 ? Ks(e2, a2, n2 / 1000, t2._getUIString("ScaleControl.Kilometers")) : Ks(e2, a2, n2, t2._getUIString("ScaleControl.Meters"));
      }
      function Ks(t2, e2, i2, a2) {
        const s2 = function(t3) {
          const e3 = Math.pow(10, `${Math.floor(t3)}`.length - 1);
          let i3 = t3 / e3;
          return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(t4) {
            const e4 = Math.pow(10, Math.ceil(-Math.log(t4) / Math.LN10));
            return Math.round(t4 * e4) / e4;
          }(i3), e3 * i3;
        }(i2);
        t2.style.width = e2 * (s2 / i2) + "px", t2.innerHTML = `${s2}&nbsp;${a2}`;
      }
      const Js = {
        closeButton: true,
        closeOnClick: true,
        focusAfterOpen: true,
        className: "",
        maxWidth: "240px",
        subpixelPositioning: false
      }, Ys = [
        "a[href]",
        "[tabindex]:not([tabindex='-1'])",
        "[contenteditable]:not([contenteditable='false'])",
        "button:not([disabled])",
        "input:not([disabled])",
        "select:not([disabled])",
        "textarea:not([disabled])"
      ].join(", ");
      function Qs(t2) {
        if (t2) {
          if (typeof t2 == "number") {
            const i2 = Math.round(Math.abs(t2) / Math.SQRT2);
            return {
              center: new e.P(0, 0),
              top: new e.P(0, t2),
              "top-left": new e.P(i2, i2),
              "top-right": new e.P(-i2, i2),
              bottom: new e.P(0, -t2),
              "bottom-left": new e.P(i2, -i2),
              "bottom-right": new e.P(-i2, -i2),
              left: new e.P(t2, 0),
              right: new e.P(-t2, 0)
            };
          }
          if (t2 instanceof e.P || Array.isArray(t2)) {
            const i2 = e.P.convert(t2);
            return {
              center: i2,
              top: i2,
              "top-left": i2,
              "top-right": i2,
              bottom: i2,
              "bottom-left": i2,
              "bottom-right": i2,
              left: i2,
              right: i2
            };
          }
          return {
            center: e.P.convert(t2.center || [0, 0]),
            top: e.P.convert(t2.top || [0, 0]),
            "top-left": e.P.convert(t2["top-left"] || [0, 0]),
            "top-right": e.P.convert(t2["top-right"] || [0, 0]),
            bottom: e.P.convert(t2.bottom || [0, 0]),
            "bottom-left": e.P.convert(t2["bottom-left"] || [0, 0]),
            "bottom-right": e.P.convert(t2["bottom-right"] || [0, 0]),
            left: e.P.convert(t2.left || [0, 0]),
            right: e.P.convert(t2.right || [0, 0])
          };
        }
        return Qs(new e.P(0, 0));
      }
      const to = i;
      t.AJAXError = e.bh, t.Evented = e.E, t.LngLat = e.N, t.MercatorCoordinate = e.Z, t.Point = e.P, t.addProtocol = e.bi, t.config = e.a, t.removeProtocol = e.bj, t.AttributionControl = Es, t.BoxZoomHandler = Ua, t.CanvasSource = et, t.CooperativeGesturesHandler = vs, t.DoubleClickZoomHandler = ds, t.DragPanHandler = ms, t.DragRotateHandler = fs, t.EdgeInsets = ba, t.FullscreenControl = class extends e.E {
        constructor(t2 = {}) {
          super(), this._onFullscreenChange = () => {
            var t3;
            let e2 = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (;(t3 = e2 == null ? undefined : e2.shadowRoot) === null || t3 === undefined ? undefined : t3.fullscreenElement; )
              e2 = e2.shadowRoot.fullscreenElement;
            e2 === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = false, t2 && t2.container && (t2.container instanceof HTMLElement ? this._container = t2.container : e.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : ("onmozfullscreenchange" in document) ? this._fullscreenchange = "mozfullscreenchange" : ("onwebkitfullscreenchange" in document) ? this._fullscreenchange = "webkitfullscreenchange" : ("onmsfullscreenchange" in document) && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(t2) {
          return this._map = t2, this._container || (this._container = this._map.getContainer()), this._controlContainer = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          r.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const t2 = this._fullscreenButton = r.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          r.create("span", "maplibregl-ctrl-icon", t2).setAttribute("aria-hidden", "true"), t2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const t2 = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", t2), this._fullscreenButton.title = t2;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new e.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new e.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, t.GeoJSONSource = J, t.GeolocateControl = class extends e.E {
        constructor(t2) {
          super(), this._onSuccess = (t3) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(t3))
                return this._setErrorState(), this.fire(new e.k("outofmaxbounds", t3)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation)
                switch (this._lastKnownPosition = t3, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(t3), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(t3), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new e.k("geolocate", t3)), this._finish();
            }
          }, this._updateCamera = (t3) => {
            const i2 = new e.N(t3.coords.longitude, t3.coords.latitude), a2 = t3.coords.accuracy, s2 = this._map.getBearing(), o2 = e.e({ bearing: s2 }, this.options.fitBoundsOptions), r2 = H.fromLngLat(i2, a2);
            this._map.fitBounds(r2, o2, { geolocateSource: true });
          }, this._updateMarker = (t3) => {
            if (t3) {
              const i2 = new e.N(t3.coords.longitude, t3.coords.latitude);
              this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else
              this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (t3) => {
            if (this._map) {
              if (this.options.trackUserLocation)
                if (t3.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4), this._geolocationWatchID !== undefined && this._clearWatch();
                } else {
                  if (t3.code === 3 && Ws)
                    return;
                  this._setErrorState();
                }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new e.k("error", t3)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = undefined;
          }, this._setupUI = () => {
            this._map && (this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this._geolocateButton = r.create("button", "maplibregl-ctrl-geolocate", this._container), r.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = true);
          }, this._finishSetupUI = (t3) => {
            if (this._map) {
              if (t3 === false) {
                e.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4);
              } else {
                const t4 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.disabled = false, this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = r.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Vs({ element: this._dotElement }), this._circleElement = r.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Vs({
                element: this._circleElement,
                pitchAlignment: "map"
              }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t4) => {
                t4.geolocateSource || this._watchState !== "ACTIVE_LOCK" || t4.originalEvent && t4.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new e.k("trackuserlocationend")), this.fire(new e.k("userlocationlostfocus")));
              });
            }
          }, this.options = e.e({}, Gs, t2);
        }
        onAdd(t2) {
          return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
            return e._(this, arguments, undefined, function* (t3 = false) {
              if (Us !== undefined && !t3)
                return Us;
              if (window.navigator.permissions === undefined)
                return Us = !!window.navigator.geolocation, Us;
              try {
                const t4 = yield window.navigator.permissions.query({
                  name: "geolocation"
                });
                Us = t4.state !== "denied";
              } catch (t4) {
                Us = !!window.navigator.geolocation;
              }
              return Us;
            });
          }().then((t3) => this._finishSetupUI(t3)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== undefined && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = undefined), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), r.remove(this._container), this._map.off("zoom", this._onZoom), this._map = undefined, Hs = 0, Ws = false;
        }
        _isOutOfMapMaxBounds(t2) {
          const e2 = this._map.getMaxBounds(), i2 = t2.coords;
          return e2 && (i2.longitude < e2.getWest() || i2.longitude > e2.getEast() || i2.latitude < e2.getSouth() || i2.latitude > e2.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const t2 = this._map.getBounds(), e2 = t2.getSouthEast(), i2 = t2.getNorthEast(), a2 = e2.distanceTo(i2), s2 = Math.ceil(this._accuracy / (a2 / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${s2}px`, this._circleElement.style.height = `${s2}px`;
        }
        trigger() {
          if (!this._setup)
            return e.w("Geolocate control triggered before added to a map"), false;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new e.k("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                Hs--, Ws = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new e.k("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.k("trackuserlocationstart")), this.fire(new e.k("userlocationfocus"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== undefined)
              this._clearWatch();
            else if (this._geolocationWatchID === undefined) {
              let t2;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Hs++, Hs > 1 ? (t2 = { maximumAge: 600000, timeout: 0 }, Ws = true) : (t2 = this.options.positionOptions, Ws = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t2);
            }
          } else
            window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return true;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = undefined, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, t.Hash = Ea, t.ImageSource = Q, t.KeyboardHandler = ls, t.LngLatBounds = H, t.LogoControl = Ps, t.Map = class extends Ts {
        constructor(t2) {
          e.bf.mark(e.bg.create);
          const i2 = Object.assign(Object.assign({}, Fs), t2);
          if (i2.minZoom != null && i2.maxZoom != null && i2.minZoom > i2.maxZoom)
            throw new Error("maxZoom must be greater than or equal to minZoom");
          if (i2.minPitch != null && i2.maxPitch != null && i2.minPitch > i2.maxPitch)
            throw new Error("maxPitch must be greater than or equal to minPitch");
          if (i2.minPitch != null && i2.minPitch < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (i2.maxPitch != null && i2.maxPitch > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (super(new Ta(i2.minZoom, i2.maxZoom, i2.minPitch, i2.maxPitch, i2.renderWorldCopies), { bearingSnap: i2.bearingSnap }), this._idleTriggered = false, this._crossFadingFactor = 1, this._renderTaskQueue = new Cs, this._controls = [], this._mapId = e.a4(), this._contextLost = (t3) => {
            t3.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new e.k("webglcontextlost", { originalEvent: t3 }));
          }, this._contextRestored = (t3) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new e.k("webglcontextrestored", { originalEvent: t3 }));
          }, this._onMapScroll = (t3) => {
            if (t3.target === this._container)
              return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = i2.interactive, this._maxTileCacheSize = i2.maxTileCacheSize, this._maxTileCacheZoomLevels = i2.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = i2.failIfMajorPerformanceCaveat === true, this._preserveDrawingBuffer = i2.preserveDrawingBuffer === true, this._antialias = i2.antialias === true, this._trackResize = i2.trackResize === true, this._bearingSnap = i2.bearingSnap, this._refreshExpiredTiles = i2.refreshExpiredTiles === true, this._fadeDuration = i2.fadeDuration, this._crossSourceCollisions = i2.crossSourceCollisions === true, this._collectResourceTiming = i2.collectResourceTiming === true, this._locale = Object.assign(Object.assign({}, ks), i2.locale), this._clickTolerance = i2.clickTolerance, this._overridePixelRatio = i2.pixelRatio, this._maxCanvasSize = i2.maxCanvasSize, this.transformCameraUpdate = i2.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = i2.cancelPendingTileRequestsWhileZooming === true, this._imageQueueHandle = _.addThrottleControl(() => this.isMoving()), this._requestManager = new p(i2.transformRequest), typeof i2.container == "string") {
            if (this._container = document.getElementById(i2.container), !this._container)
              throw new Error(`Container '${i2.container}' not found.`);
          } else {
            if (!(i2.container instanceof HTMLElement))
              throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = i2.container;
          }
          if (i2.maxBounds && this.setMaxBounds(i2.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)).on("moveend", () => this._update(false)).on("zoom", () => this._update(true)).on("terrain", () => {
            this.painter.terrainFacilitator.dirty = true, this._update(true);
          }).once("idle", () => {
            this._idleTriggered = true;
          }), typeof window != "undefined") {
            addEventListener("online", this._onWindowOnline, false);
            let t3 = false;
            const e2 = Ia((t4) => {
              this._trackResize && !this._removed && (this.resize(t4), this.redraw());
            }, 50);
            this._resizeObserver = new ResizeObserver((i3) => {
              t3 ? e2(i3) : t3 = true;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new ws(this, i2), this._hash = i2.hash && new Ea(typeof i2.hash == "string" && i2.hash || undefined).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({
            center: i2.center,
            zoom: i2.zoom,
            bearing: i2.bearing,
            pitch: i2.pitch
          }), i2.bounds && (this.resize(), this.fitBounds(i2.bounds, e.e({}, i2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = i2.localIdeographFontFamily, this._validateStyle = i2.validateStyle, i2.style && this.setStyle(i2.style, {
            localIdeographFontFamily: i2.localIdeographFontFamily
          }), i2.attributionControl && this.addControl(new Es(typeof i2.attributionControl == "boolean" ? undefined : i2.attributionControl)), i2.maplibreLogo && this.addControl(new Ps, i2.logoPosition), this.on("style.load", () => {
            this.transform.unmodified && this.jumpTo(this.style.stylesheet);
          }), this.on("data", (t3) => {
            this._update(t3.dataType === "style"), this.fire(new e.k(`${t3.dataType}data`, t3));
          }), this.on("dataloading", (t3) => {
            this.fire(new e.k(`${t3.dataType}dataloading`, t3));
          }), this.on("dataabort", (t3) => {
            this.fire(new e.k("sourcedataabort", t3));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(t2, i2) {
          if (i2 === undefined && (i2 = t2.getDefaultPosition ? t2.getDefaultPosition() : "top-right"), !t2 || !t2.onAdd)
            return this.fire(new e.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const a2 = t2.onAdd(this);
          this._controls.push(t2);
          const s2 = this._controlPositions[i2];
          return i2.indexOf("bottom") !== -1 ? s2.insertBefore(a2, s2.firstChild) : s2.appendChild(a2), this;
        }
        removeControl(t2) {
          if (!t2 || !t2.onRemove)
            return this.fire(new e.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const i2 = this._controls.indexOf(t2);
          return i2 > -1 && this._controls.splice(i2, 1), t2.onRemove(this), this;
        }
        hasControl(t2) {
          return this._controls.indexOf(t2) > -1;
        }
        calculateCameraOptionsFromTo(t2, e2, i2, a2) {
          return a2 == null && this.terrain && (a2 = this.terrain.getElevationForLngLatZoom(i2, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(t2, e2, i2, a2);
        }
        resize(t2) {
          var i2;
          const a2 = this._containerDimensions(), s2 = a2[0], o2 = a2[1], r2 = this._getClampedPixelRatio(s2, o2);
          if (this._resizeCanvas(s2, o2, r2), this.painter.resize(s2, o2, r2), this.painter.overLimit()) {
            const t3 = this.painter.context.gl;
            this._maxCanvasSize = [t3.drawingBufferWidth, t3.drawingBufferHeight];
            const e2 = this._getClampedPixelRatio(s2, o2);
            this._resizeCanvas(s2, o2, e2), this.painter.resize(s2, o2, e2);
          }
          this.transform.resize(s2, o2), (i2 = this._requestedCameraState) === null || i2 === undefined || i2.resize(s2, o2);
          const n2 = !this._moving;
          return n2 && (this.stop(), this.fire(new e.k("movestart", t2)).fire(new e.k("move", t2))), this.fire(new e.k("resize", t2)), n2 && this.fire(new e.k("moveend", t2)), this;
        }
        _getClampedPixelRatio(t2, e2) {
          const { 0: i2, 1: a2 } = this._maxCanvasSize, s2 = this.getPixelRatio(), o2 = t2 * s2, r2 = e2 * s2;
          return Math.min(o2 > i2 ? i2 / o2 : 1, r2 > a2 ? a2 / r2 : 1) * s2;
        }
        getPixelRatio() {
          var t2;
          return (t2 = this._overridePixelRatio) !== null && t2 !== undefined ? t2 : devicePixelRatio;
        }
        setPixelRatio(t2) {
          this._overridePixelRatio = t2, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(t2) {
          return this.transform.setMaxBounds(H.convert(t2)), this._update();
        }
        setMinZoom(t2) {
          if ((t2 = t2 == null ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
            return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 && this.setZoom(t2), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(t2) {
          if ((t2 = t2 == null ? 22 : t2) >= this.transform.minZoom)
            return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 && this.setZoom(t2), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(t2) {
          if ((t2 = t2 == null ? 0 : t2) < 0)
            throw new Error("minPitch must be greater than or equal to 0");
          if (t2 >= 0 && t2 <= this.transform.maxPitch)
            return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 && this.setPitch(t2), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(t2) {
          if ((t2 = t2 == null ? 60 : t2) > 85)
            throw new Error("maxPitch must be less than or equal to 85");
          if (t2 >= this.transform.minPitch)
            return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 && this.setPitch(t2), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(t2) {
          return this.transform.renderWorldCopies = t2, this._update();
        }
        project(t2) {
          return this.transform.locationPoint(e.N.convert(t2), this.style && this.terrain);
        }
        unproject(t2) {
          return this.transform.pointLocation(e.P.convert(t2), this.terrain);
        }
        isMoving() {
          var t2;
          return this._moving || ((t2 = this.handlers) === null || t2 === undefined ? undefined : t2.isMoving());
        }
        isZooming() {
          var t2;
          return this._zooming || ((t2 = this.handlers) === null || t2 === undefined ? undefined : t2.isZooming());
        }
        isRotating() {
          var t2;
          return this._rotating || ((t2 = this.handlers) === null || t2 === undefined ? undefined : t2.isRotating());
        }
        _createDelegatedListener(t2, e2, i2) {
          if (t2 === "mouseenter" || t2 === "mouseover") {
            let a2 = false;
            const s2 = (s3) => {
              const o2 = e2.filter((t3) => this.getLayer(t3)), r2 = o2.length !== 0 ? this.queryRenderedFeatures(s3.point, { layers: o2 }) : [];
              r2.length ? a2 || (a2 = true, i2.call(this, new ka(t2, this, s3.originalEvent, { features: r2 }))) : a2 = false;
            };
            return {
              layers: e2,
              listener: i2,
              delegates: {
                mousemove: s2,
                mouseout: () => {
                  a2 = false;
                }
              }
            };
          }
          if (t2 === "mouseleave" || t2 === "mouseout") {
            let a2 = false;
            const s2 = (s3) => {
              const o3 = e2.filter((t3) => this.getLayer(t3));
              (o3.length !== 0 ? this.queryRenderedFeatures(s3.point, { layers: o3 }) : []).length ? a2 = true : a2 && (a2 = false, i2.call(this, new ka(t2, this, s3.originalEvent)));
            }, o2 = (e3) => {
              a2 && (a2 = false, i2.call(this, new ka(t2, this, e3.originalEvent)));
            };
            return {
              layers: e2,
              listener: i2,
              delegates: { mousemove: s2, mouseout: o2 }
            };
          }
          {
            const a2 = (t3) => {
              const a3 = e2.filter((t4) => this.getLayer(t4)), s2 = a3.length !== 0 ? this.queryRenderedFeatures(t3.point, { layers: a3 }) : [];
              s2.length && (t3.features = s2, i2.call(this, t3), delete t3.features);
            };
            return { layers: e2, listener: i2, delegates: { [t2]: a2 } };
          }
        }
        _saveDelegatedListener(t2, e2) {
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t2] = this._delegatedListeners[t2] || [], this._delegatedListeners[t2].push(e2);
        }
        _removeDelegatedListener(t2, e2, i2) {
          if (!this._delegatedListeners || !this._delegatedListeners[t2])
            return;
          const a2 = this._delegatedListeners[t2];
          for (let t3 = 0;t3 < a2.length; t3++) {
            const s2 = a2[t3];
            if (s2.listener === i2 && s2.layers.length === e2.length && s2.layers.every((t4) => e2.includes(t4))) {
              for (const t4 in s2.delegates)
                this.off(t4, s2.delegates[t4]);
              return void a2.splice(t3, 1);
            }
          }
        }
        on(t2, e2, i2) {
          if (i2 === undefined)
            return super.on(t2, e2);
          const a2 = this._createDelegatedListener(t2, typeof e2 == "string" ? [e2] : e2, i2);
          this._saveDelegatedListener(t2, a2);
          for (const t3 in a2.delegates)
            this.on(t3, a2.delegates[t3]);
          return this;
        }
        once(t2, e2, i2) {
          if (i2 === undefined)
            return super.once(t2, e2);
          const a2 = typeof e2 == "string" ? [e2] : e2, s2 = this._createDelegatedListener(t2, a2, i2);
          for (const e3 in s2.delegates) {
            const o2 = s2.delegates[e3];
            s2.delegates[e3] = (...e4) => {
              this._removeDelegatedListener(t2, a2, i2), o2(...e4);
            };
          }
          this._saveDelegatedListener(t2, s2);
          for (const t3 in s2.delegates)
            this.once(t3, s2.delegates[t3]);
          return this;
        }
        off(t2, e2, i2) {
          return i2 === undefined ? super.off(t2, e2) : (this._removeDelegatedListener(t2, typeof e2 == "string" ? [e2] : e2, i2), this);
        }
        queryRenderedFeatures(t2, i2) {
          if (!this.style)
            return [];
          let a2;
          const s2 = t2 instanceof e.P || Array.isArray(t2), o2 = s2 ? t2 : [
            [0, 0],
            [this.transform.width, this.transform.height]
          ];
          if (i2 = i2 || (s2 ? {} : t2) || {}, o2 instanceof e.P || typeof o2[0] == "number")
            a2 = [e.P.convert(o2)];
          else {
            const t3 = e.P.convert(o2[0]), i3 = e.P.convert(o2[1]);
            a2 = [t3, new e.P(i3.x, t3.y), i3, new e.P(t3.x, i3.y), t3];
          }
          return this.style.queryRenderedFeatures(a2, i2, this.transform);
        }
        querySourceFeatures(t2, e2) {
          return this.style.querySourceFeatures(t2, e2);
        }
        setStyle(t2, i2) {
          return (i2 = e.e({}, {
            localIdeographFontFamily: this._localIdeographFontFamily,
            validate: this._validateStyle
          }, i2)).diff !== false && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && t2 ? (this._diffStyle(t2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(t2, i2));
        }
        setTransformRequest(t2) {
          return this._requestManager.setTransformRequest(t2), this;
        }
        _getUIString(t2) {
          const e2 = this._locale[t2];
          if (e2 == null)
            throw new Error(`Missing UI string '${t2}'`);
          return e2;
        }
        _updateStyle(t2, e2) {
          if (e2.transformStyle && this.style && !this.style._loaded)
            return void this.style.once("style.load", () => this._updateStyle(t2, e2));
          const i2 = this.style && e2.transformStyle ? this.style.serialize() : undefined;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!t2)), t2 ? (this.style = new de(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), typeof t2 == "string" ? this.style.loadURL(t2, e2, i2) : this.style.loadJSON(t2, e2, i2), this) : (delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new de(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(t2, i2) {
          if (typeof t2 == "string") {
            const a2 = this._requestManager.transformRequest(t2, "Style");
            e.h(a2, new AbortController).then((t3) => {
              this._updateDiff(t3.data, i2);
            }).catch((t3) => {
              t3 && this.fire(new e.j(t3));
            });
          } else
            typeof t2 == "object" && this._updateDiff(t2, i2);
        }
        _updateDiff(t2, i2) {
          try {
            this.style.setState(t2, i2) && this._update(true);
          } catch (a2) {
            e.w(`Unable to perform style diff: ${a2.message || a2.error || a2}.  Rebuilding the style from scratch.`), this._updateStyle(t2, i2);
          }
        }
        getStyle() {
          if (this.style)
            return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : e.w("There is no style added to the map.");
        }
        addSource(t2, e2) {
          return this._lazyInitEmptyStyle(), this.style.addSource(t2, e2), this._update(true);
        }
        isSourceLoaded(t2) {
          const i2 = this.style && this.style.sourceCaches[t2];
          if (i2 !== undefined)
            return i2.loaded();
          this.fire(new e.j(new Error(`There is no source with ID '${t2}'`)));
        }
        setTerrain(t2) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), t2) {
            const i2 = this.style.sourceCaches[t2.source];
            if (!i2)
              throw new Error(`cannot load terrain, because there exists no source with ID: ${t2.source}`);
            this.terrain === null && i2.reload();
            for (const i3 in this.style._layers) {
              const a2 = this.style._layers[i3];
              a2.type === "hillshade" && a2.source === t2.source && e.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new Ds(this.painter, i2, t2), this.painter.renderToTexture = new Rs(this.painter, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (e2) => {
              e2.dataType === "style" ? this.terrain.sourceCache.freeRtt() : e2.dataType === "source" && e2.tile && (e2.sourceId !== t2.source || this._elevationFreeze || (this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(e2.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else
            this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0;
          return this.fire(new e.k("terrain", { terrain: t2 })), this;
        }
        getTerrain() {
          var t2, e2;
          return (e2 = (t2 = this.terrain) === null || t2 === undefined ? undefined : t2.options) !== null && e2 !== undefined ? e2 : null;
        }
        areTilesLoaded() {
          const t2 = this.style && this.style.sourceCaches;
          for (const e2 in t2) {
            const i2 = t2[e2]._tiles;
            for (const t3 in i2) {
              const e3 = i2[t3];
              if (e3.state !== "loaded" && e3.state !== "errored")
                return false;
            }
          }
          return true;
        }
        removeSource(t2) {
          return this.style.removeSource(t2), this._update(true);
        }
        getSource(t2) {
          return this.style.getSource(t2);
        }
        addImage(t2, i2, a2 = {}) {
          const {
            pixelRatio: s2 = 1,
            sdf: r2 = false,
            stretchX: n2,
            stretchY: l2,
            content: h2,
            textFitWidth: c2,
            textFitHeight: u2
          } = a2;
          if (this._lazyInitEmptyStyle(), !(i2 instanceof HTMLImageElement || e.b(i2))) {
            if (i2.width === undefined || i2.height === undefined)
              return this.fire(new e.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: a3, height: o2, data: d2 } = i2, _2 = i2;
              return this.style.addImage(t2, {
                data: new e.R({ width: a3, height: o2 }, new Uint8Array(d2)),
                pixelRatio: s2,
                stretchX: n2,
                stretchY: l2,
                content: h2,
                textFitWidth: c2,
                textFitHeight: u2,
                sdf: r2,
                version: 0,
                userImage: _2
              }), _2.onAdd && _2.onAdd(this, t2), this;
            }
          }
          {
            const { width: a3, height: d2, data: _2 } = o.getImageData(i2);
            this.style.addImage(t2, {
              data: new e.R({ width: a3, height: d2 }, _2),
              pixelRatio: s2,
              stretchX: n2,
              stretchY: l2,
              content: h2,
              textFitWidth: c2,
              textFitHeight: u2,
              sdf: r2,
              version: 0
            });
          }
        }
        updateImage(t2, i2) {
          const a2 = this.style.getImage(t2);
          if (!a2)
            return this.fire(new e.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const s2 = i2 instanceof HTMLImageElement || e.b(i2) ? o.getImageData(i2) : i2, { width: r2, height: n2, data: l2 } = s2;
          if (r2 === undefined || n2 === undefined)
            return this.fire(new e.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (r2 !== a2.data.width || n2 !== a2.data.height)
            return this.fire(new e.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const h2 = !(i2 instanceof HTMLImageElement || e.b(i2));
          return a2.data.replace(l2, h2), this.style.updateImage(t2, a2), this;
        }
        getImage(t2) {
          return this.style.getImage(t2);
        }
        hasImage(t2) {
          return t2 ? !!this.style.getImage(t2) : (this.fire(new e.j(new Error("Missing required image id"))), false);
        }
        removeImage(t2) {
          this.style.removeImage(t2);
        }
        loadImage(t2) {
          return _.getImage(this._requestManager.transformRequest(t2, "Image"), new AbortController);
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(t2, e2) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(t2, e2), this._update(true);
        }
        moveLayer(t2, e2) {
          return this.style.moveLayer(t2, e2), this._update(true);
        }
        removeLayer(t2) {
          return this.style.removeLayer(t2), this._update(true);
        }
        getLayer(t2) {
          return this.style.getLayer(t2);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(t2, e2, i2) {
          return this.style.setLayerZoomRange(t2, e2, i2), this._update(true);
        }
        setFilter(t2, e2, i2 = {}) {
          return this.style.setFilter(t2, e2, i2), this._update(true);
        }
        getFilter(t2) {
          return this.style.getFilter(t2);
        }
        setPaintProperty(t2, e2, i2, a2 = {}) {
          return this.style.setPaintProperty(t2, e2, i2, a2), this._update(true);
        }
        getPaintProperty(t2, e2) {
          return this.style.getPaintProperty(t2, e2);
        }
        setLayoutProperty(t2, e2, i2, a2 = {}) {
          return this.style.setLayoutProperty(t2, e2, i2, a2), this._update(true);
        }
        getLayoutProperty(t2, e2) {
          return this.style.getLayoutProperty(t2, e2);
        }
        setGlyphs(t2, e2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(t2, e2), this._update(true);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(t2, e2, i2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.addSprite(t2, e2, i2, (t3) => {
            t3 || this._update(true);
          }), this;
        }
        removeSprite(t2) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(t2), this._update(true);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(t2, e2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setSprite(t2, e2, (t3) => {
            t3 || this._update(true);
          }), this;
        }
        setLight(t2, e2 = {}) {
          return this._lazyInitEmptyStyle(), this.style.setLight(t2, e2), this._update(true);
        }
        getLight() {
          return this.style.getLight();
        }
        setSky(t2) {
          return this._lazyInitEmptyStyle(), this.style.setSky(t2), this._update(true);
        }
        getSky() {
          return this.style.getSky();
        }
        setFeatureState(t2, e2) {
          return this.style.setFeatureState(t2, e2), this._update();
        }
        removeFeatureState(t2, e2) {
          return this.style.removeFeatureState(t2, e2), this._update();
        }
        getFeatureState(t2) {
          return this.style.getFeatureState(t2);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let t2 = 0, e2 = 0;
          return this._container && (t2 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t2, e2];
        }
        _setupContainer() {
          const t2 = this._container;
          t2.classList.add("maplibregl-map");
          const e2 = this._canvasContainer = r.create("div", "maplibregl-canvas-container", t2);
          this._interactive && e2.classList.add("maplibregl-interactive"), this._canvas = r.create("canvas", "maplibregl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
          const i2 = this._containerDimensions(), a2 = this._getClampedPixelRatio(i2[0], i2[1]);
          this._resizeCanvas(i2[0], i2[1], a2);
          const s2 = this._controlContainer = r.create("div", "maplibregl-control-container", t2), o2 = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t3) => {
            o2[t3] = r.create("div", `maplibregl-ctrl-${t3} `, s2);
          }), this._container.addEventListener("scroll", this._onMapScroll, false);
        }
        _resizeCanvas(t2, e2, i2) {
          this._canvas.width = Math.floor(i2 * t2), this._canvas.height = Math.floor(i2 * e2), this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${e2}px`;
        }
        _setupPainter() {
          const t2 = {
            alpha: true,
            stencil: true,
            depth: true,
            failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat,
            preserveDrawingBuffer: this._preserveDrawingBuffer,
            antialias: this._antialias || false
          };
          let e2 = null;
          this._canvas.addEventListener("webglcontextcreationerror", (i3) => {
            e2 = { requestedAttributes: t2 }, i3 && (e2.statusMessage = i3.statusMessage, e2.type = i3.type);
          }, { once: true });
          const i2 = this._canvas.getContext("webgl2", t2) || this._canvas.getContext("webgl", t2);
          if (!i2) {
            const t3 = "Failed to initialize WebGL";
            throw e2 ? (e2.message = t3, new Error(JSON.stringify(e2))) : new Error(t3);
          }
          this.painter = new va(i2, this.transform), n.testSupport(i2);
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(t2) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || t2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(t2) {
          return this._update(), this._renderTaskQueue.add(t2);
        }
        _cancelRenderFrame(t2) {
          this._renderTaskQueue.remove(t2);
        }
        _render(t2) {
          const i2 = this._idleTriggered ? this._fadeDuration : 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(t2), this._removed)
            return;
          let a2 = false;
          if (this.style && this._styleDirty) {
            this._styleDirty = false;
            const t3 = this.transform.zoom, s3 = o.now();
            this.style.zoomHistory.update(t3, s3);
            const r2 = new e.z(t3, {
              now: s3,
              fadeDuration: i2,
              zoomHistory: this.style.zoomHistory,
              transition: this.style.getTransition()
            }), n2 = r2.crossFadingFactor();
            n2 === 1 && n2 === this._crossFadingFactor || (a2 = true, this._crossFadingFactor = n2), this.style.update(r2);
          }
          this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.minElevationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.minElevationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, i2, this._crossSourceCollisions), this.painter.render(this.style, {
            showTileBoundaries: this.showTileBoundaries,
            showOverdrawInspector: this._showOverdrawInspector,
            rotating: this.isRotating(),
            zooming: this.isZooming(),
            moving: this.isMoving(),
            fadeDuration: i2,
            showPadding: this.showPadding
          }), this.fire(new e.k("render")), this.loaded() && !this._loaded && (this._loaded = true, e.bf.mark(e.bg.load), this.fire(new e.k("load"))), this.style && (this.style.hasTransitions() || a2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const s2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return s2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new e.k("idle")), !this._loaded || this._fullyLoaded || s2 || (this._fullyLoaded = true, e.bf.mark(e.bg.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
        }
        remove() {
          var t2;
          this._hash && this._hash.remove();
          for (const t3 of this._controls)
            t3.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window != "undefined" && removeEventListener("online", this._onWindowOnline, false), _.removeThrottleControl(this._imageQueueHandle), (t2 = this._resizeObserver) === null || t2 === undefined || t2.disconnect();
          const i2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
          (i2 == null ? undefined : i2.loseContext) && i2.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), r.remove(this._canvasContainer), r.remove(this._controlContainer), this._container.classList.remove("maplibregl-map"), e.bf.clearMetrics(), this._removed = true, this.fire(new e.k("remove"));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController, o.frameAsync(this._frameRequest).then((t2) => {
            e.bf.frame(t2), this._frameRequest = null, this._render(t2);
          }).catch(() => {
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(t2) {
          this._showTileBoundaries !== t2 && (this._showTileBoundaries = t2, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(t2) {
          this._showPadding !== t2 && (this._showPadding = t2, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(t2) {
          this._showCollisionBoxes !== t2 && (this._showCollisionBoxes = t2, t2 ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(t2) {
          this._showOverdrawInspector !== t2 && (this._showOverdrawInspector = t2, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(t2) {
          this._repaint !== t2 && (this._repaint = t2, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(t2) {
          this._vertices = t2, this._update();
        }
        get version() {
          return Ls;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
      }, t.MapMouseEvent = ka, t.MapTouchEvent = La, t.MapWheelEvent = Fa, t.Marker = Vs, t.NavigationControl = class {
        constructor(t2) {
          this._updateZoomButtons = () => {
            const t3 = this._map.getZoom(), e2 = t3 === this._map.getMaxZoom(), i2 = t3 === this._map.getMinZoom();
            this._zoomInButton.disabled = e2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", e2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
          }, this._rotateCompassArrow = () => {
            const t3 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
            this._compassIcon.style.transform = t3;
          }, this._setButtonTitle = (t3, e2) => {
            const i2 = this._map._getUIString(`NavigationControl.${e2}`);
            t3.title = i2, t3.setAttribute("aria-label", i2);
          }, this.options = e.e({}, Os, t2), this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t3) => t3.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t3) => this._map.zoomIn({}, { originalEvent: t3 })), r.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t3) => this._map.zoomOut({}, { originalEvent: t3 })), r.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t3) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t3 }) : this._map.resetNorth({}, { originalEvent: t3 });
          }), this._compassIcon = r.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(t2) {
          return this._map = t2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ns(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          r.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(t2, e2) {
          const i2 = r.create("button", t2, this._container);
          return i2.type = "button", i2.addEventListener("click", e2), i2;
        }
      }, t.Popup = class extends e.E {
        constructor(t2) {
          super(), this.remove = () => (this._content && r.remove(this._content), this._container && (r.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new e.k("close"))), this), this._onMouseUp = (t3) => {
            this._update(t3.point);
          }, this._onMouseMove = (t3) => {
            this._update(t3.point);
          }, this._onDrag = (t3) => {
            this._update(t3.point);
          }, this._update = (t3) => {
            var e2;
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
              return;
            if (!this._container) {
              if (this._container = r.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = r.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                for (const t4 of this.options.className.split(" "))
                  this._container.classList.add(t4);
              this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? js(this._lngLat, this._flatPos, this._map.transform) : (e2 = this._lngLat) === null || e2 === undefined ? undefined : e2.wrap(), this._trackPointer && !t3)
              return;
            const i2 = this._flatPos = this._pos = this._trackPointer && t3 ? t3 : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && t3 ? t3 : this._map.transform.locationPoint(this._lngLat));
            let a2 = this.options.anchor;
            const s2 = Qs(this.options.offset);
            if (!a2) {
              const t4 = this._container.offsetWidth, e3 = this._container.offsetHeight;
              let o3;
              o3 = i2.y + s2.bottom.y < e3 ? ["top"] : i2.y > this._map.transform.height - e3 ? ["bottom"] : [], i2.x < t4 / 2 ? o3.push("left") : i2.x > this._map.transform.width - t4 / 2 && o3.push("right"), a2 = o3.length === 0 ? "bottom" : o3.join("-");
            }
            let o2 = i2.add(s2[a2]);
            this.options.subpixelPositioning || (o2 = o2.round()), r.setTransform(this._container, `${Zs[a2]} translate(${o2.x}px,${o2.y}px)`), qs(this._container, a2, "popup");
          }, this._onClose = () => {
            this.remove();
          }, this.options = e.e(Object.create(Js), t2);
        }
        addTo(t2) {
          return this._map && this.remove(), this._map = t2, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new e.k("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t2) {
          return this._lngLat = e.N.convert(t2), this._pos = null, this._flatPos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = true, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(t2) {
          return this.setDOMContent(document.createTextNode(t2));
        }
        setHTML(t2) {
          const e2 = document.createDocumentFragment(), i2 = document.createElement("body");
          let a2;
          for (i2.innerHTML = t2;a2 = i2.firstChild, a2; )
            e2.appendChild(a2);
          return this.setDOMContent(e2);
        }
        getMaxWidth() {
          var t2;
          return (t2 = this._container) === null || t2 === undefined ? undefined : t2.style.maxWidth;
        }
        setMaxWidth(t2) {
          return this.options.maxWidth = t2, this._update(), this;
        }
        setDOMContent(t2) {
          if (this._content)
            for (;this._content.hasChildNodes(); )
              this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else
            this._content = r.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(t2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(t2) {
          return this._container && this._container.classList.add(t2), this;
        }
        removeClassName(t2) {
          return this._container && this._container.classList.remove(t2), this;
        }
        setOffset(t2) {
          return this.options.offset = t2, this._update(), this;
        }
        toggleClassName(t2) {
          if (this._container)
            return this._container.classList.toggle(t2);
        }
        setSubpixelPositioning(t2) {
          this.options.subpixelPositioning = t2;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = r.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container)
            return;
          const t2 = this._container.querySelector(Ys);
          t2 && t2.focus();
        }
      }, t.RasterDEMTileSource = K, t.RasterTileSource = X, t.ScaleControl = class {
        constructor(t2) {
          this._onMove = () => {
            Xs(this._map, this._container, this.options);
          }, this.setUnit = (t3) => {
            this.options.unit = t3, Xs(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, $s), t2);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(t2) {
          return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", t2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          r.remove(this._container), this._map.off("move", this._onMove), this._map = undefined;
        }
      }, t.ScrollZoomHandler = us, t.Style = de, t.TerrainControl = class {
        constructor(t2) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
          }, this.options = t2;
        }
        onAdd(t2) {
          return this._map = t2, this._container = r.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = r.create("button", "maplibregl-ctrl-terrain", this._container), r.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          r.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = undefined;
        }
      }, t.TwoFingersTouchPitchHandler = rs, t.TwoFingersTouchRotateHandler = ss, t.TwoFingersTouchZoomHandler = is, t.TwoFingersTouchZoomRotateHandler = gs, t.VectorTileSource = $, t.VideoSource = tt, t.addSourceType = (t2, i2) => e._(undefined, undefined, undefined, function* () {
        if (at(t2))
          throw new Error(`A source type called "${t2}" already exists.`);
        ((t3, e2) => {
          it[t3] = e2;
        })(t2, i2);
      }), t.clearPrewarmedResources = function() {
        const t2 = B;
        t2 && (t2.isPreloaded() && t2.numActive() === 1 ? (t2.release(k), B = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, t.getMaxParallelImageRequests = function() {
        return e.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, t.getRTLTextPluginStatus = function() {
        return nt().getRTLTextPluginStatus();
      }, t.getVersion = function() {
        return to;
      }, t.getWorkerCount = function() {
        return L.workerCount;
      }, t.getWorkerUrl = function() {
        return e.a.WORKER_URL;
      }, t.importScriptInWorkers = function(t2) {
        return j().broadcast("IS", t2);
      }, t.prewarm = function() {
        N().acquire(k);
      }, t.setMaxParallelImageRequests = function(t2) {
        e.a.MAX_PARALLEL_IMAGE_REQUESTS = t2;
      }, t.setRTLTextPlugin = function(t2, e2) {
        return nt().setRTLTextPlugin(t2, e2);
      }, t.setWorkerCount = function(t2) {
        L.workerCount = t2;
      }, t.setWorkerUrl = function(t2) {
        e.a.WORKER_URL = t2;
      };
    });
    var maplibregl$1 = maplibregl;
    return maplibregl$1;
  });
});

// lib/hls.js
var require_hls = __commonJS((exports, module) => {
  (function __HLS_WORKER_BUNDLE__(__IN_WORKER__) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.Hls = factory());
    })(this, function() {
      function ownKeys(e, r) {
        var t = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
          var o = Object.getOwnPropertySymbols(e);
          r && (o = o.filter(function(r2) {
            return Object.getOwnPropertyDescriptor(e, r2).enumerable;
          })), t.push.apply(t, o);
        }
        return t;
      }
      function _objectSpread2(e) {
        for (var r = 1;r < arguments.length; r++) {
          var t = arguments[r] != null ? arguments[r] : {};
          r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
            _defineProperty(e, r2, t[r2]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
            Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
          });
        }
        return e;
      }
      function _toPrimitive(t, r) {
        if (typeof t != "object" || !t)
          return t;
        var e = t[Symbol.toPrimitive];
        if (e !== undefined) {
          var i = e.call(t, r || "default");
          if (typeof i != "object")
            return i;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return (r === "string" ? String : Number)(t);
      }
      function _toPropertyKey(t) {
        var i = _toPrimitive(t, "string");
        return typeof i == "symbol" ? i : String(i);
      }
      function _defineProperties(target, props) {
        for (var i = 0;i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }
      function _defineProperty(obj, key, value) {
        key = _toPropertyKey(key);
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
        return obj;
      }
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1;i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct(Parent2, args2, Class2) {
            var a = [null];
            a.push.apply(a, args2);
            var Constructor = Function.bind.apply(Parent2, a);
            var instance = new Constructor;
            if (Class2)
              _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn) {
        try {
          return Function.toString.call(fn).indexOf("[native code]") !== -1;
        } catch (e) {
          return typeof fn === "function";
        }
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? new Map : undefined;
        _wrapNativeSuper = function _wrapNativeSuper(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2))
            return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2))
              return _cache.get(Class2);
            _cache.set(Class2, Wrapper);
          }
          function Wrapper() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      function _assertThisInitialized(self2) {
        if (self2 === undefined) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o)
          return;
        if (typeof o === "string")
          return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor)
          n = o.constructor.name;
        if (n === "Map" || n === "Set")
          return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
          return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length)
          len = arr.length;
        for (var i = 0, arr2 = new Array(len);i < len; i++)
          arr2[i] = arr[i];
        return arr2;
      }
      function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (it)
          return (it = it.call(o)).next.bind(it);
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
          if (it)
            o = it;
          var i = 0;
          return function() {
            if (i >= o.length)
              return {
                done: true
              };
            return {
              done: false,
              value: o[i++]
            };
          };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      function getDefaultExportFromCjs(x) {
        return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
      }
      var urlToolkit = { exports: {} };
      (function(module2, exports2) {
        (function(root) {
          var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
          var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
          var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
          var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
          var URLToolkit = {
            buildAbsoluteURL: function(baseURL, relativeURL, opts) {
              opts = opts || {};
              baseURL = baseURL.trim();
              relativeURL = relativeURL.trim();
              if (!relativeURL) {
                if (!opts.alwaysNormalize) {
                  return baseURL;
                }
                var basePartsForNormalise = URLToolkit.parseURL(baseURL);
                if (!basePartsForNormalise) {
                  throw new Error("Error trying to parse base URL.");
                }
                basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
                return URLToolkit.buildURLFromParts(basePartsForNormalise);
              }
              var relativeParts = URLToolkit.parseURL(relativeURL);
              if (!relativeParts) {
                throw new Error("Error trying to parse relative URL.");
              }
              if (relativeParts.scheme) {
                if (!opts.alwaysNormalize) {
                  return relativeURL;
                }
                relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
                return URLToolkit.buildURLFromParts(relativeParts);
              }
              var baseParts = URLToolkit.parseURL(baseURL);
              if (!baseParts) {
                throw new Error("Error trying to parse base URL.");
              }
              if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
                var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
                baseParts.netLoc = pathParts[1];
                baseParts.path = pathParts[2];
              }
              if (baseParts.netLoc && !baseParts.path) {
                baseParts.path = "/";
              }
              var builtParts = {
                scheme: baseParts.scheme,
                netLoc: relativeParts.netLoc,
                path: null,
                params: relativeParts.params,
                query: relativeParts.query,
                fragment: relativeParts.fragment
              };
              if (!relativeParts.netLoc) {
                builtParts.netLoc = baseParts.netLoc;
                if (relativeParts.path[0] !== "/") {
                  if (!relativeParts.path) {
                    builtParts.path = baseParts.path;
                    if (!relativeParts.params) {
                      builtParts.params = baseParts.params;
                      if (!relativeParts.query) {
                        builtParts.query = baseParts.query;
                      }
                    }
                  } else {
                    var baseURLPath = baseParts.path;
                    var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                    builtParts.path = URLToolkit.normalizePath(newPath);
                  }
                }
              }
              if (builtParts.path === null) {
                builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
              }
              return URLToolkit.buildURLFromParts(builtParts);
            },
            parseURL: function(url2) {
              var parts = URL_REGEX.exec(url2);
              if (!parts) {
                return null;
              }
              return {
                scheme: parts[1] || "",
                netLoc: parts[2] || "",
                path: parts[3] || "",
                params: parts[4] || "",
                query: parts[5] || "",
                fragment: parts[6] || ""
              };
            },
            normalizePath: function(path) {
              path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
              while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) {
              }
              return path.split("").reverse().join("");
            },
            buildURLFromParts: function(parts) {
              return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
            }
          };
          module2.exports = URLToolkit;
        })();
      })(urlToolkit);
      var urlToolkitExports = urlToolkit.exports;
      var isFiniteNumber = Number.isFinite || function(value) {
        return typeof value === "number" && isFinite(value);
      };
      var isSafeInteger = Number.isSafeInteger || function(value) {
        return typeof value === "number" && Math.abs(value) <= MAX_SAFE_INTEGER;
      };
      var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
      var Events = /* @__PURE__ */ function(Events2) {
        Events2["MEDIA_ATTACHING"] = "hlsMediaAttaching";
        Events2["MEDIA_ATTACHED"] = "hlsMediaAttached";
        Events2["MEDIA_DETACHING"] = "hlsMediaDetaching";
        Events2["MEDIA_DETACHED"] = "hlsMediaDetached";
        Events2["BUFFER_RESET"] = "hlsBufferReset";
        Events2["BUFFER_CODECS"] = "hlsBufferCodecs";
        Events2["BUFFER_CREATED"] = "hlsBufferCreated";
        Events2["BUFFER_APPENDING"] = "hlsBufferAppending";
        Events2["BUFFER_APPENDED"] = "hlsBufferAppended";
        Events2["BUFFER_EOS"] = "hlsBufferEos";
        Events2["BUFFER_FLUSHING"] = "hlsBufferFlushing";
        Events2["BUFFER_FLUSHED"] = "hlsBufferFlushed";
        Events2["MANIFEST_LOADING"] = "hlsManifestLoading";
        Events2["MANIFEST_LOADED"] = "hlsManifestLoaded";
        Events2["MANIFEST_PARSED"] = "hlsManifestParsed";
        Events2["LEVEL_SWITCHING"] = "hlsLevelSwitching";
        Events2["LEVEL_SWITCHED"] = "hlsLevelSwitched";
        Events2["LEVEL_LOADING"] = "hlsLevelLoading";
        Events2["LEVEL_LOADED"] = "hlsLevelLoaded";
        Events2["LEVEL_UPDATED"] = "hlsLevelUpdated";
        Events2["LEVEL_PTS_UPDATED"] = "hlsLevelPtsUpdated";
        Events2["LEVELS_UPDATED"] = "hlsLevelsUpdated";
        Events2["AUDIO_TRACKS_UPDATED"] = "hlsAudioTracksUpdated";
        Events2["AUDIO_TRACK_SWITCHING"] = "hlsAudioTrackSwitching";
        Events2["AUDIO_TRACK_SWITCHED"] = "hlsAudioTrackSwitched";
        Events2["AUDIO_TRACK_LOADING"] = "hlsAudioTrackLoading";
        Events2["AUDIO_TRACK_LOADED"] = "hlsAudioTrackLoaded";
        Events2["SUBTITLE_TRACKS_UPDATED"] = "hlsSubtitleTracksUpdated";
        Events2["SUBTITLE_TRACKS_CLEARED"] = "hlsSubtitleTracksCleared";
        Events2["SUBTITLE_TRACK_SWITCH"] = "hlsSubtitleTrackSwitch";
        Events2["SUBTITLE_TRACK_LOADING"] = "hlsSubtitleTrackLoading";
        Events2["SUBTITLE_TRACK_LOADED"] = "hlsSubtitleTrackLoaded";
        Events2["SUBTITLE_FRAG_PROCESSED"] = "hlsSubtitleFragProcessed";
        Events2["CUES_PARSED"] = "hlsCuesParsed";
        Events2["NON_NATIVE_TEXT_TRACKS_FOUND"] = "hlsNonNativeTextTracksFound";
        Events2["INIT_PTS_FOUND"] = "hlsInitPtsFound";
        Events2["FRAG_LOADING"] = "hlsFragLoading";
        Events2["FRAG_LOAD_EMERGENCY_ABORTED"] = "hlsFragLoadEmergencyAborted";
        Events2["FRAG_LOADED"] = "hlsFragLoaded";
        Events2["FRAG_DECRYPTED"] = "hlsFragDecrypted";
        Events2["FRAG_PARSING_INIT_SEGMENT"] = "hlsFragParsingInitSegment";
        Events2["FRAG_PARSING_USERDATA"] = "hlsFragParsingUserdata";
        Events2["FRAG_PARSING_METADATA"] = "hlsFragParsingMetadata";
        Events2["FRAG_PARSED"] = "hlsFragParsed";
        Events2["FRAG_BUFFERED"] = "hlsFragBuffered";
        Events2["FRAG_CHANGED"] = "hlsFragChanged";
        Events2["FPS_DROP"] = "hlsFpsDrop";
        Events2["FPS_DROP_LEVEL_CAPPING"] = "hlsFpsDropLevelCapping";
        Events2["MAX_AUTO_LEVEL_UPDATED"] = "hlsMaxAutoLevelUpdated";
        Events2["ERROR"] = "hlsError";
        Events2["DESTROYING"] = "hlsDestroying";
        Events2["KEY_LOADING"] = "hlsKeyLoading";
        Events2["KEY_LOADED"] = "hlsKeyLoaded";
        Events2["LIVE_BACK_BUFFER_REACHED"] = "hlsLiveBackBufferReached";
        Events2["BACK_BUFFER_REACHED"] = "hlsBackBufferReached";
        Events2["STEERING_MANIFEST_LOADED"] = "hlsSteeringManifestLoaded";
        return Events2;
      }({});
      var ErrorTypes2 = /* @__PURE__ */ function(ErrorTypes3) {
        ErrorTypes3["NETWORK_ERROR"] = "networkError";
        ErrorTypes3["MEDIA_ERROR"] = "mediaError";
        ErrorTypes3["KEY_SYSTEM_ERROR"] = "keySystemError";
        ErrorTypes3["MUX_ERROR"] = "muxError";
        ErrorTypes3["OTHER_ERROR"] = "otherError";
        return ErrorTypes3;
      }({});
      var ErrorDetails = /* @__PURE__ */ function(ErrorDetails2) {
        ErrorDetails2["KEY_SYSTEM_NO_KEYS"] = "keySystemNoKeys";
        ErrorDetails2["KEY_SYSTEM_NO_ACCESS"] = "keySystemNoAccess";
        ErrorDetails2["KEY_SYSTEM_NO_SESSION"] = "keySystemNoSession";
        ErrorDetails2["KEY_SYSTEM_NO_CONFIGURED_LICENSE"] = "keySystemNoConfiguredLicense";
        ErrorDetails2["KEY_SYSTEM_LICENSE_REQUEST_FAILED"] = "keySystemLicenseRequestFailed";
        ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED"] = "keySystemServerCertificateRequestFailed";
        ErrorDetails2["KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED"] = "keySystemServerCertificateUpdateFailed";
        ErrorDetails2["KEY_SYSTEM_SESSION_UPDATE_FAILED"] = "keySystemSessionUpdateFailed";
        ErrorDetails2["KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED"] = "keySystemStatusOutputRestricted";
        ErrorDetails2["KEY_SYSTEM_STATUS_INTERNAL_ERROR"] = "keySystemStatusInternalError";
        ErrorDetails2["MANIFEST_LOAD_ERROR"] = "manifestLoadError";
        ErrorDetails2["MANIFEST_LOAD_TIMEOUT"] = "manifestLoadTimeOut";
        ErrorDetails2["MANIFEST_PARSING_ERROR"] = "manifestParsingError";
        ErrorDetails2["MANIFEST_INCOMPATIBLE_CODECS_ERROR"] = "manifestIncompatibleCodecsError";
        ErrorDetails2["LEVEL_EMPTY_ERROR"] = "levelEmptyError";
        ErrorDetails2["LEVEL_LOAD_ERROR"] = "levelLoadError";
        ErrorDetails2["LEVEL_LOAD_TIMEOUT"] = "levelLoadTimeOut";
        ErrorDetails2["LEVEL_PARSING_ERROR"] = "levelParsingError";
        ErrorDetails2["LEVEL_SWITCH_ERROR"] = "levelSwitchError";
        ErrorDetails2["AUDIO_TRACK_LOAD_ERROR"] = "audioTrackLoadError";
        ErrorDetails2["AUDIO_TRACK_LOAD_TIMEOUT"] = "audioTrackLoadTimeOut";
        ErrorDetails2["SUBTITLE_LOAD_ERROR"] = "subtitleTrackLoadError";
        ErrorDetails2["SUBTITLE_TRACK_LOAD_TIMEOUT"] = "subtitleTrackLoadTimeOut";
        ErrorDetails2["FRAG_LOAD_ERROR"] = "fragLoadError";
        ErrorDetails2["FRAG_LOAD_TIMEOUT"] = "fragLoadTimeOut";
        ErrorDetails2["FRAG_DECRYPT_ERROR"] = "fragDecryptError";
        ErrorDetails2["FRAG_PARSING_ERROR"] = "fragParsingError";
        ErrorDetails2["FRAG_GAP"] = "fragGap";
        ErrorDetails2["REMUX_ALLOC_ERROR"] = "remuxAllocError";
        ErrorDetails2["KEY_LOAD_ERROR"] = "keyLoadError";
        ErrorDetails2["KEY_LOAD_TIMEOUT"] = "keyLoadTimeOut";
        ErrorDetails2["BUFFER_ADD_CODEC_ERROR"] = "bufferAddCodecError";
        ErrorDetails2["BUFFER_INCOMPATIBLE_CODECS_ERROR"] = "bufferIncompatibleCodecsError";
        ErrorDetails2["BUFFER_APPEND_ERROR"] = "bufferAppendError";
        ErrorDetails2["BUFFER_APPENDING_ERROR"] = "bufferAppendingError";
        ErrorDetails2["BUFFER_STALLED_ERROR"] = "bufferStalledError";
        ErrorDetails2["BUFFER_FULL_ERROR"] = "bufferFullError";
        ErrorDetails2["BUFFER_SEEK_OVER_HOLE"] = "bufferSeekOverHole";
        ErrorDetails2["BUFFER_NUDGE_ON_STALL"] = "bufferNudgeOnStall";
        ErrorDetails2["INTERNAL_EXCEPTION"] = "internalException";
        ErrorDetails2["INTERNAL_ABORTED"] = "aborted";
        ErrorDetails2["UNKNOWN"] = "unknown";
        return ErrorDetails2;
      }({});
      var noop = function noop() {
      };
      var fakeLogger = {
        trace: noop,
        debug: noop,
        log: noop,
        warn: noop,
        info: noop,
        error: noop
      };
      var exportedLogger = fakeLogger;
      function consolePrintFn(type) {
        var func = self.console[type];
        if (func) {
          return func.bind(self.console, "[" + type + "] >");
        }
        return noop;
      }
      function exportLoggerFunctions(debugConfig) {
        for (var _len = arguments.length, functions = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
          functions[_key - 1] = arguments[_key];
        }
        functions.forEach(function(type) {
          exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);
        });
      }
      function enableLogs(debugConfig, id) {
        if (typeof console === "object" && debugConfig === true || typeof debugConfig === "object") {
          exportLoggerFunctions(debugConfig, "debug", "log", "info", "warn", "error");
          try {
            exportedLogger.log('Debug logs enabled for "' + id + '" in hls.js version ' + "1.5.18");
          } catch (e) {
            exportedLogger = fakeLogger;
          }
        } else {
          exportedLogger = fakeLogger;
        }
      }
      var logger = exportedLogger;
      var DECIMAL_RESOLUTION_REGEX = /^(\d+)x(\d+)$/;
      var ATTR_LIST_REGEX = /(.+?)=(".*?"|.*?)(?:,|$)/g;
      var AttrList = /* @__PURE__ */ function() {
        function AttrList2(attrs) {
          if (typeof attrs === "string") {
            attrs = AttrList2.parseAttrList(attrs);
          }
          _extends(this, attrs);
        }
        var _proto = AttrList2.prototype;
        _proto.decimalInteger = function decimalInteger(attrName) {
          var intValue = parseInt(this[attrName], 10);
          if (intValue > Number.MAX_SAFE_INTEGER) {
            return Infinity;
          }
          return intValue;
        };
        _proto.hexadecimalInteger = function hexadecimalInteger(attrName) {
          if (this[attrName]) {
            var stringValue = (this[attrName] || "0x").slice(2);
            stringValue = (stringValue.length & 1 ? "0" : "") + stringValue;
            var value = new Uint8Array(stringValue.length / 2);
            for (var i = 0;i < stringValue.length / 2; i++) {
              value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);
            }
            return value;
          } else {
            return null;
          }
        };
        _proto.hexadecimalIntegerAsNumber = function hexadecimalIntegerAsNumber(attrName) {
          var intValue = parseInt(this[attrName], 16);
          if (intValue > Number.MAX_SAFE_INTEGER) {
            return Infinity;
          }
          return intValue;
        };
        _proto.decimalFloatingPoint = function decimalFloatingPoint(attrName) {
          return parseFloat(this[attrName]);
        };
        _proto.optionalFloat = function optionalFloat(attrName, defaultValue) {
          var value = this[attrName];
          return value ? parseFloat(value) : defaultValue;
        };
        _proto.enumeratedString = function enumeratedString(attrName) {
          return this[attrName];
        };
        _proto.bool = function bool(attrName) {
          return this[attrName] === "YES";
        };
        _proto.decimalResolution = function decimalResolution(attrName) {
          var res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);
          if (res === null) {
            return;
          }
          return {
            width: parseInt(res[1], 10),
            height: parseInt(res[2], 10)
          };
        };
        AttrList2.parseAttrList = function parseAttrList(input) {
          var match;
          var attrs = {};
          var quote = '"';
          ATTR_LIST_REGEX.lastIndex = 0;
          while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {
            var value = match[2];
            if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {
              value = value.slice(1, -1);
            }
            var name = match[1].trim();
            attrs[name] = value;
          }
          return attrs;
        };
        _createClass(AttrList2, [{
          key: "clientAttrs",
          get: function get() {
            return Object.keys(this).filter(function(attr) {
              return attr.substring(0, 2) === "X-";
            });
          }
        }]);
        return AttrList2;
      }();
      function isDateRangeCueAttribute(attrName) {
        return attrName !== "ID" && attrName !== "CLASS" && attrName !== "START-DATE" && attrName !== "DURATION" && attrName !== "END-DATE" && attrName !== "END-ON-NEXT";
      }
      function isSCTE35Attribute(attrName) {
        return attrName === "SCTE35-OUT" || attrName === "SCTE35-IN";
      }
      var DateRange = /* @__PURE__ */ function() {
        function DateRange2(dateRangeAttr, dateRangeWithSameId) {
          this.attr = undefined;
          this._startDate = undefined;
          this._endDate = undefined;
          this._badValueForSameId = undefined;
          if (dateRangeWithSameId) {
            var previousAttr = dateRangeWithSameId.attr;
            for (var key in previousAttr) {
              if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {
                logger.warn('DATERANGE tag attribute: "' + key + '" does not match for tags with ID: "' + dateRangeAttr.ID + '"');
                this._badValueForSameId = key;
                break;
              }
            }
            dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);
          }
          this.attr = dateRangeAttr;
          this._startDate = new Date(dateRangeAttr["START-DATE"]);
          if ("END-DATE" in this.attr) {
            var endDate = new Date(this.attr["END-DATE"]);
            if (isFiniteNumber(endDate.getTime())) {
              this._endDate = endDate;
            }
          }
        }
        _createClass(DateRange2, [{
          key: "id",
          get: function get() {
            return this.attr.ID;
          }
        }, {
          key: "class",
          get: function get() {
            return this.attr.CLASS;
          }
        }, {
          key: "startDate",
          get: function get() {
            return this._startDate;
          }
        }, {
          key: "endDate",
          get: function get() {
            if (this._endDate) {
              return this._endDate;
            }
            var duration = this.duration;
            if (duration !== null) {
              return new Date(this._startDate.getTime() + duration * 1000);
            }
            return null;
          }
        }, {
          key: "duration",
          get: function get() {
            if ("DURATION" in this.attr) {
              var duration = this.attr.decimalFloatingPoint("DURATION");
              if (isFiniteNumber(duration)) {
                return duration;
              }
            } else if (this._endDate) {
              return (this._endDate.getTime() - this._startDate.getTime()) / 1000;
            }
            return null;
          }
        }, {
          key: "plannedDuration",
          get: function get() {
            if ("PLANNED-DURATION" in this.attr) {
              return this.attr.decimalFloatingPoint("PLANNED-DURATION");
            }
            return null;
          }
        }, {
          key: "endOnNext",
          get: function get() {
            return this.attr.bool("END-ON-NEXT");
          }
        }, {
          key: "isValid",
          get: function get() {
            return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);
          }
        }]);
        return DateRange2;
      }();
      var LoadStats = function LoadStats() {
        this.aborted = false;
        this.loaded = 0;
        this.retry = 0;
        this.total = 0;
        this.chunkCount = 0;
        this.bwEstimate = 0;
        this.loading = {
          start: 0,
          first: 0,
          end: 0
        };
        this.parsing = {
          start: 0,
          end: 0
        };
        this.buffering = {
          start: 0,
          first: 0,
          end: 0
        };
      };
      var ElementaryStreamTypes = {
        AUDIO: "audio",
        VIDEO: "video",
        AUDIOVIDEO: "audiovideo"
      };
      var BaseSegment = /* @__PURE__ */ function() {
        function BaseSegment2(baseurl) {
          var _this$elementaryStrea;
          this._byteRange = null;
          this._url = null;
          this.baseurl = undefined;
          this.relurl = undefined;
          this.elementaryStreams = (_this$elementaryStrea = {}, _this$elementaryStrea[ElementaryStreamTypes.AUDIO] = null, _this$elementaryStrea[ElementaryStreamTypes.VIDEO] = null, _this$elementaryStrea[ElementaryStreamTypes.AUDIOVIDEO] = null, _this$elementaryStrea);
          this.baseurl = baseurl;
        }
        var _proto = BaseSegment2.prototype;
        _proto.setByteRange = function setByteRange(value, previous) {
          var params = value.split("@", 2);
          var start;
          if (params.length === 1) {
            start = (previous == null ? undefined : previous.byteRangeEndOffset) || 0;
          } else {
            start = parseInt(params[1]);
          }
          this._byteRange = [start, parseInt(params[0]) + start];
        };
        _createClass(BaseSegment2, [{
          key: "byteRange",
          get: function get() {
            if (!this._byteRange) {
              return [];
            }
            return this._byteRange;
          }
        }, {
          key: "byteRangeStartOffset",
          get: function get() {
            return this.byteRange[0];
          }
        }, {
          key: "byteRangeEndOffset",
          get: function get() {
            return this.byteRange[1];
          }
        }, {
          key: "url",
          get: function get() {
            if (!this._url && this.baseurl && this.relurl) {
              this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {
                alwaysNormalize: true
              });
            }
            return this._url || "";
          },
          set: function set(value) {
            this._url = value;
          }
        }]);
        return BaseSegment2;
      }();
      var Fragment = /* @__PURE__ */ function(_BaseSegment) {
        _inheritsLoose(Fragment2, _BaseSegment);
        function Fragment2(type, baseurl) {
          var _this;
          _this = _BaseSegment.call(this, baseurl) || this;
          _this._decryptdata = null;
          _this.rawProgramDateTime = null;
          _this.programDateTime = null;
          _this.tagList = [];
          _this.duration = 0;
          _this.sn = 0;
          _this.levelkeys = undefined;
          _this.type = undefined;
          _this.loader = null;
          _this.keyLoader = null;
          _this.level = -1;
          _this.cc = 0;
          _this.startPTS = undefined;
          _this.endPTS = undefined;
          _this.startDTS = undefined;
          _this.endDTS = undefined;
          _this.start = 0;
          _this.deltaPTS = undefined;
          _this.maxStartPTS = undefined;
          _this.minEndPTS = undefined;
          _this.stats = new LoadStats;
          _this.data = undefined;
          _this.bitrateTest = false;
          _this.title = null;
          _this.initSegment = null;
          _this.endList = undefined;
          _this.gap = undefined;
          _this.urlId = 0;
          _this.type = type;
          return _this;
        }
        var _proto2 = Fragment2.prototype;
        _proto2.setKeyFormat = function setKeyFormat(keyFormat) {
          if (this.levelkeys) {
            var _key = this.levelkeys[keyFormat];
            if (_key && !this._decryptdata) {
              this._decryptdata = _key.getDecryptData(this.sn);
            }
          }
        };
        _proto2.abortRequests = function abortRequests() {
          var _this$loader, _this$keyLoader;
          (_this$loader = this.loader) == null || _this$loader.abort();
          (_this$keyLoader = this.keyLoader) == null || _this$keyLoader.abort();
        };
        _proto2.setElementaryStreamInfo = function setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial) {
          if (partial === undefined) {
            partial = false;
          }
          var elementaryStreams = this.elementaryStreams;
          var info = elementaryStreams[type];
          if (!info) {
            elementaryStreams[type] = {
              startPTS,
              endPTS,
              startDTS,
              endDTS,
              partial
            };
            return;
          }
          info.startPTS = Math.min(info.startPTS, startPTS);
          info.endPTS = Math.max(info.endPTS, endPTS);
          info.startDTS = Math.min(info.startDTS, startDTS);
          info.endDTS = Math.max(info.endDTS, endDTS);
        };
        _proto2.clearElementaryStreamInfo = function clearElementaryStreamInfo() {
          var elementaryStreams = this.elementaryStreams;
          elementaryStreams[ElementaryStreamTypes.AUDIO] = null;
          elementaryStreams[ElementaryStreamTypes.VIDEO] = null;
          elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;
        };
        _createClass(Fragment2, [{
          key: "decryptdata",
          get: function get() {
            var levelkeys = this.levelkeys;
            if (!levelkeys && !this._decryptdata) {
              return null;
            }
            if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {
              var _key2 = this.levelkeys.identity;
              if (_key2) {
                this._decryptdata = _key2.getDecryptData(this.sn);
              } else {
                var keyFormats = Object.keys(this.levelkeys);
                if (keyFormats.length === 1) {
                  return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);
                }
              }
            }
            return this._decryptdata;
          }
        }, {
          key: "end",
          get: function get() {
            return this.start + this.duration;
          }
        }, {
          key: "endProgramDateTime",
          get: function get() {
            if (this.programDateTime === null) {
              return null;
            }
            if (!isFiniteNumber(this.programDateTime)) {
              return null;
            }
            var duration = !isFiniteNumber(this.duration) ? 0 : this.duration;
            return this.programDateTime + duration * 1000;
          }
        }, {
          key: "encrypted",
          get: function get() {
            var _this$_decryptdata;
            if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {
              return true;
            } else if (this.levelkeys) {
              var keyFormats = Object.keys(this.levelkeys);
              var len = keyFormats.length;
              if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {
                return true;
              }
            }
            return false;
          }
        }]);
        return Fragment2;
      }(BaseSegment);
      var Part = /* @__PURE__ */ function(_BaseSegment2) {
        _inheritsLoose(Part2, _BaseSegment2);
        function Part2(partAttrs, frag, baseurl, index, previous) {
          var _this2;
          _this2 = _BaseSegment2.call(this, baseurl) || this;
          _this2.fragOffset = 0;
          _this2.duration = 0;
          _this2.gap = false;
          _this2.independent = false;
          _this2.relurl = undefined;
          _this2.fragment = undefined;
          _this2.index = undefined;
          _this2.stats = new LoadStats;
          _this2.duration = partAttrs.decimalFloatingPoint("DURATION");
          _this2.gap = partAttrs.bool("GAP");
          _this2.independent = partAttrs.bool("INDEPENDENT");
          _this2.relurl = partAttrs.enumeratedString("URI");
          _this2.fragment = frag;
          _this2.index = index;
          var byteRange = partAttrs.enumeratedString("BYTERANGE");
          if (byteRange) {
            _this2.setByteRange(byteRange, previous);
          }
          if (previous) {
            _this2.fragOffset = previous.fragOffset + previous.duration;
          }
          return _this2;
        }
        _createClass(Part2, [{
          key: "start",
          get: function get() {
            return this.fragment.start + this.fragOffset;
          }
        }, {
          key: "end",
          get: function get() {
            return this.start + this.duration;
          }
        }, {
          key: "loaded",
          get: function get() {
            var elementaryStreams = this.elementaryStreams;
            return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);
          }
        }]);
        return Part2;
      }(BaseSegment);
      var DEFAULT_TARGET_DURATION = 10;
      var LevelDetails = /* @__PURE__ */ function() {
        function LevelDetails2(baseUrl) {
          this.PTSKnown = false;
          this.alignedSliding = false;
          this.averagetargetduration = undefined;
          this.endCC = 0;
          this.endSN = 0;
          this.fragments = undefined;
          this.fragmentHint = undefined;
          this.partList = null;
          this.dateRanges = undefined;
          this.live = true;
          this.ageHeader = 0;
          this.advancedDateTime = undefined;
          this.updated = true;
          this.advanced = true;
          this.availabilityDelay = undefined;
          this.misses = 0;
          this.startCC = 0;
          this.startSN = 0;
          this.startTimeOffset = null;
          this.targetduration = 0;
          this.totalduration = 0;
          this.type = null;
          this.url = undefined;
          this.m3u8 = "";
          this.version = null;
          this.canBlockReload = false;
          this.canSkipUntil = 0;
          this.canSkipDateRanges = false;
          this.skippedSegments = 0;
          this.recentlyRemovedDateranges = undefined;
          this.partHoldBack = 0;
          this.holdBack = 0;
          this.partTarget = 0;
          this.preloadHint = undefined;
          this.renditionReports = undefined;
          this.tuneInGoal = 0;
          this.deltaUpdateFailed = undefined;
          this.driftStartTime = 0;
          this.driftEndTime = 0;
          this.driftStart = 0;
          this.driftEnd = 0;
          this.encryptedFragments = undefined;
          this.playlistParsingError = null;
          this.variableList = null;
          this.hasVariableRefs = false;
          this.fragments = [];
          this.encryptedFragments = [];
          this.dateRanges = {};
          this.url = baseUrl;
        }
        var _proto = LevelDetails2.prototype;
        _proto.reloaded = function reloaded(previous) {
          if (!previous) {
            this.advanced = true;
            this.updated = true;
            return;
          }
          var partSnDiff = this.lastPartSn - previous.lastPartSn;
          var partIndexDiff = this.lastPartIndex - previous.lastPartIndex;
          this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;
          this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;
          if (this.updated || this.advanced) {
            this.misses = Math.floor(previous.misses * 0.6);
          } else {
            this.misses = previous.misses + 1;
          }
          this.availabilityDelay = previous.availabilityDelay;
        };
        _createClass(LevelDetails2, [{
          key: "hasProgramDateTime",
          get: function get() {
            if (this.fragments.length) {
              return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);
            }
            return false;
          }
        }, {
          key: "levelTargetDuration",
          get: function get() {
            return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;
          }
        }, {
          key: "drift",
          get: function get() {
            var runTime = this.driftEndTime - this.driftStartTime;
            if (runTime > 0) {
              var runDuration = this.driftEnd - this.driftStart;
              return runDuration * 1000 / runTime;
            }
            return 1;
          }
        }, {
          key: "edge",
          get: function get() {
            return this.partEnd || this.fragmentEnd;
          }
        }, {
          key: "partEnd",
          get: function get() {
            var _this$partList;
            if ((_this$partList = this.partList) != null && _this$partList.length) {
              return this.partList[this.partList.length - 1].end;
            }
            return this.fragmentEnd;
          }
        }, {
          key: "fragmentEnd",
          get: function get() {
            var _this$fragments;
            if ((_this$fragments = this.fragments) != null && _this$fragments.length) {
              return this.fragments[this.fragments.length - 1].end;
            }
            return 0;
          }
        }, {
          key: "age",
          get: function get() {
            if (this.advancedDateTime) {
              return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;
            }
            return 0;
          }
        }, {
          key: "lastPartIndex",
          get: function get() {
            var _this$partList2;
            if ((_this$partList2 = this.partList) != null && _this$partList2.length) {
              return this.partList[this.partList.length - 1].index;
            }
            return -1;
          }
        }, {
          key: "lastPartSn",
          get: function get() {
            var _this$partList3;
            if ((_this$partList3 = this.partList) != null && _this$partList3.length) {
              return this.partList[this.partList.length - 1].fragment.sn;
            }
            return this.endSN;
          }
        }]);
        return LevelDetails2;
      }();
      function base64Decode(base64encodedStr) {
        return Uint8Array.from(atob(base64encodedStr), function(c) {
          return c.charCodeAt(0);
        });
      }
      function getKeyIdBytes(str) {
        var keyIdbytes = strToUtf8array(str).subarray(0, 16);
        var paddedkeyIdbytes = new Uint8Array(16);
        paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);
        return paddedkeyIdbytes;
      }
      function changeEndianness(keyId) {
        var swap = function swap(array, from, to) {
          var cur = array[from];
          array[from] = array[to];
          array[to] = cur;
        };
        swap(keyId, 0, 3);
        swap(keyId, 1, 2);
        swap(keyId, 4, 5);
        swap(keyId, 6, 7);
      }
      function convertDataUriToArrayBytes(uri) {
        var colonsplit = uri.split(":");
        var keydata = null;
        if (colonsplit[0] === "data" && colonsplit.length === 2) {
          var semicolonsplit = colonsplit[1].split(";");
          var commasplit = semicolonsplit[semicolonsplit.length - 1].split(",");
          if (commasplit.length === 2) {
            var isbase64 = commasplit[0] === "base64";
            var data = commasplit[1];
            if (isbase64) {
              semicolonsplit.splice(-1, 1);
              keydata = base64Decode(data);
            } else {
              keydata = getKeyIdBytes(data);
            }
          }
        }
        return keydata;
      }
      function strToUtf8array(str) {
        return Uint8Array.from(unescape(encodeURIComponent(str)), function(c) {
          return c.charCodeAt(0);
        });
      }
      var optionalSelf = typeof self !== "undefined" ? self : undefined;
      var KeySystems = {
        CLEARKEY: "org.w3.clearkey",
        FAIRPLAY: "com.apple.fps",
        PLAYREADY: "com.microsoft.playready",
        WIDEVINE: "com.widevine.alpha"
      };
      var KeySystemFormats = {
        CLEARKEY: "org.w3.clearkey",
        FAIRPLAY: "com.apple.streamingkeydelivery",
        PLAYREADY: "com.microsoft.playready",
        WIDEVINE: "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed"
      };
      function keySystemFormatToKeySystemDomain(format2) {
        switch (format2) {
          case KeySystemFormats.FAIRPLAY:
            return KeySystems.FAIRPLAY;
          case KeySystemFormats.PLAYREADY:
            return KeySystems.PLAYREADY;
          case KeySystemFormats.WIDEVINE:
            return KeySystems.WIDEVINE;
          case KeySystemFormats.CLEARKEY:
            return KeySystems.CLEARKEY;
        }
      }
      var KeySystemIds = {
        CENC: "1077efecc0b24d02ace33c1e52e2fb4b",
        CLEARKEY: "e2719d58a985b3c9781ab030af78d30e",
        FAIRPLAY: "94ce86fb07ff4f43adb893d2fa968ca2",
        PLAYREADY: "9a04f07998404286ab92e65be0885f95",
        WIDEVINE: "edef8ba979d64acea3c827dcd51d21ed"
      };
      function keySystemIdToKeySystemDomain(systemId) {
        if (systemId === KeySystemIds.WIDEVINE) {
          return KeySystems.WIDEVINE;
        } else if (systemId === KeySystemIds.PLAYREADY) {
          return KeySystems.PLAYREADY;
        } else if (systemId === KeySystemIds.CENC || systemId === KeySystemIds.CLEARKEY) {
          return KeySystems.CLEARKEY;
        }
      }
      function keySystemDomainToKeySystemFormat(keySystem) {
        switch (keySystem) {
          case KeySystems.FAIRPLAY:
            return KeySystemFormats.FAIRPLAY;
          case KeySystems.PLAYREADY:
            return KeySystemFormats.PLAYREADY;
          case KeySystems.WIDEVINE:
            return KeySystemFormats.WIDEVINE;
          case KeySystems.CLEARKEY:
            return KeySystemFormats.CLEARKEY;
        }
      }
      function getKeySystemsForConfig(config) {
        var { drmSystems, widevineLicenseUrl } = config;
        var keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter(function(keySystem) {
          return !!drmSystems[keySystem];
        }) : [];
        if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {
          keySystemsToAttempt.push(KeySystems.WIDEVINE);
        }
        return keySystemsToAttempt;
      }
      var requestMediaKeySystemAccess = function(_optionalSelf$navigat) {
        if (optionalSelf != null && (_optionalSelf$navigat = optionalSelf.navigator) != null && _optionalSelf$navigat.requestMediaKeySystemAccess) {
          return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);
        } else {
          return null;
        }
      }();
      function getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {
        var initDataTypes;
        switch (keySystem) {
          case KeySystems.FAIRPLAY:
            initDataTypes = ["cenc", "sinf"];
            break;
          case KeySystems.WIDEVINE:
          case KeySystems.PLAYREADY:
            initDataTypes = ["cenc"];
            break;
          case KeySystems.CLEARKEY:
            initDataTypes = ["cenc", "keyids"];
            break;
          default:
            throw new Error("Unknown key-system: " + keySystem);
        }
        return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);
      }
      function createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {
        var baseConfig = {
          initDataTypes,
          persistentState: drmSystemOptions.persistentState || "optional",
          distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || "optional",
          sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || "temporary"],
          audioCapabilities: audioCodecs.map(function(codec) {
            return {
              contentType: 'audio/mp4; codecs="' + codec + '"',
              robustness: drmSystemOptions.audioRobustness || "",
              encryptionScheme: drmSystemOptions.audioEncryptionScheme || null
            };
          }),
          videoCapabilities: videoCodecs.map(function(codec) {
            return {
              contentType: 'video/mp4; codecs="' + codec + '"',
              robustness: drmSystemOptions.videoRobustness || "",
              encryptionScheme: drmSystemOptions.videoEncryptionScheme || null
            };
          })
        };
        return [baseConfig];
      }
      function sliceUint8(array, start, end) {
        return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));
      }
      var isHeader$2 = function isHeader(data, offset) {
        if (offset + 10 <= data.length) {
          if (data[offset] === 73 && data[offset + 1] === 68 && data[offset + 2] === 51) {
            if (data[offset + 3] < 255 && data[offset + 4] < 255) {
              if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
                return true;
              }
            }
          }
        }
        return false;
      };
      var isFooter = function isFooter(data, offset) {
        if (offset + 10 <= data.length) {
          if (data[offset] === 51 && data[offset + 1] === 68 && data[offset + 2] === 73) {
            if (data[offset + 3] < 255 && data[offset + 4] < 255) {
              if (data[offset + 6] < 128 && data[offset + 7] < 128 && data[offset + 8] < 128 && data[offset + 9] < 128) {
                return true;
              }
            }
          }
        }
        return false;
      };
      var getID3Data = function getID3Data(data, offset) {
        var front = offset;
        var length = 0;
        while (isHeader$2(data, offset)) {
          length += 10;
          var size = readSize(data, offset + 6);
          length += size;
          if (isFooter(data, offset + 10)) {
            length += 10;
          }
          offset += length;
        }
        if (length > 0) {
          return data.subarray(front, front + length);
        }
        return;
      };
      var readSize = function readSize(data, offset) {
        var size = 0;
        size = (data[offset] & 127) << 21;
        size |= (data[offset + 1] & 127) << 14;
        size |= (data[offset + 2] & 127) << 7;
        size |= data[offset + 3] & 127;
        return size;
      };
      var canParse$2 = function canParse(data, offset) {
        return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;
      };
      var getTimeStamp = function getTimeStamp(data) {
        var frames = getID3Frames(data);
        for (var i = 0;i < frames.length; i++) {
          var frame = frames[i];
          if (isTimeStampFrame(frame)) {
            return readTimeStamp(frame);
          }
        }
        return;
      };
      var isTimeStampFrame = function isTimeStampFrame(frame) {
        return frame && frame.key === "PRIV" && frame.info === "com.apple.streaming.transportStreamTimestamp";
      };
      var getFrameData = function getFrameData(data) {
        var type = String.fromCharCode(data[0], data[1], data[2], data[3]);
        var size = readSize(data, 4);
        var offset = 10;
        return {
          type,
          size,
          data: data.subarray(offset, offset + size)
        };
      };
      var getID3Frames = function getID3Frames(id3Data) {
        var offset = 0;
        var frames = [];
        while (isHeader$2(id3Data, offset)) {
          var size = readSize(id3Data, offset + 6);
          offset += 10;
          var end = offset + size;
          while (offset + 8 < end) {
            var frameData = getFrameData(id3Data.subarray(offset));
            var frame = decodeFrame(frameData);
            if (frame) {
              frames.push(frame);
            }
            offset += frameData.size + 10;
          }
          if (isFooter(id3Data, offset)) {
            offset += 10;
          }
        }
        return frames;
      };
      var decodeFrame = function decodeFrame(frame) {
        if (frame.type === "PRIV") {
          return decodePrivFrame(frame);
        } else if (frame.type[0] === "W") {
          return decodeURLFrame(frame);
        }
        return decodeTextFrame(frame);
      };
      var decodePrivFrame = function decodePrivFrame(frame) {
        if (frame.size < 2) {
          return;
        }
        var owner = utf8ArrayToStr(frame.data, true);
        var privateData = new Uint8Array(frame.data.subarray(owner.length + 1));
        return {
          key: frame.type,
          info: owner,
          data: privateData.buffer
        };
      };
      var decodeTextFrame = function decodeTextFrame(frame) {
        if (frame.size < 2) {
          return;
        }
        if (frame.type === "TXXX") {
          var index = 1;
          var description = utf8ArrayToStr(frame.data.subarray(index), true);
          index += description.length + 1;
          var value = utf8ArrayToStr(frame.data.subarray(index));
          return {
            key: frame.type,
            info: description,
            data: value
          };
        }
        var text = utf8ArrayToStr(frame.data.subarray(1));
        return {
          key: frame.type,
          data: text
        };
      };
      var decodeURLFrame = function decodeURLFrame(frame) {
        if (frame.type === "WXXX") {
          if (frame.size < 2) {
            return;
          }
          var index = 1;
          var description = utf8ArrayToStr(frame.data.subarray(index), true);
          index += description.length + 1;
          var value = utf8ArrayToStr(frame.data.subarray(index));
          return {
            key: frame.type,
            info: description,
            data: value
          };
        }
        var url2 = utf8ArrayToStr(frame.data);
        return {
          key: frame.type,
          data: url2
        };
      };
      var readTimeStamp = function readTimeStamp(timeStampFrame) {
        if (timeStampFrame.data.byteLength === 8) {
          var data = new Uint8Array(timeStampFrame.data);
          var pts33Bit = data[3] & 1;
          var timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];
          timestamp /= 45;
          if (pts33Bit) {
            timestamp += 47721858.84;
          }
          return Math.round(timestamp);
        }
        return;
      };
      var utf8ArrayToStr = function utf8ArrayToStr(array, exitOnNull) {
        if (exitOnNull === undefined) {
          exitOnNull = false;
        }
        var decoder2 = getTextDecoder();
        if (decoder2) {
          var decoded = decoder2.decode(array);
          if (exitOnNull) {
            var idx = decoded.indexOf("\x00");
            return idx !== -1 ? decoded.substring(0, idx) : decoded;
          }
          return decoded.replace(/\0/g, "");
        }
        var len = array.length;
        var c;
        var char2;
        var char3;
        var out = "";
        var i = 0;
        while (i < len) {
          c = array[i++];
          if (c === 0 && exitOnNull) {
            return out;
          } else if (c === 0 || c === 3) {
            continue;
          }
          switch (c >> 4) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
              out += String.fromCharCode(c);
              break;
            case 12:
            case 13:
              char2 = array[i++];
              out += String.fromCharCode((c & 31) << 6 | char2 & 63);
              break;
            case 14:
              char2 = array[i++];
              char3 = array[i++];
              out += String.fromCharCode((c & 15) << 12 | (char2 & 63) << 6 | (char3 & 63) << 0);
              break;
          }
        }
        return out;
      };
      var decoder;
      function getTextDecoder() {
        if (navigator.userAgent.includes("PlayStation 4")) {
          return;
        }
        if (!decoder && typeof self.TextDecoder !== "undefined") {
          decoder = new self.TextDecoder("utf-8");
        }
        return decoder;
      }
      var Hex = {
        hexDump: function hexDump(array) {
          var str = "";
          for (var i = 0;i < array.length; i++) {
            var h = array[i].toString(16);
            if (h.length < 2) {
              h = "0" + h;
            }
            str += h;
          }
          return str;
        }
      };
      var UINT32_MAX$1 = Math.pow(2, 32) - 1;
      var push = [].push;
      var RemuxerTrackIdConfig = {
        video: 1,
        audio: 2,
        id3: 3,
        text: 4
      };
      function bin2str(data) {
        return String.fromCharCode.apply(null, data);
      }
      function readUint16(buffer, offset) {
        var val = buffer[offset] << 8 | buffer[offset + 1];
        return val < 0 ? 65536 + val : val;
      }
      function readUint32(buffer, offset) {
        var val = readSint32(buffer, offset);
        return val < 0 ? 4294967296 + val : val;
      }
      function readUint64(buffer, offset) {
        var result = readUint32(buffer, offset);
        result *= Math.pow(2, 32);
        result += readUint32(buffer, offset + 4);
        return result;
      }
      function readSint32(buffer, offset) {
        return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];
      }
      function writeUint32(buffer, offset, value) {
        buffer[offset] = value >> 24;
        buffer[offset + 1] = value >> 16 & 255;
        buffer[offset + 2] = value >> 8 & 255;
        buffer[offset + 3] = value & 255;
      }
      function hasMoofData(data) {
        var end = data.byteLength;
        for (var i = 0;i < end; ) {
          var size = readUint32(data, i);
          if (size > 8 && data[i + 4] === 109 && data[i + 5] === 111 && data[i + 6] === 111 && data[i + 7] === 102) {
            return true;
          }
          i = size > 1 ? i + size : end;
        }
        return false;
      }
      function findBox(data, path) {
        var results = [];
        if (!path.length) {
          return results;
        }
        var end = data.byteLength;
        for (var i = 0;i < end; ) {
          var size = readUint32(data, i);
          var type = bin2str(data.subarray(i + 4, i + 8));
          var endbox = size > 1 ? i + size : end;
          if (type === path[0]) {
            if (path.length === 1) {
              results.push(data.subarray(i + 8, endbox));
            } else {
              var subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));
              if (subresults.length) {
                push.apply(results, subresults);
              }
            }
          }
          i = endbox;
        }
        return results;
      }
      function parseSegmentIndex(sidx) {
        var references = [];
        var version = sidx[0];
        var index = 8;
        var timescale = readUint32(sidx, index);
        index += 4;
        var earliestPresentationTime = 0;
        var firstOffset = 0;
        if (version === 0) {
          earliestPresentationTime = readUint32(sidx, index);
          firstOffset = readUint32(sidx, index + 4);
          index += 8;
        } else {
          earliestPresentationTime = readUint64(sidx, index);
          firstOffset = readUint64(sidx, index + 8);
          index += 16;
        }
        index += 2;
        var startByte = sidx.length + firstOffset;
        var referencesCount = readUint16(sidx, index);
        index += 2;
        for (var i = 0;i < referencesCount; i++) {
          var referenceIndex = index;
          var referenceInfo = readUint32(sidx, referenceIndex);
          referenceIndex += 4;
          var referenceSize = referenceInfo & 2147483647;
          var referenceType = (referenceInfo & 2147483648) >>> 31;
          if (referenceType === 1) {
            logger.warn("SIDX has hierarchical references (not supported)");
            return null;
          }
          var subsegmentDuration = readUint32(sidx, referenceIndex);
          referenceIndex += 4;
          references.push({
            referenceSize,
            subsegmentDuration,
            info: {
              duration: subsegmentDuration / timescale,
              start: startByte,
              end: startByte + referenceSize - 1
            }
          });
          startByte += referenceSize;
          referenceIndex += 4;
          index = referenceIndex;
        }
        return {
          earliestPresentationTime,
          timescale,
          version,
          referencesCount,
          references
        };
      }
      function parseInitSegment(initSegment) {
        var result = [];
        var traks = findBox(initSegment, ["moov", "trak"]);
        for (var i = 0;i < traks.length; i++) {
          var trak = traks[i];
          var tkhd = findBox(trak, ["tkhd"])[0];
          if (tkhd) {
            var version = tkhd[0];
            var trackId = readUint32(tkhd, version === 0 ? 12 : 20);
            var mdhd = findBox(trak, ["mdia", "mdhd"])[0];
            if (mdhd) {
              version = mdhd[0];
              var timescale = readUint32(mdhd, version === 0 ? 12 : 20);
              var hdlr = findBox(trak, ["mdia", "hdlr"])[0];
              if (hdlr) {
                var hdlrType = bin2str(hdlr.subarray(8, 12));
                var type = {
                  soun: ElementaryStreamTypes.AUDIO,
                  vide: ElementaryStreamTypes.VIDEO
                }[hdlrType];
                if (type) {
                  var stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
                  var stsdData = parseStsd(stsd);
                  result[trackId] = {
                    timescale,
                    type
                  };
                  result[type] = _objectSpread2({
                    timescale,
                    id: trackId
                  }, stsdData);
                }
              }
            }
          }
        }
        var trex = findBox(initSegment, ["moov", "mvex", "trex"]);
        trex.forEach(function(trex2) {
          var trackId2 = readUint32(trex2, 4);
          var track = result[trackId2];
          if (track) {
            track.default = {
              duration: readUint32(trex2, 12),
              flags: readUint32(trex2, 20)
            };
          }
        });
        return result;
      }
      function parseStsd(stsd) {
        var sampleEntries = stsd.subarray(8);
        var sampleEntriesEnd = sampleEntries.subarray(8 + 78);
        var fourCC = bin2str(sampleEntries.subarray(4, 8));
        var codec = fourCC;
        var encrypted = fourCC === "enca" || fourCC === "encv";
        if (encrypted) {
          var encBox = findBox(sampleEntries, [fourCC])[0];
          var encBoxChildren = encBox.subarray(fourCC === "enca" ? 28 : 78);
          var sinfs = findBox(encBoxChildren, ["sinf"]);
          sinfs.forEach(function(sinf) {
            var schm = findBox(sinf, ["schm"])[0];
            if (schm) {
              var scheme = bin2str(schm.subarray(4, 8));
              if (scheme === "cbcs" || scheme === "cenc") {
                var frma = findBox(sinf, ["frma"])[0];
                if (frma) {
                  codec = bin2str(frma);
                }
              }
            }
          });
        }
        switch (codec) {
          case "avc1":
          case "avc2":
          case "avc3":
          case "avc4": {
            var avcCBox = findBox(sampleEntriesEnd, ["avcC"])[0];
            codec += "." + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);
            break;
          }
          case "mp4a": {
            var codecBox = findBox(sampleEntries, [fourCC])[0];
            var esdsBox = findBox(codecBox.subarray(28), ["esds"])[0];
            if (esdsBox && esdsBox.length > 12) {
              var i = 4;
              if (esdsBox[i++] !== 3) {
                break;
              }
              i = skipBERInteger(esdsBox, i);
              i += 2;
              var flags = esdsBox[i++];
              if (flags & 128) {
                i += 2;
              }
              if (flags & 64) {
                i += esdsBox[i++];
              }
              if (esdsBox[i++] !== 4) {
                break;
              }
              i = skipBERInteger(esdsBox, i);
              var objectType = esdsBox[i++];
              if (objectType === 64) {
                codec += "." + toHex(objectType);
              } else {
                break;
              }
              i += 12;
              if (esdsBox[i++] !== 5) {
                break;
              }
              i = skipBERInteger(esdsBox, i);
              var firstByte = esdsBox[i++];
              var audioObjectType = (firstByte & 248) >> 3;
              if (audioObjectType === 31) {
                audioObjectType += 1 + ((firstByte & 7) << 3) + ((esdsBox[i] & 224) >> 5);
              }
              codec += "." + audioObjectType;
            }
            break;
          }
          case "hvc1":
          case "hev1": {
            var hvcCBox = findBox(sampleEntriesEnd, ["hvcC"])[0];
            var profileByte = hvcCBox[1];
            var profileSpace = ["", "A", "B", "C"][profileByte >> 6];
            var generalProfileIdc = profileByte & 31;
            var profileCompat = readUint32(hvcCBox, 2);
            var tierFlag = (profileByte & 32) >> 5 ? "H" : "L";
            var levelIDC = hvcCBox[12];
            var constraintIndicator = hvcCBox.subarray(6, 12);
            codec += "." + profileSpace + generalProfileIdc;
            codec += "." + profileCompat.toString(16).toUpperCase();
            codec += "." + tierFlag + levelIDC;
            var constraintString = "";
            for (var _i = constraintIndicator.length;_i--; ) {
              var _byte = constraintIndicator[_i];
              if (_byte || constraintString) {
                var encodedByte = _byte.toString(16).toUpperCase();
                constraintString = "." + encodedByte + constraintString;
              }
            }
            codec += constraintString;
            break;
          }
          case "dvh1":
          case "dvhe": {
            var dvcCBox = findBox(sampleEntriesEnd, ["dvcC"])[0];
            var profile = dvcCBox[2] >> 1 & 127;
            var level = dvcCBox[2] << 5 & 32 | dvcCBox[3] >> 3 & 31;
            codec += "." + addLeadingZero(profile) + "." + addLeadingZero(level);
            break;
          }
          case "vp09": {
            var vpcCBox = findBox(sampleEntriesEnd, ["vpcC"])[0];
            var _profile = vpcCBox[4];
            var _level = vpcCBox[5];
            var bitDepth = vpcCBox[6] >> 4 & 15;
            codec += "." + addLeadingZero(_profile) + "." + addLeadingZero(_level) + "." + addLeadingZero(bitDepth);
            break;
          }
          case "av01": {
            var av1CBox = findBox(sampleEntriesEnd, ["av1C"])[0];
            var _profile2 = av1CBox[1] >>> 5;
            var _level2 = av1CBox[1] & 31;
            var _tierFlag = av1CBox[2] >>> 7 ? "H" : "M";
            var highBitDepth = (av1CBox[2] & 64) >> 6;
            var twelveBit = (av1CBox[2] & 32) >> 5;
            var _bitDepth = _profile2 === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;
            var monochrome = (av1CBox[2] & 16) >> 4;
            var chromaSubsamplingX = (av1CBox[2] & 8) >> 3;
            var chromaSubsamplingY = (av1CBox[2] & 4) >> 2;
            var chromaSamplePosition = av1CBox[2] & 3;
            var colorPrimaries = 1;
            var transferCharacteristics = 1;
            var matrixCoefficients = 1;
            var videoFullRangeFlag = 0;
            codec += "." + _profile2 + "." + addLeadingZero(_level2) + _tierFlag + "." + addLeadingZero(_bitDepth) + "." + monochrome + "." + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + "." + addLeadingZero(colorPrimaries) + "." + addLeadingZero(transferCharacteristics) + "." + addLeadingZero(matrixCoefficients) + "." + videoFullRangeFlag;
            break;
          }
        }
        return {
          codec,
          encrypted
        };
      }
      function skipBERInteger(bytes, i) {
        var limit = i + 5;
        while (bytes[i++] & 128 && i < limit) {
        }
        return i;
      }
      function toHex(x) {
        return ("0" + x.toString(16).toUpperCase()).slice(-2);
      }
      function addLeadingZero(num) {
        return (num < 10 ? "0" : "") + num;
      }
      function patchEncyptionData(initSegment, decryptdata) {
        if (!initSegment || !decryptdata) {
          return initSegment;
        }
        var keyId = decryptdata.keyId;
        if (keyId && decryptdata.isCommonEncryption) {
          var traks = findBox(initSegment, ["moov", "trak"]);
          traks.forEach(function(trak) {
            var stsd = findBox(trak, ["mdia", "minf", "stbl", "stsd"])[0];
            var sampleEntries = stsd.subarray(8);
            var encBoxes = findBox(sampleEntries, ["enca"]);
            var isAudio = encBoxes.length > 0;
            if (!isAudio) {
              encBoxes = findBox(sampleEntries, ["encv"]);
            }
            encBoxes.forEach(function(enc) {
              var encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);
              var sinfBoxes = findBox(encBoxChildren, ["sinf"]);
              sinfBoxes.forEach(function(sinf) {
                var tenc = parseSinf(sinf);
                if (tenc) {
                  var tencKeyId = tenc.subarray(8, 24);
                  if (!tencKeyId.some(function(b) {
                    return b !== 0;
                  })) {
                    logger.log("[eme] Patching keyId in 'enc" + (isAudio ? "a" : "v") + ">sinf>>tenc' box: " + Hex.hexDump(tencKeyId) + " -> " + Hex.hexDump(keyId));
                    tenc.set(keyId, 8);
                  }
                }
              });
            });
          });
        }
        return initSegment;
      }
      function parseSinf(sinf) {
        var schm = findBox(sinf, ["schm"])[0];
        if (schm) {
          var scheme = bin2str(schm.subarray(4, 8));
          if (scheme === "cbcs" || scheme === "cenc") {
            return findBox(sinf, ["schi", "tenc"])[0];
          }
        }
        return null;
      }
      function getStartDTS(initData, fmp4) {
        return findBox(fmp4, ["moof", "traf"]).reduce(function(result, traf) {
          var tfdt = findBox(traf, ["tfdt"])[0];
          var version = tfdt[0];
          var start = findBox(traf, ["tfhd"]).reduce(function(result2, tfhd) {
            var id = readUint32(tfhd, 4);
            var track = initData[id];
            if (track) {
              var baseTime = readUint32(tfdt, 4);
              if (version === 1) {
                if (baseTime === UINT32_MAX$1) {
                  logger.warn("[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time");
                  return result2;
                }
                baseTime *= UINT32_MAX$1 + 1;
                baseTime += readUint32(tfdt, 8);
              }
              var scale = track.timescale || 90000;
              var startTime = baseTime / scale;
              if (isFiniteNumber(startTime) && (result2 === null || startTime < result2)) {
                return startTime;
              }
            }
            return result2;
          }, null);
          if (start !== null && isFiniteNumber(start) && (result === null || start < result)) {
            return start;
          }
          return result;
        }, null);
      }
      function getDuration(data, initData) {
        var rawDuration = 0;
        var videoDuration = 0;
        var audioDuration = 0;
        var trafs = findBox(data, ["moof", "traf"]);
        for (var i = 0;i < trafs.length; i++) {
          var traf = trafs[i];
          var tfhd = findBox(traf, ["tfhd"])[0];
          var id = readUint32(tfhd, 4);
          var track = initData[id];
          if (!track) {
            continue;
          }
          var trackDefault = track.default;
          var tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? undefined : trackDefault.flags);
          var sampleDuration = trackDefault == null ? undefined : trackDefault.duration;
          if (tfhdFlags & 8) {
            if (tfhdFlags & 2) {
              sampleDuration = readUint32(tfhd, 12);
            } else {
              sampleDuration = readUint32(tfhd, 8);
            }
          }
          var timescale = track.timescale || 90000;
          var truns = findBox(traf, ["trun"]);
          for (var j = 0;j < truns.length; j++) {
            rawDuration = computeRawDurationFromSamples(truns[j]);
            if (!rawDuration && sampleDuration) {
              var sampleCount = readUint32(truns[j], 4);
              rawDuration = sampleDuration * sampleCount;
            }
            if (track.type === ElementaryStreamTypes.VIDEO) {
              videoDuration += rawDuration / timescale;
            } else if (track.type === ElementaryStreamTypes.AUDIO) {
              audioDuration += rawDuration / timescale;
            }
          }
        }
        if (videoDuration === 0 && audioDuration === 0) {
          var sidxMinStart = Infinity;
          var sidxMaxEnd = 0;
          var sidxDuration = 0;
          var sidxs = findBox(data, ["sidx"]);
          for (var _i2 = 0;_i2 < sidxs.length; _i2++) {
            var sidx = parseSegmentIndex(sidxs[_i2]);
            if (sidx != null && sidx.references) {
              sidxMinStart = Math.min(sidxMinStart, sidx.earliestPresentationTime / sidx.timescale);
              var subSegmentDuration = sidx.references.reduce(function(dur, ref) {
                return dur + ref.info.duration || 0;
              }, 0);
              sidxMaxEnd = Math.max(sidxMaxEnd, subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale);
              sidxDuration = sidxMaxEnd - sidxMinStart;
            }
          }
          if (sidxDuration && isFiniteNumber(sidxDuration)) {
            return sidxDuration;
          }
        }
        if (videoDuration) {
          return videoDuration;
        }
        return audioDuration;
      }
      function computeRawDurationFromSamples(trun) {
        var flags = readUint32(trun, 0);
        var offset = 8;
        if (flags & 1) {
          offset += 4;
        }
        if (flags & 4) {
          offset += 4;
        }
        var duration = 0;
        var sampleCount = readUint32(trun, 4);
        for (var i = 0;i < sampleCount; i++) {
          if (flags & 256) {
            var sampleDuration = readUint32(trun, offset);
            duration += sampleDuration;
            offset += 4;
          }
          if (flags & 512) {
            offset += 4;
          }
          if (flags & 1024) {
            offset += 4;
          }
          if (flags & 2048) {
            offset += 4;
          }
        }
        return duration;
      }
      function offsetStartDTS(initData, fmp4, timeOffset) {
        findBox(fmp4, ["moof", "traf"]).forEach(function(traf) {
          findBox(traf, ["tfhd"]).forEach(function(tfhd) {
            var id = readUint32(tfhd, 4);
            var track = initData[id];
            if (!track) {
              return;
            }
            var timescale = track.timescale || 90000;
            findBox(traf, ["tfdt"]).forEach(function(tfdt) {
              var version = tfdt[0];
              var offset = timeOffset * timescale;
              if (offset) {
                var baseMediaDecodeTime = readUint32(tfdt, 4);
                if (version === 0) {
                  baseMediaDecodeTime -= offset;
                  baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
                  writeUint32(tfdt, 4, baseMediaDecodeTime);
                } else {
                  baseMediaDecodeTime *= Math.pow(2, 32);
                  baseMediaDecodeTime += readUint32(tfdt, 8);
                  baseMediaDecodeTime -= offset;
                  baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);
                  var upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));
                  var lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));
                  writeUint32(tfdt, 4, upper);
                  writeUint32(tfdt, 8, lower);
                }
              }
            });
          });
        });
      }
      function segmentValidRange(data) {
        var segmentedRange = {
          valid: null,
          remainder: null
        };
        var moofs = findBox(data, ["moof"]);
        if (moofs.length < 2) {
          segmentedRange.remainder = data;
          return segmentedRange;
        }
        var last = moofs[moofs.length - 1];
        segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);
        segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);
        return segmentedRange;
      }
      function appendUint8Array(data1, data2) {
        var temp = new Uint8Array(data1.length + data2.length);
        temp.set(data1);
        temp.set(data2, data1.length);
        return temp;
      }
      function parseSamples(timeOffset, track) {
        var seiSamples = [];
        var videoData = track.samples;
        var timescale = track.timescale;
        var trackId = track.id;
        var isHEVCFlavor = false;
        var moofs = findBox(videoData, ["moof"]);
        moofs.map(function(moof) {
          var moofOffset = moof.byteOffset - 8;
          var trafs = findBox(moof, ["traf"]);
          trafs.map(function(traf) {
            var baseTime = findBox(traf, ["tfdt"]).map(function(tfdt) {
              var version = tfdt[0];
              var result = readUint32(tfdt, 4);
              if (version === 1) {
                result *= Math.pow(2, 32);
                result += readUint32(tfdt, 8);
              }
              return result / timescale;
            })[0];
            if (baseTime !== undefined) {
              timeOffset = baseTime;
            }
            return findBox(traf, ["tfhd"]).map(function(tfhd) {
              var id = readUint32(tfhd, 4);
              var tfhdFlags = readUint32(tfhd, 0) & 16777215;
              var baseDataOffsetPresent = (tfhdFlags & 1) !== 0;
              var sampleDescriptionIndexPresent = (tfhdFlags & 2) !== 0;
              var defaultSampleDurationPresent = (tfhdFlags & 8) !== 0;
              var defaultSampleDuration = 0;
              var defaultSampleSizePresent = (tfhdFlags & 16) !== 0;
              var defaultSampleSize = 0;
              var defaultSampleFlagsPresent = (tfhdFlags & 32) !== 0;
              var tfhdOffset = 8;
              if (id === trackId) {
                if (baseDataOffsetPresent) {
                  tfhdOffset += 8;
                }
                if (sampleDescriptionIndexPresent) {
                  tfhdOffset += 4;
                }
                if (defaultSampleDurationPresent) {
                  defaultSampleDuration = readUint32(tfhd, tfhdOffset);
                  tfhdOffset += 4;
                }
                if (defaultSampleSizePresent) {
                  defaultSampleSize = readUint32(tfhd, tfhdOffset);
                  tfhdOffset += 4;
                }
                if (defaultSampleFlagsPresent) {
                  tfhdOffset += 4;
                }
                if (track.type === "video") {
                  isHEVCFlavor = isHEVC(track.codec);
                }
                findBox(traf, ["trun"]).map(function(trun) {
                  var version = trun[0];
                  var flags = readUint32(trun, 0) & 16777215;
                  var dataOffsetPresent = (flags & 1) !== 0;
                  var dataOffset = 0;
                  var firstSampleFlagsPresent = (flags & 4) !== 0;
                  var sampleDurationPresent = (flags & 256) !== 0;
                  var sampleDuration = 0;
                  var sampleSizePresent = (flags & 512) !== 0;
                  var sampleSize = 0;
                  var sampleFlagsPresent = (flags & 1024) !== 0;
                  var sampleCompositionOffsetsPresent = (flags & 2048) !== 0;
                  var compositionOffset = 0;
                  var sampleCount = readUint32(trun, 4);
                  var trunOffset = 8;
                  if (dataOffsetPresent) {
                    dataOffset = readUint32(trun, trunOffset);
                    trunOffset += 4;
                  }
                  if (firstSampleFlagsPresent) {
                    trunOffset += 4;
                  }
                  var sampleOffset = dataOffset + moofOffset;
                  for (var ix = 0;ix < sampleCount; ix++) {
                    if (sampleDurationPresent) {
                      sampleDuration = readUint32(trun, trunOffset);
                      trunOffset += 4;
                    } else {
                      sampleDuration = defaultSampleDuration;
                    }
                    if (sampleSizePresent) {
                      sampleSize = readUint32(trun, trunOffset);
                      trunOffset += 4;
                    } else {
                      sampleSize = defaultSampleSize;
                    }
                    if (sampleFlagsPresent) {
                      trunOffset += 4;
                    }
                    if (sampleCompositionOffsetsPresent) {
                      if (version === 0) {
                        compositionOffset = readUint32(trun, trunOffset);
                      } else {
                        compositionOffset = readSint32(trun, trunOffset);
                      }
                      trunOffset += 4;
                    }
                    if (track.type === ElementaryStreamTypes.VIDEO) {
                      var naluTotalSize = 0;
                      while (naluTotalSize < sampleSize) {
                        var naluSize = readUint32(videoData, sampleOffset);
                        sampleOffset += 4;
                        if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {
                          var data = videoData.subarray(sampleOffset, sampleOffset + naluSize);
                          parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);
                        }
                        sampleOffset += naluSize;
                        naluTotalSize += naluSize + 4;
                      }
                    }
                    timeOffset += sampleDuration / timescale;
                  }
                });
              }
            });
          });
        });
        return seiSamples;
      }
      function isHEVC(codec) {
        if (!codec) {
          return false;
        }
        var delimit = codec.indexOf(".");
        var baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);
        return baseCodec === "hvc1" || baseCodec === "hev1" || baseCodec === "dvh1" || baseCodec === "dvhe";
      }
      function isSEIMessage(isHEVCFlavor, naluHeader) {
        if (isHEVCFlavor) {
          var naluType = naluHeader >> 1 & 63;
          return naluType === 39 || naluType === 40;
        } else {
          var _naluType = naluHeader & 31;
          return _naluType === 6;
        }
      }
      function parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {
        var data = discardEPB(unescapedData);
        var seiPtr = 0;
        seiPtr += headerSize;
        var payloadType = 0;
        var payloadSize = 0;
        var b = 0;
        while (seiPtr < data.length) {
          payloadType = 0;
          do {
            if (seiPtr >= data.length) {
              break;
            }
            b = data[seiPtr++];
            payloadType += b;
          } while (b === 255);
          payloadSize = 0;
          do {
            if (seiPtr >= data.length) {
              break;
            }
            b = data[seiPtr++];
            payloadSize += b;
          } while (b === 255);
          var leftOver = data.length - seiPtr;
          var payPtr = seiPtr;
          if (payloadSize < leftOver) {
            seiPtr += payloadSize;
          } else if (payloadSize > leftOver) {
            logger.error("Malformed SEI payload. " + payloadSize + " is too small, only " + leftOver + " bytes left to parse.");
            break;
          }
          if (payloadType === 4) {
            var countryCode = data[payPtr++];
            if (countryCode === 181) {
              var providerCode = readUint16(data, payPtr);
              payPtr += 2;
              if (providerCode === 49) {
                var userStructure = readUint32(data, payPtr);
                payPtr += 4;
                if (userStructure === 1195456820) {
                  var userDataType = data[payPtr++];
                  if (userDataType === 3) {
                    var firstByte = data[payPtr++];
                    var totalCCs = 31 & firstByte;
                    var enabled = 64 & firstByte;
                    var totalBytes = enabled ? 2 + totalCCs * 3 : 0;
                    var byteArray = new Uint8Array(totalBytes);
                    if (enabled) {
                      byteArray[0] = firstByte;
                      for (var i = 1;i < totalBytes; i++) {
                        byteArray[i] = data[payPtr++];
                      }
                    }
                    samples.push({
                      type: userDataType,
                      payloadType,
                      pts,
                      bytes: byteArray
                    });
                  }
                }
              }
            }
          } else if (payloadType === 5) {
            if (payloadSize > 16) {
              var uuidStrArray = [];
              for (var _i3 = 0;_i3 < 16; _i3++) {
                var _b = data[payPtr++].toString(16);
                uuidStrArray.push(_b.length == 1 ? "0" + _b : _b);
                if (_i3 === 3 || _i3 === 5 || _i3 === 7 || _i3 === 9) {
                  uuidStrArray.push("-");
                }
              }
              var length = payloadSize - 16;
              var userDataBytes = new Uint8Array(length);
              for (var _i4 = 0;_i4 < length; _i4++) {
                userDataBytes[_i4] = data[payPtr++];
              }
              samples.push({
                payloadType,
                pts,
                uuid: uuidStrArray.join(""),
                userData: utf8ArrayToStr(userDataBytes),
                userDataBytes
              });
            }
          }
        }
      }
      function discardEPB(data) {
        var length = data.byteLength;
        var EPBPositions = [];
        var i = 1;
        while (i < length - 2) {
          if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
            EPBPositions.push(i + 2);
            i += 2;
          } else {
            i++;
          }
        }
        if (EPBPositions.length === 0) {
          return data;
        }
        var newLength = length - EPBPositions.length;
        var newData = new Uint8Array(newLength);
        var sourceIndex = 0;
        for (i = 0;i < newLength; sourceIndex++, i++) {
          if (sourceIndex === EPBPositions[0]) {
            sourceIndex++;
            EPBPositions.shift();
          }
          newData[i] = data[sourceIndex];
        }
        return newData;
      }
      function parseEmsg(data) {
        var version = data[0];
        var schemeIdUri = "";
        var value = "";
        var timeScale = 0;
        var presentationTimeDelta = 0;
        var presentationTime = 0;
        var eventDuration = 0;
        var id = 0;
        var offset = 0;
        if (version === 0) {
          while (bin2str(data.subarray(offset, offset + 1)) !== "\x00") {
            schemeIdUri += bin2str(data.subarray(offset, offset + 1));
            offset += 1;
          }
          schemeIdUri += bin2str(data.subarray(offset, offset + 1));
          offset += 1;
          while (bin2str(data.subarray(offset, offset + 1)) !== "\x00") {
            value += bin2str(data.subarray(offset, offset + 1));
            offset += 1;
          }
          value += bin2str(data.subarray(offset, offset + 1));
          offset += 1;
          timeScale = readUint32(data, 12);
          presentationTimeDelta = readUint32(data, 16);
          eventDuration = readUint32(data, 20);
          id = readUint32(data, 24);
          offset = 28;
        } else if (version === 1) {
          offset += 4;
          timeScale = readUint32(data, offset);
          offset += 4;
          var leftPresentationTime = readUint32(data, offset);
          offset += 4;
          var rightPresentationTime = readUint32(data, offset);
          offset += 4;
          presentationTime = Math.pow(2, 32) * leftPresentationTime + rightPresentationTime;
          if (!isSafeInteger(presentationTime)) {
            presentationTime = Number.MAX_SAFE_INTEGER;
            logger.warn("Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box");
          }
          eventDuration = readUint32(data, offset);
          offset += 4;
          id = readUint32(data, offset);
          offset += 4;
          while (bin2str(data.subarray(offset, offset + 1)) !== "\x00") {
            schemeIdUri += bin2str(data.subarray(offset, offset + 1));
            offset += 1;
          }
          schemeIdUri += bin2str(data.subarray(offset, offset + 1));
          offset += 1;
          while (bin2str(data.subarray(offset, offset + 1)) !== "\x00") {
            value += bin2str(data.subarray(offset, offset + 1));
            offset += 1;
          }
          value += bin2str(data.subarray(offset, offset + 1));
          offset += 1;
        }
        var payload = data.subarray(offset, data.byteLength);
        return {
          schemeIdUri,
          value,
          timeScale,
          presentationTime,
          presentationTimeDelta,
          eventDuration,
          id,
          payload
        };
      }
      function mp4Box(type) {
        for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
          payload[_key - 1] = arguments[_key];
        }
        var len = payload.length;
        var size = 8;
        var i = len;
        while (i--) {
          size += payload[i].byteLength;
        }
        var result = new Uint8Array(size);
        result[0] = size >> 24 & 255;
        result[1] = size >> 16 & 255;
        result[2] = size >> 8 & 255;
        result[3] = size & 255;
        result.set(type, 4);
        for (i = 0, size = 8;i < len; i++) {
          result.set(payload[i], size);
          size += payload[i].byteLength;
        }
        return result;
      }
      function mp4pssh(systemId, keyids, data) {
        if (systemId.byteLength !== 16) {
          throw new RangeError("Invalid system id");
        }
        var version;
        var kids;
        if (keyids) {
          version = 1;
          kids = new Uint8Array(keyids.length * 16);
          for (var ix = 0;ix < keyids.length; ix++) {
            var k = keyids[ix];
            if (k.byteLength !== 16) {
              throw new RangeError("Invalid key");
            }
            kids.set(k, ix * 16);
          }
        } else {
          version = 0;
          kids = new Uint8Array;
        }
        var kidCount;
        if (version > 0) {
          kidCount = new Uint8Array(4);
          if (keyids.length > 0) {
            new DataView(kidCount.buffer).setUint32(0, keyids.length, false);
          }
        } else {
          kidCount = new Uint8Array;
        }
        var dataSize = new Uint8Array(4);
        if (data && data.byteLength > 0) {
          new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);
        }
        return mp4Box([112, 115, 115, 104], new Uint8Array([
          version,
          0,
          0,
          0
        ]), systemId, kidCount, kids, dataSize, data || new Uint8Array);
      }
      function parseMultiPssh(initData) {
        var results = [];
        if (initData instanceof ArrayBuffer) {
          var length = initData.byteLength;
          var offset = 0;
          while (offset + 32 < length) {
            var view = new DataView(initData, offset);
            var pssh = parsePssh(view);
            results.push(pssh);
            offset += pssh.size;
          }
        }
        return results;
      }
      function parsePssh(view) {
        var size = view.getUint32(0);
        var offset = view.byteOffset;
        var length = view.byteLength;
        if (length < size) {
          return {
            offset,
            size: length
          };
        }
        var type = view.getUint32(4);
        if (type !== 1886614376) {
          return {
            offset,
            size
          };
        }
        var version = view.getUint32(8) >>> 24;
        if (version !== 0 && version !== 1) {
          return {
            offset,
            size
          };
        }
        var buffer = view.buffer;
        var systemId = Hex.hexDump(new Uint8Array(buffer, offset + 12, 16));
        var dataSizeOrKidCount = view.getUint32(28);
        var kids = null;
        var data = null;
        if (version === 0) {
          if (size - 32 < dataSizeOrKidCount || dataSizeOrKidCount < 22) {
            return {
              offset,
              size
            };
          }
          data = new Uint8Array(buffer, offset + 32, dataSizeOrKidCount);
        } else if (version === 1) {
          if (!dataSizeOrKidCount || length < offset + 32 + dataSizeOrKidCount * 16 + 16) {
            return {
              offset,
              size
            };
          }
          kids = [];
          for (var i = 0;i < dataSizeOrKidCount; i++) {
            kids.push(new Uint8Array(buffer, offset + 32 + i * 16, 16));
          }
        }
        return {
          version,
          systemId,
          kids,
          data,
          offset,
          size
        };
      }
      var keyUriToKeyIdMap = {};
      var LevelKey = /* @__PURE__ */ function() {
        LevelKey2.clearKeyUriToKeyIdMap = function clearKeyUriToKeyIdMap() {
          keyUriToKeyIdMap = {};
        };
        function LevelKey2(method, uri, format2, formatversions, iv) {
          if (formatversions === undefined) {
            formatversions = [1];
          }
          if (iv === undefined) {
            iv = null;
          }
          this.uri = undefined;
          this.method = undefined;
          this.keyFormat = undefined;
          this.keyFormatVersions = undefined;
          this.encrypted = undefined;
          this.isCommonEncryption = undefined;
          this.iv = null;
          this.key = null;
          this.keyId = null;
          this.pssh = null;
          this.method = method;
          this.uri = uri;
          this.keyFormat = format2;
          this.keyFormatVersions = formatversions;
          this.iv = iv;
          this.encrypted = method ? method !== "NONE" : false;
          this.isCommonEncryption = this.encrypted && method !== "AES-128";
        }
        var _proto = LevelKey2.prototype;
        _proto.isSupported = function isSupported() {
          if (this.method) {
            if (this.method === "AES-128" || this.method === "NONE") {
              return true;
            }
            if (this.keyFormat === "identity") {
              return this.method === "SAMPLE-AES";
            } else {
              switch (this.keyFormat) {
                case KeySystemFormats.FAIRPLAY:
                case KeySystemFormats.WIDEVINE:
                case KeySystemFormats.PLAYREADY:
                case KeySystemFormats.CLEARKEY:
                  return ["ISO-23001-7", "SAMPLE-AES", "SAMPLE-AES-CENC", "SAMPLE-AES-CTR"].indexOf(this.method) !== -1;
              }
            }
          }
          return false;
        };
        _proto.getDecryptData = function getDecryptData(sn) {
          if (!this.encrypted || !this.uri) {
            return null;
          }
          if (this.method === "AES-128" && this.uri && !this.iv) {
            if (typeof sn !== "number") {
              if (this.method === "AES-128" && !this.iv) {
                logger.warn('missing IV for initialization segment with method="' + this.method + '" - compliance issue');
              }
              sn = 0;
            }
            var iv = createInitializationVector(sn);
            var decryptdata = new LevelKey2(this.method, this.uri, "identity", this.keyFormatVersions, iv);
            return decryptdata;
          }
          var keyBytes = convertDataUriToArrayBytes(this.uri);
          if (keyBytes) {
            switch (this.keyFormat) {
              case KeySystemFormats.WIDEVINE:
                this.pssh = keyBytes;
                if (keyBytes.length >= 22) {
                  this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);
                }
                break;
              case KeySystemFormats.PLAYREADY: {
                var PlayReadyKeySystemUUID = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
                this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);
                var keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);
                var keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));
                var xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf("<"), keyByteStr.length);
                var parser = new DOMParser;
                var xmlDoc = parser.parseFromString(xmlKeyBytes, "text/xml");
                var keyData = xmlDoc.getElementsByTagName("KID")[0];
                if (keyData) {
                  var keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute("VALUE");
                  if (keyId) {
                    var keyIdArray = base64Decode(keyId).subarray(0, 16);
                    changeEndianness(keyIdArray);
                    this.keyId = keyIdArray;
                  }
                }
                break;
              }
              default: {
                var keydata = keyBytes.subarray(0, 16);
                if (keydata.length !== 16) {
                  var padded = new Uint8Array(16);
                  padded.set(keydata, 16 - keydata.length);
                  keydata = padded;
                }
                this.keyId = keydata;
                break;
              }
            }
          }
          if (!this.keyId || this.keyId.byteLength !== 16) {
            var _keyId = keyUriToKeyIdMap[this.uri];
            if (!_keyId) {
              var val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;
              _keyId = new Uint8Array(16);
              var dv = new DataView(_keyId.buffer, 12, 4);
              dv.setUint32(0, val);
              keyUriToKeyIdMap[this.uri] = _keyId;
            }
            this.keyId = _keyId;
          }
          return this;
        };
        return LevelKey2;
      }();
      function createInitializationVector(segmentNumber) {
        var uint8View = new Uint8Array(16);
        for (var i = 12;i < 16; i++) {
          uint8View[i] = segmentNumber >> 8 * (15 - i) & 255;
        }
        return uint8View;
      }
      var VARIABLE_REPLACEMENT_REGEX = /\{\$([a-zA-Z0-9-_]+)\}/g;
      function hasVariableReferences(str) {
        return VARIABLE_REPLACEMENT_REGEX.test(str);
      }
      function substituteVariablesInAttributes(parsed, attr, attributeNames) {
        if (parsed.variableList !== null || parsed.hasVariableRefs) {
          for (var i = attributeNames.length;i--; ) {
            var name = attributeNames[i];
            var value = attr[name];
            if (value) {
              attr[name] = substituteVariables(parsed, value);
            }
          }
        }
      }
      function substituteVariables(parsed, value) {
        if (parsed.variableList !== null || parsed.hasVariableRefs) {
          var variableList = parsed.variableList;
          return value.replace(VARIABLE_REPLACEMENT_REGEX, function(variableReference) {
            var variableName = variableReference.substring(2, variableReference.length - 1);
            var variableValue = variableList == null ? undefined : variableList[variableName];
            if (variableValue === undefined) {
              parsed.playlistParsingError || (parsed.playlistParsingError = new Error('Missing preceding EXT-X-DEFINE tag for Variable Reference: "' + variableName + '"'));
              return variableReference;
            }
            return variableValue;
          });
        }
        return value;
      }
      function addVariableDefinition(parsed, attr, parentUrl) {
        var variableList = parsed.variableList;
        if (!variableList) {
          parsed.variableList = variableList = {};
        }
        var NAME;
        var VALUE;
        if ("QUERYPARAM" in attr) {
          NAME = attr.QUERYPARAM;
          try {
            var searchParams = new self.URL(parentUrl).searchParams;
            if (searchParams.has(NAME)) {
              VALUE = searchParams.get(NAME);
            } else {
              throw new Error('"' + NAME + '" does not match any query parameter in URI: "' + parentUrl + '"');
            }
          } catch (error2) {
            parsed.playlistParsingError || (parsed.playlistParsingError = new Error("EXT-X-DEFINE QUERYPARAM: " + error2.message));
          }
        } else {
          NAME = attr.NAME;
          VALUE = attr.VALUE;
        }
        if (NAME in variableList) {
          parsed.playlistParsingError || (parsed.playlistParsingError = new Error('EXT-X-DEFINE duplicate Variable Name declarations: "' + NAME + '"'));
        } else {
          variableList[NAME] = VALUE || "";
        }
      }
      function importVariableDefinition(parsed, attr, sourceVariableList) {
        var IMPORT = attr.IMPORT;
        if (sourceVariableList && IMPORT in sourceVariableList) {
          var variableList = parsed.variableList;
          if (!variableList) {
            parsed.variableList = variableList = {};
          }
          variableList[IMPORT] = sourceVariableList[IMPORT];
        } else {
          parsed.playlistParsingError || (parsed.playlistParsingError = new Error('EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: "' + IMPORT + '"'));
        }
      }
      function getMediaSource(preferManagedMediaSource) {
        if (preferManagedMediaSource === undefined) {
          preferManagedMediaSource = true;
        }
        if (typeof self === "undefined")
          return;
        var mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;
        return mms || self.MediaSource || self.WebKitMediaSource;
      }
      function isManagedMediaSource(source) {
        return typeof self !== "undefined" && source === self.ManagedMediaSource;
      }
      var sampleEntryCodesISO = {
        audio: {
          a3ds: 1,
          "ac-3": 0.95,
          "ac-4": 1,
          alac: 0.9,
          alaw: 1,
          dra1: 1,
          "dts+": 1,
          "dts-": 1,
          dtsc: 1,
          dtse: 1,
          dtsh: 1,
          "ec-3": 0.9,
          enca: 1,
          fLaC: 0.9,
          flac: 0.9,
          FLAC: 0.9,
          g719: 1,
          g726: 1,
          m4ae: 1,
          mha1: 1,
          mha2: 1,
          mhm1: 1,
          mhm2: 1,
          mlpa: 1,
          mp4a: 1,
          "raw ": 1,
          Opus: 1,
          opus: 1,
          samr: 1,
          sawb: 1,
          sawp: 1,
          sevc: 1,
          sqcp: 1,
          ssmv: 1,
          twos: 1,
          ulaw: 1
        },
        video: {
          avc1: 1,
          avc2: 1,
          avc3: 1,
          avc4: 1,
          avcp: 1,
          av01: 0.8,
          drac: 1,
          dva1: 1,
          dvav: 1,
          dvh1: 0.7,
          dvhe: 0.7,
          encv: 1,
          hev1: 0.75,
          hvc1: 0.75,
          mjp2: 1,
          mp4v: 1,
          mvc1: 1,
          mvc2: 1,
          mvc3: 1,
          mvc4: 1,
          resv: 1,
          rv60: 1,
          s263: 1,
          svc1: 1,
          svc2: 1,
          "vc-1": 1,
          vp08: 1,
          vp09: 0.9
        },
        text: {
          stpp: 1,
          wvtt: 1
        }
      };
      function isCodecType(codec, type) {
        var typeCodes = sampleEntryCodesISO[type];
        return !!typeCodes && !!typeCodes[codec.slice(0, 4)];
      }
      function areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource) {
        if (preferManagedMediaSource === undefined) {
          preferManagedMediaSource = true;
        }
        return !codecs.split(",").some(function(codec) {
          return !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource);
        });
      }
      function isCodecMediaSourceSupported(codec, type, preferManagedMediaSource) {
        var _MediaSource$isTypeSu;
        if (preferManagedMediaSource === undefined) {
          preferManagedMediaSource = true;
        }
        var MediaSource = getMediaSource(preferManagedMediaSource);
        return (_MediaSource$isTypeSu = MediaSource == null ? undefined : MediaSource.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;
      }
      function mimeTypeForCodec(codec, type) {
        return type + '/mp4;codecs="' + codec + '"';
      }
      function videoCodecPreferenceValue(videoCodec) {
        if (videoCodec) {
          var fourCC = videoCodec.substring(0, 4);
          return sampleEntryCodesISO.video[fourCC];
        }
        return 2;
      }
      function codecsSetSelectionPreferenceValue(codecSet) {
        return codecSet.split(",").reduce(function(num, fourCC) {
          var preferenceValue = sampleEntryCodesISO.video[fourCC];
          if (preferenceValue) {
            return (preferenceValue * 2 + num) / (num ? 3 : 2);
          }
          return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);
        }, 0);
      }
      var CODEC_COMPATIBLE_NAMES = {};
      function getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource) {
        if (preferManagedMediaSource === undefined) {
          preferManagedMediaSource = true;
        }
        if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {
          return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];
        }
        var codecsToCheck = {
          flac: ["flac", "fLaC", "FLAC"],
          opus: ["opus", "Opus"]
        }[lowerCaseCodec];
        for (var i = 0;i < codecsToCheck.length; i++) {
          if (isCodecMediaSourceSupported(codecsToCheck[i], "audio", preferManagedMediaSource)) {
            CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];
            return codecsToCheck[i];
          }
        }
        return lowerCaseCodec;
      }
      var AUDIO_CODEC_REGEXP = /flac|opus/i;
      function getCodecCompatibleName(codec, preferManagedMediaSource) {
        if (preferManagedMediaSource === undefined) {
          preferManagedMediaSource = true;
        }
        return codec.replace(AUDIO_CODEC_REGEXP, function(m) {
          return getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource);
        });
      }
      function pickMostCompleteCodecName(parsedCodec, levelCodec) {
        if (parsedCodec && parsedCodec !== "mp4a") {
          return parsedCodec;
        }
        return levelCodec ? levelCodec.split(",")[0] : levelCodec;
      }
      function convertAVC1ToAVCOTI(codec) {
        var codecs = codec.split(",");
        for (var i = 0;i < codecs.length; i++) {
          var avcdata = codecs[i].split(".");
          if (avcdata.length > 2) {
            var result = avcdata.shift() + ".";
            result += parseInt(avcdata.shift()).toString(16);
            result += ("000" + parseInt(avcdata.shift()).toString(16)).slice(-4);
            codecs[i] = result;
          }
        }
        return codecs.join(",");
      }
      var MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\r\n]*)(?:[\r\n](?:#[^\r\n]*)?)*([^\r\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\r\n]*)[\r\n]+/g;
      var MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;
      var IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m;
      var LEVEL_PLAYLIST_REGEX_FAST = new RegExp([
        /#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source,
        /(?!#) *(\S[^\r\n]*)/.source,
        /#EXT-X-BYTERANGE:*(.+)/.source,
        /#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,
        /#.*/.source
      ].join("|"), "g");
      var LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\r?\n?/.source].join("|"));
      var M3U8Parser = /* @__PURE__ */ function() {
        function M3U8Parser2() {
        }
        M3U8Parser2.findGroup = function findGroup(groups, mediaGroupId) {
          for (var i = 0;i < groups.length; i++) {
            var group = groups[i];
            if (group.id === mediaGroupId) {
              return group;
            }
          }
        };
        M3U8Parser2.resolve = function resolve(url2, baseUrl) {
          return urlToolkitExports.buildAbsoluteURL(baseUrl, url2, {
            alwaysNormalize: true
          });
        };
        M3U8Parser2.isMediaPlaylist = function isMediaPlaylist(str) {
          return IS_MEDIA_PLAYLIST.test(str);
        };
        M3U8Parser2.parseMasterPlaylist = function parseMasterPlaylist(string, baseurl) {
          var hasVariableRefs = hasVariableReferences(string);
          var parsed = {
            contentSteering: null,
            levels: [],
            playlistParsingError: null,
            sessionData: null,
            sessionKeys: null,
            startTimeOffset: null,
            variableList: null,
            hasVariableRefs
          };
          var levelsWithKnownCodecs = [];
          MASTER_PLAYLIST_REGEX.lastIndex = 0;
          var result;
          while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {
            if (result[1]) {
              var _level$unknownCodecs;
              var attrs = new AttrList(result[1]);
              {
                substituteVariablesInAttributes(parsed, attrs, ["CODECS", "SUPPLEMENTAL-CODECS", "ALLOWED-CPC", "PATHWAY-ID", "STABLE-VARIANT-ID", "AUDIO", "VIDEO", "SUBTITLES", "CLOSED-CAPTIONS", "NAME"]);
              }
              var uri = substituteVariables(parsed, result[2]);
              var level = {
                attrs,
                bitrate: attrs.decimalInteger("BANDWIDTH") || attrs.decimalInteger("AVERAGE-BANDWIDTH"),
                name: attrs.NAME,
                url: M3U8Parser2.resolve(uri, baseurl)
              };
              var resolution = attrs.decimalResolution("RESOLUTION");
              if (resolution) {
                level.width = resolution.width;
                level.height = resolution.height;
              }
              setCodecs(attrs.CODECS, level);
              if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {
                levelsWithKnownCodecs.push(level);
              }
              parsed.levels.push(level);
            } else if (result[3]) {
              var tag = result[3];
              var attributes = result[4];
              switch (tag) {
                case "SESSION-DATA": {
                  var sessionAttrs = new AttrList(attributes);
                  {
                    substituteVariablesInAttributes(parsed, sessionAttrs, ["DATA-ID", "LANGUAGE", "VALUE", "URI"]);
                  }
                  var dataId = sessionAttrs["DATA-ID"];
                  if (dataId) {
                    if (parsed.sessionData === null) {
                      parsed.sessionData = {};
                    }
                    parsed.sessionData[dataId] = sessionAttrs;
                  }
                  break;
                }
                case "SESSION-KEY": {
                  var sessionKey = parseKey(attributes, baseurl, parsed);
                  if (sessionKey.encrypted && sessionKey.isSupported()) {
                    if (parsed.sessionKeys === null) {
                      parsed.sessionKeys = [];
                    }
                    parsed.sessionKeys.push(sessionKey);
                  } else {
                    logger.warn('[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: "' + attributes + '"');
                  }
                  break;
                }
                case "DEFINE": {
                  {
                    var variableAttributes = new AttrList(attributes);
                    substituteVariablesInAttributes(parsed, variableAttributes, ["NAME", "VALUE", "QUERYPARAM"]);
                    addVariableDefinition(parsed, variableAttributes, baseurl);
                  }
                  break;
                }
                case "CONTENT-STEERING": {
                  var contentSteeringAttributes = new AttrList(attributes);
                  {
                    substituteVariablesInAttributes(parsed, contentSteeringAttributes, ["SERVER-URI", "PATHWAY-ID"]);
                  }
                  parsed.contentSteering = {
                    uri: M3U8Parser2.resolve(contentSteeringAttributes["SERVER-URI"], baseurl),
                    pathwayId: contentSteeringAttributes["PATHWAY-ID"] || "."
                  };
                  break;
                }
                case "START": {
                  parsed.startTimeOffset = parseStartTimeOffset(attributes);
                  break;
                }
              }
            }
          }
          var stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;
          parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;
          if (parsed.levels.length === 0) {
            parsed.playlistParsingError = new Error("no levels found in manifest");
          }
          return parsed;
        };
        M3U8Parser2.parseMasterPlaylistMedia = function parseMasterPlaylistMedia(string, baseurl, parsed) {
          var result;
          var results = {};
          var levels = parsed.levels;
          var groupsByType = {
            AUDIO: levels.map(function(level) {
              return {
                id: level.attrs.AUDIO,
                audioCodec: level.audioCodec
              };
            }),
            SUBTITLES: levels.map(function(level) {
              return {
                id: level.attrs.SUBTITLES,
                textCodec: level.textCodec
              };
            }),
            "CLOSED-CAPTIONS": []
          };
          var id = 0;
          MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;
          while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {
            var attrs = new AttrList(result[1]);
            var type = attrs.TYPE;
            if (type) {
              var groups = groupsByType[type];
              var medias = results[type] || [];
              results[type] = medias;
              {
                substituteVariablesInAttributes(parsed, attrs, ["URI", "GROUP-ID", "LANGUAGE", "ASSOC-LANGUAGE", "STABLE-RENDITION-ID", "NAME", "INSTREAM-ID", "CHARACTERISTICS", "CHANNELS"]);
              }
              var lang = attrs.LANGUAGE;
              var assocLang = attrs["ASSOC-LANGUAGE"];
              var channels = attrs.CHANNELS;
              var characteristics = attrs.CHARACTERISTICS;
              var instreamId = attrs["INSTREAM-ID"];
              var media = {
                attrs,
                bitrate: 0,
                id: id++,
                groupId: attrs["GROUP-ID"] || "",
                name: attrs.NAME || lang || "",
                type,
                default: attrs.bool("DEFAULT"),
                autoselect: attrs.bool("AUTOSELECT"),
                forced: attrs.bool("FORCED"),
                lang,
                url: attrs.URI ? M3U8Parser2.resolve(attrs.URI, baseurl) : ""
              };
              if (assocLang) {
                media.assocLang = assocLang;
              }
              if (channels) {
                media.channels = channels;
              }
              if (characteristics) {
                media.characteristics = characteristics;
              }
              if (instreamId) {
                media.instreamId = instreamId;
              }
              if (groups != null && groups.length) {
                var groupCodec = M3U8Parser2.findGroup(groups, media.groupId) || groups[0];
                assignCodec(media, groupCodec, "audioCodec");
                assignCodec(media, groupCodec, "textCodec");
              }
              medias.push(media);
            }
          }
          return results;
        };
        M3U8Parser2.parseLevelPlaylist = function parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {
          var level = new LevelDetails(baseurl);
          var fragments = level.fragments;
          var currentInitSegment = null;
          var currentSN = 0;
          var currentPart = 0;
          var totalduration = 0;
          var discontinuityCounter = 0;
          var prevFrag = null;
          var frag = new Fragment(type, baseurl);
          var result;
          var i;
          var levelkeys;
          var firstPdtIndex = -1;
          var createNextFrag = false;
          var nextByteRange = null;
          LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;
          level.m3u8 = string;
          level.hasVariableRefs = hasVariableReferences(string);
          while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {
            if (createNextFrag) {
              createNextFrag = false;
              frag = new Fragment(type, baseurl);
              frag.start = totalduration;
              frag.sn = currentSN;
              frag.cc = discontinuityCounter;
              frag.level = id;
              if (currentInitSegment) {
                frag.initSegment = currentInitSegment;
                frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
                currentInitSegment.rawProgramDateTime = null;
                if (nextByteRange) {
                  frag.setByteRange(nextByteRange);
                  nextByteRange = null;
                }
              }
            }
            var duration = result[1];
            if (duration) {
              frag.duration = parseFloat(duration);
              var title = (" " + result[2]).slice(1);
              frag.title = title || null;
              frag.tagList.push(title ? ["INF", duration, title] : ["INF", duration]);
            } else if (result[3]) {
              if (isFiniteNumber(frag.duration)) {
                frag.start = totalduration;
                if (levelkeys) {
                  setFragLevelKeys(frag, levelkeys, level);
                }
                frag.sn = currentSN;
                frag.level = id;
                frag.cc = discontinuityCounter;
                fragments.push(frag);
                var uri = (" " + result[3]).slice(1);
                frag.relurl = substituteVariables(level, uri);
                assignProgramDateTime(frag, prevFrag);
                prevFrag = frag;
                totalduration += frag.duration;
                currentSN++;
                currentPart = 0;
                createNextFrag = true;
              }
            } else if (result[4]) {
              var data = (" " + result[4]).slice(1);
              if (prevFrag) {
                frag.setByteRange(data, prevFrag);
              } else {
                frag.setByteRange(data);
              }
            } else if (result[5]) {
              frag.rawProgramDateTime = (" " + result[5]).slice(1);
              frag.tagList.push(["PROGRAM-DATE-TIME", frag.rawProgramDateTime]);
              if (firstPdtIndex === -1) {
                firstPdtIndex = fragments.length;
              }
            } else {
              result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);
              if (!result) {
                logger.warn("No matches on slow regex match for level playlist!");
                continue;
              }
              for (i = 1;i < result.length; i++) {
                if (typeof result[i] !== "undefined") {
                  break;
                }
              }
              var tag = (" " + result[i]).slice(1);
              var value1 = (" " + result[i + 1]).slice(1);
              var value2 = result[i + 2] ? (" " + result[i + 2]).slice(1) : "";
              switch (tag) {
                case "PLAYLIST-TYPE":
                  level.type = value1.toUpperCase();
                  break;
                case "MEDIA-SEQUENCE":
                  currentSN = level.startSN = parseInt(value1);
                  break;
                case "SKIP": {
                  var skipAttrs = new AttrList(value1);
                  {
                    substituteVariablesInAttributes(level, skipAttrs, ["RECENTLY-REMOVED-DATERANGES"]);
                  }
                  var skippedSegments = skipAttrs.decimalInteger("SKIPPED-SEGMENTS");
                  if (isFiniteNumber(skippedSegments)) {
                    level.skippedSegments = skippedSegments;
                    for (var _i = skippedSegments;_i--; ) {
                      fragments.unshift(null);
                    }
                    currentSN += skippedSegments;
                  }
                  var recentlyRemovedDateranges = skipAttrs.enumeratedString("RECENTLY-REMOVED-DATERANGES");
                  if (recentlyRemovedDateranges) {
                    level.recentlyRemovedDateranges = recentlyRemovedDateranges.split("\t");
                  }
                  break;
                }
                case "TARGETDURATION":
                  level.targetduration = Math.max(parseInt(value1), 1);
                  break;
                case "VERSION":
                  level.version = parseInt(value1);
                  break;
                case "INDEPENDENT-SEGMENTS":
                case "EXTM3U":
                  break;
                case "ENDLIST":
                  level.live = false;
                  break;
                case "#":
                  if (value1 || value2) {
                    frag.tagList.push(value2 ? [value1, value2] : [value1]);
                  }
                  break;
                case "DISCONTINUITY":
                  discontinuityCounter++;
                  frag.tagList.push(["DIS"]);
                  break;
                case "GAP":
                  frag.gap = true;
                  frag.tagList.push([tag]);
                  break;
                case "BITRATE":
                  frag.tagList.push([tag, value1]);
                  break;
                case "DATERANGE": {
                  var dateRangeAttr = new AttrList(value1);
                  {
                    substituteVariablesInAttributes(level, dateRangeAttr, ["ID", "CLASS", "START-DATE", "END-DATE", "SCTE35-CMD", "SCTE35-OUT", "SCTE35-IN"]);
                    substituteVariablesInAttributes(level, dateRangeAttr, dateRangeAttr.clientAttrs);
                  }
                  var dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);
                  if (dateRange.isValid || level.skippedSegments) {
                    level.dateRanges[dateRange.id] = dateRange;
                  } else {
                    logger.warn('Ignoring invalid DATERANGE tag: "' + value1 + '"');
                  }
                  frag.tagList.push(["EXT-X-DATERANGE", value1]);
                  break;
                }
                case "DEFINE": {
                  {
                    var variableAttributes = new AttrList(value1);
                    substituteVariablesInAttributes(level, variableAttributes, ["NAME", "VALUE", "IMPORT", "QUERYPARAM"]);
                    if ("IMPORT" in variableAttributes) {
                      importVariableDefinition(level, variableAttributes, multivariantVariableList);
                    } else {
                      addVariableDefinition(level, variableAttributes, baseurl);
                    }
                  }
                  break;
                }
                case "DISCONTINUITY-SEQUENCE":
                  discontinuityCounter = parseInt(value1);
                  break;
                case "KEY": {
                  var levelKey = parseKey(value1, baseurl, level);
                  if (levelKey.isSupported()) {
                    if (levelKey.method === "NONE") {
                      levelkeys = undefined;
                      break;
                    }
                    if (!levelkeys) {
                      levelkeys = {};
                    }
                    if (levelkeys[levelKey.keyFormat]) {
                      levelkeys = _extends({}, levelkeys);
                    }
                    levelkeys[levelKey.keyFormat] = levelKey;
                  } else {
                    logger.warn('[Keys] Ignoring invalid EXT-X-KEY tag: "' + value1 + '"');
                  }
                  break;
                }
                case "START":
                  level.startTimeOffset = parseStartTimeOffset(value1);
                  break;
                case "MAP": {
                  var mapAttrs = new AttrList(value1);
                  {
                    substituteVariablesInAttributes(level, mapAttrs, ["BYTERANGE", "URI"]);
                  }
                  if (frag.duration) {
                    var init = new Fragment(type, baseurl);
                    setInitSegment(init, mapAttrs, id, levelkeys);
                    currentInitSegment = init;
                    frag.initSegment = currentInitSegment;
                    if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {
                      frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;
                    }
                  } else {
                    var end = frag.byteRangeEndOffset;
                    if (end) {
                      var start = frag.byteRangeStartOffset;
                      nextByteRange = end - start + "@" + start;
                    } else {
                      nextByteRange = null;
                    }
                    setInitSegment(frag, mapAttrs, id, levelkeys);
                    currentInitSegment = frag;
                    createNextFrag = true;
                  }
                  break;
                }
                case "SERVER-CONTROL": {
                  var serverControlAttrs = new AttrList(value1);
                  level.canBlockReload = serverControlAttrs.bool("CAN-BLOCK-RELOAD");
                  level.canSkipUntil = serverControlAttrs.optionalFloat("CAN-SKIP-UNTIL", 0);
                  level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool("CAN-SKIP-DATERANGES");
                  level.partHoldBack = serverControlAttrs.optionalFloat("PART-HOLD-BACK", 0);
                  level.holdBack = serverControlAttrs.optionalFloat("HOLD-BACK", 0);
                  break;
                }
                case "PART-INF": {
                  var partInfAttrs = new AttrList(value1);
                  level.partTarget = partInfAttrs.decimalFloatingPoint("PART-TARGET");
                  break;
                }
                case "PART": {
                  var partList = level.partList;
                  if (!partList) {
                    partList = level.partList = [];
                  }
                  var previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;
                  var index = currentPart++;
                  var partAttrs = new AttrList(value1);
                  {
                    substituteVariablesInAttributes(level, partAttrs, ["BYTERANGE", "URI"]);
                  }
                  var part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);
                  partList.push(part);
                  frag.duration += part.duration;
                  break;
                }
                case "PRELOAD-HINT": {
                  var preloadHintAttrs = new AttrList(value1);
                  {
                    substituteVariablesInAttributes(level, preloadHintAttrs, ["URI"]);
                  }
                  level.preloadHint = preloadHintAttrs;
                  break;
                }
                case "RENDITION-REPORT": {
                  var renditionReportAttrs = new AttrList(value1);
                  {
                    substituteVariablesInAttributes(level, renditionReportAttrs, ["URI"]);
                  }
                  level.renditionReports = level.renditionReports || [];
                  level.renditionReports.push(renditionReportAttrs);
                  break;
                }
                default:
                  logger.warn("line parsed but not handled: " + result);
                  break;
              }
            }
          }
          if (prevFrag && !prevFrag.relurl) {
            fragments.pop();
            totalduration -= prevFrag.duration;
            if (level.partList) {
              level.fragmentHint = prevFrag;
            }
          } else if (level.partList) {
            assignProgramDateTime(frag, prevFrag);
            frag.cc = discontinuityCounter;
            level.fragmentHint = frag;
            if (levelkeys) {
              setFragLevelKeys(frag, levelkeys, level);
            }
          }
          var fragmentLength = fragments.length;
          var firstFragment = fragments[0];
          var lastFragment = fragments[fragmentLength - 1];
          totalduration += level.skippedSegments * level.targetduration;
          if (totalduration > 0 && fragmentLength && lastFragment) {
            level.averagetargetduration = totalduration / fragmentLength;
            var lastSn = lastFragment.sn;
            level.endSN = lastSn !== "initSegment" ? lastSn : 0;
            if (!level.live) {
              lastFragment.endList = true;
            }
            if (firstFragment) {
              level.startCC = firstFragment.cc;
            }
          } else {
            level.endSN = 0;
            level.startCC = 0;
          }
          if (level.fragmentHint) {
            totalduration += level.fragmentHint.duration;
          }
          level.totalduration = totalduration;
          level.endCC = discontinuityCounter;
          if (firstPdtIndex > 0) {
            backfillProgramDateTimes(fragments, firstPdtIndex);
          }
          return level;
        };
        return M3U8Parser2;
      }();
      function parseKey(keyTagAttributes, baseurl, parsed) {
        var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;
        var keyAttrs = new AttrList(keyTagAttributes);
        {
          substituteVariablesInAttributes(parsed, keyAttrs, ["KEYFORMAT", "KEYFORMATVERSIONS", "URI", "IV", "URI"]);
        }
        var decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : "";
        var decrypturi = keyAttrs.URI;
        var decryptiv = keyAttrs.hexadecimalInteger("IV");
        var decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;
        var decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : "identity";
        if (decrypturi && keyAttrs.IV && !decryptiv) {
          logger.error("Invalid IV: " + keyAttrs.IV);
        }
        var resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : "";
        var keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : "1").split("/").map(Number).filter(Number.isFinite);
        return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);
      }
      function parseStartTimeOffset(startAttributes) {
        var startAttrs = new AttrList(startAttributes);
        var startTimeOffset = startAttrs.decimalFloatingPoint("TIME-OFFSET");
        if (isFiniteNumber(startTimeOffset)) {
          return startTimeOffset;
        }
        return null;
      }
      function setCodecs(codecsAttributeValue, level) {
        var codecs = (codecsAttributeValue || "").split(/[ ,]+/).filter(function(c) {
          return c;
        });
        ["video", "audio", "text"].forEach(function(type) {
          var filtered = codecs.filter(function(codec) {
            return isCodecType(codec, type);
          });
          if (filtered.length) {
            level[type + "Codec"] = filtered.join(",");
            codecs = codecs.filter(function(codec) {
              return filtered.indexOf(codec) === -1;
            });
          }
        });
        level.unknownCodecs = codecs;
      }
      function assignCodec(media, groupItem, codecProperty) {
        var codecValue = groupItem[codecProperty];
        if (codecValue) {
          media[codecProperty] = codecValue;
        }
      }
      function backfillProgramDateTimes(fragments, firstPdtIndex) {
        var fragPrev = fragments[firstPdtIndex];
        for (var i = firstPdtIndex;i--; ) {
          var frag = fragments[i];
          if (!frag) {
            return;
          }
          frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;
          fragPrev = frag;
        }
      }
      function assignProgramDateTime(frag, prevFrag) {
        if (frag.rawProgramDateTime) {
          frag.programDateTime = Date.parse(frag.rawProgramDateTime);
        } else if (prevFrag != null && prevFrag.programDateTime) {
          frag.programDateTime = prevFrag.endProgramDateTime;
        }
        if (!isFiniteNumber(frag.programDateTime)) {
          frag.programDateTime = null;
          frag.rawProgramDateTime = null;
        }
      }
      function setInitSegment(frag, mapAttrs, id, levelkeys) {
        frag.relurl = mapAttrs.URI;
        if (mapAttrs.BYTERANGE) {
          frag.setByteRange(mapAttrs.BYTERANGE);
        }
        frag.level = id;
        frag.sn = "initSegment";
        if (levelkeys) {
          frag.levelkeys = levelkeys;
        }
        frag.initSegment = null;
      }
      function setFragLevelKeys(frag, levelkeys, level) {
        frag.levelkeys = levelkeys;
        var encryptedFragments = level.encryptedFragments;
        if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(function(format2) {
          return levelkeys[format2].isCommonEncryption;
        })) {
          encryptedFragments.push(frag);
        }
      }
      var PlaylistContextType = {
        MANIFEST: "manifest",
        LEVEL: "level",
        AUDIO_TRACK: "audioTrack",
        SUBTITLE_TRACK: "subtitleTrack"
      };
      var PlaylistLevelType = {
        MAIN: "main",
        AUDIO: "audio",
        SUBTITLE: "subtitle"
      };
      function mapContextToLevelType(context) {
        var type = context.type;
        switch (type) {
          case PlaylistContextType.AUDIO_TRACK:
            return PlaylistLevelType.AUDIO;
          case PlaylistContextType.SUBTITLE_TRACK:
            return PlaylistLevelType.SUBTITLE;
          default:
            return PlaylistLevelType.MAIN;
        }
      }
      function getResponseUrl(response, context) {
        var url2 = response.url;
        if (url2 === undefined || url2.indexOf("data:") === 0) {
          url2 = context.url;
        }
        return url2;
      }
      var PlaylistLoader = /* @__PURE__ */ function() {
        function PlaylistLoader2(hls) {
          this.hls = undefined;
          this.loaders = Object.create(null);
          this.variableList = null;
          this.hls = hls;
          this.registerListeners();
        }
        var _proto = PlaylistLoader2.prototype;
        _proto.startLoad = function startLoad(startPosition) {
        };
        _proto.stopLoad = function stopLoad() {
          this.destroyInternalLoaders();
        };
        _proto.registerListeners = function registerListeners() {
          var hls = this.hls;
          hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
          hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
          hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
        };
        _proto.unregisterListeners = function unregisterListeners() {
          var hls = this.hls;
          hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
          hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);
          hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);
        };
        _proto.createInternalLoader = function createInternalLoader(context) {
          var config = this.hls.config;
          var PLoader = config.pLoader;
          var Loader = config.loader;
          var InternalLoader = PLoader || Loader;
          var loader = new InternalLoader(config);
          this.loaders[context.type] = loader;
          return loader;
        };
        _proto.getInternalLoader = function getInternalLoader(context) {
          return this.loaders[context.type];
        };
        _proto.resetInternalLoader = function resetInternalLoader(contextType) {
          if (this.loaders[contextType]) {
            delete this.loaders[contextType];
          }
        };
        _proto.destroyInternalLoaders = function destroyInternalLoaders() {
          for (var contextType in this.loaders) {
            var loader = this.loaders[contextType];
            if (loader) {
              loader.destroy();
            }
            this.resetInternalLoader(contextType);
          }
        };
        _proto.destroy = function destroy() {
          this.variableList = null;
          this.unregisterListeners();
          this.destroyInternalLoaders();
        };
        _proto.onManifestLoading = function onManifestLoading(event, data) {
          var url2 = data.url;
          this.variableList = null;
          this.load({
            id: null,
            level: 0,
            responseType: "text",
            type: PlaylistContextType.MANIFEST,
            url: url2,
            deliveryDirectives: null
          });
        };
        _proto.onLevelLoading = function onLevelLoading(event, data) {
          var { id, level, pathwayId, url: url2, deliveryDirectives } = data;
          this.load({
            id,
            level,
            pathwayId,
            responseType: "text",
            type: PlaylistContextType.LEVEL,
            url: url2,
            deliveryDirectives
          });
        };
        _proto.onAudioTrackLoading = function onAudioTrackLoading(event, data) {
          var { id, groupId, url: url2, deliveryDirectives } = data;
          this.load({
            id,
            groupId,
            level: null,
            responseType: "text",
            type: PlaylistContextType.AUDIO_TRACK,
            url: url2,
            deliveryDirectives
          });
        };
        _proto.onSubtitleTrackLoading = function onSubtitleTrackLoading(event, data) {
          var { id, groupId, url: url2, deliveryDirectives } = data;
          this.load({
            id,
            groupId,
            level: null,
            responseType: "text",
            type: PlaylistContextType.SUBTITLE_TRACK,
            url: url2,
            deliveryDirectives
          });
        };
        _proto.load = function load(context) {
          var _context$deliveryDire, _this = this;
          var config = this.hls.config;
          var loader = this.getInternalLoader(context);
          if (loader) {
            var loaderContext = loader.context;
            if (loaderContext && loaderContext.url === context.url && loaderContext.level === context.level) {
              logger.trace("[playlist-loader]: playlist request ongoing");
              return;
            }
            logger.log("[playlist-loader]: aborting previous loader for type: " + context.type);
            loader.abort();
          }
          var loadPolicy;
          if (context.type === PlaylistContextType.MANIFEST) {
            loadPolicy = config.manifestLoadPolicy.default;
          } else {
            loadPolicy = _extends({}, config.playlistLoadPolicy.default, {
              timeoutRetry: null,
              errorRetry: null
            });
          }
          loader = this.createInternalLoader(context);
          if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? undefined : _context$deliveryDire.part)) {
            var levelDetails;
            if (context.type === PlaylistContextType.LEVEL && context.level !== null) {
              levelDetails = this.hls.levels[context.level].details;
            } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {
              levelDetails = this.hls.audioTracks[context.id].details;
            } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {
              levelDetails = this.hls.subtitleTracks[context.id].details;
            }
            if (levelDetails) {
              var partTarget = levelDetails.partTarget;
              var targetDuration = levelDetails.targetduration;
              if (partTarget && targetDuration) {
                var maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;
                loadPolicy = _extends({}, loadPolicy, {
                  maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),
                  maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)
                });
              }
            }
          }
          var legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
          var loaderConfig = {
            loadPolicy,
            timeout: loadPolicy.maxLoadTimeMs,
            maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
            retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
            maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
          };
          var loaderCallbacks = {
            onSuccess: function onSuccess(response, stats, context2, networkDetails) {
              var loader2 = _this.getInternalLoader(context2);
              _this.resetInternalLoader(context2.type);
              var string = response.data;
              if (string.indexOf("#EXTM3U") !== 0) {
                _this.handleManifestParsingError(response, context2, new Error("no EXTM3U delimiter"), networkDetails || null, stats);
                return;
              }
              stats.parsing.start = performance.now();
              if (M3U8Parser.isMediaPlaylist(string)) {
                _this.handleTrackOrLevelPlaylist(response, stats, context2, networkDetails || null, loader2);
              } else {
                _this.handleMasterPlaylist(response, stats, context2, networkDetails);
              }
            },
            onError: function onError(response, context2, networkDetails, stats) {
              _this.handleNetworkError(context2, networkDetails, false, response, stats);
            },
            onTimeout: function onTimeout(stats, context2, networkDetails) {
              _this.handleNetworkError(context2, networkDetails, true, undefined, stats);
            }
          };
          loader.load(context, loaderConfig, loaderCallbacks);
        };
        _proto.handleMasterPlaylist = function handleMasterPlaylist(response, stats, context, networkDetails) {
          var hls = this.hls;
          var string = response.data;
          var url2 = getResponseUrl(response, context);
          var parsedResult = M3U8Parser.parseMasterPlaylist(string, url2);
          if (parsedResult.playlistParsingError) {
            this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);
            return;
          }
          var { contentSteering, levels, sessionData, sessionKeys, startTimeOffset, variableList } = parsedResult;
          this.variableList = variableList;
          var _M3U8Parser$parseMast = M3U8Parser.parseMasterPlaylistMedia(string, url2, parsedResult), _M3U8Parser$parseMast2 = _M3U8Parser$parseMast.AUDIO, audioTracks = _M3U8Parser$parseMast2 === undefined ? [] : _M3U8Parser$parseMast2, subtitles = _M3U8Parser$parseMast.SUBTITLES, captions = _M3U8Parser$parseMast["CLOSED-CAPTIONS"];
          if (audioTracks.length) {
            var embeddedAudioFound = audioTracks.some(function(audioTrack) {
              return !audioTrack.url;
            });
            if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {
              logger.log("[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one");
              audioTracks.unshift({
                type: "main",
                name: "main",
                groupId: "main",
                default: false,
                autoselect: false,
                forced: false,
                id: -1,
                attrs: new AttrList({}),
                bitrate: 0,
                url: ""
              });
            }
          }
          hls.trigger(Events.MANIFEST_LOADED, {
            levels,
            audioTracks,
            subtitles,
            captions,
            contentSteering,
            url: url2,
            stats,
            networkDetails,
            sessionData,
            sessionKeys,
            startTimeOffset,
            variableList
          });
        };
        _proto.handleTrackOrLevelPlaylist = function handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {
          var hls = this.hls;
          var { id, level, type } = context;
          var url2 = getResponseUrl(response, context);
          var levelUrlId = 0;
          var levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;
          var levelType = mapContextToLevelType(context);
          var levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url2, levelId, levelType, levelUrlId, this.variableList);
          if (type === PlaylistContextType.MANIFEST) {
            var singleLevel = {
              attrs: new AttrList({}),
              bitrate: 0,
              details: levelDetails,
              name: "",
              url: url2
            };
            hls.trigger(Events.MANIFEST_LOADED, {
              levels: [singleLevel],
              audioTracks: [],
              url: url2,
              stats,
              networkDetails,
              sessionData: null,
              sessionKeys: null,
              contentSteering: null,
              startTimeOffset: null,
              variableList: null
            });
          }
          stats.parsing.end = performance.now();
          context.levelDetails = levelDetails;
          this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);
        };
        _proto.handleManifestParsingError = function handleManifestParsingError(response, context, error2, networkDetails, stats) {
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes2.NETWORK_ERROR,
            details: ErrorDetails.MANIFEST_PARSING_ERROR,
            fatal: context.type === PlaylistContextType.MANIFEST,
            url: response.url,
            err: error2,
            error: error2,
            reason: error2.message,
            response,
            context,
            networkDetails,
            stats
          });
        };
        _proto.handleNetworkError = function handleNetworkError(context, networkDetails, timeout, response, stats) {
          if (timeout === undefined) {
            timeout = false;
          }
          var message = "A network " + (timeout ? "timeout" : "error" + (response ? " (status " + response.code + ")" : "")) + " occurred while loading " + context.type;
          if (context.type === PlaylistContextType.LEVEL) {
            message += ": " + context.level + " id: " + context.id;
          } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {
            message += " id: " + context.id + ' group-id: "' + context.groupId + '"';
          }
          var error2 = new Error(message);
          logger.warn("[playlist-loader]: " + message);
          var details = ErrorDetails.UNKNOWN;
          var fatal = false;
          var loader = this.getInternalLoader(context);
          switch (context.type) {
            case PlaylistContextType.MANIFEST:
              details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;
              fatal = true;
              break;
            case PlaylistContextType.LEVEL:
              details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;
              fatal = false;
              break;
            case PlaylistContextType.AUDIO_TRACK:
              details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;
              fatal = false;
              break;
            case PlaylistContextType.SUBTITLE_TRACK:
              details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;
              fatal = false;
              break;
          }
          if (loader) {
            this.resetInternalLoader(context.type);
          }
          var errorData = {
            type: ErrorTypes2.NETWORK_ERROR,
            details,
            fatal,
            url: context.url,
            loader,
            context,
            error: error2,
            networkDetails,
            stats
          };
          if (response) {
            var url2 = (networkDetails == null ? undefined : networkDetails.url) || context.url;
            errorData.response = _objectSpread2({
              url: url2,
              data: undefined
            }, response);
          }
          this.hls.trigger(Events.ERROR, errorData);
        };
        _proto.handlePlaylistLoaded = function handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {
          var hls = this.hls;
          var { type, level, id, groupId, deliveryDirectives } = context;
          var url2 = getResponseUrl(response, context);
          var parent = mapContextToLevelType(context);
          var levelIndex = typeof context.level === "number" && parent === PlaylistLevelType.MAIN ? level : undefined;
          if (!levelDetails.fragments.length) {
            var _error = new Error("No Segments found in Playlist");
            hls.trigger(Events.ERROR, {
              type: ErrorTypes2.NETWORK_ERROR,
              details: ErrorDetails.LEVEL_EMPTY_ERROR,
              fatal: false,
              url: url2,
              error: _error,
              reason: _error.message,
              response,
              context,
              level: levelIndex,
              parent,
              networkDetails,
              stats
            });
            return;
          }
          if (!levelDetails.targetduration) {
            levelDetails.playlistParsingError = new Error("Missing Target Duration");
          }
          var error2 = levelDetails.playlistParsingError;
          if (error2) {
            hls.trigger(Events.ERROR, {
              type: ErrorTypes2.NETWORK_ERROR,
              details: ErrorDetails.LEVEL_PARSING_ERROR,
              fatal: false,
              url: url2,
              error: error2,
              reason: error2.message,
              response,
              context,
              level: levelIndex,
              parent,
              networkDetails,
              stats
            });
            return;
          }
          if (levelDetails.live && loader) {
            if (loader.getCacheAge) {
              levelDetails.ageHeader = loader.getCacheAge() || 0;
            }
            if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {
              levelDetails.ageHeader = 0;
            }
          }
          switch (type) {
            case PlaylistContextType.MANIFEST:
            case PlaylistContextType.LEVEL:
              hls.trigger(Events.LEVEL_LOADED, {
                details: levelDetails,
                level: levelIndex || 0,
                id: id || 0,
                stats,
                networkDetails,
                deliveryDirectives
              });
              break;
            case PlaylistContextType.AUDIO_TRACK:
              hls.trigger(Events.AUDIO_TRACK_LOADED, {
                details: levelDetails,
                id: id || 0,
                groupId: groupId || "",
                stats,
                networkDetails,
                deliveryDirectives
              });
              break;
            case PlaylistContextType.SUBTITLE_TRACK:
              hls.trigger(Events.SUBTITLE_TRACK_LOADED, {
                details: levelDetails,
                id: id || 0,
                groupId: groupId || "",
                stats,
                networkDetails,
                deliveryDirectives
              });
              break;
          }
        };
        return PlaylistLoader2;
      }();
      function sendAddTrackEvent(track, videoEl) {
        var event;
        try {
          event = new Event("addtrack");
        } catch (err) {
          event = document.createEvent("Event");
          event.initEvent("addtrack", false, false);
        }
        event.track = track;
        videoEl.dispatchEvent(event);
      }
      function addCueToTrack(track, cue) {
        var mode = track.mode;
        if (mode === "disabled") {
          track.mode = "hidden";
        }
        if (track.cues && !track.cues.getCueById(cue.id)) {
          try {
            track.addCue(cue);
            if (!track.cues.getCueById(cue.id)) {
              throw new Error("addCue is failed for: " + cue);
            }
          } catch (err) {
            logger.debug("[texttrack-utils]: " + err);
            try {
              var textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);
              textTrackCue.id = cue.id;
              track.addCue(textTrackCue);
            } catch (err2) {
              logger.debug("[texttrack-utils]: Legacy TextTrackCue fallback failed: " + err2);
            }
          }
        }
        if (mode === "disabled") {
          track.mode = mode;
        }
      }
      function clearCurrentCues(track) {
        var mode = track.mode;
        if (mode === "disabled") {
          track.mode = "hidden";
        }
        if (track.cues) {
          for (var i = track.cues.length;i--; ) {
            track.removeCue(track.cues[i]);
          }
        }
        if (mode === "disabled") {
          track.mode = mode;
        }
      }
      function removeCuesInRange(track, start, end, predicate) {
        var mode = track.mode;
        if (mode === "disabled") {
          track.mode = "hidden";
        }
        if (track.cues && track.cues.length > 0) {
          var cues = getCuesInRange(track.cues, start, end);
          for (var i = 0;i < cues.length; i++) {
            if (!predicate || predicate(cues[i])) {
              track.removeCue(cues[i]);
            }
          }
        }
        if (mode === "disabled") {
          track.mode = mode;
        }
      }
      function getFirstCueIndexAfterTime(cues, time) {
        if (time < cues[0].startTime) {
          return 0;
        }
        var len = cues.length - 1;
        if (time > cues[len].endTime) {
          return -1;
        }
        var left = 0;
        var right = len;
        while (left <= right) {
          var mid = Math.floor((right + left) / 2);
          if (time < cues[mid].startTime) {
            right = mid - 1;
          } else if (time > cues[mid].startTime && left < len) {
            left = mid + 1;
          } else {
            return mid;
          }
        }
        return cues[left].startTime - time < time - cues[right].startTime ? left : right;
      }
      function getCuesInRange(cues, start, end) {
        var cuesFound = [];
        var firstCueInRange = getFirstCueIndexAfterTime(cues, start);
        if (firstCueInRange > -1) {
          for (var i = firstCueInRange, len = cues.length;i < len; i++) {
            var _cue = cues[i];
            if (_cue.startTime >= start && _cue.endTime <= end) {
              cuesFound.push(_cue);
            } else if (_cue.startTime > end) {
              return cuesFound;
            }
          }
        }
        return cuesFound;
      }
      function filterSubtitleTracks(textTrackList) {
        var tracks = [];
        for (var i = 0;i < textTrackList.length; i++) {
          var track = textTrackList[i];
          if ((track.kind === "subtitles" || track.kind === "captions") && track.label) {
            tracks.push(textTrackList[i]);
          }
        }
        return tracks;
      }
      var MetadataSchema = {
        audioId3: "org.id3",
        dateRange: "com.apple.quicktime.HLS",
        emsg: "https://aomedia.org/emsg/ID3"
      };
      var MIN_CUE_DURATION = 0.25;
      function getCueClass() {
        if (typeof self === "undefined")
          return;
        return self.VTTCue || self.TextTrackCue;
      }
      function createCueWithDataFields(Cue, startTime, endTime, data, type) {
        var cue = new Cue(startTime, endTime, "");
        try {
          cue.value = data;
          if (type) {
            cue.type = type;
          }
        } catch (e) {
          cue = new Cue(startTime, endTime, JSON.stringify(type ? _objectSpread2({
            type
          }, data) : data));
        }
        return cue;
      }
      var MAX_CUE_ENDTIME = function() {
        var Cue = getCueClass();
        try {
          Cue && new Cue(0, Number.POSITIVE_INFINITY, "");
        } catch (e) {
          return Number.MAX_VALUE;
        }
        return Number.POSITIVE_INFINITY;
      }();
      function dateRangeDateToTimelineSeconds(date, offset) {
        return date.getTime() / 1000 - offset;
      }
      function hexToArrayBuffer(str) {
        return Uint8Array.from(str.replace(/^0x/, "").replace(/([\da-fA-F]{2}) ?/g, "0x$1 ").replace(/ +$/, "").split(" ")).buffer;
      }
      var ID3TrackController = /* @__PURE__ */ function() {
        function ID3TrackController2(hls) {
          this.hls = undefined;
          this.id3Track = null;
          this.media = null;
          this.dateRangeCuesAppended = {};
          this.hls = hls;
          this._registerListeners();
        }
        var _proto = ID3TrackController2.prototype;
        _proto.destroy = function destroy() {
          this._unregisterListeners();
          this.id3Track = null;
          this.media = null;
          this.dateRangeCuesAppended = {};
          this.hls = null;
        };
        _proto._registerListeners = function _registerListeners() {
          var hls = this.hls;
          hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
          hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
          hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
        };
        _proto._unregisterListeners = function _unregisterListeners() {
          var hls = this.hls;
          hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);
          hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
          hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
        };
        _proto.onMediaAttached = function onMediaAttached(event, data) {
          this.media = data.media;
        };
        _proto.onMediaDetaching = function onMediaDetaching() {
          if (!this.id3Track) {
            return;
          }
          clearCurrentCues(this.id3Track);
          this.id3Track = null;
          this.media = null;
          this.dateRangeCuesAppended = {};
        };
        _proto.onManifestLoading = function onManifestLoading() {
          this.dateRangeCuesAppended = {};
        };
        _proto.createTrack = function createTrack(media) {
          var track = this.getID3Track(media.textTracks);
          track.mode = "hidden";
          return track;
        };
        _proto.getID3Track = function getID3Track(textTracks) {
          if (!this.media) {
            return;
          }
          for (var i = 0;i < textTracks.length; i++) {
            var textTrack = textTracks[i];
            if (textTrack.kind === "metadata" && textTrack.label === "id3") {
              sendAddTrackEvent(textTrack, this.media);
              return textTrack;
            }
          }
          return this.media.addTextTrack("metadata", "id3");
        };
        _proto.onFragParsingMetadata = function onFragParsingMetadata(event, data) {
          if (!this.media) {
            return;
          }
          var _this$hls$config = this.hls.config, enableEmsgMetadataCues = _this$hls$config.enableEmsgMetadataCues, enableID3MetadataCues = _this$hls$config.enableID3MetadataCues;
          if (!enableEmsgMetadataCues && !enableID3MetadataCues) {
            return;
          }
          var samples = data.samples;
          if (!this.id3Track) {
            this.id3Track = this.createTrack(this.media);
          }
          var Cue = getCueClass();
          if (!Cue) {
            return;
          }
          for (var i = 0;i < samples.length; i++) {
            var type = samples[i].type;
            if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {
              continue;
            }
            var frames = getID3Frames(samples[i].data);
            if (frames) {
              var startTime = samples[i].pts;
              var endTime = startTime + samples[i].duration;
              if (endTime > MAX_CUE_ENDTIME) {
                endTime = MAX_CUE_ENDTIME;
              }
              var timeDiff = endTime - startTime;
              if (timeDiff <= 0) {
                endTime = startTime + MIN_CUE_DURATION;
              }
              for (var j = 0;j < frames.length; j++) {
                var frame = frames[j];
                if (!isTimeStampFrame(frame)) {
                  this.updateId3CueEnds(startTime, type);
                  var cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);
                  if (cue) {
                    this.id3Track.addCue(cue);
                  }
                }
              }
            }
          }
        };
        _proto.updateId3CueEnds = function updateId3CueEnds(startTime, type) {
          var _this$id3Track;
          var cues = (_this$id3Track = this.id3Track) == null ? undefined : _this$id3Track.cues;
          if (cues) {
            for (var i = cues.length;i--; ) {
              var cue = cues[i];
              if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {
                cue.endTime = startTime;
              }
            }
          }
        };
        _proto.onBufferFlushing = function onBufferFlushing(event, _ref) {
          var { startOffset, endOffset, type } = _ref;
          var id3Track = this.id3Track, hls = this.hls;
          if (!hls) {
            return;
          }
          var _hls$config = hls.config, enableEmsgMetadataCues = _hls$config.enableEmsgMetadataCues, enableID3MetadataCues = _hls$config.enableID3MetadataCues;
          if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {
            var predicate;
            if (type === "audio") {
              predicate = function predicate(cue) {
                return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;
              };
            } else if (type === "video") {
              predicate = function predicate(cue) {
                return cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
              };
            } else {
              predicate = function predicate(cue) {
                return cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;
              };
            }
            removeCuesInRange(id3Track, startOffset, endOffset, predicate);
          }
        };
        _proto.onLevelUpdated = function onLevelUpdated(event, _ref2) {
          var _this = this;
          var details = _ref2.details;
          if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {
            return;
          }
          var dateRangeCuesAppended = this.dateRangeCuesAppended, id3Track = this.id3Track;
          var dateRanges = details.dateRanges;
          var ids = Object.keys(dateRanges);
          if (id3Track) {
            var idsToRemove = Object.keys(dateRangeCuesAppended).filter(function(id) {
              return !ids.includes(id);
            });
            var _loop = function _loop() {
              var id = idsToRemove[i];
              Object.keys(dateRangeCuesAppended[id].cues).forEach(function(key) {
                id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);
              });
              delete dateRangeCuesAppended[id];
            };
            for (var i = idsToRemove.length;i--; ) {
              _loop();
            }
          }
          var lastFragment = details.fragments[details.fragments.length - 1];
          if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? undefined : lastFragment.programDateTime)) {
            return;
          }
          if (!this.id3Track) {
            this.id3Track = this.createTrack(this.media);
          }
          var dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;
          var Cue = getCueClass();
          var _loop2 = function _loop2() {
            var id = ids[_i];
            var dateRange = dateRanges[id];
            var startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);
            var appendedDateRangeCues = dateRangeCuesAppended[id];
            var cues = (appendedDateRangeCues == null ? undefined : appendedDateRangeCues.cues) || {};
            var durationKnown = (appendedDateRangeCues == null ? undefined : appendedDateRangeCues.durationKnown) || false;
            var endTime = MAX_CUE_ENDTIME;
            var endDate = dateRange.endDate;
            if (endDate) {
              endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);
              durationKnown = true;
            } else if (dateRange.endOnNext && !durationKnown) {
              var nextDateRangeWithSameClass = ids.reduce(function(candidateDateRange, id2) {
                if (id2 !== dateRange.id) {
                  var otherDateRange = dateRanges[id2];
                  if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {
                    return otherDateRange;
                  }
                }
                return candidateDateRange;
              }, null);
              if (nextDateRangeWithSameClass) {
                endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);
                durationKnown = true;
              }
            }
            var attributes = Object.keys(dateRange.attr);
            for (var j = 0;j < attributes.length; j++) {
              var key = attributes[j];
              if (!isDateRangeCueAttribute(key)) {
                continue;
              }
              var cue = cues[key];
              if (cue) {
                if (durationKnown && !appendedDateRangeCues.durationKnown) {
                  cue.endTime = endTime;
                }
              } else if (Cue) {
                var data = dateRange.attr[key];
                if (isSCTE35Attribute(key)) {
                  data = hexToArrayBuffer(data);
                }
                var _cue = createCueWithDataFields(Cue, startTime, endTime, {
                  key,
                  data
                }, MetadataSchema.dateRange);
                if (_cue) {
                  _cue.id = id;
                  _this.id3Track.addCue(_cue);
                  cues[key] = _cue;
                }
              }
            }
            dateRangeCuesAppended[id] = {
              cues,
              dateRange,
              durationKnown
            };
          };
          for (var _i = 0;_i < ids.length; _i++) {
            _loop2();
          }
        };
        return ID3TrackController2;
      }();
      var LatencyController = /* @__PURE__ */ function() {
        function LatencyController2(hls) {
          var _this = this;
          this.hls = undefined;
          this.config = undefined;
          this.media = null;
          this.levelDetails = null;
          this.currentTime = 0;
          this.stallCount = 0;
          this._latency = null;
          this.timeupdateHandler = function() {
            return _this.timeupdate();
          };
          this.hls = hls;
          this.config = hls.config;
          this.registerListeners();
        }
        var _proto = LatencyController2.prototype;
        _proto.destroy = function destroy() {
          this.unregisterListeners();
          this.onMediaDetaching();
          this.levelDetails = null;
          this.hls = this.timeupdateHandler = null;
        };
        _proto.registerListeners = function registerListeners() {
          this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
          this.hls.on(Events.ERROR, this.onError, this);
        };
        _proto.unregisterListeners = function unregisterListeners() {
          this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
          this.hls.off(Events.ERROR, this.onError, this);
        };
        _proto.onMediaAttached = function onMediaAttached(event, data) {
          this.media = data.media;
          this.media.addEventListener("timeupdate", this.timeupdateHandler);
        };
        _proto.onMediaDetaching = function onMediaDetaching() {
          if (this.media) {
            this.media.removeEventListener("timeupdate", this.timeupdateHandler);
            this.media = null;
          }
        };
        _proto.onManifestLoading = function onManifestLoading() {
          this.levelDetails = null;
          this._latency = null;
          this.stallCount = 0;
        };
        _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {
          var details = _ref.details;
          this.levelDetails = details;
          if (details.advanced) {
            this.timeupdate();
          }
          if (!details.live && this.media) {
            this.media.removeEventListener("timeupdate", this.timeupdateHandler);
          }
        };
        _proto.onError = function onError(event, data) {
          var _this$levelDetails;
          if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {
            return;
          }
          this.stallCount++;
          if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {
            logger.warn("[playback-rate-controller]: Stall detected, adjusting target latency");
          }
        };
        _proto.timeupdate = function timeupdate() {
          var media = this.media, levelDetails = this.levelDetails;
          if (!media || !levelDetails) {
            return;
          }
          this.currentTime = media.currentTime;
          var latency = this.computeLatency();
          if (latency === null) {
            return;
          }
          this._latency = latency;
          var _this$config = this.config, lowLatencyMode = _this$config.lowLatencyMode, maxLiveSyncPlaybackRate = _this$config.maxLiveSyncPlaybackRate;
          if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {
            return;
          }
          var targetLatency = this.targetLatency;
          if (targetLatency === null) {
            return;
          }
          var distanceFromTarget = latency - targetLatency;
          var liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);
          var inLiveRange = distanceFromTarget < liveMinLatencyDuration;
          if (inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {
            var max = Math.min(2, Math.max(1, maxLiveSyncPlaybackRate));
            var rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;
            media.playbackRate = Math.min(max, Math.max(1, rate));
          } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {
            media.playbackRate = 1;
          }
        };
        _proto.estimateLiveEdge = function estimateLiveEdge() {
          var levelDetails = this.levelDetails;
          if (levelDetails === null) {
            return null;
          }
          return levelDetails.edge + levelDetails.age;
        };
        _proto.computeLatency = function computeLatency() {
          var liveEdge = this.estimateLiveEdge();
          if (liveEdge === null) {
            return null;
          }
          return liveEdge - this.currentTime;
        };
        _createClass(LatencyController2, [{
          key: "latency",
          get: function get() {
            return this._latency || 0;
          }
        }, {
          key: "maxLatency",
          get: function get() {
            var config = this.config, levelDetails = this.levelDetails;
            if (config.liveMaxLatencyDuration !== undefined) {
              return config.liveMaxLatencyDuration;
            }
            return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;
          }
        }, {
          key: "targetLatency",
          get: function get() {
            var levelDetails = this.levelDetails;
            if (levelDetails === null) {
              return null;
            }
            var { holdBack, partHoldBack, targetduration } = levelDetails;
            var _this$config2 = this.config, liveSyncDuration = _this$config2.liveSyncDuration, liveSyncDurationCount = _this$config2.liveSyncDurationCount, lowLatencyMode = _this$config2.lowLatencyMode;
            var userConfig = this.hls.userConfig;
            var targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;
            if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {
              targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;
            }
            var maxLiveSyncOnStallIncrease = targetduration;
            var liveSyncOnStallIncrease = 1;
            return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);
          }
        }, {
          key: "liveSyncPosition",
          get: function get() {
            var liveEdge = this.estimateLiveEdge();
            var targetLatency = this.targetLatency;
            var levelDetails = this.levelDetails;
            if (liveEdge === null || targetLatency === null || levelDetails === null) {
              return null;
            }
            var edge = levelDetails.edge;
            var syncPosition = liveEdge - targetLatency - this.edgeStalled;
            var min = edge - levelDetails.totalduration;
            var max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);
            return Math.min(Math.max(min, syncPosition), max);
          }
        }, {
          key: "drift",
          get: function get() {
            var levelDetails = this.levelDetails;
            if (levelDetails === null) {
              return 1;
            }
            return levelDetails.drift;
          }
        }, {
          key: "edgeStalled",
          get: function get() {
            var levelDetails = this.levelDetails;
            if (levelDetails === null) {
              return 0;
            }
            var maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;
            return Math.max(levelDetails.age - maxLevelUpdateAge, 0);
          }
        }, {
          key: "forwardBufferLength",
          get: function get() {
            var media = this.media, levelDetails = this.levelDetails;
            if (!media || !levelDetails) {
              return 0;
            }
            var bufferedRanges = media.buffered.length;
            return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;
          }
        }]);
        return LatencyController2;
      }();
      var HdcpLevels = ["NONE", "TYPE-0", "TYPE-1", null];
      function isHdcpLevel(value) {
        return HdcpLevels.indexOf(value) > -1;
      }
      var VideoRangeValues = ["SDR", "PQ", "HLG"];
      function isVideoRange(value) {
        return !!value && VideoRangeValues.indexOf(value) > -1;
      }
      var HlsSkip = {
        No: "",
        Yes: "YES",
        v2: "v2"
      };
      function getSkipValue(details) {
        var { canSkipUntil, canSkipDateRanges, age } = details;
        var playlistRecentEnough = age < canSkipUntil / 2;
        if (canSkipUntil && playlistRecentEnough) {
          if (canSkipDateRanges) {
            return HlsSkip.v2;
          }
          return HlsSkip.Yes;
        }
        return HlsSkip.No;
      }
      var HlsUrlParameters = /* @__PURE__ */ function() {
        function HlsUrlParameters2(msn, part, skip) {
          this.msn = undefined;
          this.part = undefined;
          this.skip = undefined;
          this.msn = msn;
          this.part = part;
          this.skip = skip;
        }
        var _proto = HlsUrlParameters2.prototype;
        _proto.addDirectives = function addDirectives(uri) {
          var url2 = new self.URL(uri);
          if (this.msn !== undefined) {
            url2.searchParams.set("_HLS_msn", this.msn.toString());
          }
          if (this.part !== undefined) {
            url2.searchParams.set("_HLS_part", this.part.toString());
          }
          if (this.skip) {
            url2.searchParams.set("_HLS_skip", this.skip);
          }
          return url2.href;
        };
        return HlsUrlParameters2;
      }();
      var Level = /* @__PURE__ */ function() {
        function Level2(data) {
          this._attrs = undefined;
          this.audioCodec = undefined;
          this.bitrate = undefined;
          this.codecSet = undefined;
          this.url = undefined;
          this.frameRate = undefined;
          this.height = undefined;
          this.id = undefined;
          this.name = undefined;
          this.videoCodec = undefined;
          this.width = undefined;
          this.details = undefined;
          this.fragmentError = 0;
          this.loadError = 0;
          this.loaded = undefined;
          this.realBitrate = 0;
          this.supportedPromise = undefined;
          this.supportedResult = undefined;
          this._avgBitrate = 0;
          this._audioGroups = undefined;
          this._subtitleGroups = undefined;
          this._urlId = 0;
          this.url = [data.url];
          this._attrs = [data.attrs];
          this.bitrate = data.bitrate;
          if (data.details) {
            this.details = data.details;
          }
          this.id = data.id || 0;
          this.name = data.name;
          this.width = data.width || 0;
          this.height = data.height || 0;
          this.frameRate = data.attrs.optionalFloat("FRAME-RATE", 0);
          this._avgBitrate = data.attrs.decimalInteger("AVERAGE-BANDWIDTH");
          this.audioCodec = data.audioCodec;
          this.videoCodec = data.videoCodec;
          this.codecSet = [data.videoCodec, data.audioCodec].filter(function(c) {
            return !!c;
          }).map(function(s) {
            return s.substring(0, 4);
          }).join(",");
          this.addGroupId("audio", data.attrs.AUDIO);
          this.addGroupId("text", data.attrs.SUBTITLES);
        }
        var _proto2 = Level2.prototype;
        _proto2.hasAudioGroup = function hasAudioGroup(groupId) {
          return hasGroup(this._audioGroups, groupId);
        };
        _proto2.hasSubtitleGroup = function hasSubtitleGroup(groupId) {
          return hasGroup(this._subtitleGroups, groupId);
        };
        _proto2.addGroupId = function addGroupId(type, groupId) {
          if (!groupId) {
            return;
          }
          if (type === "audio") {
            var audioGroups = this._audioGroups;
            if (!audioGroups) {
              audioGroups = this._audioGroups = [];
            }
            if (audioGroups.indexOf(groupId) === -1) {
              audioGroups.push(groupId);
            }
          } else if (type === "text") {
            var subtitleGroups = this._subtitleGroups;
            if (!subtitleGroups) {
              subtitleGroups = this._subtitleGroups = [];
            }
            if (subtitleGroups.indexOf(groupId) === -1) {
              subtitleGroups.push(groupId);
            }
          }
        };
        _proto2.addFallback = function addFallback() {
        };
        _createClass(Level2, [{
          key: "maxBitrate",
          get: function get() {
            return Math.max(this.realBitrate, this.bitrate);
          }
        }, {
          key: "averageBitrate",
          get: function get() {
            return this._avgBitrate || this.realBitrate || this.bitrate;
          }
        }, {
          key: "attrs",
          get: function get() {
            return this._attrs[0];
          }
        }, {
          key: "codecs",
          get: function get() {
            return this.attrs.CODECS || "";
          }
        }, {
          key: "pathwayId",
          get: function get() {
            return this.attrs["PATHWAY-ID"] || ".";
          }
        }, {
          key: "videoRange",
          get: function get() {
            return this.attrs["VIDEO-RANGE"] || "SDR";
          }
        }, {
          key: "score",
          get: function get() {
            return this.attrs.optionalFloat("SCORE", 0);
          }
        }, {
          key: "uri",
          get: function get() {
            return this.url[0] || "";
          }
        }, {
          key: "audioGroups",
          get: function get() {
            return this._audioGroups;
          }
        }, {
          key: "subtitleGroups",
          get: function get() {
            return this._subtitleGroups;
          }
        }, {
          key: "urlId",
          get: function get() {
            return 0;
          },
          set: function set(value) {
          }
        }, {
          key: "audioGroupIds",
          get: function get() {
            return this.audioGroups ? [this.audioGroupId] : undefined;
          }
        }, {
          key: "textGroupIds",
          get: function get() {
            return this.subtitleGroups ? [this.textGroupId] : undefined;
          }
        }, {
          key: "audioGroupId",
          get: function get() {
            var _this$audioGroups;
            return (_this$audioGroups = this.audioGroups) == null ? undefined : _this$audioGroups[0];
          }
        }, {
          key: "textGroupId",
          get: function get() {
            var _this$subtitleGroups;
            return (_this$subtitleGroups = this.subtitleGroups) == null ? undefined : _this$subtitleGroups[0];
          }
        }]);
        return Level2;
      }();
      function hasGroup(groups, groupId) {
        if (!groupId || !groups) {
          return false;
        }
        return groups.indexOf(groupId) !== -1;
      }
      function updateFromToPTS(fragFrom, fragTo) {
        var fragToPTS = fragTo.startPTS;
        if (isFiniteNumber(fragToPTS)) {
          var duration = 0;
          var frag;
          if (fragTo.sn > fragFrom.sn) {
            duration = fragToPTS - fragFrom.start;
            frag = fragFrom;
          } else {
            duration = fragFrom.start - fragToPTS;
            frag = fragTo;
          }
          if (frag.duration !== duration) {
            frag.duration = duration;
          }
        } else if (fragTo.sn > fragFrom.sn) {
          var contiguous = fragFrom.cc === fragTo.cc;
          if (contiguous && fragFrom.minEndPTS) {
            fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);
          } else {
            fragTo.start = fragFrom.start + fragFrom.duration;
          }
        } else {
          fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);
        }
      }
      function updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {
        var parsedMediaDuration = endPTS - startPTS;
        if (parsedMediaDuration <= 0) {
          logger.warn("Fragment should have a positive duration", frag);
          endPTS = startPTS + frag.duration;
          endDTS = startDTS + frag.duration;
        }
        var maxStartPTS = startPTS;
        var minEndPTS = endPTS;
        var fragStartPts = frag.startPTS;
        var fragEndPts = frag.endPTS;
        if (isFiniteNumber(fragStartPts)) {
          var deltaPTS = Math.abs(fragStartPts - startPTS);
          if (!isFiniteNumber(frag.deltaPTS)) {
            frag.deltaPTS = deltaPTS;
          } else {
            frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);
          }
          maxStartPTS = Math.max(startPTS, fragStartPts);
          startPTS = Math.min(startPTS, fragStartPts);
          startDTS = Math.min(startDTS, frag.startDTS);
          minEndPTS = Math.min(endPTS, fragEndPts);
          endPTS = Math.max(endPTS, fragEndPts);
          endDTS = Math.max(endDTS, frag.endDTS);
        }
        var drift = startPTS - frag.start;
        if (frag.start !== 0) {
          frag.start = startPTS;
        }
        frag.duration = endPTS - frag.start;
        frag.startPTS = startPTS;
        frag.maxStartPTS = maxStartPTS;
        frag.startDTS = startDTS;
        frag.endPTS = endPTS;
        frag.minEndPTS = minEndPTS;
        frag.endDTS = endDTS;
        var sn = frag.sn;
        if (!details || sn < details.startSN || sn > details.endSN) {
          return 0;
        }
        var i;
        var fragIdx = sn - details.startSN;
        var fragments = details.fragments;
        fragments[fragIdx] = frag;
        for (i = fragIdx;i > 0; i--) {
          updateFromToPTS(fragments[i], fragments[i - 1]);
        }
        for (i = fragIdx;i < fragments.length - 1; i++) {
          updateFromToPTS(fragments[i], fragments[i + 1]);
        }
        if (details.fragmentHint) {
          updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);
        }
        details.PTSKnown = details.alignedSliding = true;
        return drift;
      }
      function mergeDetails(oldDetails, newDetails) {
        var currentInitSegment = null;
        var oldFragments = oldDetails.fragments;
        for (var i = oldFragments.length - 1;i >= 0; i--) {
          var oldInit = oldFragments[i].initSegment;
          if (oldInit) {
            currentInitSegment = oldInit;
            break;
          }
        }
        if (oldDetails.fragmentHint) {
          delete oldDetails.fragmentHint.endPTS;
        }
        var ccOffset = 0;
        var PTSFrag;
        mapFragmentIntersection(oldDetails, newDetails, function(oldFrag, newFrag) {
          if (oldFrag.relurl) {
            ccOffset = oldFrag.cc - newFrag.cc;
          }
          if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {
            newFrag.start = newFrag.startPTS = oldFrag.startPTS;
            newFrag.startDTS = oldFrag.startDTS;
            newFrag.maxStartPTS = oldFrag.maxStartPTS;
            newFrag.endPTS = oldFrag.endPTS;
            newFrag.endDTS = oldFrag.endDTS;
            newFrag.minEndPTS = oldFrag.minEndPTS;
            newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;
            if (newFrag.duration) {
              PTSFrag = newFrag;
            }
            newDetails.PTSKnown = newDetails.alignedSliding = true;
          }
          newFrag.elementaryStreams = oldFrag.elementaryStreams;
          newFrag.loader = oldFrag.loader;
          newFrag.stats = oldFrag.stats;
          if (oldFrag.initSegment) {
            newFrag.initSegment = oldFrag.initSegment;
            currentInitSegment = oldFrag.initSegment;
          }
        });
        if (currentInitSegment) {
          var fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
          fragmentsToCheck.forEach(function(frag) {
            var _currentInitSegment;
            if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? undefined : _currentInitSegment.relurl))) {
              frag.initSegment = currentInitSegment;
            }
          });
        }
        if (newDetails.skippedSegments) {
          newDetails.deltaUpdateFailed = newDetails.fragments.some(function(frag) {
            return !frag;
          });
          if (newDetails.deltaUpdateFailed) {
            logger.warn("[level-helper] Previous playlist missing segments skipped in delta playlist");
            for (var _i = newDetails.skippedSegments;_i--; ) {
              newDetails.fragments.shift();
            }
            newDetails.startSN = newDetails.fragments[0].sn;
            newDetails.startCC = newDetails.fragments[0].cc;
          } else if (newDetails.canSkipDateRanges) {
            newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);
          }
        }
        var newFragments = newDetails.fragments;
        if (ccOffset) {
          logger.warn("discontinuity sliding from playlist, take drift into account");
          for (var _i2 = 0;_i2 < newFragments.length; _i2++) {
            newFragments[_i2].cc += ccOffset;
          }
        }
        if (newDetails.skippedSegments) {
          newDetails.startCC = newDetails.fragments[0].cc;
        }
        mapPartIntersection(oldDetails.partList, newDetails.partList, function(oldPart, newPart) {
          newPart.elementaryStreams = oldPart.elementaryStreams;
          newPart.stats = oldPart.stats;
        });
        if (PTSFrag) {
          updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);
        } else {
          adjustSliding(oldDetails, newDetails);
        }
        if (newFragments.length) {
          newDetails.totalduration = newDetails.edge - newFragments[0].start;
        }
        newDetails.driftStartTime = oldDetails.driftStartTime;
        newDetails.driftStart = oldDetails.driftStart;
        var advancedDateTime = newDetails.advancedDateTime;
        if (newDetails.advanced && advancedDateTime) {
          var edge = newDetails.edge;
          if (!newDetails.driftStart) {
            newDetails.driftStartTime = advancedDateTime;
            newDetails.driftStart = edge;
          }
          newDetails.driftEndTime = advancedDateTime;
          newDetails.driftEnd = edge;
        } else {
          newDetails.driftEndTime = oldDetails.driftEndTime;
          newDetails.driftEnd = oldDetails.driftEnd;
          newDetails.advancedDateTime = oldDetails.advancedDateTime;
        }
      }
      function mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {
        var dateRanges = _extends({}, oldDateRanges);
        if (recentlyRemovedDateranges) {
          recentlyRemovedDateranges.forEach(function(id) {
            delete dateRanges[id];
          });
        }
        Object.keys(deltaDateRanges).forEach(function(id) {
          var dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);
          if (dateRange.isValid) {
            dateRanges[id] = dateRange;
          } else {
            logger.warn('Ignoring invalid Playlist Delta Update DATERANGE tag: "' + JSON.stringify(deltaDateRanges[id].attr) + '"');
          }
        });
        return dateRanges;
      }
      function mapPartIntersection(oldParts, newParts, intersectionFn) {
        if (oldParts && newParts) {
          var delta = 0;
          for (var i = 0, len = oldParts.length;i <= len; i++) {
            var _oldPart = oldParts[i];
            var _newPart = newParts[i + delta];
            if (_oldPart && _newPart && _oldPart.index === _newPart.index && _oldPart.fragment.sn === _newPart.fragment.sn) {
              intersectionFn(_oldPart, _newPart);
            } else {
              delta--;
            }
          }
        }
      }
      function mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {
        var skippedSegments = newDetails.skippedSegments;
        var start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;
        var end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;
        var delta = newDetails.startSN - oldDetails.startSN;
        var newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;
        var oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;
        for (var i = start;i <= end; i++) {
          var _oldFrag = oldFrags[delta + i];
          var _newFrag = newFrags[i];
          if (skippedSegments && !_newFrag && i < skippedSegments) {
            _newFrag = newDetails.fragments[i] = _oldFrag;
          }
          if (_oldFrag && _newFrag) {
            intersectionFn(_oldFrag, _newFrag);
          }
        }
      }
      function adjustSliding(oldDetails, newDetails) {
        var delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;
        var oldFragments = oldDetails.fragments;
        if (delta < 0 || delta >= oldFragments.length) {
          return;
        }
        addSliding(newDetails, oldFragments[delta].start);
      }
      function addSliding(details, start) {
        if (start) {
          var fragments = details.fragments;
          for (var i = details.skippedSegments;i < fragments.length; i++) {
            fragments[i].start += start;
          }
          if (details.fragmentHint) {
            details.fragmentHint.start += start;
          }
        }
      }
      function computeReloadInterval(newDetails, distanceToLiveEdgeMs) {
        if (distanceToLiveEdgeMs === undefined) {
          distanceToLiveEdgeMs = Infinity;
        }
        var reloadInterval = 1000 * newDetails.targetduration;
        if (newDetails.updated) {
          var fragments = newDetails.fragments;
          var liveEdgeMaxTargetDurations = 4;
          if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {
            var lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;
            if (lastSegmentDuration < reloadInterval) {
              reloadInterval = lastSegmentDuration;
            }
          }
        } else {
          reloadInterval /= 2;
        }
        return Math.round(reloadInterval);
      }
      function getFragmentWithSN(level, sn, fragCurrent) {
        if (!(level != null && level.details)) {
          return null;
        }
        var levelDetails = level.details;
        var fragment = levelDetails.fragments[sn - levelDetails.startSN];
        if (fragment) {
          return fragment;
        }
        fragment = levelDetails.fragmentHint;
        if (fragment && fragment.sn === sn) {
          return fragment;
        }
        if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {
          return fragCurrent;
        }
        return null;
      }
      function getPartWith(level, sn, partIndex) {
        var _level$details;
        if (!(level != null && level.details)) {
          return null;
        }
        return findPart((_level$details = level.details) == null ? undefined : _level$details.partList, sn, partIndex);
      }
      function findPart(partList, sn, partIndex) {
        if (partList) {
          for (var i = partList.length;i--; ) {
            var part = partList[i];
            if (part.index === partIndex && part.fragment.sn === sn) {
              return part;
            }
          }
        }
        return null;
      }
      function reassignFragmentLevelIndexes(levels) {
        levels.forEach(function(level, index) {
          var details = level.details;
          if (details != null && details.fragments) {
            details.fragments.forEach(function(fragment) {
              fragment.level = index;
            });
          }
        });
      }
      function isTimeoutError(error2) {
        switch (error2.details) {
          case ErrorDetails.FRAG_LOAD_TIMEOUT:
          case ErrorDetails.KEY_LOAD_TIMEOUT:
          case ErrorDetails.LEVEL_LOAD_TIMEOUT:
          case ErrorDetails.MANIFEST_LOAD_TIMEOUT:
            return true;
        }
        return false;
      }
      function getRetryConfig(loadPolicy, error2) {
        var isTimeout = isTimeoutError(error2);
        return loadPolicy.default[(isTimeout ? "timeout" : "error") + "Retry"];
      }
      function getRetryDelay(retryConfig, retryCount) {
        var backoffFactor = retryConfig.backoff === "linear" ? 1 : Math.pow(2, retryCount);
        return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);
      }
      function getLoaderConfigWithoutReties(loderConfig) {
        return _objectSpread2(_objectSpread2({}, loderConfig), {
          errorRetry: null,
          timeoutRetry: null
        });
      }
      function shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {
        if (!retryConfig) {
          return false;
        }
        var httpStatus = loaderResponse == null ? undefined : loaderResponse.code;
        var retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);
        return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;
      }
      function retryForHttpStatus(httpStatus) {
        return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);
      }
      var BinarySearch = {
        search: function search(list, comparisonFn) {
          var minIndex = 0;
          var maxIndex = list.length - 1;
          var currentIndex = null;
          var currentElement = null;
          while (minIndex <= maxIndex) {
            currentIndex = (minIndex + maxIndex) / 2 | 0;
            currentElement = list[currentIndex];
            var comparisonResult = comparisonFn(currentElement);
            if (comparisonResult > 0) {
              minIndex = currentIndex + 1;
            } else if (comparisonResult < 0) {
              maxIndex = currentIndex - 1;
            } else {
              return currentElement;
            }
          }
          return null;
        }
      };
      function findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {
        if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {
          return null;
        }
        var startPDT = fragments[0].programDateTime;
        if (PDTValue < (startPDT || 0)) {
          return null;
        }
        var endPDT = fragments[fragments.length - 1].endProgramDateTime;
        if (PDTValue >= (endPDT || 0)) {
          return null;
        }
        maxFragLookUpTolerance = maxFragLookUpTolerance || 0;
        for (var seg = 0;seg < fragments.length; ++seg) {
          var frag = fragments[seg];
          if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {
            return frag;
          }
        }
        return null;
      }
      function findFragmentByPTS(fragPrevious, fragments, bufferEnd, maxFragLookUpTolerance, nextFragLookupTolerance) {
        if (bufferEnd === undefined) {
          bufferEnd = 0;
        }
        if (maxFragLookUpTolerance === undefined) {
          maxFragLookUpTolerance = 0;
        }
        if (nextFragLookupTolerance === undefined) {
          nextFragLookupTolerance = 0.005;
        }
        var fragNext = null;
        if (fragPrevious) {
          fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;
          var bufferEdgeError = fragPrevious.endDTS - bufferEnd;
          if (bufferEdgeError > 0 && bufferEdgeError < 0.0000015) {
            bufferEnd += 0.0000015;
          }
        } else if (bufferEnd === 0 && fragments[0].start === 0) {
          fragNext = fragments[0];
        }
        if (fragNext && ((!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0 || fragmentWithinFastStartSwitch(fragNext, fragPrevious, Math.min(nextFragLookupTolerance, maxFragLookUpTolerance)))) {
          return fragNext;
        }
        var foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));
        if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {
          return foundFragment;
        }
        return fragNext;
      }
      function fragmentWithinFastStartSwitch(fragNext, fragPrevious, nextFragLookupTolerance) {
        if (fragPrevious && fragPrevious.start === 0 && fragPrevious.level < fragNext.level && (fragPrevious.endPTS || 0) > 0) {
          var firstDuration = fragPrevious.tagList.reduce(function(duration, tag) {
            if (tag[0] === "INF") {
              duration += parseFloat(tag[1]);
            }
            return duration;
          }, nextFragLookupTolerance);
          return fragNext.start <= firstDuration;
        }
        return false;
      }
      function fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, candidate) {
        if (bufferEnd === undefined) {
          bufferEnd = 0;
        }
        if (maxFragLookUpTolerance === undefined) {
          maxFragLookUpTolerance = 0;
        }
        if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {
          return 0;
        }
        var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));
        if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {
          return 1;
        } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {
          return -1;
        }
        return 0;
      }
      function pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {
        var candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;
        var endProgramDateTime = candidate.endProgramDateTime || 0;
        return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;
      }
      function findFragWithCC(fragments, cc) {
        return BinarySearch.search(fragments, function(candidate) {
          if (candidate.cc < cc) {
            return 1;
          } else if (candidate.cc > cc) {
            return -1;
          } else {
            return 0;
          }
        });
      }
      var NetworkErrorAction = {
        DoNothing: 0,
        SendEndCallback: 1,
        SendAlternateToPenaltyBox: 2,
        RemoveAlternatePermanently: 3,
        InsertDiscontinuity: 4,
        RetryRequest: 5
      };
      var ErrorActionFlags = {
        None: 0,
        MoveAllAlternatesMatchingHost: 1,
        MoveAllAlternatesMatchingHDCP: 2,
        SwitchToSDR: 4
      };
      var ErrorController = /* @__PURE__ */ function() {
        function ErrorController2(hls) {
          this.hls = undefined;
          this.playlistError = 0;
          this.penalizedRenditions = {};
          this.log = undefined;
          this.warn = undefined;
          this.error = undefined;
          this.hls = hls;
          this.log = logger.log.bind(logger, "[info]:");
          this.warn = logger.warn.bind(logger, "[warning]:");
          this.error = logger.error.bind(logger, "[error]:");
          this.registerListeners();
        }
        var _proto = ErrorController2.prototype;
        _proto.registerListeners = function registerListeners() {
          var hls = this.hls;
          hls.on(Events.ERROR, this.onError, this);
          hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
        };
        _proto.unregisterListeners = function unregisterListeners() {
          var hls = this.hls;
          if (!hls) {
            return;
          }
          hls.off(Events.ERROR, this.onError, this);
          hls.off(Events.ERROR, this.onErrorOut, this);
          hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
        };
        _proto.destroy = function destroy() {
          this.unregisterListeners();
          this.hls = null;
          this.penalizedRenditions = {};
        };
        _proto.startLoad = function startLoad(startPosition) {
        };
        _proto.stopLoad = function stopLoad() {
          this.playlistError = 0;
        };
        _proto.getVariantLevelIndex = function getVariantLevelIndex(frag) {
          return (frag == null ? undefined : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;
        };
        _proto.onManifestLoading = function onManifestLoading() {
          this.playlistError = 0;
          this.penalizedRenditions = {};
        };
        _proto.onLevelUpdated = function onLevelUpdated() {
          this.playlistError = 0;
        };
        _proto.onError = function onError(event, data) {
          var _data$frag, _data$level;
          if (data.fatal) {
            return;
          }
          var hls = this.hls;
          var context = data.context;
          switch (data.details) {
            case ErrorDetails.FRAG_LOAD_ERROR:
            case ErrorDetails.FRAG_LOAD_TIMEOUT:
            case ErrorDetails.KEY_LOAD_ERROR:
            case ErrorDetails.KEY_LOAD_TIMEOUT:
              data.errorAction = this.getFragRetryOrSwitchAction(data);
              return;
            case ErrorDetails.FRAG_PARSING_ERROR:
              if ((_data$frag = data.frag) != null && _data$frag.gap) {
                data.errorAction = {
                  action: NetworkErrorAction.DoNothing,
                  flags: ErrorActionFlags.None
                };
                return;
              }
            case ErrorDetails.FRAG_GAP:
            case ErrorDetails.FRAG_DECRYPT_ERROR: {
              data.errorAction = this.getFragRetryOrSwitchAction(data);
              data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
              return;
            }
            case ErrorDetails.LEVEL_EMPTY_ERROR:
            case ErrorDetails.LEVEL_PARSING_ERROR:
              {
                var _data$context, _data$context$levelDe;
                var levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;
                if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {
                  data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);
                } else {
                  data.levelRetry = false;
                  data.errorAction = this.getLevelSwitchAction(data, levelIndex);
                }
              }
              return;
            case ErrorDetails.LEVEL_LOAD_ERROR:
            case ErrorDetails.LEVEL_LOAD_TIMEOUT:
              if (typeof (context == null ? undefined : context.level) === "number") {
                data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);
              }
              return;
            case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
            case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
            case ErrorDetails.SUBTITLE_LOAD_ERROR:
            case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:
              if (context) {
                var level = hls.levels[hls.loadLevel];
                if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {
                  data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);
                  data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;
                  data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;
                  return;
                }
              }
              return;
            case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:
              {
                var _level = hls.levels[hls.loadLevel];
                var restrictedHdcpLevel = _level == null ? undefined : _level.attrs["HDCP-LEVEL"];
                if (restrictedHdcpLevel) {
                  data.errorAction = {
                    action: NetworkErrorAction.SendAlternateToPenaltyBox,
                    flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,
                    hdcpLevel: restrictedHdcpLevel
                  };
                } else {
                  this.keySystemError(data);
                }
              }
              return;
            case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
            case ErrorDetails.REMUX_ALLOC_ERROR:
            case ErrorDetails.BUFFER_APPEND_ERROR:
              data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);
              return;
            case ErrorDetails.INTERNAL_EXCEPTION:
            case ErrorDetails.BUFFER_APPENDING_ERROR:
            case ErrorDetails.BUFFER_FULL_ERROR:
            case ErrorDetails.LEVEL_SWITCH_ERROR:
            case ErrorDetails.BUFFER_STALLED_ERROR:
            case ErrorDetails.BUFFER_SEEK_OVER_HOLE:
            case ErrorDetails.BUFFER_NUDGE_ON_STALL:
              data.errorAction = {
                action: NetworkErrorAction.DoNothing,
                flags: ErrorActionFlags.None
              };
              return;
          }
          if (data.type === ErrorTypes2.KEY_SYSTEM_ERROR) {
            this.keySystemError(data);
          }
        };
        _proto.keySystemError = function keySystemError(data) {
          var levelIndex = this.getVariantLevelIndex(data.frag);
          data.levelRetry = false;
          data.errorAction = this.getLevelSwitchAction(data, levelIndex);
        };
        _proto.getPlaylistRetryOrSwitchAction = function getPlaylistRetryOrSwitchAction(data, levelIndex) {
          var hls = this.hls;
          var retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);
          var retryCount = this.playlistError++;
          var retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);
          if (retry) {
            return {
              action: NetworkErrorAction.RetryRequest,
              flags: ErrorActionFlags.None,
              retryConfig,
              retryCount
            };
          }
          var errorAction = this.getLevelSwitchAction(data, levelIndex);
          if (retryConfig) {
            errorAction.retryConfig = retryConfig;
            errorAction.retryCount = retryCount;
          }
          return errorAction;
        };
        _proto.getFragRetryOrSwitchAction = function getFragRetryOrSwitchAction(data) {
          var hls = this.hls;
          var variantLevelIndex = this.getVariantLevelIndex(data.frag);
          var level = hls.levels[variantLevelIndex];
          var _hls$config = hls.config, fragLoadPolicy = _hls$config.fragLoadPolicy, keyLoadPolicy = _hls$config.keyLoadPolicy;
          var retryConfig = getRetryConfig(data.details.startsWith("key") ? keyLoadPolicy : fragLoadPolicy, data);
          var fragmentErrors = hls.levels.reduce(function(acc, level2) {
            return acc + level2.fragmentError;
          }, 0);
          if (level) {
            if (data.details !== ErrorDetails.FRAG_GAP) {
              level.fragmentError++;
            }
            var retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);
            if (retry) {
              return {
                action: NetworkErrorAction.RetryRequest,
                flags: ErrorActionFlags.None,
                retryConfig,
                retryCount: fragmentErrors
              };
            }
          }
          var errorAction = this.getLevelSwitchAction(data, variantLevelIndex);
          if (retryConfig) {
            errorAction.retryConfig = retryConfig;
            errorAction.retryCount = fragmentErrors;
          }
          return errorAction;
        };
        _proto.getLevelSwitchAction = function getLevelSwitchAction(data, levelIndex) {
          var hls = this.hls;
          if (levelIndex === null || levelIndex === undefined) {
            levelIndex = hls.loadLevel;
          }
          var level = this.hls.levels[levelIndex];
          if (level) {
            var _data$frag2, _data$context2;
            var errorDetails = data.details;
            level.loadError++;
            if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {
              level.fragmentError++;
            }
            var nextLevel = -1;
            var { levels, loadLevel, minAutoLevel, maxAutoLevel } = hls;
            if (!hls.autoLevelEnabled) {
              hls.loadLevel = -1;
            }
            var fragErrorType = (_data$frag2 = data.frag) == null ? undefined : _data$frag2.type;
            var isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === "audio" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
            var findAudioCodecAlternate = isAudioCodecError && levels.some(function(_ref) {
              var audioCodec = _ref.audioCodec;
              return level.audioCodec !== audioCodec;
            });
            var isVideoCodecError = data.sourceBufferName === "video" && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);
            var findVideoCodecAlternate = isVideoCodecError && levels.some(function(_ref2) {
              var { codecSet, audioCodec } = _ref2;
              return level.codecSet !== codecSet && level.audioCodec === audioCodec;
            });
            var _ref3 = (_data$context2 = data.context) != null ? _data$context2 : {}, playlistErrorType = _ref3.type, playlistErrorGroupId = _ref3.groupId;
            var _loop = function _loop() {
              var candidate = (i + loadLevel) % levels.length;
              if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {
                var _level$audioGroups, _level$subtitleGroups;
                var levelCandidate = levels[candidate];
                if (errorDetails === ErrorDetails.FRAG_GAP && fragErrorType === PlaylistLevelType.MAIN && data.frag) {
                  var levelDetails = levels[candidate].details;
                  if (levelDetails) {
                    var fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);
                    if (fragCandidate != null && fragCandidate.gap) {
                      return 0;
                    }
                  }
                } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {
                  return 0;
                } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some(function(groupId) {
                  return levelCandidate.hasAudioGroup(groupId);
                }) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some(function(groupId) {
                  return levelCandidate.hasSubtitleGroup(groupId);
                }) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || !findAudioCodecAlternate && level.audioCodec !== levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet) {
                  return 0;
                }
                nextLevel = candidate;
                return 1;
              }
            }, _ret;
            for (var i = levels.length;i--; ) {
              _ret = _loop();
              if (_ret === 0)
                continue;
              if (_ret === 1)
                break;
            }
            if (nextLevel > -1 && hls.loadLevel !== nextLevel) {
              data.levelRetry = true;
              this.playlistError = 0;
              return {
                action: NetworkErrorAction.SendAlternateToPenaltyBox,
                flags: ErrorActionFlags.None,
                nextAutoLevel: nextLevel
              };
            }
          }
          return {
            action: NetworkErrorAction.SendAlternateToPenaltyBox,
            flags: ErrorActionFlags.MoveAllAlternatesMatchingHost
          };
        };
        _proto.onErrorOut = function onErrorOut(event, data) {
          var _data$errorAction;
          switch ((_data$errorAction = data.errorAction) == null ? undefined : _data$errorAction.action) {
            case NetworkErrorAction.DoNothing:
              break;
            case NetworkErrorAction.SendAlternateToPenaltyBox:
              this.sendAlternateToPenaltyBox(data);
              if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {
                data.fatal = true;
              } else if (/MediaSource readyState: ended/.test(data.error.message)) {
                this.warn('MediaSource ended after "' + data.sourceBufferName + '" sourceBuffer append error. Attempting to recover from media error.');
                this.hls.recoverMediaError();
              }
              break;
          }
          if (data.fatal) {
            this.hls.stopLoad();
            return;
          }
        };
        _proto.sendAlternateToPenaltyBox = function sendAlternateToPenaltyBox(data) {
          var hls = this.hls;
          var errorAction = data.errorAction;
          if (!errorAction) {
            return;
          }
          var { flags, hdcpLevel, nextAutoLevel } = errorAction;
          switch (flags) {
            case ErrorActionFlags.None:
              this.switchLevel(data, nextAutoLevel);
              break;
            case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:
              if (hdcpLevel) {
                hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];
                errorAction.resolved = true;
              }
              this.warn('Restricting playback to HDCP-LEVEL of "' + hls.maxHdcpLevel + '" or lower');
              break;
          }
          if (!errorAction.resolved) {
            this.switchLevel(data, nextAutoLevel);
          }
        };
        _proto.switchLevel = function switchLevel(data, levelIndex) {
          if (levelIndex !== undefined && data.errorAction) {
            this.warn("switching to level " + levelIndex + " after " + data.details);
            this.hls.nextAutoLevel = levelIndex;
            data.errorAction.resolved = true;
            this.hls.nextLoadLevel = this.hls.nextAutoLevel;
          }
        };
        return ErrorController2;
      }();
      var BasePlaylistController = /* @__PURE__ */ function() {
        function BasePlaylistController2(hls, logPrefix) {
          this.hls = undefined;
          this.timer = -1;
          this.requestScheduled = -1;
          this.canLoad = false;
          this.log = undefined;
          this.warn = undefined;
          this.log = logger.log.bind(logger, logPrefix + ":");
          this.warn = logger.warn.bind(logger, logPrefix + ":");
          this.hls = hls;
        }
        var _proto = BasePlaylistController2.prototype;
        _proto.destroy = function destroy() {
          this.clearTimer();
          this.hls = this.log = this.warn = null;
        };
        _proto.clearTimer = function clearTimer() {
          if (this.timer !== -1) {
            self.clearTimeout(this.timer);
            this.timer = -1;
          }
        };
        _proto.startLoad = function startLoad() {
          this.canLoad = true;
          this.requestScheduled = -1;
          this.loadPlaylist();
        };
        _proto.stopLoad = function stopLoad() {
          this.canLoad = false;
          this.clearTimer();
        };
        _proto.switchParams = function switchParams(playlistUri, previous, current) {
          var renditionReports = previous == null ? undefined : previous.renditionReports;
          if (renditionReports) {
            var foundIndex = -1;
            for (var i = 0;i < renditionReports.length; i++) {
              var attr = renditionReports[i];
              var uri = undefined;
              try {
                uri = new self.URL(attr.URI, previous.url).href;
              } catch (error2) {
                logger.warn("Could not construct new URL for Rendition Report: " + error2);
                uri = attr.URI || "";
              }
              if (uri === playlistUri) {
                foundIndex = i;
                break;
              } else if (uri === playlistUri.substring(0, uri.length)) {
                foundIndex = i;
              }
            }
            if (foundIndex !== -1) {
              var _attr = renditionReports[foundIndex];
              var msn = parseInt(_attr["LAST-MSN"]) || (previous == null ? undefined : previous.lastPartSn);
              var part = parseInt(_attr["LAST-PART"]) || (previous == null ? undefined : previous.lastPartIndex);
              if (this.hls.config.lowLatencyMode) {
                var currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);
                if (part >= 0 && currentGoal > previous.partTarget) {
                  part += 1;
                }
              }
              var skip = current && getSkipValue(current);
              return new HlsUrlParameters(msn, part >= 0 ? part : undefined, skip);
            }
          }
        };
        _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
          if (this.requestScheduled === -1) {
            this.requestScheduled = self.performance.now();
          }
        };
        _proto.shouldLoadPlaylist = function shouldLoadPlaylist(playlist) {
          return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);
        };
        _proto.shouldReloadPlaylist = function shouldReloadPlaylist(playlist) {
          return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);
        };
        _proto.playlistLoaded = function playlistLoaded(index, data, previousDetails) {
          var _this = this;
          var { details, stats } = data;
          var now2 = self.performance.now();
          var elapsed = stats.loading.first ? Math.max(0, now2 - stats.loading.first) : 0;
          details.advancedDateTime = Date.now() - elapsed;
          if (details.live || previousDetails != null && previousDetails.live) {
            details.reloaded(previousDetails);
            if (previousDetails) {
              this.log("live playlist " + index + " " + (details.advanced ? "REFRESHED " + details.lastPartSn + "-" + details.lastPartIndex : details.updated ? "UPDATED" : "MISSED"));
            }
            if (previousDetails && details.fragments.length > 0) {
              mergeDetails(previousDetails, details);
            }
            if (!this.canLoad || !details.live) {
              return;
            }
            var deliveryDirectives;
            var msn = undefined;
            var part = undefined;
            if (details.canBlockReload && details.endSN && details.advanced) {
              var lowLatencyMode = this.hls.config.lowLatencyMode;
              var lastPartSn = details.lastPartSn;
              var endSn = details.endSN;
              var lastPartIndex = details.lastPartIndex;
              var hasParts = lastPartIndex !== -1;
              var lastPart = lastPartSn === endSn;
              var nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;
              if (hasParts) {
                msn = lastPart ? endSn + 1 : lastPartSn;
                part = lastPart ? nextSnStartIndex : lastPartIndex + 1;
              } else {
                msn = endSn + 1;
              }
              var lastAdvanced = details.age;
              var cdnAge = lastAdvanced + details.ageHeader;
              var currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);
              if (currentGoal > 0) {
                if (previousDetails && currentGoal > previousDetails.tuneInGoal) {
                  this.warn("CDN Tune-in goal increased from: " + previousDetails.tuneInGoal + " to: " + currentGoal + " with playlist age: " + details.age);
                  currentGoal = 0;
                } else {
                  var segments = Math.floor(currentGoal / details.targetduration);
                  msn += segments;
                  if (part !== undefined) {
                    var parts = Math.round(currentGoal % details.targetduration / details.partTarget);
                    part += parts;
                  }
                  this.log("CDN Tune-in age: " + details.ageHeader + "s last advanced " + lastAdvanced.toFixed(2) + "s goal: " + currentGoal + " skip sn " + segments + " to part " + part);
                }
                details.tuneInGoal = currentGoal;
              }
              deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
              if (lowLatencyMode || !lastPart) {
                this.loadPlaylist(deliveryDirectives);
                return;
              }
            } else if (details.canBlockReload || details.canSkipUntil) {
              deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);
            }
            var bufferInfo = this.hls.mainForwardBufferInfo;
            var position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;
            var distanceToLiveEdgeMs = (details.edge - position) * 1000;
            var reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);
            if (details.updated && now2 > this.requestScheduled + reloadInterval) {
              this.requestScheduled = stats.loading.start;
            }
            if (msn !== undefined && details.canBlockReload) {
              this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);
            } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now2) {
              this.requestScheduled = now2;
            } else if (this.requestScheduled - now2 <= 0) {
              this.requestScheduled += reloadInterval;
            }
            var estimatedTimeUntilUpdate = this.requestScheduled - now2;
            estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);
            this.log("reload live playlist " + index + " in " + Math.round(estimatedTimeUntilUpdate) + " ms");
            this.timer = self.setTimeout(function() {
              return _this.loadPlaylist(deliveryDirectives);
            }, estimatedTimeUntilUpdate);
          } else {
            this.clearTimer();
          }
        };
        _proto.getDeliveryDirectives = function getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {
          var skip = getSkipValue(details);
          if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {
            msn = previousDeliveryDirectives.msn;
            part = previousDeliveryDirectives.part;
            skip = HlsSkip.No;
          }
          return new HlsUrlParameters(msn, part, skip);
        };
        _proto.checkRetry = function checkRetry(errorEvent) {
          var _this2 = this;
          var errorDetails = errorEvent.details;
          var isTimeout = isTimeoutError(errorEvent);
          var errorAction = errorEvent.errorAction;
          var _ref = errorAction || {}, action = _ref.action, _ref$retryCount = _ref.retryCount, retryCount = _ref$retryCount === undefined ? 0 : _ref$retryCount, retryConfig = _ref.retryConfig;
          var retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);
          if (retry) {
            var _errorEvent$context;
            this.requestScheduled = -1;
            if (retryCount >= retryConfig.maxNumRetry) {
              return false;
            }
            if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {
              this.warn("Retrying playlist loading " + (retryCount + 1) + "/" + retryConfig.maxNumRetry + ' after "' + errorDetails + '" without delivery-directives');
              this.loadPlaylist();
            } else {
              var delay = getRetryDelay(retryConfig, retryCount);
              this.timer = self.setTimeout(function() {
                return _this2.loadPlaylist();
              }, delay);
              this.warn("Retrying playlist loading " + (retryCount + 1) + "/" + retryConfig.maxNumRetry + ' after "' + errorDetails + '" in ' + delay + "ms");
            }
            errorEvent.levelRetry = true;
            errorAction.resolved = true;
          }
          return retry;
        };
        return BasePlaylistController2;
      }();
      var EWMA = /* @__PURE__ */ function() {
        function EWMA2(halfLife, estimate, weight) {
          if (estimate === undefined) {
            estimate = 0;
          }
          if (weight === undefined) {
            weight = 0;
          }
          this.halfLife = undefined;
          this.alpha_ = undefined;
          this.estimate_ = undefined;
          this.totalWeight_ = undefined;
          this.halfLife = halfLife;
          this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;
          this.estimate_ = estimate;
          this.totalWeight_ = weight;
        }
        var _proto = EWMA2.prototype;
        _proto.sample = function sample(weight, value) {
          var adjAlpha = Math.pow(this.alpha_, weight);
          this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
          this.totalWeight_ += weight;
        };
        _proto.getTotalWeight = function getTotalWeight() {
          return this.totalWeight_;
        };
        _proto.getEstimate = function getEstimate() {
          if (this.alpha_) {
            var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
            if (zeroFactor) {
              return this.estimate_ / zeroFactor;
            }
          }
          return this.estimate_;
        };
        return EWMA2;
      }();
      var EwmaBandWidthEstimator = /* @__PURE__ */ function() {
        function EwmaBandWidthEstimator2(slow, fast, defaultEstimate, defaultTTFB) {
          if (defaultTTFB === undefined) {
            defaultTTFB = 100;
          }
          this.defaultEstimate_ = undefined;
          this.minWeight_ = undefined;
          this.minDelayMs_ = undefined;
          this.slow_ = undefined;
          this.fast_ = undefined;
          this.defaultTTFB_ = undefined;
          this.ttfb_ = undefined;
          this.defaultEstimate_ = defaultEstimate;
          this.minWeight_ = 0.001;
          this.minDelayMs_ = 50;
          this.slow_ = new EWMA(slow);
          this.fast_ = new EWMA(fast);
          this.defaultTTFB_ = defaultTTFB;
          this.ttfb_ = new EWMA(slow);
        }
        var _proto = EwmaBandWidthEstimator2.prototype;
        _proto.update = function update(slow, fast) {
          var slow_ = this.slow_, fast_ = this.fast_, ttfb_ = this.ttfb_;
          if (slow_.halfLife !== slow) {
            this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());
          }
          if (fast_.halfLife !== fast) {
            this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());
          }
          if (ttfb_.halfLife !== slow) {
            this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());
          }
        };
        _proto.sample = function sample(durationMs, numBytes) {
          durationMs = Math.max(durationMs, this.minDelayMs_);
          var numBits = 8 * numBytes;
          var durationS = durationMs / 1000;
          var bandwidthInBps = numBits / durationS;
          this.fast_.sample(durationS, bandwidthInBps);
          this.slow_.sample(durationS, bandwidthInBps);
        };
        _proto.sampleTTFB = function sampleTTFB(ttfb) {
          var seconds = ttfb / 1000;
          var weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);
          this.ttfb_.sample(weight, Math.max(ttfb, 5));
        };
        _proto.canEstimate = function canEstimate() {
          return this.fast_.getTotalWeight() >= this.minWeight_;
        };
        _proto.getEstimate = function getEstimate() {
          if (this.canEstimate()) {
            return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
          } else {
            return this.defaultEstimate_;
          }
        };
        _proto.getEstimateTTFB = function getEstimateTTFB() {
          if (this.ttfb_.getTotalWeight() >= this.minWeight_) {
            return this.ttfb_.getEstimate();
          } else {
            return this.defaultTTFB_;
          }
        };
        _proto.destroy = function destroy() {
        };
        return EwmaBandWidthEstimator2;
      }();
      var SUPPORTED_INFO_DEFAULT = {
        supported: true,
        configurations: [],
        decodingInfoResults: [{
          supported: true,
          powerEfficient: true,
          smooth: true
        }]
      };
      var SUPPORTED_INFO_CACHE = {};
      function requiresMediaCapabilitiesDecodingInfo(level, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference) {
        var audioGroups = level.audioCodec ? level.audioGroups : null;
        var audioCodecPreference = audioPreference == null ? undefined : audioPreference.audioCodec;
        var channelsPreference = audioPreference == null ? undefined : audioPreference.channels;
        var maxChannels = channelsPreference ? parseInt(channelsPreference) : audioCodecPreference ? Infinity : 2;
        var audioChannels = null;
        if (audioGroups != null && audioGroups.length) {
          try {
            if (audioGroups.length === 1 && audioGroups[0]) {
              audioChannels = audioTracksByGroup.groups[audioGroups[0]].channels;
            } else {
              audioChannels = audioGroups.reduce(function(acc, groupId) {
                if (groupId) {
                  var audioTrackGroup = audioTracksByGroup.groups[groupId];
                  if (!audioTrackGroup) {
                    throw new Error("Audio track group " + groupId + " not found");
                  }
                  Object.keys(audioTrackGroup.channels).forEach(function(key) {
                    acc[key] = (acc[key] || 0) + audioTrackGroup.channels[key];
                  });
                }
                return acc;
              }, {
                2: 0
              });
            }
          } catch (error2) {
            return true;
          }
        }
        return level.videoCodec !== undefined && (level.width > 1920 && level.height > 1088 || level.height > 1920 && level.width > 1088 || level.frameRate > Math.max(currentFrameRate, 30) || level.videoRange !== "SDR" && level.videoRange !== currentVideoRange || level.bitrate > Math.max(currentBw, 8000000)) || !!audioChannels && isFiniteNumber(maxChannels) && Object.keys(audioChannels).some(function(channels) {
          return parseInt(channels) > maxChannels;
        });
      }
      function getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities) {
        var videoCodecs = level.videoCodec;
        var audioCodecs = level.audioCodec;
        if (!videoCodecs || !audioCodecs || !mediaCapabilities) {
          return Promise.resolve(SUPPORTED_INFO_DEFAULT);
        }
        var baseVideoConfiguration = {
          width: level.width,
          height: level.height,
          bitrate: Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate)),
          framerate: level.frameRate || 30
        };
        var videoRange = level.videoRange;
        if (videoRange !== "SDR") {
          baseVideoConfiguration.transferFunction = videoRange.toLowerCase();
        }
        var configurations = videoCodecs.split(",").map(function(videoCodec) {
          return {
            type: "media-source",
            video: _objectSpread2(_objectSpread2({}, baseVideoConfiguration), {}, {
              contentType: mimeTypeForCodec(videoCodec, "video")
            })
          };
        });
        if (audioCodecs && level.audioGroups) {
          level.audioGroups.forEach(function(audioGroupId) {
            var _audioTracksByGroup$g;
            if (!audioGroupId) {
              return;
            }
            (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null || _audioTracksByGroup$g.tracks.forEach(function(audioTrack) {
              if (audioTrack.groupId === audioGroupId) {
                var channels = audioTrack.channels || "";
                var channelsNumber = parseFloat(channels);
                if (isFiniteNumber(channelsNumber) && channelsNumber > 2) {
                  configurations.push.apply(configurations, audioCodecs.split(",").map(function(audioCodec) {
                    return {
                      type: "media-source",
                      audio: {
                        contentType: mimeTypeForCodec(audioCodec, "audio"),
                        channels: "" + channelsNumber
                      }
                    };
                  }));
                }
              }
            });
          });
        }
        return Promise.all(configurations.map(function(configuration) {
          var decodingInfoKey = getMediaDecodingInfoKey(configuration);
          return SUPPORTED_INFO_CACHE[decodingInfoKey] || (SUPPORTED_INFO_CACHE[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));
        })).then(function(decodingInfoResults) {
          return {
            supported: !decodingInfoResults.some(function(info) {
              return !info.supported;
            }),
            configurations,
            decodingInfoResults
          };
        }).catch(function(error2) {
          return {
            supported: false,
            configurations,
            decodingInfoResults: [],
            error: error2
          };
        });
      }
      function getMediaDecodingInfoKey(config) {
        var { audio, video } = config;
        var mediaConfig = video || audio;
        if (mediaConfig) {
          var codec = mediaConfig.contentType.split('"')[1];
          if (video) {
            return "r" + video.height + "x" + video.width + "f" + Math.ceil(video.framerate) + (video.transferFunction || "sd") + "_" + codec + "_" + Math.ceil(video.bitrate / 1e5);
          }
          if (audio) {
            return "c" + audio.channels + (audio.spatialRendering ? "s" : "n") + "_" + codec;
          }
        }
        return "";
      }
      function isHdrSupported() {
        if (typeof matchMedia === "function") {
          var mediaQueryList = matchMedia("(dynamic-range: high)");
          var badQuery = matchMedia("bad query");
          if (mediaQueryList.media !== badQuery.media) {
            return mediaQueryList.matches === true;
          }
        }
        return false;
      }
      function getVideoSelectionOptions(currentVideoRange, videoPreference) {
        var preferHDR = false;
        var allowedVideoRanges = [];
        if (currentVideoRange) {
          preferHDR = currentVideoRange !== "SDR";
          allowedVideoRanges = [currentVideoRange];
        }
        if (videoPreference) {
          allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);
          preferHDR = videoPreference.preferHDR !== undefined ? videoPreference.preferHDR : isHdrSupported();
          if (preferHDR) {
            allowedVideoRanges = allowedVideoRanges.filter(function(range) {
              return range !== "SDR";
            });
          } else {
            allowedVideoRanges = ["SDR"];
          }
        }
        return {
          preferHDR,
          allowedVideoRanges
        };
      }
      function getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {
        var codecSets = Object.keys(codecTiers);
        var channelsPreference = audioPreference == null ? undefined : audioPreference.channels;
        var audioCodecPreference = audioPreference == null ? undefined : audioPreference.audioCodec;
        var preferStereo = channelsPreference && parseInt(channelsPreference) === 2;
        var hasStereo = true;
        var hasCurrentVideoRange = false;
        var minHeight = Infinity;
        var minFramerate = Infinity;
        var minBitrate = Infinity;
        var selectedScore = 0;
        var videoRanges = [];
        var _getVideoSelectionOpt = getVideoSelectionOptions(currentVideoRange, videoPreference), preferHDR = _getVideoSelectionOpt.preferHDR, allowedVideoRanges = _getVideoSelectionOpt.allowedVideoRanges;
        var _loop = function _loop() {
          var tier = codecTiers[codecSets[i]];
          hasStereo = tier.channels[2] > 0;
          minHeight = Math.min(minHeight, tier.minHeight);
          minFramerate = Math.min(minFramerate, tier.minFramerate);
          minBitrate = Math.min(minBitrate, tier.minBitrate);
          var matchingVideoRanges = allowedVideoRanges.filter(function(range) {
            return tier.videoRanges[range] > 0;
          });
          if (matchingVideoRanges.length > 0) {
            hasCurrentVideoRange = true;
            videoRanges = matchingVideoRanges;
          }
        };
        for (var i = codecSets.length;i--; ) {
          _loop();
        }
        minHeight = isFiniteNumber(minHeight) ? minHeight : 0;
        minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;
        var maxHeight = Math.max(1080, minHeight);
        var maxFramerate = Math.max(30, minFramerate);
        minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;
        currentBw = Math.max(minBitrate, currentBw);
        if (!hasCurrentVideoRange) {
          currentVideoRange = undefined;
          videoRanges = [];
        }
        var codecSet = codecSets.reduce(function(selected, candidate) {
          var candidateTier = codecTiers[candidate];
          if (candidate === selected) {
            return selected;
          }
          if (candidateTier.minBitrate > currentBw) {
            logStartCodecCandidateIgnored(candidate, "min bitrate of " + candidateTier.minBitrate + " > current estimate of " + currentBw);
            return selected;
          }
          if (!candidateTier.hasDefaultAudio) {
            logStartCodecCandidateIgnored(candidate, "no renditions with default or auto-select sound found");
            return selected;
          }
          if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {
            logStartCodecCandidateIgnored(candidate, 'audio codec preference "' + audioCodecPreference + '" not found');
            return selected;
          }
          if (channelsPreference && !preferStereo) {
            if (!candidateTier.channels[channelsPreference]) {
              logStartCodecCandidateIgnored(candidate, "no renditions with " + channelsPreference + " channel sound found (channels options: " + Object.keys(candidateTier.channels) + ")");
              return selected;
            }
          } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels["2"] === 0) {
            logStartCodecCandidateIgnored(candidate, "no renditions with stereo sound found");
            return selected;
          }
          if (candidateTier.minHeight > maxHeight) {
            logStartCodecCandidateIgnored(candidate, "min resolution of " + candidateTier.minHeight + " > maximum of " + maxHeight);
            return selected;
          }
          if (candidateTier.minFramerate > maxFramerate) {
            logStartCodecCandidateIgnored(candidate, "min framerate of " + candidateTier.minFramerate + " > maximum of " + maxFramerate);
            return selected;
          }
          if (!videoRanges.some(function(range) {
            return candidateTier.videoRanges[range] > 0;
          })) {
            logStartCodecCandidateIgnored(candidate, "no variants with VIDEO-RANGE of " + JSON.stringify(videoRanges) + " found");
            return selected;
          }
          if (candidateTier.maxScore < selectedScore) {
            logStartCodecCandidateIgnored(candidate, "max score of " + candidateTier.maxScore + " < selected max of " + selectedScore);
            return selected;
          }
          if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {
            return selected;
          }
          selectedScore = candidateTier.maxScore;
          return candidate;
        }, undefined);
        return {
          codecSet,
          videoRanges,
          preferHDR,
          minFramerate,
          minBitrate
        };
      }
      function logStartCodecCandidateIgnored(codeSet, reason) {
        logger.log('[abr] start candidates with "' + codeSet + '" ignored because ' + reason);
      }
      function getAudioTracksByGroup(allAudioTracks) {
        return allAudioTracks.reduce(function(audioTracksByGroup, track) {
          var trackGroup = audioTracksByGroup.groups[track.groupId];
          if (!trackGroup) {
            trackGroup = audioTracksByGroup.groups[track.groupId] = {
              tracks: [],
              channels: {
                2: 0
              },
              hasDefault: false,
              hasAutoSelect: false
            };
          }
          trackGroup.tracks.push(track);
          var channelsKey = track.channels || "2";
          trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;
          trackGroup.hasDefault = trackGroup.hasDefault || track.default;
          trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;
          if (trackGroup.hasDefault) {
            audioTracksByGroup.hasDefaultAudio = true;
          }
          if (trackGroup.hasAutoSelect) {
            audioTracksByGroup.hasAutoSelectAudio = true;
          }
          return audioTracksByGroup;
        }, {
          hasDefaultAudio: false,
          hasAutoSelectAudio: false,
          groups: {}
        });
      }
      function getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {
        return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce(function(tiers, level) {
          if (!level.codecSet) {
            return tiers;
          }
          var audioGroups = level.audioGroups;
          var tier = tiers[level.codecSet];
          if (!tier) {
            tiers[level.codecSet] = tier = {
              minBitrate: Infinity,
              minHeight: Infinity,
              minFramerate: Infinity,
              maxScore: 0,
              videoRanges: {
                SDR: 0
              },
              channels: {
                "2": 0
              },
              hasDefaultAudio: !audioGroups,
              fragmentError: 0
            };
          }
          tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);
          var lesserWidthOrHeight = Math.min(level.height, level.width);
          tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);
          tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);
          tier.maxScore = Math.max(tier.maxScore, level.score);
          tier.fragmentError += level.fragmentError;
          tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;
          if (audioGroups) {
            audioGroups.forEach(function(audioGroupId) {
              if (!audioGroupId) {
                return;
              }
              var audioGroup = audioTracksByGroup.groups[audioGroupId];
              if (!audioGroup) {
                return;
              }
              tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;
              Object.keys(audioGroup.channels).forEach(function(channels) {
                tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];
              });
            });
          }
          return tiers;
        }, {});
      }
      function findMatchingOption(option, tracks, matchPredicate) {
        if ("attrs" in option) {
          var index = tracks.indexOf(option);
          if (index !== -1) {
            return index;
          }
        }
        for (var i = 0;i < tracks.length; i++) {
          var _track = tracks[i];
          if (matchesOption(option, _track, matchPredicate)) {
            return i;
          }
        }
        return -1;
      }
      function matchesOption(option, track, matchPredicate) {
        var { groupId, name, lang, assocLang, characteristics, default: isDefault } = option;
        var forced = option.forced;
        return (groupId === undefined || track.groupId === groupId) && (name === undefined || track.name === name) && (lang === undefined || track.lang === lang) && (lang === undefined || track.assocLang === assocLang) && (isDefault === undefined || track.default === isDefault) && (forced === undefined || track.forced === forced) && (characteristics === undefined || characteristicsMatch(characteristics, track.characteristics)) && (matchPredicate === undefined || matchPredicate(option, track));
      }
      function characteristicsMatch(characteristicsA, characteristicsB) {
        if (characteristicsB === undefined) {
          characteristicsB = "";
        }
        var arrA = characteristicsA.split(",");
        var arrB = characteristicsB.split(",");
        return arrA.length === arrB.length && !arrA.some(function(el) {
          return arrB.indexOf(el) === -1;
        });
      }
      function audioMatchPredicate(option, track) {
        var { audioCodec, channels } = option;
        return (audioCodec === undefined || (track.audioCodec || "").substring(0, 4) === audioCodec.substring(0, 4)) && (channels === undefined || channels === (track.channels || "2"));
      }
      function findClosestLevelWithAudioGroup(option, levels, allAudioTracks, searchIndex, matchPredicate) {
        var currentLevel = levels[searchIndex];
        var variants = levels.reduce(function(variantMap, level, index) {
          var uri = level.uri;
          var renditions2 = variantMap[uri] || (variantMap[uri] = []);
          renditions2.push(index);
          return variantMap;
        }, {});
        var renditions = variants[currentLevel.uri];
        if (renditions.length > 1) {
          searchIndex = Math.max.apply(Math, renditions);
        }
        var currentVideoRange = currentLevel.videoRange;
        var currentFrameRate = currentLevel.frameRate;
        var currentVideoCodec = currentLevel.codecSet.substring(0, 4);
        var matchingVideo = searchDownAndUpList(levels, searchIndex, function(level) {
          if (level.videoRange !== currentVideoRange || level.frameRate !== currentFrameRate || level.codecSet.substring(0, 4) !== currentVideoCodec) {
            return false;
          }
          var audioGroups = level.audioGroups;
          var tracks = allAudioTracks.filter(function(track) {
            return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;
          });
          return findMatchingOption(option, tracks, matchPredicate) > -1;
        });
        if (matchingVideo > -1) {
          return matchingVideo;
        }
        return searchDownAndUpList(levels, searchIndex, function(level) {
          var audioGroups = level.audioGroups;
          var tracks = allAudioTracks.filter(function(track) {
            return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;
          });
          return findMatchingOption(option, tracks, matchPredicate) > -1;
        });
      }
      function searchDownAndUpList(arr, searchIndex, predicate) {
        for (var i = searchIndex;i > -1; i--) {
          if (predicate(arr[i])) {
            return i;
          }
        }
        for (var _i = searchIndex + 1;_i < arr.length; _i++) {
          if (predicate(arr[_i])) {
            return _i;
          }
        }
        return -1;
      }
      var AbrController = /* @__PURE__ */ function() {
        function AbrController2(_hls) {
          var _this = this;
          this.hls = undefined;
          this.lastLevelLoadSec = 0;
          this.lastLoadedFragLevel = -1;
          this.firstSelection = -1;
          this._nextAutoLevel = -1;
          this.nextAutoLevelKey = "";
          this.audioTracksByGroup = null;
          this.codecTiers = null;
          this.timer = -1;
          this.fragCurrent = null;
          this.partCurrent = null;
          this.bitrateTestDelay = 0;
          this.bwEstimator = undefined;
          this._abandonRulesCheck = function() {
            var { fragCurrent: frag, partCurrent: part, hls } = _this;
            var { autoLevelEnabled, media } = hls;
            if (!frag || !media) {
              return;
            }
            var now2 = performance.now();
            var stats = part ? part.stats : frag.stats;
            var duration = part ? part.duration : frag.duration;
            var timeLoading = now2 - stats.loading.start;
            var minAutoLevel = hls.minAutoLevel;
            if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level <= minAutoLevel) {
              _this.clearTimer();
              _this._nextAutoLevel = -1;
              return;
            }
            if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {
              return;
            }
            var bufferInfo = hls.mainForwardBufferInfo;
            if (bufferInfo === null) {
              return;
            }
            var ttfbEstimate = _this.bwEstimator.getEstimateTTFB();
            var playbackRate = Math.abs(media.playbackRate);
            if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {
              return;
            }
            var bufferStarvationDelay = bufferInfo.len / playbackRate;
            var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
            var loadedFirstByte = stats.loaded && ttfb > -1;
            var bwEstimate = _this.getBwEstimate();
            var levels = hls.levels;
            var level = levels[frag.level];
            var expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.averageBitrate / 8));
            var timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;
            if (timeStreaming < 1 && loadedFirstByte) {
              timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);
            }
            var loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;
            var fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1000;
            if (fragLoadedDelay <= bufferStarvationDelay) {
              return;
            }
            var bwe = loadRate ? loadRate * 8 : bwEstimate;
            var fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;
            var nextLoadLevel;
            for (nextLoadLevel = frag.level - 1;nextLoadLevel > minAutoLevel; nextLoadLevel--) {
              var levelNextBitrate = levels[nextLoadLevel].maxBitrate;
              fragLevelNextLoadedDelay = _this.getTimeToLoadFrag(ttfbEstimate / 1000, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);
              if (fragLevelNextLoadedDelay < bufferStarvationDelay) {
                break;
              }
            }
            if (fragLevelNextLoadedDelay >= fragLoadedDelay) {
              return;
            }
            if (fragLevelNextLoadedDelay > duration * 10) {
              return;
            }
            hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;
            if (loadedFirstByte) {
              _this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
            } else {
              _this.bwEstimator.sampleTTFB(timeLoading);
            }
            var nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;
            if (_this.getBwEstimate() * _this.hls.config.abrBandWidthUpFactor > nextLoadLevelBitrate) {
              _this.resetEstimator(nextLoadLevelBitrate);
            }
            _this.clearTimer();
            logger.warn("[abr] Fragment " + frag.sn + (part ? " part " + part.index : "") + " of level " + frag.level + ` is loading too slowly;
      Time to underbuffer: ` + bufferStarvationDelay.toFixed(3) + ` s
      Estimated load time for current fragment: ` + fragLoadedDelay.toFixed(3) + ` s
      Estimated load time for down switch fragment: ` + fragLevelNextLoadedDelay.toFixed(3) + ` s
      TTFB estimate: ` + (ttfb | 0) + ` ms
      Current BW estimate: ` + (isFiniteNumber(bwEstimate) ? bwEstimate | 0 : "Unknown") + ` bps
      New BW estimate: ` + (_this.getBwEstimate() | 0) + ` bps
      Switching to level ` + nextLoadLevel + " @ " + (nextLoadLevelBitrate | 0) + " bps");
            hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {
              frag,
              part,
              stats
            });
          };
          this.hls = _hls;
          this.bwEstimator = this.initEstimator();
          this.registerListeners();
        }
        var _proto = AbrController2.prototype;
        _proto.resetEstimator = function resetEstimator(abrEwmaDefaultEstimate) {
          if (abrEwmaDefaultEstimate) {
            logger.log("setting initial bwe to " + abrEwmaDefaultEstimate);
            this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;
          }
          this.firstSelection = -1;
          this.bwEstimator = this.initEstimator();
        };
        _proto.initEstimator = function initEstimator() {
          var config = this.hls.config;
          return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);
        };
        _proto.registerListeners = function registerListeners() {
          var hls = this.hls;
          hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
          hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
          hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
          hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
          hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
          hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
          hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
          hls.on(Events.ERROR, this.onError, this);
        };
        _proto.unregisterListeners = function unregisterListeners() {
          var hls = this.hls;
          if (!hls) {
            return;
          }
          hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
          hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
          hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
          hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
          hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
          hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
          hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);
          hls.off(Events.ERROR, this.onError, this);
        };
        _proto.destroy = function destroy() {
          this.unregisterListeners();
          this.clearTimer();
          this.hls = this._abandonRulesCheck = null;
          this.fragCurrent = this.partCurrent = null;
        };
        _proto.onManifestLoading = function onManifestLoading(event, data) {
          this.lastLoadedFragLevel = -1;
          this.firstSelection = -1;
          this.lastLevelLoadSec = 0;
          this.fragCurrent = this.partCurrent = null;
          this.onLevelsUpdated();
          this.clearTimer();
        };
        _proto.onLevelsUpdated = function onLevelsUpdated() {
          if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {
            this.lastLoadedFragLevel = this.fragCurrent.level;
          }
          this._nextAutoLevel = -1;
          this.onMaxAutoLevelUpdated();
          this.codecTiers = null;
          this.audioTracksByGroup = null;
        };
        _proto.onMaxAutoLevelUpdated = function onMaxAutoLevelUpdated() {
          this.firstSelection = -1;
          this.nextAutoLevelKey = "";
        };
        _proto.onFragLoading = function onFragLoading(event, data) {
          var frag = data.frag;
          if (this.ignoreFragment(frag)) {
            return;
          }
          if (!frag.bitrateTest) {
            var _data$part;
            this.fragCurrent = frag;
            this.partCurrent = (_data$part = data.part) != null ? _data$part : null;
          }
          this.clearTimer();
          this.timer = self.setInterval(this._abandonRulesCheck, 100);
        };
        _proto.onLevelSwitching = function onLevelSwitching(event, data) {
          this.clearTimer();
        };
        _proto.onError = function onError(event, data) {
          if (data.fatal) {
            return;
          }
          switch (data.details) {
            case ErrorDetails.BUFFER_ADD_CODEC_ERROR:
            case ErrorDetails.BUFFER_APPEND_ERROR:
              this.lastLoadedFragLevel = -1;
              this.firstSelection = -1;
              break;
            case ErrorDetails.FRAG_LOAD_TIMEOUT: {
              var frag = data.frag;
              var fragCurrent = this.fragCurrent, part = this.partCurrent;
              if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {
                var now2 = performance.now();
                var stats = part ? part.stats : frag.stats;
                var timeLoading = now2 - stats.loading.start;
                var ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;
                var loadedFirstByte = stats.loaded && ttfb > -1;
                if (loadedFirstByte) {
                  var ttfbEstimate = this.bwEstimator.getEstimateTTFB();
                  this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);
                } else {
                  this.bwEstimator.sampleTTFB(timeLoading);
                }
              }
              break;
            }
          }
        };
        _proto.getTimeToLoadFrag = function getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {
          var fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;
          var playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;
          return fragLoadSec + playlistLoadSec;
        };
        _proto.onLevelLoaded = function onLevelLoaded(event, data) {
          var config = this.hls.config;
          var loading = data.stats.loading;
          var timeLoadingMs = loading.end - loading.start;
          if (isFiniteNumber(timeLoadingMs)) {
            this.lastLevelLoadSec = timeLoadingMs / 1000;
          }
          if (data.details.live) {
            this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);
          } else {
            this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);
          }
        };
        _proto.onFragLoaded = function onFragLoaded(event, _ref) {
          var { frag, part } = _ref;
          var stats = part ? part.stats : frag.stats;
          if (frag.type === PlaylistLevelType.MAIN) {
            this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);
          }
          if (this.ignoreFragment(frag)) {
            return;
          }
          this.clearTimer();
          if (frag.level === this._nextAutoLevel) {
            this._nextAutoLevel = -1;
          }
          this.firstSelection = -1;
          if (this.hls.config.abrMaxWithRealBitrate) {
            var duration = part ? part.duration : frag.duration;
            var level = this.hls.levels[frag.level];
            var loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;
            var loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;
            level.loaded = {
              bytes: loadedBytes,
              duration: loadedDuration
            };
            level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);
          }
          if (frag.bitrateTest) {
            var fragBufferedData = {
              stats,
              frag,
              part,
              id: frag.type
            };
            this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);
            frag.bitrateTest = false;
          } else {
            this.lastLoadedFragLevel = frag.level;
          }
        };
        _proto.onFragBuffered = function onFragBuffered(event, data) {
          var { frag, part } = data;
          var stats = part != null && part.stats.loaded ? part.stats : frag.stats;
          if (stats.aborted) {
            return;
          }
          if (this.ignoreFragment(frag)) {
            return;
          }
          var processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());
          this.bwEstimator.sample(processingMs, stats.loaded);
          stats.bwEstimate = this.getBwEstimate();
          if (frag.bitrateTest) {
            this.bitrateTestDelay = processingMs / 1000;
          } else {
            this.bitrateTestDelay = 0;
          }
        };
        _proto.ignoreFragment = function ignoreFragment(frag) {
          return frag.type !== PlaylistLevelType.MAIN || frag.sn === "initSegment";
        };
        _proto.clearTimer = function clearTimer() {
          if (this.timer > -1) {
            self.clearInterval(this.timer);
            this.timer = -1;
          }
        };
        _proto.getAutoLevelKey = function getAutoLevelKey() {
          return this.getBwEstimate() + "_" + this.getStarvationDelay().toFixed(2);
        };
        _proto.getNextABRAutoLevel = function getNextABRAutoLevel() {
          var fragCurrent = this.fragCurrent, partCurrent = this.partCurrent, hls = this.hls;
          var { maxAutoLevel, config, minAutoLevel } = hls;
          var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
          var avgbw = this.getBwEstimate();
          var bufferStarvationDelay = this.getStarvationDelay();
          var bwFactor = config.abrBandWidthFactor;
          var bwUpFactor = config.abrBandWidthUpFactor;
          if (bufferStarvationDelay) {
            var _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);
            if (_bestLevel >= 0) {
              return _bestLevel;
            }
          }
          var maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;
          if (!bufferStarvationDelay) {
            var bitrateTestDelay = this.bitrateTestDelay;
            if (bitrateTestDelay) {
              var maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;
              maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;
              logger.info("[abr] bitrate test took " + Math.round(1000 * bitrateTestDelay) + "ms, set first fragment max fetchDuration to " + Math.round(1000 * maxStarvationDelay) + " ms");
              bwFactor = bwUpFactor = 1;
            }
          }
          var bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);
          logger.info("[abr] " + (bufferStarvationDelay ? "rebuffering expected" : "buffer is empty") + ", optimal quality level " + bestLevel);
          if (bestLevel > -1) {
            return bestLevel;
          }
          var minLevel = hls.levels[minAutoLevel];
          var autoLevel = hls.levels[hls.loadLevel];
          if ((minLevel == null ? undefined : minLevel.bitrate) < (autoLevel == null ? undefined : autoLevel.bitrate)) {
            return minAutoLevel;
          }
          return hls.loadLevel;
        };
        _proto.getStarvationDelay = function getStarvationDelay() {
          var hls = this.hls;
          var media = hls.media;
          if (!media) {
            return Infinity;
          }
          var playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1;
          var bufferInfo = hls.mainForwardBufferInfo;
          return (bufferInfo ? bufferInfo.len : 0) / playbackRate;
        };
        _proto.getBwEstimate = function getBwEstimate() {
          return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;
        };
        _proto.findBestLevel = function findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {
          var _level$details, _this2 = this;
          var maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;
          var lastLoadedFragLevel = this.lastLoadedFragLevel;
          var selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;
          var fragCurrent = this.fragCurrent, partCurrent = this.partCurrent;
          var _this$hls = this.hls, levels = _this$hls.levels, allAudioTracks = _this$hls.allAudioTracks, loadLevel = _this$hls.loadLevel, config = _this$hls.config;
          if (levels.length === 1) {
            return 0;
          }
          var level = levels[selectionBaseLevel];
          var live = !!(level != null && (_level$details = level.details) != null && _level$details.live);
          var firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;
          var currentCodecSet;
          var currentVideoRange = "SDR";
          var currentFrameRate = (level == null ? undefined : level.frameRate) || 0;
          var { audioPreference, videoPreference } = config;
          var audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));
          if (firstSelection) {
            if (this.firstSelection !== -1) {
              return this.firstSelection;
            }
            var codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));
            var startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);
            var { codecSet, videoRanges, minFramerate, minBitrate, preferHDR } = startTier;
            currentCodecSet = codecSet;
            currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];
            currentFrameRate = minFramerate;
            currentBw = Math.max(currentBw, minBitrate);
            logger.log("[abr] picked start tier " + JSON.stringify(startTier));
          } else {
            currentCodecSet = level == null ? undefined : level.codecSet;
            currentVideoRange = level == null ? undefined : level.videoRange;
          }
          var currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;
          var ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;
          var levelsSkipped = [];
          var _loop = function _loop() {
            var _levelInfo$supportedR;
            var levelInfo = levels[i];
            var upSwitch = i > selectionBaseLevel;
            if (!levelInfo) {
              return 0;
            }
            if (config.useMediaCapabilities && !levelInfo.supportedResult && !levelInfo.supportedPromise) {
              var mediaCapabilities = navigator.mediaCapabilities;
              if (typeof (mediaCapabilities == null ? undefined : mediaCapabilities.decodingInfo) === "function" && requiresMediaCapabilitiesDecodingInfo(levelInfo, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference)) {
                levelInfo.supportedPromise = getMediaDecodingInfoPromise(levelInfo, audioTracksByGroup, mediaCapabilities);
                levelInfo.supportedPromise.then(function(decodingInfo) {
                  if (!_this2.hls) {
                    return;
                  }
                  levelInfo.supportedResult = decodingInfo;
                  var levels2 = _this2.hls.levels;
                  var index = levels2.indexOf(levelInfo);
                  if (decodingInfo.error) {
                    logger.warn('[abr] MediaCapabilities decodingInfo error: "' + decodingInfo.error + '" for level ' + index + " " + JSON.stringify(decodingInfo));
                  } else if (!decodingInfo.supported) {
                    logger.warn("[abr] Unsupported MediaCapabilities decodingInfo result for level " + index + " " + JSON.stringify(decodingInfo));
                    if (index > -1 && levels2.length > 1) {
                      logger.log("[abr] Removing unsupported level " + index);
                      _this2.hls.removeLevel(index);
                    }
                  }
                });
              } else {
                levelInfo.supportedResult = SUPPORTED_INFO_DEFAULT;
              }
            }
            if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || levelInfo.supportedResult && !((_levelInfo$supportedR = levelInfo.supportedResult.decodingInfoResults) != null && _levelInfo$supportedR[0].smooth)) {
              levelsSkipped.push(i);
              return 0;
            }
            var levelDetails = levelInfo.details;
            var avgDuration = (partCurrent ? levelDetails == null ? undefined : levelDetails.partTarget : levelDetails == null ? undefined : levelDetails.averagetargetduration) || currentFragDuration;
            var adjustedbw;
            if (!upSwitch) {
              adjustedbw = bwFactor * currentBw;
            } else {
              adjustedbw = bwUpFactor * currentBw;
            }
            var bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levels[i].averageBitrate : levels[i].maxBitrate;
            var fetchDuration = _this2.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);
            var canSwitchWithinTolerance = adjustedbw >= bitrate && (i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && (fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !_this2.bitrateTestDelay || fetchDuration < maxFetchDuration);
            if (canSwitchWithinTolerance) {
              var forcedAutoLevel = _this2.forcedAutoLevel;
              if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {
                if (levelsSkipped.length) {
                  logger.trace("[abr] Skipped level(s) " + levelsSkipped.join(",") + " of " + maxAutoLevel + ' max with CODECS and VIDEO-RANGE:"' + levels[levelsSkipped[0]].codecs + '" ' + levels[levelsSkipped[0]].videoRange + '; not compatible with "' + level.codecs + '" ' + currentVideoRange);
                }
                logger.info("[abr] switch candidate:" + selectionBaseLevel + "->" + i + " adjustedbw(" + Math.round(adjustedbw) + ")-bitrate=" + Math.round(adjustedbw - bitrate) + " ttfb:" + ttfbEstimateSec.toFixed(1) + " avgDuration:" + avgDuration.toFixed(1) + " maxFetchDuration:" + maxFetchDuration.toFixed(1) + " fetchDuration:" + fetchDuration.toFixed(1) + " firstSelection:" + firstSelection + " codecSet:" + currentCodecSet + " videoRange:" + currentVideoRange + " hls.loadLevel:" + loadLevel);
              }
              if (firstSelection) {
                _this2.firstSelection = i;
              }
              return {
                v: i
              };
            }
          }, _ret;
          for (var i = maxAutoLevel;i >= minAutoLevel; i--) {
            _ret = _loop();
            if (_ret === 0)
              continue;
            if (_ret)
              return _ret.v;
          }
          return -1;
        };
        _createClass(AbrController2, [{
          key: "firstAutoLevel",
          get: function get() {
            var _this$hls2 = this.hls, maxAutoLevel = _this$hls2.maxAutoLevel, minAutoLevel = _this$hls2.minAutoLevel;
            var bwEstimate = this.getBwEstimate();
            var maxStartDelay = this.hls.config.maxStarvationDelay;
            var abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);
            if (abrAutoLevel > -1) {
              return abrAutoLevel;
            }
            var firstLevel = this.hls.firstLevel;
            var clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);
            logger.warn("[abr] Could not find best starting auto level. Defaulting to first in playlist " + firstLevel + " clamped to " + clamped);
            return clamped;
          }
        }, {
          key: "forcedAutoLevel",
          get: function get() {
            if (this.nextAutoLevelKey) {
              return -1;
            }
            return this._nextAutoLevel;
          }
        }, {
          key: "nextAutoLevel",
          get: function get() {
            var forcedAutoLevel = this.forcedAutoLevel;
            var bwEstimator = this.bwEstimator;
            var useEstimate = bwEstimator.canEstimate();
            var loadedFirstFrag = this.lastLoadedFragLevel > -1;
            if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {
              return forcedAutoLevel;
            }
            var nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;
            if (forcedAutoLevel !== -1) {
              var levels = this.hls.levels;
              if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {
                return forcedAutoLevel;
              }
            }
            this._nextAutoLevel = nextABRAutoLevel;
            this.nextAutoLevelKey = this.getAutoLevelKey();
            return nextABRAutoLevel;
          },
          set: function set(nextLevel) {
            var _this$hls3 = this.hls, maxAutoLevel = _this$hls3.maxAutoLevel, minAutoLevel = _this$hls3.minAutoLevel;
            var value = Math.min(Math.max(nextLevel, minAutoLevel), maxAutoLevel);
            if (this._nextAutoLevel !== value) {
              this.nextAutoLevelKey = "";
              this._nextAutoLevel = value;
            }
          }
        }]);
        return AbrController2;
      }();
      var TaskLoop = /* @__PURE__ */ function() {
        function TaskLoop2() {
          this._boundTick = undefined;
          this._tickTimer = null;
          this._tickInterval = null;
          this._tickCallCount = 0;
          this._boundTick = this.tick.bind(this);
        }
        var _proto = TaskLoop2.prototype;
        _proto.destroy = function destroy() {
          this.onHandlerDestroying();
          this.onHandlerDestroyed();
        };
        _proto.onHandlerDestroying = function onHandlerDestroying() {
          this.clearNextTick();
          this.clearInterval();
        };
        _proto.onHandlerDestroyed = function onHandlerDestroyed() {
        };
        _proto.hasInterval = function hasInterval() {
          return !!this._tickInterval;
        };
        _proto.hasNextTick = function hasNextTick() {
          return !!this._tickTimer;
        };
        _proto.setInterval = function setInterval(millis) {
          if (!this._tickInterval) {
            this._tickCallCount = 0;
            this._tickInterval = self.setInterval(this._boundTick, millis);
            return true;
          }
          return false;
        };
        _proto.clearInterval = function clearInterval() {
          if (this._tickInterval) {
            self.clearInterval(this._tickInterval);
            this._tickInterval = null;
            return true;
          }
          return false;
        };
        _proto.clearNextTick = function clearNextTick() {
          if (this._tickTimer) {
            self.clearTimeout(this._tickTimer);
            this._tickTimer = null;
            return true;
          }
          return false;
        };
        _proto.tick = function tick() {
          this._tickCallCount++;
          if (this._tickCallCount === 1) {
            this.doTick();
            if (this._tickCallCount > 1) {
              this.tickImmediate();
            }
            this._tickCallCount = 0;
          }
        };
        _proto.tickImmediate = function tickImmediate() {
          this.clearNextTick();
          this._tickTimer = self.setTimeout(this._boundTick, 0);
        };
        _proto.doTick = function doTick() {
        };
        return TaskLoop2;
      }();
      var FragmentState = {
        NOT_LOADED: "NOT_LOADED",
        APPENDING: "APPENDING",
        PARTIAL: "PARTIAL",
        OK: "OK"
      };
      var FragmentTracker = /* @__PURE__ */ function() {
        function FragmentTracker2(hls) {
          this.activePartLists = Object.create(null);
          this.endListFragments = Object.create(null);
          this.fragments = Object.create(null);
          this.timeRanges = Object.create(null);
          this.bufferPadding = 0.2;
          this.hls = undefined;
          this.hasGaps = false;
          this.hls = hls;
          this._registerListeners();
        }
        var _proto = FragmentTracker2.prototype;
        _proto._registerListeners = function _registerListeners() {
          var hls = this.hls;
          hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);
          hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
          hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
        };
        _proto._unregisterListeners = function _unregisterListeners() {
          var hls = this.hls;
          hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);
          hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
          hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
        };
        _proto.destroy = function destroy() {
          this._unregisterListeners();
          this.fragments = this.activePartLists = this.endListFragments = this.timeRanges = null;
        };
        _proto.getAppendedFrag = function getAppendedFrag(position, levelType) {
          var activeParts = this.activePartLists[levelType];
          if (activeParts) {
            for (var i = activeParts.length;i--; ) {
              var activePart = activeParts[i];
              if (!activePart) {
                break;
              }
              var appendedPTS = activePart.end;
              if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {
                return activePart;
              }
            }
          }
          return this.getBufferedFrag(position, levelType);
        };
        _proto.getBufferedFrag = function getBufferedFrag(position, levelType) {
          var fragments = this.fragments;
          var keys = Object.keys(fragments);
          for (var i = keys.length;i--; ) {
            var fragmentEntity = fragments[keys[i]];
            if ((fragmentEntity == null ? undefined : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {
              var frag = fragmentEntity.body;
              if (frag.start <= position && position <= frag.end) {
                return frag;
              }
            }
          }
          return null;
        };
        _proto.detectEvictedFragments = function detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {
          var _this = this;
          if (this.timeRanges) {
            this.timeRanges[elementaryStream] = timeRange;
          }
          var appendedPartSn = (appendedPart == null ? undefined : appendedPart.fragment.sn) || -1;
          Object.keys(this.fragments).forEach(function(key) {
            var fragmentEntity = _this.fragments[key];
            if (!fragmentEntity) {
              return;
            }
            if (appendedPartSn >= fragmentEntity.body.sn) {
              return;
            }
            if (!fragmentEntity.buffered && !fragmentEntity.loaded) {
              if (fragmentEntity.body.type === playlistType) {
                _this.removeFragment(fragmentEntity.body);
              }
              return;
            }
            var esData = fragmentEntity.range[elementaryStream];
            if (!esData) {
              return;
            }
            esData.time.some(function(time) {
              var isNotBuffered = !_this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);
              if (isNotBuffered) {
                _this.removeFragment(fragmentEntity.body);
              }
              return isNotBuffered;
            });
          });
        };
        _proto.detectPartialFragments = function detectPartialFragments(data) {
          var _this2 = this;
          var timeRanges = this.timeRanges;
          var { frag, part } = data;
          if (!timeRanges || frag.sn === "initSegment") {
            return;
          }
          var fragKey = getFragmentKey(frag);
          var fragmentEntity = this.fragments[fragKey];
          if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {
            return;
          }
          var isFragHint = !frag.relurl;
          Object.keys(timeRanges).forEach(function(elementaryStream) {
            var streamInfo = frag.elementaryStreams[elementaryStream];
            if (!streamInfo) {
              return;
            }
            var timeRange = timeRanges[elementaryStream];
            var partial = isFragHint || streamInfo.partial === true;
            fragmentEntity.range[elementaryStream] = _this2.getBufferedTimes(frag, part, partial, timeRange);
          });
          fragmentEntity.loaded = null;
          if (Object.keys(fragmentEntity.range).length) {
            fragmentEntity.buffered = true;
            var endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;
            if (endList) {
              this.endListFragments[fragmentEntity.body.type] = fragmentEntity;
            }
            if (!isPartial(fragmentEntity)) {
              this.removeParts(frag.sn - 1, frag.type);
            }
          } else {
            this.removeFragment(fragmentEntity.body);
          }
        };
        _proto.removeParts = function removeParts(snToKeep, levelType) {
          var activeParts = this.activePartLists[levelType];
          if (!activeParts) {
            return;
          }
          this.activePartLists[levelType] = activeParts.filter(function(part) {
            return part.fragment.sn >= snToKeep;
          });
        };
        _proto.fragBuffered = function fragBuffered(frag, force) {
          var fragKey = getFragmentKey(frag);
          var fragmentEntity = this.fragments[fragKey];
          if (!fragmentEntity && force) {
            fragmentEntity = this.fragments[fragKey] = {
              body: frag,
              appendedPTS: null,
              loaded: null,
              buffered: false,
              range: Object.create(null)
            };
            if (frag.gap) {
              this.hasGaps = true;
            }
          }
          if (fragmentEntity) {
            fragmentEntity.loaded = null;
            fragmentEntity.buffered = true;
          }
        };
        _proto.getBufferedTimes = function getBufferedTimes(fragment, part, partial, timeRange) {
          var buffered = {
            time: [],
            partial
          };
          var startPTS = fragment.start;
          var endPTS = fragment.end;
          var minEndPTS = fragment.minEndPTS || endPTS;
          var maxStartPTS = fragment.maxStartPTS || startPTS;
          for (var i = 0;i < timeRange.length; i++) {
            var startTime = timeRange.start(i) - this.bufferPadding;
            var endTime = timeRange.end(i) + this.bufferPadding;
            if (maxStartPTS >= startTime && minEndPTS <= endTime) {
              buffered.time.push({
                startPTS: Math.max(startPTS, timeRange.start(i)),
                endPTS: Math.min(endPTS, timeRange.end(i))
              });
              break;
            } else if (startPTS < endTime && endPTS > startTime) {
              var start = Math.max(startPTS, timeRange.start(i));
              var end = Math.min(endPTS, timeRange.end(i));
              if (end > start) {
                buffered.partial = true;
                buffered.time.push({
                  startPTS: start,
                  endPTS: end
                });
              }
            } else if (endPTS <= startTime) {
              break;
            }
          }
          return buffered;
        };
        _proto.getPartialFragment = function getPartialFragment(time) {
          var bestFragment = null;
          var timePadding;
          var startTime;
          var endTime;
          var bestOverlap = 0;
          var bufferPadding = this.bufferPadding, fragments = this.fragments;
          Object.keys(fragments).forEach(function(key) {
            var fragmentEntity = fragments[key];
            if (!fragmentEntity) {
              return;
            }
            if (isPartial(fragmentEntity)) {
              startTime = fragmentEntity.body.start - bufferPadding;
              endTime = fragmentEntity.body.end + bufferPadding;
              if (time >= startTime && time <= endTime) {
                timePadding = Math.min(time - startTime, endTime - time);
                if (bestOverlap <= timePadding) {
                  bestFragment = fragmentEntity.body;
                  bestOverlap = timePadding;
                }
              }
            }
          });
          return bestFragment;
        };
        _proto.isEndListAppended = function isEndListAppended(type) {
          var lastFragmentEntity = this.endListFragments[type];
          return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));
        };
        _proto.getState = function getState(fragment) {
          var fragKey = getFragmentKey(fragment);
          var fragmentEntity = this.fragments[fragKey];
          if (fragmentEntity) {
            if (!fragmentEntity.buffered) {
              return FragmentState.APPENDING;
            } else if (isPartial(fragmentEntity)) {
              return FragmentState.PARTIAL;
            } else {
              return FragmentState.OK;
            }
          }
          return FragmentState.NOT_LOADED;
        };
        _proto.isTimeBuffered = function isTimeBuffered(startPTS, endPTS, timeRange) {
          var startTime;
          var endTime;
          for (var i = 0;i < timeRange.length; i++) {
            startTime = timeRange.start(i) - this.bufferPadding;
            endTime = timeRange.end(i) + this.bufferPadding;
            if (startPTS >= startTime && endPTS <= endTime) {
              return true;
            }
            if (endPTS <= startTime) {
              return false;
            }
          }
          return false;
        };
        _proto.onFragLoaded = function onFragLoaded(event, data) {
          var { frag, part } = data;
          if (frag.sn === "initSegment" || frag.bitrateTest) {
            return;
          }
          var loaded = part ? null : data;
          var fragKey = getFragmentKey(frag);
          this.fragments[fragKey] = {
            body: frag,
            appendedPTS: null,
            loaded,
            buffered: false,
            range: Object.create(null)
          };
        };
        _proto.onBufferAppended = function onBufferAppended(event, data) {
          var _this3 = this;
          var { frag, part, timeRanges } = data;
          if (frag.sn === "initSegment") {
            return;
          }
          var playlistType = frag.type;
          if (part) {
            var activeParts = this.activePartLists[playlistType];
            if (!activeParts) {
              this.activePartLists[playlistType] = activeParts = [];
            }
            activeParts.push(part);
          }
          this.timeRanges = timeRanges;
          Object.keys(timeRanges).forEach(function(elementaryStream) {
            var timeRange = timeRanges[elementaryStream];
            _this3.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);
          });
        };
        _proto.onFragBuffered = function onFragBuffered(event, data) {
          this.detectPartialFragments(data);
        };
        _proto.hasFragment = function hasFragment(fragment) {
          var fragKey = getFragmentKey(fragment);
          return !!this.fragments[fragKey];
        };
        _proto.hasParts = function hasParts(type) {
          var _this$activePartLists;
          return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);
        };
        _proto.removeFragmentsInRange = function removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {
          var _this4 = this;
          if (withGapOnly && !this.hasGaps) {
            return;
          }
          Object.keys(this.fragments).forEach(function(key) {
            var fragmentEntity = _this4.fragments[key];
            if (!fragmentEntity) {
              return;
            }
            var frag = fragmentEntity.body;
            if (frag.type !== playlistType || withGapOnly && !frag.gap) {
              return;
            }
            if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {
              _this4.removeFragment(frag);
            }
          });
        };
        _proto.removeFragment = function removeFragment(fragment) {
          var fragKey = getFragmentKey(fragment);
          fragment.stats.loaded = 0;
          fragment.clearElementaryStreamInfo();
          var activeParts = this.activePartLists[fragment.type];
          if (activeParts) {
            var snToRemove = fragment.sn;
            this.activePartLists[fragment.type] = activeParts.filter(function(part) {
              return part.fragment.sn !== snToRemove;
            });
          }
          delete this.fragments[fragKey];
          if (fragment.endList) {
            delete this.endListFragments[fragment.type];
          }
        };
        _proto.removeAllFragments = function removeAllFragments() {
          this.fragments = Object.create(null);
          this.endListFragments = Object.create(null);
          this.activePartLists = Object.create(null);
          this.hasGaps = false;
        };
        return FragmentTracker2;
      }();
      function isPartial(fragmentEntity) {
        var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;
        return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? undefined : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? undefined : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? undefined : _fragmentEntity$range3.partial));
      }
      function getFragmentKey(fragment) {
        return fragment.type + "_" + fragment.level + "_" + fragment.sn;
      }
      var noopBuffered = {
        length: 0,
        start: function start() {
          return 0;
        },
        end: function end() {
          return 0;
        }
      };
      var BufferHelper = /* @__PURE__ */ function() {
        function BufferHelper2() {
        }
        BufferHelper2.isBuffered = function isBuffered(media, position) {
          try {
            if (media) {
              var buffered = BufferHelper2.getBuffered(media);
              for (var i = 0;i < buffered.length; i++) {
                if (position >= buffered.start(i) && position <= buffered.end(i)) {
                  return true;
                }
              }
            }
          } catch (error2) {
          }
          return false;
        };
        BufferHelper2.bufferInfo = function bufferInfo(media, pos, maxHoleDuration) {
          try {
            if (media) {
              var vbuffered = BufferHelper2.getBuffered(media);
              var buffered = [];
              var i;
              for (i = 0;i < vbuffered.length; i++) {
                buffered.push({
                  start: vbuffered.start(i),
                  end: vbuffered.end(i)
                });
              }
              return this.bufferedInfo(buffered, pos, maxHoleDuration);
            }
          } catch (error2) {
          }
          return {
            len: 0,
            start: pos,
            end: pos,
            nextStart: undefined
          };
        };
        BufferHelper2.bufferedInfo = function bufferedInfo(buffered, pos, maxHoleDuration) {
          pos = Math.max(0, pos);
          buffered.sort(function(a, b) {
            var diff = a.start - b.start;
            if (diff) {
              return diff;
            } else {
              return b.end - a.end;
            }
          });
          var buffered2 = [];
          if (maxHoleDuration) {
            for (var i = 0;i < buffered.length; i++) {
              var buf2len = buffered2.length;
              if (buf2len) {
                var buf2end = buffered2[buf2len - 1].end;
                if (buffered[i].start - buf2end < maxHoleDuration) {
                  if (buffered[i].end > buf2end) {
                    buffered2[buf2len - 1].end = buffered[i].end;
                  }
                } else {
                  buffered2.push(buffered[i]);
                }
              } else {
                buffered2.push(buffered[i]);
              }
            }
          } else {
            buffered2 = buffered;
          }
          var bufferLen = 0;
          var bufferStartNext;
          var bufferStart = pos;
          var bufferEnd = pos;
          for (var _i = 0;_i < buffered2.length; _i++) {
            var start = buffered2[_i].start;
            var end = buffered2[_i].end;
            if (pos + maxHoleDuration >= start && pos < end) {
              bufferStart = start;
              bufferEnd = end;
              bufferLen = bufferEnd - pos;
            } else if (pos + maxHoleDuration < start) {
              bufferStartNext = start;
              break;
            }
          }
          return {
            len: bufferLen,
            start: bufferStart || 0,
            end: bufferEnd || 0,
            nextStart: bufferStartNext
          };
        };
        BufferHelper2.getBuffered = function getBuffered(media) {
          try {
            return media.buffered;
          } catch (e) {
            logger.log("failed to get media.buffered", e);
            return noopBuffered;
          }
        };
        return BufferHelper2;
      }();
      var ChunkMetadata = function ChunkMetadata(level, sn, id, size, part, partial) {
        if (size === undefined) {
          size = 0;
        }
        if (part === undefined) {
          part = -1;
        }
        if (partial === undefined) {
          partial = false;
        }
        this.level = undefined;
        this.sn = undefined;
        this.part = undefined;
        this.id = undefined;
        this.size = undefined;
        this.partial = undefined;
        this.transmuxing = getNewPerformanceTiming();
        this.buffering = {
          audio: getNewPerformanceTiming(),
          video: getNewPerformanceTiming(),
          audiovideo: getNewPerformanceTiming()
        };
        this.level = level;
        this.sn = sn;
        this.id = id;
        this.size = size;
        this.part = part;
        this.partial = partial;
      };
      function getNewPerformanceTiming() {
        return {
          start: 0,
          executeStart: 0,
          executeEnd: 0,
          end: 0
        };
      }
      function findFirstFragWithCC(fragments, cc) {
        for (var i = 0, len = fragments.length;i < len; i++) {
          var _fragments$i;
          if (((_fragments$i = fragments[i]) == null ? undefined : _fragments$i.cc) === cc) {
            return fragments[i];
          }
        }
        return null;
      }
      function shouldAlignOnDiscontinuities(lastFrag, switchDetails, details) {
        if (switchDetails) {
          if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {
            return true;
          }
        }
        return false;
      }
      function findDiscontinuousReferenceFrag(prevDetails, curDetails) {
        var prevFrags = prevDetails.fragments;
        var curFrags = curDetails.fragments;
        if (!curFrags.length || !prevFrags.length) {
          logger.log("No fragments to align");
          return;
        }
        var prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);
        if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {
          logger.log("No frag in previous level to align on");
          return;
        }
        return prevStartFrag;
      }
      function adjustFragmentStart(frag, sliding) {
        if (frag) {
          var start = frag.start + sliding;
          frag.start = frag.startPTS = start;
          frag.endPTS = start + frag.duration;
        }
      }
      function adjustSlidingStart(sliding, details) {
        var fragments = details.fragments;
        for (var i = 0, len = fragments.length;i < len; i++) {
          adjustFragmentStart(fragments[i], sliding);
        }
        if (details.fragmentHint) {
          adjustFragmentStart(details.fragmentHint, sliding);
        }
        details.alignedSliding = true;
      }
      function alignStream(lastFrag, switchDetails, details) {
        if (!switchDetails) {
          return;
        }
        alignDiscontinuities(lastFrag, details, switchDetails);
        if (!details.alignedSliding && switchDetails) {
          alignMediaPlaylistByPDT(details, switchDetails);
        }
        if (!details.alignedSliding && switchDetails && !details.skippedSegments) {
          adjustSliding(switchDetails, details);
        }
      }
      function alignDiscontinuities(lastFrag, details, switchDetails) {
        if (shouldAlignOnDiscontinuities(lastFrag, switchDetails, details)) {
          var referenceFrag = findDiscontinuousReferenceFrag(switchDetails, details);
          if (referenceFrag && isFiniteNumber(referenceFrag.start)) {
            logger.log("Adjusting PTS using last level due to CC increase within current level " + details.url);
            adjustSlidingStart(referenceFrag.start, details);
          }
        }
      }
      function alignMediaPlaylistByPDT(details, refDetails) {
        if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {
          return;
        }
        var fragments = details.fragments;
        var refFragments = refDetails.fragments;
        if (!fragments.length || !refFragments.length) {
          return;
        }
        var refFrag;
        var frag;
        var targetCC = Math.min(refDetails.endCC, details.endCC);
        if (refDetails.startCC < targetCC && details.startCC < targetCC) {
          refFrag = findFirstFragWithCC(refFragments, targetCC);
          frag = findFirstFragWithCC(fragments, targetCC);
        }
        if (!refFrag || !frag) {
          refFrag = refFragments[Math.floor(refFragments.length / 2)];
          frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];
        }
        var refPDT = refFrag.programDateTime;
        var targetPDT = frag.programDateTime;
        if (!refPDT || !targetPDT) {
          return;
        }
        var delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);
        adjustSlidingStart(delta, details);
      }
      var MIN_CHUNK_SIZE = Math.pow(2, 17);
      var FragmentLoader = /* @__PURE__ */ function() {
        function FragmentLoader2(config) {
          this.config = undefined;
          this.loader = null;
          this.partLoadTimeout = -1;
          this.config = config;
        }
        var _proto = FragmentLoader2.prototype;
        _proto.destroy = function destroy() {
          if (this.loader) {
            this.loader.destroy();
            this.loader = null;
          }
        };
        _proto.abort = function abort() {
          if (this.loader) {
            this.loader.abort();
          }
        };
        _proto.load = function load(frag, _onProgress) {
          var _this = this;
          var url2 = frag.url;
          if (!url2) {
            return Promise.reject(new LoadError({
              type: ErrorTypes2.NETWORK_ERROR,
              details: ErrorDetails.FRAG_LOAD_ERROR,
              fatal: false,
              frag,
              error: new Error("Fragment does not have a " + (url2 ? "part list" : "url")),
              networkDetails: null
            }));
          }
          this.abort();
          var config = this.config;
          var FragmentILoader = config.fLoader;
          var DefaultILoader = config.loader;
          return new Promise(function(resolve, reject) {
            if (_this.loader) {
              _this.loader.destroy();
            }
            if (frag.gap) {
              if (frag.tagList.some(function(tags) {
                return tags[0] === "GAP";
              })) {
                reject(createGapLoadError(frag));
                return;
              } else {
                frag.gap = false;
              }
            }
            var loader = _this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
            var loaderContext = createLoaderContext(frag);
            var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
            var loaderConfig = {
              loadPolicy,
              timeout: loadPolicy.maxLoadTimeMs,
              maxRetry: 0,
              retryDelay: 0,
              maxRetryDelay: 0,
              highWaterMark: frag.sn === "initSegment" ? Infinity : MIN_CHUNK_SIZE
            };
            frag.stats = loader.stats;
            loader.load(loaderContext, loaderConfig, {
              onSuccess: function onSuccess(response, stats, context, networkDetails) {
                _this.resetLoader(frag, loader);
                var payload = response.data;
                if (context.resetIV && frag.decryptdata) {
                  frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));
                  payload = payload.slice(16);
                }
                resolve({
                  frag,
                  part: null,
                  payload,
                  networkDetails
                });
              },
              onError: function onError(response, context, networkDetails, stats) {
                _this.resetLoader(frag, loader);
                reject(new LoadError({
                  type: ErrorTypes2.NETWORK_ERROR,
                  details: ErrorDetails.FRAG_LOAD_ERROR,
                  fatal: false,
                  frag,
                  response: _objectSpread2({
                    url: url2,
                    data: undefined
                  }, response),
                  error: new Error("HTTP Error " + response.code + " " + response.text),
                  networkDetails,
                  stats
                }));
              },
              onAbort: function onAbort(stats, context, networkDetails) {
                _this.resetLoader(frag, loader);
                reject(new LoadError({
                  type: ErrorTypes2.NETWORK_ERROR,
                  details: ErrorDetails.INTERNAL_ABORTED,
                  fatal: false,
                  frag,
                  error: new Error("Aborted"),
                  networkDetails,
                  stats
                }));
              },
              onTimeout: function onTimeout(stats, context, networkDetails) {
                _this.resetLoader(frag, loader);
                reject(new LoadError({
                  type: ErrorTypes2.NETWORK_ERROR,
                  details: ErrorDetails.FRAG_LOAD_TIMEOUT,
                  fatal: false,
                  frag,
                  error: new Error("Timeout after " + loaderConfig.timeout + "ms"),
                  networkDetails,
                  stats
                }));
              },
              onProgress: function onProgress(stats, context, data, networkDetails) {
                if (_onProgress) {
                  _onProgress({
                    frag,
                    part: null,
                    payload: data,
                    networkDetails
                  });
                }
              }
            });
          });
        };
        _proto.loadPart = function loadPart(frag, part, onProgress) {
          var _this2 = this;
          this.abort();
          var config = this.config;
          var FragmentILoader = config.fLoader;
          var DefaultILoader = config.loader;
          return new Promise(function(resolve, reject) {
            if (_this2.loader) {
              _this2.loader.destroy();
            }
            if (frag.gap || part.gap) {
              reject(createGapLoadError(frag, part));
              return;
            }
            var loader = _this2.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);
            var loaderContext = createLoaderContext(frag, part);
            var loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);
            var loaderConfig = {
              loadPolicy,
              timeout: loadPolicy.maxLoadTimeMs,
              maxRetry: 0,
              retryDelay: 0,
              maxRetryDelay: 0,
              highWaterMark: MIN_CHUNK_SIZE
            };
            part.stats = loader.stats;
            loader.load(loaderContext, loaderConfig, {
              onSuccess: function onSuccess(response, stats, context, networkDetails) {
                _this2.resetLoader(frag, loader);
                _this2.updateStatsFromPart(frag, part);
                var partLoadedData = {
                  frag,
                  part,
                  payload: response.data,
                  networkDetails
                };
                onProgress(partLoadedData);
                resolve(partLoadedData);
              },
              onError: function onError(response, context, networkDetails, stats) {
                _this2.resetLoader(frag, loader);
                reject(new LoadError({
                  type: ErrorTypes2.NETWORK_ERROR,
                  details: ErrorDetails.FRAG_LOAD_ERROR,
                  fatal: false,
                  frag,
                  part,
                  response: _objectSpread2({
                    url: loaderContext.url,
                    data: undefined
                  }, response),
                  error: new Error("HTTP Error " + response.code + " " + response.text),
                  networkDetails,
                  stats
                }));
              },
              onAbort: function onAbort(stats, context, networkDetails) {
                frag.stats.aborted = part.stats.aborted;
                _this2.resetLoader(frag, loader);
                reject(new LoadError({
                  type: ErrorTypes2.NETWORK_ERROR,
                  details: ErrorDetails.INTERNAL_ABORTED,
                  fatal: false,
                  frag,
                  part,
                  error: new Error("Aborted"),
                  networkDetails,
                  stats
                }));
              },
              onTimeout: function onTimeout(stats, context, networkDetails) {
                _this2.resetLoader(frag, loader);
                reject(new LoadError({
                  type: ErrorTypes2.NETWORK_ERROR,
                  details: ErrorDetails.FRAG_LOAD_TIMEOUT,
                  fatal: false,
                  frag,
                  part,
                  error: new Error("Timeout after " + loaderConfig.timeout + "ms"),
                  networkDetails,
                  stats
                }));
              }
            });
          });
        };
        _proto.updateStatsFromPart = function updateStatsFromPart(frag, part) {
          var fragStats = frag.stats;
          var partStats = part.stats;
          var partTotal = partStats.total;
          fragStats.loaded += partStats.loaded;
          if (partTotal) {
            var estTotalParts = Math.round(frag.duration / part.duration);
            var estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);
            var estRemainingParts = estTotalParts - estLoadedParts;
            var estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);
            fragStats.total = fragStats.loaded + estRemainingBytes;
          } else {
            fragStats.total = Math.max(fragStats.loaded, fragStats.total);
          }
          var fragLoading = fragStats.loading;
          var partLoading = partStats.loading;
          if (fragLoading.start) {
            fragLoading.first += partLoading.first - partLoading.start;
          } else {
            fragLoading.start = partLoading.start;
            fragLoading.first = partLoading.first;
          }
          fragLoading.end = partLoading.end;
        };
        _proto.resetLoader = function resetLoader(frag, loader) {
          frag.loader = null;
          if (this.loader === loader) {
            self.clearTimeout(this.partLoadTimeout);
            this.loader = null;
          }
          loader.destroy();
        };
        return FragmentLoader2;
      }();
      function createLoaderContext(frag, part) {
        if (part === undefined) {
          part = null;
        }
        var segment = part || frag;
        var loaderContext = {
          frag,
          part,
          responseType: "arraybuffer",
          url: segment.url,
          headers: {},
          rangeStart: 0,
          rangeEnd: 0
        };
        var start = segment.byteRangeStartOffset;
        var end = segment.byteRangeEndOffset;
        if (isFiniteNumber(start) && isFiniteNumber(end)) {
          var _frag$decryptdata;
          var byteRangeStart = start;
          var byteRangeEnd = end;
          if (frag.sn === "initSegment" && ((_frag$decryptdata = frag.decryptdata) == null ? undefined : _frag$decryptdata.method) === "AES-128") {
            var fragmentLen = end - start;
            if (fragmentLen % 16) {
              byteRangeEnd = end + (16 - fragmentLen % 16);
            }
            if (start !== 0) {
              loaderContext.resetIV = true;
              byteRangeStart = start - 16;
            }
          }
          loaderContext.rangeStart = byteRangeStart;
          loaderContext.rangeEnd = byteRangeEnd;
        }
        return loaderContext;
      }
      function createGapLoadError(frag, part) {
        var error2 = new Error("GAP " + (frag.gap ? "tag" : "attribute") + " found");
        var errorData = {
          type: ErrorTypes2.MEDIA_ERROR,
          details: ErrorDetails.FRAG_GAP,
          fatal: false,
          frag,
          error: error2,
          networkDetails: null
        };
        if (part) {
          errorData.part = part;
        }
        (part ? part : frag).stats.aborted = true;
        return new LoadError(errorData);
      }
      var LoadError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(LoadError2, _Error);
        function LoadError2(data) {
          var _this3;
          _this3 = _Error.call(this, data.error.message) || this;
          _this3.data = undefined;
          _this3.data = data;
          return _this3;
        }
        return LoadError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      var AESCrypto = /* @__PURE__ */ function() {
        function AESCrypto2(subtle, iv) {
          this.subtle = undefined;
          this.aesIV = undefined;
          this.subtle = subtle;
          this.aesIV = iv;
        }
        var _proto = AESCrypto2.prototype;
        _proto.decrypt = function decrypt(data, key) {
          return this.subtle.decrypt({
            name: "AES-CBC",
            iv: this.aesIV
          }, key, data);
        };
        return AESCrypto2;
      }();
      var FastAESKey = /* @__PURE__ */ function() {
        function FastAESKey2(subtle, key) {
          this.subtle = undefined;
          this.key = undefined;
          this.subtle = subtle;
          this.key = key;
        }
        var _proto = FastAESKey2.prototype;
        _proto.expandKey = function expandKey() {
          return this.subtle.importKey("raw", this.key, {
            name: "AES-CBC"
          }, false, ["encrypt", "decrypt"]);
        };
        return FastAESKey2;
      }();
      function removePadding(array) {
        var outputBytes = array.byteLength;
        var paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);
        if (paddingBytes) {
          return sliceUint8(array, 0, outputBytes - paddingBytes);
        }
        return array;
      }
      var AESDecryptor = /* @__PURE__ */ function() {
        function AESDecryptor2() {
          this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
          this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
          this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];
          this.sBox = new Uint32Array(256);
          this.invSBox = new Uint32Array(256);
          this.key = new Uint32Array(0);
          this.ksRows = 0;
          this.keySize = 0;
          this.keySchedule = undefined;
          this.invKeySchedule = undefined;
          this.initTable();
        }
        var _proto = AESDecryptor2.prototype;
        _proto.uint8ArrayToUint32Array_ = function uint8ArrayToUint32Array_(arrayBuffer) {
          var view = new DataView(arrayBuffer);
          var newArray = new Uint32Array(4);
          for (var i = 0;i < 4; i++) {
            newArray[i] = view.getUint32(i * 4);
          }
          return newArray;
        };
        _proto.initTable = function initTable() {
          var sBox = this.sBox;
          var invSBox = this.invSBox;
          var subMix = this.subMix;
          var subMix0 = subMix[0];
          var subMix1 = subMix[1];
          var subMix2 = subMix[2];
          var subMix3 = subMix[3];
          var invSubMix = this.invSubMix;
          var invSubMix0 = invSubMix[0];
          var invSubMix1 = invSubMix[1];
          var invSubMix2 = invSubMix[2];
          var invSubMix3 = invSubMix[3];
          var d = new Uint32Array(256);
          var x = 0;
          var xi = 0;
          var i = 0;
          for (i = 0;i < 256; i++) {
            if (i < 128) {
              d[i] = i << 1;
            } else {
              d[i] = i << 1 ^ 283;
            }
          }
          for (i = 0;i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            sBox[x] = sx;
            invSBox[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t = d[sx] * 257 ^ sx * 16843008;
            subMix0[x] = t << 24 | t >>> 8;
            subMix1[x] = t << 16 | t >>> 16;
            subMix2[x] = t << 8 | t >>> 24;
            subMix3[x] = t;
            t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            invSubMix0[sx] = t << 24 | t >>> 8;
            invSubMix1[sx] = t << 16 | t >>> 16;
            invSubMix2[sx] = t << 8 | t >>> 24;
            invSubMix3[sx] = t;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            }
          }
        };
        _proto.expandKey = function expandKey(keyBuffer) {
          var key = this.uint8ArrayToUint32Array_(keyBuffer);
          var sameKey = true;
          var offset = 0;
          while (offset < key.length && sameKey) {
            sameKey = key[offset] === this.key[offset];
            offset++;
          }
          if (sameKey) {
            return;
          }
          this.key = key;
          var keySize = this.keySize = key.length;
          if (keySize !== 4 && keySize !== 6 && keySize !== 8) {
            throw new Error("Invalid aes key size=" + keySize);
          }
          var ksRows = this.ksRows = (keySize + 6 + 1) * 4;
          var ksRow;
          var invKsRow;
          var keySchedule = this.keySchedule = new Uint32Array(ksRows);
          var invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);
          var sbox = this.sBox;
          var rcon = this.rcon;
          var invSubMix = this.invSubMix;
          var invSubMix0 = invSubMix[0];
          var invSubMix1 = invSubMix[1];
          var invSubMix2 = invSubMix[2];
          var invSubMix3 = invSubMix[3];
          var prev;
          var t;
          for (ksRow = 0;ksRow < ksRows; ksRow++) {
            if (ksRow < keySize) {
              prev = keySchedule[ksRow] = key[ksRow];
              continue;
            }
            t = prev;
            if (ksRow % keySize === 0) {
              t = t << 8 | t >>> 24;
              t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
              t ^= rcon[ksRow / keySize | 0] << 24;
            } else if (keySize > 6 && ksRow % keySize === 4) {
              t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 255] << 16 | sbox[t >>> 8 & 255] << 8 | sbox[t & 255];
            }
            keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;
          }
          for (invKsRow = 0;invKsRow < ksRows; invKsRow++) {
            ksRow = ksRows - invKsRow;
            if (invKsRow & 3) {
              t = keySchedule[ksRow];
            } else {
              t = keySchedule[ksRow - 4];
            }
            if (invKsRow < 4 || ksRow <= 4) {
              invKeySchedule[invKsRow] = t;
            } else {
              invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 255]] ^ invSubMix2[sbox[t >>> 8 & 255]] ^ invSubMix3[sbox[t & 255]];
            }
            invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;
          }
        };
        _proto.networkToHostOrderSwap = function networkToHostOrderSwap(word) {
          return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
        };
        _proto.decrypt = function decrypt(inputArrayBuffer, offset, aesIV) {
          var nRounds = this.keySize + 6;
          var invKeySchedule = this.invKeySchedule;
          var invSBOX = this.invSBox;
          var invSubMix = this.invSubMix;
          var invSubMix0 = invSubMix[0];
          var invSubMix1 = invSubMix[1];
          var invSubMix2 = invSubMix[2];
          var invSubMix3 = invSubMix[3];
          var initVector = this.uint8ArrayToUint32Array_(aesIV);
          var initVector0 = initVector[0];
          var initVector1 = initVector[1];
          var initVector2 = initVector[2];
          var initVector3 = initVector[3];
          var inputInt32 = new Int32Array(inputArrayBuffer);
          var outputInt32 = new Int32Array(inputInt32.length);
          var t0, t1, t2, t3;
          var s0, s1, s2, s3;
          var inputWords0, inputWords1, inputWords2, inputWords3;
          var ksRow, i;
          var swapWord = this.networkToHostOrderSwap;
          while (offset < inputInt32.length) {
            inputWords0 = swapWord(inputInt32[offset]);
            inputWords1 = swapWord(inputInt32[offset + 1]);
            inputWords2 = swapWord(inputInt32[offset + 2]);
            inputWords3 = swapWord(inputInt32[offset + 3]);
            s0 = inputWords0 ^ invKeySchedule[0];
            s1 = inputWords3 ^ invKeySchedule[1];
            s2 = inputWords2 ^ invKeySchedule[2];
            s3 = inputWords1 ^ invKeySchedule[3];
            ksRow = 4;
            for (i = 1;i < nRounds; i++) {
              t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 255] ^ invSubMix2[s2 >> 8 & 255] ^ invSubMix3[s3 & 255] ^ invKeySchedule[ksRow];
              t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 255] ^ invSubMix2[s3 >> 8 & 255] ^ invSubMix3[s0 & 255] ^ invKeySchedule[ksRow + 1];
              t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 255] ^ invSubMix2[s0 >> 8 & 255] ^ invSubMix3[s1 & 255] ^ invKeySchedule[ksRow + 2];
              t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 255] ^ invSubMix2[s1 >> 8 & 255] ^ invSubMix3[s2 & 255] ^ invKeySchedule[ksRow + 3];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
              ksRow = ksRow + 4;
            }
            t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 255] << 16 ^ invSBOX[s2 >> 8 & 255] << 8 ^ invSBOX[s3 & 255] ^ invKeySchedule[ksRow];
            t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 255] << 16 ^ invSBOX[s3 >> 8 & 255] << 8 ^ invSBOX[s0 & 255] ^ invKeySchedule[ksRow + 1];
            t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 255] << 16 ^ invSBOX[s0 >> 8 & 255] << 8 ^ invSBOX[s1 & 255] ^ invKeySchedule[ksRow + 2];
            t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 255] << 16 ^ invSBOX[s1 >> 8 & 255] << 8 ^ invSBOX[s2 & 255] ^ invKeySchedule[ksRow + 3];
            outputInt32[offset] = swapWord(t0 ^ initVector0);
            outputInt32[offset + 1] = swapWord(t3 ^ initVector1);
            outputInt32[offset + 2] = swapWord(t2 ^ initVector2);
            outputInt32[offset + 3] = swapWord(t1 ^ initVector3);
            initVector0 = inputWords0;
            initVector1 = inputWords1;
            initVector2 = inputWords2;
            initVector3 = inputWords3;
            offset = offset + 4;
          }
          return outputInt32.buffer;
        };
        return AESDecryptor2;
      }();
      var CHUNK_SIZE = 16;
      var Decrypter = /* @__PURE__ */ function() {
        function Decrypter2(config, _temp) {
          var _ref = _temp === undefined ? {} : _temp, _ref$removePKCS7Paddi = _ref.removePKCS7Padding, removePKCS7Padding = _ref$removePKCS7Paddi === undefined ? true : _ref$removePKCS7Paddi;
          this.logEnabled = true;
          this.removePKCS7Padding = undefined;
          this.subtle = null;
          this.softwareDecrypter = null;
          this.key = null;
          this.fastAesKey = null;
          this.remainderData = null;
          this.currentIV = null;
          this.currentResult = null;
          this.useSoftware = undefined;
          this.useSoftware = config.enableSoftwareAES;
          this.removePKCS7Padding = removePKCS7Padding;
          if (removePKCS7Padding) {
            try {
              var browserCrypto = self.crypto;
              if (browserCrypto) {
                this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;
              }
            } catch (e) {
            }
          }
          this.useSoftware = !this.subtle;
        }
        var _proto = Decrypter2.prototype;
        _proto.destroy = function destroy() {
          this.subtle = null;
          this.softwareDecrypter = null;
          this.key = null;
          this.fastAesKey = null;
          this.remainderData = null;
          this.currentIV = null;
          this.currentResult = null;
        };
        _proto.isSync = function isSync() {
          return this.useSoftware;
        };
        _proto.flush = function flush() {
          var currentResult = this.currentResult, remainderData = this.remainderData;
          if (!currentResult || remainderData) {
            this.reset();
            return null;
          }
          var data = new Uint8Array(currentResult);
          this.reset();
          if (this.removePKCS7Padding) {
            return removePadding(data);
          }
          return data;
        };
        _proto.reset = function reset() {
          this.currentResult = null;
          this.currentIV = null;
          this.remainderData = null;
          if (this.softwareDecrypter) {
            this.softwareDecrypter = null;
          }
        };
        _proto.decrypt = function decrypt(data, key, iv) {
          var _this = this;
          if (this.useSoftware) {
            return new Promise(function(resolve, reject) {
              _this.softwareDecrypt(new Uint8Array(data), key, iv);
              var decryptResult = _this.flush();
              if (decryptResult) {
                resolve(decryptResult.buffer);
              } else {
                reject(new Error("[softwareDecrypt] Failed to decrypt data"));
              }
            });
          }
          return this.webCryptoDecrypt(new Uint8Array(data), key, iv);
        };
        _proto.softwareDecrypt = function softwareDecrypt(data, key, iv) {
          var currentIV = this.currentIV, currentResult = this.currentResult, remainderData = this.remainderData;
          this.logOnce("JS AES decrypt");
          if (remainderData) {
            data = appendUint8Array(remainderData, data);
            this.remainderData = null;
          }
          var currentChunk = this.getValidChunk(data);
          if (!currentChunk.length) {
            return null;
          }
          if (currentIV) {
            iv = currentIV;
          }
          var softwareDecrypter = this.softwareDecrypter;
          if (!softwareDecrypter) {
            softwareDecrypter = this.softwareDecrypter = new AESDecryptor;
          }
          softwareDecrypter.expandKey(key);
          var result = currentResult;
          this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);
          this.currentIV = sliceUint8(currentChunk, -16).buffer;
          if (!result) {
            return null;
          }
          return result;
        };
        _proto.webCryptoDecrypt = function webCryptoDecrypt(data, key, iv) {
          var _this2 = this;
          if (this.key !== key || !this.fastAesKey) {
            if (!this.subtle) {
              return Promise.resolve(this.onWebCryptoError(data, key, iv));
            }
            this.key = key;
            this.fastAesKey = new FastAESKey(this.subtle, key);
          }
          return this.fastAesKey.expandKey().then(function(aesKey) {
            if (!_this2.subtle) {
              return Promise.reject(new Error("web crypto not initialized"));
            }
            _this2.logOnce("WebCrypto AES decrypt");
            var crypto2 = new AESCrypto(_this2.subtle, new Uint8Array(iv));
            return crypto2.decrypt(data.buffer, aesKey);
          }).catch(function(err) {
            logger.warn("[decrypter]: WebCrypto Error, disable WebCrypto API, " + err.name + ": " + err.message);
            return _this2.onWebCryptoError(data, key, iv);
          });
        };
        _proto.onWebCryptoError = function onWebCryptoError(data, key, iv) {
          this.useSoftware = true;
          this.logEnabled = true;
          this.softwareDecrypt(data, key, iv);
          var decryptResult = this.flush();
          if (decryptResult) {
            return decryptResult.buffer;
          }
          throw new Error("WebCrypto and softwareDecrypt: failed to decrypt data");
        };
        _proto.getValidChunk = function getValidChunk(data) {
          var currentChunk = data;
          var splitPoint = data.length - data.length % CHUNK_SIZE;
          if (splitPoint !== data.length) {
            currentChunk = sliceUint8(data, 0, splitPoint);
            this.remainderData = sliceUint8(data, splitPoint);
          }
          return currentChunk;
        };
        _proto.logOnce = function logOnce(msg) {
          if (!this.logEnabled) {
            return;
          }
          logger.log("[decrypter]: " + msg);
          this.logEnabled = false;
        };
        return Decrypter2;
      }();
      var TimeRanges = {
        toString: function toString(r) {
          var log = "";
          var len = r.length;
          for (var i = 0;i < len; i++) {
            log += "[" + r.start(i).toFixed(3) + "-" + r.end(i).toFixed(3) + "]";
          }
          return log;
        }
      };
      var State = {
        STOPPED: "STOPPED",
        IDLE: "IDLE",
        KEY_LOADING: "KEY_LOADING",
        FRAG_LOADING: "FRAG_LOADING",
        FRAG_LOADING_WAITING_RETRY: "FRAG_LOADING_WAITING_RETRY",
        WAITING_TRACK: "WAITING_TRACK",
        PARSING: "PARSING",
        PARSED: "PARSED",
        ENDED: "ENDED",
        ERROR: "ERROR",
        WAITING_INIT_PTS: "WAITING_INIT_PTS",
        WAITING_LEVEL: "WAITING_LEVEL"
      };
      var BaseStreamController = /* @__PURE__ */ function(_TaskLoop) {
        _inheritsLoose(BaseStreamController2, _TaskLoop);
        function BaseStreamController2(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {
          var _this;
          _this = _TaskLoop.call(this) || this;
          _this.hls = undefined;
          _this.fragPrevious = null;
          _this.fragCurrent = null;
          _this.fragmentTracker = undefined;
          _this.transmuxer = null;
          _this._state = State.STOPPED;
          _this.playlistType = undefined;
          _this.media = null;
          _this.mediaBuffer = null;
          _this.config = undefined;
          _this.bitrateTest = false;
          _this.lastCurrentTime = 0;
          _this.nextLoadPosition = 0;
          _this.startPosition = 0;
          _this.startTimeOffset = null;
          _this.loadedmetadata = false;
          _this.retryDate = 0;
          _this.levels = null;
          _this.fragmentLoader = undefined;
          _this.keyLoader = undefined;
          _this.levelLastLoaded = null;
          _this.startFragRequested = false;
          _this.decrypter = undefined;
          _this.initPTS = [];
          _this.buffering = true;
          _this.onvseeking = null;
          _this.onvended = null;
          _this.logPrefix = "";
          _this.log = undefined;
          _this.warn = undefined;
          _this.playlistType = playlistType;
          _this.logPrefix = logPrefix;
          _this.log = logger.log.bind(logger, logPrefix + ":");
          _this.warn = logger.warn.bind(logger, logPrefix + ":");
          _this.hls = hls;
          _this.fragmentLoader = new FragmentLoader(hls.config);
          _this.keyLoader = keyLoader;
          _this.fragmentTracker = fragmentTracker;
          _this.config = hls.config;
          _this.decrypter = new Decrypter(hls.config);
          hls.on(Events.MANIFEST_LOADED, _this.onManifestLoaded, _assertThisInitialized(_this));
          return _this;
        }
        var _proto = BaseStreamController2.prototype;
        _proto.doTick = function doTick() {
          this.onTickEnd();
        };
        _proto.onTickEnd = function onTickEnd() {
        };
        _proto.startLoad = function startLoad(startPosition) {
        };
        _proto.stopLoad = function stopLoad() {
          this.fragmentLoader.abort();
          this.keyLoader.abort(this.playlistType);
          var frag = this.fragCurrent;
          if (frag != null && frag.loader) {
            frag.abortRequests();
            this.fragmentTracker.removeFragment(frag);
          }
          this.resetTransmuxer();
          this.fragCurrent = null;
          this.fragPrevious = null;
          this.clearInterval();
          this.clearNextTick();
          this.state = State.STOPPED;
        };
        _proto.pauseBuffering = function pauseBuffering() {
          this.buffering = false;
        };
        _proto.resumeBuffering = function resumeBuffering() {
          this.buffering = true;
        };
        _proto._streamEnded = function _streamEnded(bufferInfo, levelDetails) {
          if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {
            return false;
          }
          var partList = levelDetails.partList;
          if (partList != null && partList.length) {
            var lastPart = partList[partList.length - 1];
            var lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);
            return lastPartBuffered;
          }
          var playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;
          return this.fragmentTracker.isEndListAppended(playlistType);
        };
        _proto.getLevelDetails = function getLevelDetails() {
          if (this.levels && this.levelLastLoaded !== null) {
            var _this$levelLastLoaded;
            return (_this$levelLastLoaded = this.levelLastLoaded) == null ? undefined : _this$levelLastLoaded.details;
          }
        };
        _proto.onMediaAttached = function onMediaAttached(event, data) {
          var media = this.media = this.mediaBuffer = data.media;
          this.onvseeking = this.onMediaSeeking.bind(this);
          this.onvended = this.onMediaEnded.bind(this);
          media.addEventListener("seeking", this.onvseeking);
          media.addEventListener("ended", this.onvended);
          var config = this.config;
          if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {
            this.startLoad(config.startPosition);
          }
        };
        _proto.onMediaDetaching = function onMediaDetaching() {
          var media = this.media;
          if (media != null && media.ended) {
            this.log("MSE detaching and video ended, reset startPosition");
            this.startPosition = this.lastCurrentTime = 0;
          }
          if (media && this.onvseeking && this.onvended) {
            media.removeEventListener("seeking", this.onvseeking);
            media.removeEventListener("ended", this.onvended);
            this.onvseeking = this.onvended = null;
          }
          if (this.keyLoader) {
            this.keyLoader.detach();
          }
          this.media = this.mediaBuffer = null;
          this.loadedmetadata = false;
          this.fragmentTracker.removeAllFragments();
          this.stopLoad();
        };
        _proto.onMediaSeeking = function onMediaSeeking() {
          var config = this.config, fragCurrent = this.fragCurrent, media = this.media, mediaBuffer = this.mediaBuffer, state = this.state;
          var currentTime = media ? media.currentTime : 0;
          var bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);
          this.log("media seeking to " + (isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime) + ", state: " + state);
          if (this.state === State.ENDED) {
            this.resetLoadingState();
          } else if (fragCurrent) {
            var tolerance = config.maxFragLookUpTolerance;
            var fragStartOffset = fragCurrent.start - tolerance;
            var fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;
            if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {
              var pastFragment = currentTime > fragEndOffset;
              if (currentTime < fragStartOffset || pastFragment) {
                if (pastFragment && fragCurrent.loader) {
                  this.log("seeking outside of buffer while fragment load in progress, cancel fragment load");
                  fragCurrent.abortRequests();
                  this.resetLoadingState();
                }
                this.fragPrevious = null;
              }
            }
          }
          if (media) {
            this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);
            this.lastCurrentTime = currentTime;
          }
          if (!this.loadedmetadata && !bufferInfo.len) {
            this.nextLoadPosition = this.startPosition = currentTime;
          }
          this.tickImmediate();
        };
        _proto.onMediaEnded = function onMediaEnded() {
          this.startPosition = this.lastCurrentTime = 0;
        };
        _proto.onManifestLoaded = function onManifestLoaded(event, data) {
          this.startTimeOffset = data.startTimeOffset;
          this.initPTS = [];
        };
        _proto.onHandlerDestroying = function onHandlerDestroying() {
          this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
          this.stopLoad();
          _TaskLoop.prototype.onHandlerDestroying.call(this);
          this.hls = null;
        };
        _proto.onHandlerDestroyed = function onHandlerDestroyed() {
          this.state = State.STOPPED;
          if (this.fragmentLoader) {
            this.fragmentLoader.destroy();
          }
          if (this.keyLoader) {
            this.keyLoader.destroy();
          }
          if (this.decrypter) {
            this.decrypter.destroy();
          }
          this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;
          _TaskLoop.prototype.onHandlerDestroyed.call(this);
        };
        _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {
          this._loadFragForPlayback(frag, level, targetBufferTime);
        };
        _proto._loadFragForPlayback = function _loadFragForPlayback(frag, level, targetBufferTime) {
          var _this2 = this;
          var progressCallback = function progressCallback(data) {
            if (_this2.fragContextChanged(frag)) {
              _this2.warn("Fragment " + frag.sn + (data.part ? " p: " + data.part.index : "") + " of level " + frag.level + " was dropped during download.");
              _this2.fragmentTracker.removeFragment(frag);
              return;
            }
            frag.stats.chunkCount++;
            _this2._handleFragmentLoadProgress(data);
          };
          this._doFragLoad(frag, level, targetBufferTime, progressCallback).then(function(data) {
            if (!data) {
              return;
            }
            var state = _this2.state;
            if (_this2.fragContextChanged(frag)) {
              if (state === State.FRAG_LOADING || !_this2.fragCurrent && state === State.PARSING) {
                _this2.fragmentTracker.removeFragment(frag);
                _this2.state = State.IDLE;
              }
              return;
            }
            if ("payload" in data) {
              _this2.log("Loaded fragment " + frag.sn + " of level " + frag.level);
              _this2.hls.trigger(Events.FRAG_LOADED, data);
            }
            _this2._handleFragmentLoadComplete(data);
          }).catch(function(reason) {
            if (_this2.state === State.STOPPED || _this2.state === State.ERROR) {
              return;
            }
            _this2.warn("Frag error: " + ((reason == null ? undefined : reason.message) || reason));
            _this2.resetFragmentLoading(frag);
          });
        };
        _proto.clearTrackerIfNeeded = function clearTrackerIfNeeded(frag) {
          var _this$mediaBuffer;
          var fragmentTracker = this.fragmentTracker;
          var fragState = fragmentTracker.getState(frag);
          if (fragState === FragmentState.APPENDING) {
            var playlistType = frag.type;
            var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
            var minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);
            var backtrackFragment = this.backtrackFragment;
            var backtracked = backtrackFragment ? frag.sn - backtrackFragment.sn : 0;
            if (backtracked === 1 || this.reduceMaxBufferLength(minForwardBufferLength, frag.duration)) {
              fragmentTracker.removeFragment(frag);
            }
          } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? undefined : _this$mediaBuffer.buffered.length) === 0) {
            fragmentTracker.removeAllFragments();
          } else if (fragmentTracker.hasParts(frag.type)) {
            fragmentTracker.detectPartialFragments({
              frag,
              part: null,
              stats: frag.stats,
              id: frag.type
            });
            if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {
              fragmentTracker.removeFragment(frag);
            }
          }
        };
        _proto.checkLiveUpdate = function checkLiveUpdate(details) {
          if (details.updated && !details.live) {
            var lastFragment = details.fragments[details.fragments.length - 1];
            this.fragmentTracker.detectPartialFragments({
              frag: lastFragment,
              part: null,
              stats: lastFragment.stats,
              id: lastFragment.type
            });
          }
          if (!details.fragments[0]) {
            details.deltaUpdateFailed = true;
          }
        };
        _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset, type) {
          if (type === undefined) {
            type = null;
          }
          if (!(startOffset - endOffset)) {
            return;
          }
          var flushScope = {
            startOffset,
            endOffset,
            type
          };
          this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);
        };
        _proto._loadInitSegment = function _loadInitSegment(frag, level) {
          var _this3 = this;
          this._doFragLoad(frag, level).then(function(data) {
            if (!data || _this3.fragContextChanged(frag) || !_this3.levels) {
              throw new Error("init load aborted");
            }
            return data;
          }).then(function(data) {
            var hls = _this3.hls;
            var payload = data.payload;
            var decryptData = frag.decryptdata;
            if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
              var startTime = self.performance.now();
              return _this3.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(function(err) {
                hls.trigger(Events.ERROR, {
                  type: ErrorTypes2.MEDIA_ERROR,
                  details: ErrorDetails.FRAG_DECRYPT_ERROR,
                  fatal: false,
                  error: err,
                  reason: err.message,
                  frag
                });
                throw err;
              }).then(function(decryptedData) {
                var endTime = self.performance.now();
                hls.trigger(Events.FRAG_DECRYPTED, {
                  frag,
                  payload: decryptedData,
                  stats: {
                    tstart: startTime,
                    tdecrypt: endTime
                  }
                });
                data.payload = decryptedData;
                return _this3.completeInitSegmentLoad(data);
              });
            }
            return _this3.completeInitSegmentLoad(data);
          }).catch(function(reason) {
            if (_this3.state === State.STOPPED || _this3.state === State.ERROR) {
              return;
            }
            _this3.warn(reason);
            _this3.resetFragmentLoading(frag);
          });
        };
        _proto.completeInitSegmentLoad = function completeInitSegmentLoad(data) {
          var levels = this.levels;
          if (!levels) {
            throw new Error("init load aborted, missing levels");
          }
          var stats = data.frag.stats;
          this.state = State.IDLE;
          data.frag.data = new Uint8Array(data.payload);
          stats.parsing.start = stats.buffering.start = self.performance.now();
          stats.parsing.end = stats.buffering.end = self.performance.now();
          this.tick();
        };
        _proto.fragContextChanged = function fragContextChanged(frag) {
          var fragCurrent = this.fragCurrent;
          return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;
        };
        _proto.fragBufferedComplete = function fragBufferedComplete(frag, part) {
          var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;
          var media = this.mediaBuffer ? this.mediaBuffer : this.media;
          this.log("Buffered " + frag.type + " sn: " + frag.sn + (part ? " part: " + part.index : "") + " of " + (this.playlistType === PlaylistLevelType.MAIN ? "level" : "track") + " " + frag.level + " (frag:[" + ((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3) + "-" + ((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3) + "] > buffer:" + (media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : "(detached)") + ")");
          if (frag.sn !== "initSegment") {
            var _this$levels;
            if (frag.type !== PlaylistLevelType.SUBTITLE) {
              var el = frag.elementaryStreams;
              if (!Object.keys(el).some(function(type) {
                return !!el[type];
              })) {
                this.state = State.IDLE;
                return;
              }
            }
            var level = (_this$levels = this.levels) == null ? undefined : _this$levels[frag.level];
            if (level != null && level.fragmentError) {
              this.log("Resetting level fragment error count of " + level.fragmentError + " on frag buffered");
              level.fragmentError = 0;
            }
          }
          this.state = State.IDLE;
          if (!media) {
            return;
          }
          if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? undefined : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? undefined : _this$fragPrevious.sn)) {
            this.loadedmetadata = true;
            this.seekToStartPos();
          }
          this.tick();
        };
        _proto.seekToStartPos = function seekToStartPos() {
        };
        _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedEndData) {
          var transmuxer = this.transmuxer;
          if (!transmuxer) {
            return;
          }
          var { frag, part, partsLoaded } = fragLoadedEndData;
          var complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(function(fragLoaded) {
            return !fragLoaded;
          });
          var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);
          transmuxer.flush(chunkMeta);
        };
        _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(frag) {
        };
        _proto._doFragLoad = function _doFragLoad(frag, level, targetBufferTime, progressCallback) {
          var _frag$decryptdata, _this4 = this;
          if (targetBufferTime === undefined) {
            targetBufferTime = null;
          }
          var details = level == null ? undefined : level.details;
          if (!this.levels || !details) {
            throw new Error("frag load aborted, missing level" + (details ? "" : " detail") + "s");
          }
          var keyLoadingPromise = null;
          if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {
            this.log("Loading key for " + frag.sn + " of [" + details.startSN + "-" + details.endSN + "], " + (this.logPrefix === "[stream-controller]" ? "level" : "track") + " " + frag.level);
            this.state = State.KEY_LOADING;
            this.fragCurrent = frag;
            keyLoadingPromise = this.keyLoader.load(frag).then(function(keyLoadedData) {
              if (!_this4.fragContextChanged(keyLoadedData.frag)) {
                _this4.hls.trigger(Events.KEY_LOADED, keyLoadedData);
                if (_this4.state === State.KEY_LOADING) {
                  _this4.state = State.IDLE;
                }
                return keyLoadedData;
              }
            });
            this.hls.trigger(Events.KEY_LOADING, {
              frag
            });
            if (this.fragCurrent === null) {
              keyLoadingPromise = Promise.reject(new Error("frag load aborted, context changed in KEY_LOADING"));
            }
          } else if (!frag.encrypted && details.encryptedFragments.length) {
            this.keyLoader.loadClear(frag, details.encryptedFragments);
          }
          targetBufferTime = Math.max(frag.start, targetBufferTime || 0);
          if (this.config.lowLatencyMode && frag.sn !== "initSegment") {
            var partList = details.partList;
            if (partList && progressCallback) {
              if (targetBufferTime > frag.end && details.fragmentHint) {
                frag = details.fragmentHint;
              }
              var partIndex = this.getNextPart(partList, frag, targetBufferTime);
              if (partIndex > -1) {
                var part = partList[partIndex];
                this.log("Loading part sn: " + frag.sn + " p: " + part.index + " cc: " + frag.cc + " of playlist [" + details.startSN + "-" + details.endSN + "] parts [0-" + partIndex + "-" + (partList.length - 1) + "] " + (this.logPrefix === "[stream-controller]" ? "level" : "track") + ": " + frag.level + ", target: " + parseFloat(targetBufferTime.toFixed(3)));
                this.nextLoadPosition = part.start + part.duration;
                this.state = State.FRAG_LOADING;
                var _result;
                if (keyLoadingPromise) {
                  _result = keyLoadingPromise.then(function(keyLoadedData) {
                    if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData.frag)) {
                      return null;
                    }
                    return _this4.doFragPartsLoad(frag, part, level, progressCallback);
                  }).catch(function(error2) {
                    return _this4.handleFragLoadError(error2);
                  });
                } else {
                  _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(function(error2) {
                    return _this4.handleFragLoadError(error2);
                  });
                }
                this.hls.trigger(Events.FRAG_LOADING, {
                  frag,
                  part,
                  targetBufferTime
                });
                if (this.fragCurrent === null) {
                  return Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING parts"));
                }
                return _result;
              } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {
                return Promise.resolve(null);
              }
            }
          }
          this.log("Loading fragment " + frag.sn + " cc: " + frag.cc + " " + (details ? "of [" + details.startSN + "-" + details.endSN + "] " : "") + (this.logPrefix === "[stream-controller]" ? "level" : "track") + ": " + frag.level + ", target: " + parseFloat(targetBufferTime.toFixed(3)));
          if (isFiniteNumber(frag.sn) && !this.bitrateTest) {
            this.nextLoadPosition = frag.start + frag.duration;
          }
          this.state = State.FRAG_LOADING;
          var dataOnProgress = this.config.progressive;
          var result;
          if (dataOnProgress && keyLoadingPromise) {
            result = keyLoadingPromise.then(function(keyLoadedData) {
              if (!keyLoadedData || _this4.fragContextChanged(keyLoadedData == null ? undefined : keyLoadedData.frag)) {
                return null;
              }
              return _this4.fragmentLoader.load(frag, progressCallback);
            }).catch(function(error2) {
              return _this4.handleFragLoadError(error2);
            });
          } else {
            result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(function(_ref) {
              var fragLoadedData = _ref[0];
              if (!dataOnProgress && fragLoadedData && progressCallback) {
                progressCallback(fragLoadedData);
              }
              return fragLoadedData;
            }).catch(function(error2) {
              return _this4.handleFragLoadError(error2);
            });
          }
          this.hls.trigger(Events.FRAG_LOADING, {
            frag,
            targetBufferTime
          });
          if (this.fragCurrent === null) {
            return Promise.reject(new Error("frag load aborted, context changed in FRAG_LOADING"));
          }
          return result;
        };
        _proto.doFragPartsLoad = function doFragPartsLoad(frag, fromPart, level, progressCallback) {
          var _this5 = this;
          return new Promise(function(resolve, reject) {
            var _level$details;
            var partsLoaded = [];
            var initialPartList = (_level$details = level.details) == null ? undefined : _level$details.partList;
            var loadPart = function loadPart(part) {
              _this5.fragmentLoader.loadPart(frag, part, progressCallback).then(function(partLoadedData) {
                partsLoaded[part.index] = partLoadedData;
                var loadedPart = partLoadedData.part;
                _this5.hls.trigger(Events.FRAG_LOADED, partLoadedData);
                var nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);
                if (nextPart) {
                  loadPart(nextPart);
                } else {
                  return resolve({
                    frag,
                    part: loadedPart,
                    partsLoaded
                  });
                }
              }).catch(reject);
            };
            loadPart(fromPart);
          });
        };
        _proto.handleFragLoadError = function handleFragLoadError(error2) {
          if ("data" in error2) {
            var data = error2.data;
            if (error2.data && data.details === ErrorDetails.INTERNAL_ABORTED) {
              this.handleFragLoadAborted(data.frag, data.part);
            } else {
              this.hls.trigger(Events.ERROR, data);
            }
          } else {
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes2.OTHER_ERROR,
              details: ErrorDetails.INTERNAL_EXCEPTION,
              err: error2,
              error: error2,
              fatal: true
            });
          }
          return null;
        };
        _proto._handleTransmuxerFlush = function _handleTransmuxerFlush(chunkMeta) {
          var context = this.getCurrentContext(chunkMeta);
          if (!context || this.state !== State.PARSING) {
            if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {
              this.state = State.IDLE;
            }
            return;
          }
          var { frag, part, level } = context;
          var now2 = self.performance.now();
          frag.stats.parsing.end = now2;
          if (part) {
            part.stats.parsing.end = now2;
          }
          this.updateLevelTiming(frag, part, level, chunkMeta.partial);
        };
        _proto.getCurrentContext = function getCurrentContext(chunkMeta) {
          var levels = this.levels, fragCurrent = this.fragCurrent;
          var { level: levelIndex, sn, part: partIndex } = chunkMeta;
          if (!(levels != null && levels[levelIndex])) {
            this.warn("Levels object was unset while buffering fragment " + sn + " of level " + levelIndex + ". The current chunk will not be buffered.");
            return null;
          }
          var level = levels[levelIndex];
          var part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;
          var frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);
          if (!frag) {
            return null;
          }
          if (fragCurrent && fragCurrent !== frag) {
            frag.stats = fragCurrent.stats;
          }
          return {
            frag,
            part,
            level
          };
        };
        _proto.bufferFragmentData = function bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {
          var _buffer;
          if (!data || this.state !== State.PARSING) {
            return;
          }
          var { data1, data2 } = data;
          var buffer = data1;
          if (data1 && data2) {
            buffer = appendUint8Array(data1, data2);
          }
          if (!((_buffer = buffer) != null && _buffer.length)) {
            return;
          }
          var segment = {
            type: data.type,
            frag,
            part,
            chunkMeta,
            parent: frag.type,
            data: buffer
          };
          this.hls.trigger(Events.BUFFER_APPENDING, segment);
          if (data.dropped && data.independent && !part) {
            if (noBacktracking) {
              return;
            }
            this.flushBufferGap(frag);
          }
        };
        _proto.flushBufferGap = function flushBufferGap(frag) {
          var media = this.media;
          if (!media) {
            return;
          }
          if (!BufferHelper.isBuffered(media, media.currentTime)) {
            this.flushMainBuffer(0, frag.start);
            return;
          }
          var currentTime = media.currentTime;
          var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
          var fragDuration = frag.duration;
          var segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);
          var start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);
          if (frag.start - start > segmentFraction) {
            this.flushMainBuffer(start, frag.start);
          }
        };
        _proto.getFwdBufferInfo = function getFwdBufferInfo(bufferable, type) {
          var pos = this.getLoadPosition();
          if (!isFiniteNumber(pos)) {
            return null;
          }
          return this.getFwdBufferInfoAtPos(bufferable, pos, type);
        };
        _proto.getFwdBufferInfoAtPos = function getFwdBufferInfoAtPos(bufferable, pos, type) {
          var maxBufferHole = this.config.maxBufferHole;
          var bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);
          if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {
            var bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);
            if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {
              return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));
            }
          }
          return bufferInfo;
        };
        _proto.getMaxBufferLength = function getMaxBufferLength(levelBitrate) {
          var config = this.config;
          var maxBufLen;
          if (levelBitrate) {
            maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);
          } else {
            maxBufLen = config.maxBufferLength;
          }
          return Math.min(maxBufLen, config.maxMaxBufferLength);
        };
        _proto.reduceMaxBufferLength = function reduceMaxBufferLength(threshold, fragDuration) {
          var config = this.config;
          var minLength = Math.max(Math.min(threshold - fragDuration, config.maxBufferLength), fragDuration);
          var reducedLength = Math.max(threshold - fragDuration * 3, config.maxMaxBufferLength / 2, minLength);
          if (reducedLength >= minLength) {
            config.maxMaxBufferLength = reducedLength;
            this.warn("Reduce max buffer length to " + reducedLength + "s");
            return true;
          }
          return false;
        };
        _proto.getAppendedFrag = function getAppendedFrag(position, playlistType) {
          var fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);
          if (fragOrPart && "fragment" in fragOrPart) {
            return fragOrPart.fragment;
          }
          return fragOrPart;
        };
        _proto.getNextFragment = function getNextFragment(pos, levelDetails) {
          var fragments = levelDetails.fragments;
          var fragLen = fragments.length;
          if (!fragLen) {
            return null;
          }
          var config = this.config;
          var start = fragments[0].start;
          var frag;
          if (levelDetails.live) {
            var initialLiveManifestSize = config.initialLiveManifestSize;
            if (fragLen < initialLiveManifestSize) {
              this.warn("Not enough fragments to start playback (have: " + fragLen + ", need: " + initialLiveManifestSize + ")");
              return null;
            }
            if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {
              frag = this.getInitialLiveFragment(levelDetails, fragments);
              this.startPosition = this.nextLoadPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;
            }
          } else if (pos <= start) {
            frag = fragments[0];
          }
          if (!frag) {
            var end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;
            frag = this.getFragmentAtPosition(pos, end, levelDetails);
          }
          return this.mapToInitFragWhenRequired(frag);
        };
        _proto.isLoopLoading = function isLoopLoading(frag, targetBufferTime) {
          var trackerState = this.fragmentTracker.getState(frag);
          return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;
        };
        _proto.getNextFragmentLoopLoading = function getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {
          var gapStart = frag.gap;
          var nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);
          if (nextFragment === null) {
            return nextFragment;
          }
          frag = nextFragment;
          if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {
            var nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);
            if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {
              this.log('buffer full after gaps in "' + playlistType + '" playlist starting at sn: ' + frag.sn);
              return null;
            }
          }
          return frag;
        };
        _proto.mapToInitFragWhenRequired = function mapToInitFragWhenRequired(frag) {
          if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {
            return frag.initSegment;
          }
          return frag;
        };
        _proto.getNextPart = function getNextPart(partList, frag, targetBufferTime) {
          var nextPart = -1;
          var contiguous = false;
          var independentAttrOmitted = true;
          for (var i = 0, len = partList.length;i < len; i++) {
            var part = partList[i];
            independentAttrOmitted = independentAttrOmitted && !part.independent;
            if (nextPart > -1 && targetBufferTime < part.start) {
              break;
            }
            var loaded = part.loaded;
            if (loaded) {
              nextPart = -1;
            } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {
              nextPart = i;
            }
            contiguous = loaded;
          }
          return nextPart;
        };
        _proto.loadedEndOfParts = function loadedEndOfParts(partList, targetBufferTime) {
          var lastPart = partList[partList.length - 1];
          return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;
        };
        _proto.getInitialLiveFragment = function getInitialLiveFragment(levelDetails, fragments) {
          var fragPrevious = this.fragPrevious;
          var frag = null;
          if (fragPrevious) {
            if (levelDetails.hasProgramDateTime) {
              this.log("Live playlist, switching playlist, load frag with same PDT: " + fragPrevious.programDateTime);
              frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);
            }
            if (!frag) {
              var targetSN = fragPrevious.sn + 1;
              if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {
                var fragNext = fragments[targetSN - levelDetails.startSN];
                if (fragPrevious.cc === fragNext.cc) {
                  frag = fragNext;
                  this.log("Live playlist, switching playlist, load frag with next SN: " + frag.sn);
                }
              }
              if (!frag) {
                frag = findFragWithCC(fragments, fragPrevious.cc);
                if (frag) {
                  this.log("Live playlist, switching playlist, load frag with same CC: " + frag.sn);
                }
              }
            }
          } else {
            var liveStart = this.hls.liveSyncPosition;
            if (liveStart !== null) {
              frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);
            }
          }
          return frag;
        };
        _proto.getFragmentAtPosition = function getFragmentAtPosition(bufferEnd, end, levelDetails) {
          var config = this.config;
          var fragPrevious = this.fragPrevious;
          var { fragments, endSN } = levelDetails;
          var fragmentHint = levelDetails.fragmentHint;
          var maxFragLookUpTolerance = config.maxFragLookUpTolerance;
          var partList = levelDetails.partList;
          var loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);
          if (loadingParts && fragmentHint && !this.bitrateTest) {
            fragments = fragments.concat(fragmentHint);
            endSN = fragmentHint.sn;
          }
          var frag;
          if (bufferEnd < end) {
            var lookupTolerance = bufferEnd > end - maxFragLookUpTolerance ? 0 : maxFragLookUpTolerance;
            frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);
          } else {
            frag = fragments[fragments.length - 1];
          }
          if (frag) {
            var curSNIdx = frag.sn - levelDetails.startSN;
            var fragState = this.fragmentTracker.getState(frag);
            if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {
              fragPrevious = frag;
            }
            if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {
              var sameLevel = fragPrevious && frag.level === fragPrevious.level;
              if (sameLevel) {
                var nextFrag = fragments[curSNIdx + 1];
                if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {
                  frag = nextFrag;
                } else {
                  frag = null;
                }
              }
            }
          }
          return frag;
        };
        _proto.synchronizeToLiveEdge = function synchronizeToLiveEdge(levelDetails) {
          var config = this.config, media = this.media;
          if (!media) {
            return;
          }
          var liveSyncPosition = this.hls.liveSyncPosition;
          var currentTime = media.currentTime;
          var start = levelDetails.fragments[0].start;
          var end = levelDetails.edge;
          var withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;
          if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {
            var maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;
            if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {
              if (!this.loadedmetadata) {
                this.nextLoadPosition = liveSyncPosition;
              }
              if (media.readyState) {
                this.warn("Playback: " + currentTime.toFixed(3) + " is located too far from the end of live sliding playlist: " + end + ", reset currentTime to : " + liveSyncPosition.toFixed(3));
                media.currentTime = liveSyncPosition;
              }
            }
          }
        };
        _proto.alignPlaylists = function alignPlaylists(details, previousDetails, switchDetails) {
          var length = details.fragments.length;
          if (!length) {
            this.warn("No fragments in live playlist");
            return 0;
          }
          var slidingStart = details.fragments[0].start;
          var firstLevelLoad = !previousDetails;
          var aligned = details.alignedSliding && isFiniteNumber(slidingStart);
          if (firstLevelLoad || !aligned && !slidingStart) {
            var fragPrevious = this.fragPrevious;
            alignStream(fragPrevious, switchDetails, details);
            var alignedSlidingStart = details.fragments[0].start;
            this.log("Live playlist sliding: " + alignedSlidingStart.toFixed(2) + " start-sn: " + (previousDetails ? previousDetails.startSN : "na") + "->" + details.startSN + " prev-sn: " + (fragPrevious ? fragPrevious.sn : "na") + " fragments: " + length);
            return alignedSlidingStart;
          }
          return slidingStart;
        };
        _proto.waitForCdnTuneIn = function waitForCdnTuneIn(details) {
          var advancePartLimit = 3;
          return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);
        };
        _proto.setStartPosition = function setStartPosition(details, sliding) {
          var startPosition = this.startPosition;
          if (startPosition < sliding) {
            startPosition = -1;
          }
          if (startPosition === -1 || this.lastCurrentTime === -1) {
            var offsetInMultivariantPlaylist = this.startTimeOffset !== null;
            var startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;
            if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {
              startPosition = sliding + startTimeOffset;
              if (startTimeOffset < 0) {
                startPosition += details.totalduration;
              }
              startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);
              this.log("Start time offset " + startTimeOffset + " found in " + (offsetInMultivariantPlaylist ? "multivariant" : "media") + " playlist, adjust startPosition to " + startPosition);
              this.startPosition = startPosition;
            } else if (details.live) {
              startPosition = this.hls.liveSyncPosition || sliding;
            } else {
              this.startPosition = startPosition = 0;
            }
            this.lastCurrentTime = startPosition;
          }
          this.nextLoadPosition = startPosition;
        };
        _proto.getLoadPosition = function getLoadPosition() {
          var media = this.media;
          var pos = 0;
          if (this.loadedmetadata && media) {
            pos = media.currentTime;
          } else if (this.nextLoadPosition) {
            pos = this.nextLoadPosition;
          }
          return pos;
        };
        _proto.handleFragLoadAborted = function handleFragLoadAborted(frag, part) {
          if (this.transmuxer && frag.sn !== "initSegment" && frag.stats.aborted) {
            this.warn("Fragment " + frag.sn + (part ? " part " + part.index : "") + " of level " + frag.level + " was aborted");
            this.resetFragmentLoading(frag);
          }
        };
        _proto.resetFragmentLoading = function resetFragmentLoading(frag) {
          if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {
            this.state = State.IDLE;
          }
        };
        _proto.onFragmentOrKeyLoadError = function onFragmentOrKeyLoadError(filterType, data) {
          if (data.chunkMeta && !data.frag) {
            var context = this.getCurrentContext(data.chunkMeta);
            if (context) {
              data.frag = context.frag;
            }
          }
          var frag = data.frag;
          if (!frag || frag.type !== filterType || !this.levels) {
            return;
          }
          if (this.fragContextChanged(frag)) {
            var _this$fragCurrent2;
            this.warn("Frag load error must match current frag to retry " + frag.url + " > " + ((_this$fragCurrent2 = this.fragCurrent) == null ? undefined : _this$fragCurrent2.url));
            return;
          }
          var gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;
          if (gapTagEncountered) {
            this.fragmentTracker.fragBuffered(frag, true);
          }
          var errorAction = data.errorAction;
          var _ref2 = errorAction || {}, action = _ref2.action, _ref2$retryCount = _ref2.retryCount, retryCount = _ref2$retryCount === undefined ? 0 : _ref2$retryCount, retryConfig = _ref2.retryConfig;
          if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {
            this.resetStartWhenNotLoaded(this.levelLastLoaded);
            var delay = getRetryDelay(retryConfig, retryCount);
            this.warn("Fragment " + frag.sn + " of " + filterType + " " + frag.level + " errored with " + data.details + ", retrying loading " + (retryCount + 1) + "/" + retryConfig.maxNumRetry + " in " + delay + "ms");
            errorAction.resolved = true;
            this.retryDate = self.performance.now() + delay;
            this.state = State.FRAG_LOADING_WAITING_RETRY;
          } else if (retryConfig && errorAction) {
            this.resetFragmentErrors(filterType);
            if (retryCount < retryConfig.maxNumRetry) {
              if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {
                errorAction.resolved = true;
              }
            } else {
              logger.warn(data.details + " reached or exceeded max retry (" + retryCount + ")");
              return;
            }
          } else if ((errorAction == null ? undefined : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox) {
            this.state = State.WAITING_LEVEL;
          } else {
            this.state = State.ERROR;
          }
          this.tickImmediate();
        };
        _proto.reduceLengthAndFlushBuffer = function reduceLengthAndFlushBuffer(data) {
          if (this.state === State.PARSING || this.state === State.PARSED) {
            var frag = data.frag;
            var playlistType = data.parent;
            var bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);
            var buffered = bufferedInfo && bufferedInfo.len > 0.5;
            if (buffered) {
              this.reduceMaxBufferLength(bufferedInfo.len, (frag == null ? undefined : frag.duration) || 10);
            }
            var flushBuffer = !buffered;
            if (flushBuffer) {
              this.warn("Buffer full error while media.currentTime is not buffered, flush " + playlistType + " buffer");
            }
            if (frag) {
              this.fragmentTracker.removeFragment(frag);
              this.nextLoadPosition = frag.start;
            }
            this.resetLoadingState();
            return flushBuffer;
          }
          return false;
        };
        _proto.resetFragmentErrors = function resetFragmentErrors(filterType) {
          if (filterType === PlaylistLevelType.AUDIO) {
            this.fragCurrent = null;
          }
          if (!this.loadedmetadata) {
            this.startFragRequested = false;
          }
          if (this.state !== State.STOPPED) {
            this.state = State.IDLE;
          }
        };
        _proto.afterBufferFlushed = function afterBufferFlushed(media, bufferType, playlistType) {
          if (!media) {
            return;
          }
          var bufferedTimeRanges = BufferHelper.getBuffered(media);
          this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);
          if (this.state === State.ENDED) {
            this.resetLoadingState();
          }
        };
        _proto.resetLoadingState = function resetLoadingState() {
          this.log("Reset loading state");
          this.fragCurrent = null;
          this.fragPrevious = null;
          this.state = State.IDLE;
        };
        _proto.resetStartWhenNotLoaded = function resetStartWhenNotLoaded(level) {
          if (!this.loadedmetadata) {
            this.startFragRequested = false;
            var details = level ? level.details : null;
            if (details != null && details.live) {
              this.startPosition = -1;
              this.setStartPosition(details, 0);
              this.resetLoadingState();
            } else {
              this.nextLoadPosition = this.startPosition;
            }
          }
        };
        _proto.resetWhenMissingContext = function resetWhenMissingContext(chunkMeta) {
          this.warn("The loading context changed while buffering fragment " + chunkMeta.sn + " of level " + chunkMeta.level + ". This chunk will not be buffered.");
          this.removeUnbufferedFrags();
          this.resetStartWhenNotLoaded(this.levelLastLoaded);
          this.resetLoadingState();
        };
        _proto.removeUnbufferedFrags = function removeUnbufferedFrags(start) {
          if (start === undefined) {
            start = 0;
          }
          this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);
        };
        _proto.updateLevelTiming = function updateLevelTiming(frag, part, level, partial) {
          var _this6 = this, _this$transmuxer;
          var details = level.details;
          if (!details) {
            this.warn("level.details undefined");
            return;
          }
          var parsed = Object.keys(frag.elementaryStreams).reduce(function(result, type) {
            var info = frag.elementaryStreams[type];
            if (info) {
              var parsedDuration = info.endPTS - info.startPTS;
              if (parsedDuration <= 0) {
                _this6.warn("Could not parse fragment " + frag.sn + " " + type + " duration reliably (" + parsedDuration + ")");
                return result || false;
              }
              var drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);
              _this6.hls.trigger(Events.LEVEL_PTS_UPDATED, {
                details,
                level,
                drift,
                type,
                frag,
                start: info.startPTS,
                end: info.endPTS
              });
              return true;
            }
            return result;
          }, false);
          if (!parsed && ((_this$transmuxer = this.transmuxer) == null ? undefined : _this$transmuxer.error) === null) {
            var error2 = new Error("Found no media in fragment " + frag.sn + " of level " + frag.level + " resetting transmuxer to fallback to playlist timing");
            if (level.fragmentError === 0) {
              level.fragmentError++;
              frag.gap = true;
              this.fragmentTracker.removeFragment(frag);
              this.fragmentTracker.fragBuffered(frag, true);
            }
            this.warn(error2.message);
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes2.MEDIA_ERROR,
              details: ErrorDetails.FRAG_PARSING_ERROR,
              fatal: false,
              error: error2,
              frag,
              reason: "Found no media in msn " + frag.sn + ' of level "' + level.url + '"'
            });
            if (!this.hls) {
              return;
            }
            this.resetTransmuxer();
          }
          this.state = State.PARSED;
          this.hls.trigger(Events.FRAG_PARSED, {
            frag,
            part
          });
        };
        _proto.resetTransmuxer = function resetTransmuxer() {
          if (this.transmuxer) {
            this.transmuxer.destroy();
            this.transmuxer = null;
          }
        };
        _proto.recoverWorkerError = function recoverWorkerError(data) {
          if (data.event === "demuxerWorker") {
            this.fragmentTracker.removeAllFragments();
            this.resetTransmuxer();
            this.resetStartWhenNotLoaded(this.levelLastLoaded);
            this.resetLoadingState();
          }
        };
        _createClass(BaseStreamController2, [{
          key: "state",
          get: function get() {
            return this._state;
          },
          set: function set(nextState) {
            var previousState = this._state;
            if (previousState !== nextState) {
              this._state = nextState;
              this.log(previousState + "->" + nextState);
            }
          }
        }]);
        return BaseStreamController2;
      }(TaskLoop);
      var ChunkCache = /* @__PURE__ */ function() {
        function ChunkCache2() {
          this.chunks = [];
          this.dataLength = 0;
        }
        var _proto = ChunkCache2.prototype;
        _proto.push = function push(chunk) {
          this.chunks.push(chunk);
          this.dataLength += chunk.length;
        };
        _proto.flush = function flush() {
          var chunks = this.chunks, dataLength = this.dataLength;
          var result;
          if (!chunks.length) {
            return new Uint8Array(0);
          } else if (chunks.length === 1) {
            result = chunks[0];
          } else {
            result = concatUint8Arrays(chunks, dataLength);
          }
          this.reset();
          return result;
        };
        _proto.reset = function reset() {
          this.chunks.length = 0;
          this.dataLength = 0;
        };
        return ChunkCache2;
      }();
      function concatUint8Arrays(chunks, dataLength) {
        var result = new Uint8Array(dataLength);
        var offset = 0;
        for (var i = 0;i < chunks.length; i++) {
          var chunk = chunks[i];
          result.set(chunk, offset);
          offset += chunk.length;
        }
        return result;
      }
      function dummyTrack(type, inputTimeScale) {
        if (type === undefined) {
          type = "";
        }
        if (inputTimeScale === undefined) {
          inputTimeScale = 90000;
        }
        return {
          type,
          id: -1,
          pid: -1,
          inputTimeScale,
          sequenceNumber: -1,
          samples: [],
          dropped: 0
        };
      }
      var BaseAudioDemuxer = /* @__PURE__ */ function() {
        function BaseAudioDemuxer2() {
          this._audioTrack = undefined;
          this._id3Track = undefined;
          this.frameIndex = 0;
          this.cachedData = null;
          this.basePTS = null;
          this.initPTS = null;
          this.lastPTS = null;
        }
        var _proto = BaseAudioDemuxer2.prototype;
        _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
          this._id3Track = {
            type: "id3",
            id: 3,
            pid: -1,
            inputTimeScale: 90000,
            sequenceNumber: 0,
            samples: [],
            dropped: 0
          };
        };
        _proto.resetTimeStamp = function resetTimeStamp(deaultTimestamp) {
          this.initPTS = deaultTimestamp;
          this.resetContiguity();
        };
        _proto.resetContiguity = function resetContiguity() {
          this.basePTS = null;
          this.lastPTS = null;
          this.frameIndex = 0;
        };
        _proto.canParse = function canParse(data, offset) {
          return false;
        };
        _proto.appendFrame = function appendFrame(track, data, offset) {
        };
        _proto.demux = function demux(data, timeOffset) {
          if (this.cachedData) {
            data = appendUint8Array(this.cachedData, data);
            this.cachedData = null;
          }
          var id3Data = getID3Data(data, 0);
          var offset = id3Data ? id3Data.length : 0;
          var lastDataIndex;
          var track = this._audioTrack;
          var id3Track = this._id3Track;
          var timestamp = id3Data ? getTimeStamp(id3Data) : undefined;
          var length = data.length;
          if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {
            this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);
            this.lastPTS = this.basePTS;
          }
          if (this.lastPTS === null) {
            this.lastPTS = this.basePTS;
          }
          if (id3Data && id3Data.length > 0) {
            id3Track.samples.push({
              pts: this.lastPTS,
              dts: this.lastPTS,
              data: id3Data,
              type: MetadataSchema.audioId3,
              duration: Number.POSITIVE_INFINITY
            });
          }
          while (offset < length) {
            if (this.canParse(data, offset)) {
              var frame = this.appendFrame(track, data, offset);
              if (frame) {
                this.frameIndex++;
                this.lastPTS = frame.sample.pts;
                offset += frame.length;
                lastDataIndex = offset;
              } else {
                offset = length;
              }
            } else if (canParse$2(data, offset)) {
              id3Data = getID3Data(data, offset);
              id3Track.samples.push({
                pts: this.lastPTS,
                dts: this.lastPTS,
                data: id3Data,
                type: MetadataSchema.audioId3,
                duration: Number.POSITIVE_INFINITY
              });
              offset += id3Data.length;
              lastDataIndex = offset;
            } else {
              offset++;
            }
            if (offset === length && lastDataIndex !== length) {
              var partialData = sliceUint8(data, lastDataIndex);
              if (this.cachedData) {
                this.cachedData = appendUint8Array(this.cachedData, partialData);
              } else {
                this.cachedData = partialData;
              }
            }
          }
          return {
            audioTrack: track,
            videoTrack: dummyTrack(),
            id3Track,
            textTrack: dummyTrack()
          };
        };
        _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
          return Promise.reject(new Error("[" + this + "] This demuxer does not support Sample-AES decryption"));
        };
        _proto.flush = function flush(timeOffset) {
          var cachedData = this.cachedData;
          if (cachedData) {
            this.cachedData = null;
            this.demux(cachedData, 0);
          }
          return {
            audioTrack: this._audioTrack,
            videoTrack: dummyTrack(),
            id3Track: this._id3Track,
            textTrack: dummyTrack()
          };
        };
        _proto.destroy = function destroy() {
        };
        return BaseAudioDemuxer2;
      }();
      var initPTSFn = function initPTSFn(timestamp, timeOffset, initPTS) {
        if (isFiniteNumber(timestamp)) {
          return timestamp * 90;
        }
        var init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;
        return timeOffset * 90000 + init90kHz;
      };
      function getAudioConfig(observer, data, offset, audioCodec) {
        var adtsObjectType;
        var adtsExtensionSamplingIndex;
        var adtsChannelConfig;
        var config;
        var userAgent = navigator.userAgent.toLowerCase();
        var manifestCodec = audioCodec;
        var adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
        adtsObjectType = ((data[offset + 2] & 192) >>> 6) + 1;
        var adtsSamplingIndex = (data[offset + 2] & 60) >>> 2;
        if (adtsSamplingIndex > adtsSamplingRates.length - 1) {
          var error2 = new Error("invalid ADTS sampling index:" + adtsSamplingIndex);
          observer.emit(Events.ERROR, Events.ERROR, {
            type: ErrorTypes2.MEDIA_ERROR,
            details: ErrorDetails.FRAG_PARSING_ERROR,
            fatal: true,
            error: error2,
            reason: error2.message
          });
          return;
        }
        adtsChannelConfig = (data[offset + 2] & 1) << 2;
        adtsChannelConfig |= (data[offset + 3] & 192) >>> 6;
        logger.log("manifest codec:" + audioCodec + ", ADTS type:" + adtsObjectType + ", samplingIndex:" + adtsSamplingIndex);
        if (/firefox/i.test(userAgent)) {
          if (adtsSamplingIndex >= 6) {
            adtsObjectType = 5;
            config = new Array(4);
            adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
          } else {
            adtsObjectType = 2;
            config = new Array(2);
            adtsExtensionSamplingIndex = adtsSamplingIndex;
          }
        } else if (userAgent.indexOf("android") !== -1) {
          adtsObjectType = 2;
          config = new Array(2);
          adtsExtensionSamplingIndex = adtsSamplingIndex;
        } else {
          adtsObjectType = 5;
          config = new Array(4);
          if (audioCodec && (audioCodec.indexOf("mp4a.40.29") !== -1 || audioCodec.indexOf("mp4a.40.5") !== -1) || !audioCodec && adtsSamplingIndex >= 6) {
            adtsExtensionSamplingIndex = adtsSamplingIndex - 3;
          } else {
            if (audioCodec && audioCodec.indexOf("mp4a.40.2") !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {
              adtsObjectType = 2;
              config = new Array(2);
            }
            adtsExtensionSamplingIndex = adtsSamplingIndex;
          }
        }
        config[0] = adtsObjectType << 3;
        config[0] |= (adtsSamplingIndex & 14) >> 1;
        config[1] |= (adtsSamplingIndex & 1) << 7;
        config[1] |= adtsChannelConfig << 3;
        if (adtsObjectType === 5) {
          config[1] |= (adtsExtensionSamplingIndex & 14) >> 1;
          config[2] = (adtsExtensionSamplingIndex & 1) << 7;
          config[2] |= 2 << 2;
          config[3] = 0;
        }
        return {
          config,
          samplerate: adtsSamplingRates[adtsSamplingIndex],
          channelCount: adtsChannelConfig,
          codec: "mp4a.40." + adtsObjectType,
          manifestCodec
        };
      }
      function isHeaderPattern$1(data, offset) {
        return data[offset] === 255 && (data[offset + 1] & 246) === 240;
      }
      function getHeaderLength(data, offset) {
        return data[offset + 1] & 1 ? 7 : 9;
      }
      function getFullFrameLength(data, offset) {
        return (data[offset + 3] & 3) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 224) >>> 5;
      }
      function canGetFrameLength(data, offset) {
        return offset + 5 < data.length;
      }
      function isHeader$1(data, offset) {
        return offset + 1 < data.length && isHeaderPattern$1(data, offset);
      }
      function canParse$1(data, offset) {
        return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;
      }
      function probe$1(data, offset) {
        if (isHeader$1(data, offset)) {
          var headerLength = getHeaderLength(data, offset);
          if (offset + headerLength >= data.length) {
            return false;
          }
          var frameLength = getFullFrameLength(data, offset);
          if (frameLength <= headerLength) {
            return false;
          }
          var newOffset = offset + frameLength;
          return newOffset === data.length || isHeader$1(data, newOffset);
        }
        return false;
      }
      function initTrackConfig(track, observer, data, offset, audioCodec) {
        if (!track.samplerate) {
          var config = getAudioConfig(observer, data, offset, audioCodec);
          if (!config) {
            return;
          }
          track.config = config.config;
          track.samplerate = config.samplerate;
          track.channelCount = config.channelCount;
          track.codec = config.codec;
          track.manifestCodec = config.manifestCodec;
          logger.log("parsed codec:" + track.codec + ", rate:" + config.samplerate + ", channels:" + config.channelCount);
        }
      }
      function getFrameDuration(samplerate) {
        return 1024 * 90000 / samplerate;
      }
      function parseFrameHeader(data, offset) {
        var headerLength = getHeaderLength(data, offset);
        if (offset + headerLength <= data.length) {
          var frameLength = getFullFrameLength(data, offset) - headerLength;
          if (frameLength > 0) {
            return {
              headerLength,
              frameLength
            };
          }
        }
      }
      function appendFrame$1(track, data, offset, pts, frameIndex) {
        var frameDuration = getFrameDuration(track.samplerate);
        var stamp = pts + frameIndex * frameDuration;
        var header = parseFrameHeader(data, offset);
        var unit;
        if (header) {
          var { frameLength, headerLength } = header;
          var _length = headerLength + frameLength;
          var missing = Math.max(0, offset + _length - data.length);
          if (missing) {
            unit = new Uint8Array(_length - headerLength);
            unit.set(data.subarray(offset + headerLength, data.length), 0);
          } else {
            unit = data.subarray(offset + headerLength, offset + _length);
          }
          var _sample = {
            unit,
            pts: stamp
          };
          if (!missing) {
            track.samples.push(_sample);
          }
          return {
            sample: _sample,
            length: _length,
            missing
          };
        }
        var length = data.length - offset;
        unit = new Uint8Array(length);
        unit.set(data.subarray(offset, data.length), 0);
        var sample = {
          unit,
          pts: stamp
        };
        return {
          sample,
          length,
          missing: -1
        };
      }
      var chromeVersion$1 = null;
      var BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];
      var SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];
      var SamplesCoefficients = [
        [
          0,
          72,
          144,
          12
        ],
        [
          0,
          0,
          0,
          0
        ],
        [
          0,
          72,
          144,
          12
        ],
        [
          0,
          144,
          144,
          12
        ]
      ];
      var BytesInSlot = [
        0,
        1,
        1,
        4
      ];
      function appendFrame(track, data, offset, pts, frameIndex) {
        if (offset + 24 > data.length) {
          return;
        }
        var header = parseHeader(data, offset);
        if (header && offset + header.frameLength <= data.length) {
          var frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;
          var stamp = pts + frameIndex * frameDuration;
          var sample = {
            unit: data.subarray(offset, offset + header.frameLength),
            pts: stamp,
            dts: stamp
          };
          track.config = [];
          track.channelCount = header.channelCount;
          track.samplerate = header.sampleRate;
          track.samples.push(sample);
          return {
            sample,
            length: header.frameLength,
            missing: 0
          };
        }
      }
      function parseHeader(data, offset) {
        var mpegVersion = data[offset + 1] >> 3 & 3;
        var mpegLayer = data[offset + 1] >> 1 & 3;
        var bitRateIndex = data[offset + 2] >> 4 & 15;
        var sampleRateIndex = data[offset + 2] >> 2 & 3;
        if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {
          var paddingBit = data[offset + 2] >> 1 & 1;
          var channelMode = data[offset + 3] >> 6;
          var columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;
          var bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;
          var columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;
          var sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];
          var channelCount = channelMode === 3 ? 1 : 2;
          var sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];
          var bytesInSlot = BytesInSlot[mpegLayer];
          var samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;
          var frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;
          if (chromeVersion$1 === null) {
            var userAgent = navigator.userAgent || "";
            var result = userAgent.match(/Chrome\/(\d+)/i);
            chromeVersion$1 = result ? parseInt(result[1]) : 0;
          }
          var needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;
          if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {
            data[offset + 3] = data[offset + 3] | 128;
          }
          return {
            sampleRate,
            channelCount,
            frameLength,
            samplesPerFrame
          };
        }
      }
      function isHeaderPattern(data, offset) {
        return data[offset] === 255 && (data[offset + 1] & 224) === 224 && (data[offset + 1] & 6) !== 0;
      }
      function isHeader(data, offset) {
        return offset + 1 < data.length && isHeaderPattern(data, offset);
      }
      function canParse(data, offset) {
        var headerSize = 4;
        return isHeaderPattern(data, offset) && headerSize <= data.length - offset;
      }
      function probe(data, offset) {
        if (offset + 1 < data.length && isHeaderPattern(data, offset)) {
          var headerLength = 4;
          var header = parseHeader(data, offset);
          var frameLength = headerLength;
          if (header != null && header.frameLength) {
            frameLength = header.frameLength;
          }
          var newOffset = offset + frameLength;
          return newOffset === data.length || isHeader(data, newOffset);
        }
        return false;
      }
      var AACDemuxer = /* @__PURE__ */ function(_BaseAudioDemuxer) {
        _inheritsLoose(AACDemuxer2, _BaseAudioDemuxer);
        function AACDemuxer2(observer, config) {
          var _this;
          _this = _BaseAudioDemuxer.call(this) || this;
          _this.observer = undefined;
          _this.config = undefined;
          _this.observer = observer;
          _this.config = config;
          return _this;
        }
        var _proto = AACDemuxer2.prototype;
        _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
          _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);
          this._audioTrack = {
            container: "audio/adts",
            type: "audio",
            id: 2,
            pid: -1,
            sequenceNumber: 0,
            segmentCodec: "aac",
            samples: [],
            manifestCodec: audioCodec,
            duration: trackDuration,
            inputTimeScale: 90000,
            dropped: 0
          };
        };
        AACDemuxer2.probe = function probe$2(data) {
          if (!data) {
            return false;
          }
          var id3Data = getID3Data(data, 0);
          var offset = (id3Data == null ? undefined : id3Data.length) || 0;
          if (probe(data, offset)) {
            return false;
          }
          for (var length = data.length;offset < length; offset++) {
            if (probe$1(data, offset)) {
              logger.log("ADTS sync word found !");
              return true;
            }
          }
          return false;
        };
        _proto.canParse = function canParse(data, offset) {
          return canParse$1(data, offset);
        };
        _proto.appendFrame = function appendFrame(track, data, offset) {
          initTrackConfig(track, this.observer, data, offset, track.manifestCodec);
          var frame = appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);
          if (frame && frame.missing === 0) {
            return frame;
          }
        };
        return AACDemuxer2;
      }(BaseAudioDemuxer);
      var emsgSchemePattern = /\/emsg[-/]ID3/i;
      var MP4Demuxer = /* @__PURE__ */ function() {
        function MP4Demuxer2(observer, config) {
          this.remainderData = null;
          this.timeOffset = 0;
          this.config = undefined;
          this.videoTrack = undefined;
          this.audioTrack = undefined;
          this.id3Track = undefined;
          this.txtTrack = undefined;
          this.config = config;
        }
        var _proto = MP4Demuxer2.prototype;
        _proto.resetTimeStamp = function resetTimeStamp() {
        };
        _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
          var videoTrack = this.videoTrack = dummyTrack("video", 1);
          var audioTrack = this.audioTrack = dummyTrack("audio", 1);
          var captionTrack = this.txtTrack = dummyTrack("text", 1);
          this.id3Track = dummyTrack("id3", 1);
          this.timeOffset = 0;
          if (!(initSegment != null && initSegment.byteLength)) {
            return;
          }
          var initData = parseInitSegment(initSegment);
          if (initData.video) {
            var _initData$video = initData.video, id = _initData$video.id, timescale = _initData$video.timescale, codec = _initData$video.codec;
            videoTrack.id = id;
            videoTrack.timescale = captionTrack.timescale = timescale;
            videoTrack.codec = codec;
          }
          if (initData.audio) {
            var _initData$audio = initData.audio, _id = _initData$audio.id, _timescale = _initData$audio.timescale, _codec = _initData$audio.codec;
            audioTrack.id = _id;
            audioTrack.timescale = _timescale;
            audioTrack.codec = _codec;
          }
          captionTrack.id = RemuxerTrackIdConfig.text;
          videoTrack.sampleDuration = 0;
          videoTrack.duration = audioTrack.duration = trackDuration;
        };
        _proto.resetContiguity = function resetContiguity() {
          this.remainderData = null;
        };
        MP4Demuxer2.probe = function probe(data) {
          return hasMoofData(data);
        };
        _proto.demux = function demux(data, timeOffset) {
          this.timeOffset = timeOffset;
          var videoSamples = data;
          var videoTrack = this.videoTrack;
          var textTrack = this.txtTrack;
          if (this.config.progressive) {
            if (this.remainderData) {
              videoSamples = appendUint8Array(this.remainderData, data);
            }
            var segmentedData = segmentValidRange(videoSamples);
            this.remainderData = segmentedData.remainder;
            videoTrack.samples = segmentedData.valid || new Uint8Array;
          } else {
            videoTrack.samples = videoSamples;
          }
          var id3Track = this.extractID3Track(videoTrack, timeOffset);
          textTrack.samples = parseSamples(timeOffset, videoTrack);
          return {
            videoTrack,
            audioTrack: this.audioTrack,
            id3Track,
            textTrack: this.txtTrack
          };
        };
        _proto.flush = function flush() {
          var timeOffset = this.timeOffset;
          var videoTrack = this.videoTrack;
          var textTrack = this.txtTrack;
          videoTrack.samples = this.remainderData || new Uint8Array;
          this.remainderData = null;
          var id3Track = this.extractID3Track(videoTrack, this.timeOffset);
          textTrack.samples = parseSamples(timeOffset, videoTrack);
          return {
            videoTrack,
            audioTrack: dummyTrack(),
            id3Track,
            textTrack: dummyTrack()
          };
        };
        _proto.extractID3Track = function extractID3Track(videoTrack, timeOffset) {
          var id3Track = this.id3Track;
          if (videoTrack.samples.length) {
            var emsgs = findBox(videoTrack.samples, ["emsg"]);
            if (emsgs) {
              emsgs.forEach(function(data) {
                var emsgInfo = parseEmsg(data);
                if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {
                  var pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;
                  var duration = emsgInfo.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;
                  if (duration <= 0.001) {
                    duration = Number.POSITIVE_INFINITY;
                  }
                  var payload = emsgInfo.payload;
                  id3Track.samples.push({
                    data: payload,
                    len: payload.byteLength,
                    dts: pts,
                    pts,
                    type: MetadataSchema.emsg,
                    duration
                  });
                }
              });
            }
          }
          return id3Track;
        };
        _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
          return Promise.reject(new Error("The MP4 demuxer does not support SAMPLE-AES decryption"));
        };
        _proto.destroy = function destroy() {
        };
        return MP4Demuxer2;
      }();
      var getAudioBSID = function getAudioBSID(data, offset) {
        var bsid = 0;
        var numBits = 5;
        offset += numBits;
        var temp = new Uint32Array(1);
        var mask = new Uint32Array(1);
        var _byte = new Uint8Array(1);
        while (numBits > 0) {
          _byte[0] = data[offset];
          var bits = Math.min(numBits, 8);
          var shift = 8 - bits;
          mask[0] = 4278190080 >>> 24 + shift << shift;
          temp[0] = (_byte[0] & mask[0]) >> shift;
          bsid = !bsid ? temp[0] : bsid << bits | temp[0];
          offset += 1;
          numBits -= bits;
        }
        return bsid;
      };
      var AC3Demuxer = /* @__PURE__ */ function(_BaseAudioDemuxer) {
        _inheritsLoose(AC3Demuxer2, _BaseAudioDemuxer);
        function AC3Demuxer2(observer) {
          var _this;
          _this = _BaseAudioDemuxer.call(this) || this;
          _this.observer = undefined;
          _this.observer = observer;
          return _this;
        }
        var _proto = AC3Demuxer2.prototype;
        _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
          _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);
          this._audioTrack = {
            container: "audio/ac-3",
            type: "audio",
            id: 2,
            pid: -1,
            sequenceNumber: 0,
            segmentCodec: "ac3",
            samples: [],
            manifestCodec: audioCodec,
            duration: trackDuration,
            inputTimeScale: 90000,
            dropped: 0
          };
        };
        _proto.canParse = function canParse(data, offset) {
          return offset + 64 < data.length;
        };
        _proto.appendFrame = function appendFrame(track, data, offset) {
          var frameLength = _appendFrame(track, data, offset, this.basePTS, this.frameIndex);
          if (frameLength !== -1) {
            var sample = track.samples[track.samples.length - 1];
            return {
              sample,
              length: frameLength,
              missing: 0
            };
          }
        };
        AC3Demuxer2.probe = function probe(data) {
          if (!data) {
            return false;
          }
          var id3Data = getID3Data(data, 0);
          if (!id3Data) {
            return false;
          }
          var offset = id3Data.length;
          if (data[offset] === 11 && data[offset + 1] === 119 && getTimeStamp(id3Data) !== undefined && getAudioBSID(data, offset) < 16) {
            return true;
          }
          return false;
        };
        return AC3Demuxer2;
      }(BaseAudioDemuxer);
      function _appendFrame(track, data, start, pts, frameIndex) {
        if (start + 8 > data.length) {
          return -1;
        }
        if (data[start] !== 11 || data[start + 1] !== 119) {
          return -1;
        }
        var samplingRateCode = data[start + 4] >> 6;
        if (samplingRateCode >= 3) {
          return -1;
        }
        var samplingRateMap = [48000, 44100, 32000];
        var sampleRate = samplingRateMap[samplingRateCode];
        var frameSizeCode = data[start + 4] & 63;
        var frameSizeMap = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920];
        var frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;
        if (start + frameLength > data.length) {
          return -1;
        }
        var channelMode = data[start + 6] >> 5;
        var skipCount = 0;
        if (channelMode === 2) {
          skipCount += 2;
        } else {
          if (channelMode & 1 && channelMode !== 1) {
            skipCount += 2;
          }
          if (channelMode & 4) {
            skipCount += 2;
          }
        }
        var lfeon = (data[start + 6] << 8 | data[start + 7]) >> 12 - skipCount & 1;
        var channelsMap = [2, 1, 2, 3, 3, 4, 4, 5];
        var channelCount = channelsMap[channelMode] + lfeon;
        var bsid = data[start + 5] >> 3;
        var bsmod = data[start + 5] & 7;
        var config = new Uint8Array([samplingRateCode << 6 | bsid << 1 | bsmod >> 2, (bsmod & 3) << 6 | channelMode << 3 | lfeon << 2 | frameSizeCode >> 4, frameSizeCode << 4 & 224]);
        var frameDuration = 1536 / sampleRate * 90000;
        var stamp = pts + frameIndex * frameDuration;
        var unit = data.subarray(start, start + frameLength);
        track.config = config;
        track.channelCount = channelCount;
        track.samplerate = sampleRate;
        track.samples.push({
          unit,
          pts: stamp
        });
        return frameLength;
      }
      var BaseVideoParser = /* @__PURE__ */ function() {
        function BaseVideoParser2() {
          this.VideoSample = null;
        }
        var _proto = BaseVideoParser2.prototype;
        _proto.createVideoSample = function createVideoSample(key, pts, dts, debug) {
          return {
            key,
            frame: false,
            pts,
            dts,
            units: [],
            debug,
            length: 0
          };
        };
        _proto.getLastNalUnit = function getLastNalUnit(samples) {
          var _VideoSample;
          var VideoSample = this.VideoSample;
          var lastUnit;
          if (!VideoSample || VideoSample.units.length === 0) {
            VideoSample = samples[samples.length - 1];
          }
          if ((_VideoSample = VideoSample) != null && _VideoSample.units) {
            var units = VideoSample.units;
            lastUnit = units[units.length - 1];
          }
          return lastUnit;
        };
        _proto.pushAccessUnit = function pushAccessUnit(VideoSample, videoTrack) {
          if (VideoSample.units.length && VideoSample.frame) {
            if (VideoSample.pts === undefined) {
              var samples = videoTrack.samples;
              var nbSamples = samples.length;
              if (nbSamples) {
                var lastSample = samples[nbSamples - 1];
                VideoSample.pts = lastSample.pts;
                VideoSample.dts = lastSample.dts;
              } else {
                videoTrack.dropped++;
                return;
              }
            }
            videoTrack.samples.push(VideoSample);
          }
          if (VideoSample.debug.length) {
            logger.log(VideoSample.pts + "/" + VideoSample.dts + ":" + VideoSample.debug);
          }
        };
        return BaseVideoParser2;
      }();
      var ExpGolomb = /* @__PURE__ */ function() {
        function ExpGolomb2(data) {
          this.data = undefined;
          this.bytesAvailable = undefined;
          this.word = undefined;
          this.bitsAvailable = undefined;
          this.data = data;
          this.bytesAvailable = data.byteLength;
          this.word = 0;
          this.bitsAvailable = 0;
        }
        var _proto = ExpGolomb2.prototype;
        _proto.loadWord = function loadWord() {
          var data = this.data;
          var bytesAvailable = this.bytesAvailable;
          var position = data.byteLength - bytesAvailable;
          var workingBytes = new Uint8Array(4);
          var availableBytes = Math.min(4, bytesAvailable);
          if (availableBytes === 0) {
            throw new Error("no bytes available");
          }
          workingBytes.set(data.subarray(position, position + availableBytes));
          this.word = new DataView(workingBytes.buffer).getUint32(0);
          this.bitsAvailable = availableBytes * 8;
          this.bytesAvailable -= availableBytes;
        };
        _proto.skipBits = function skipBits(count) {
          var skipBytes;
          count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);
          if (this.bitsAvailable > count) {
            this.word <<= count;
            this.bitsAvailable -= count;
          } else {
            count -= this.bitsAvailable;
            skipBytes = count >> 3;
            count -= skipBytes << 3;
            this.bytesAvailable -= skipBytes;
            this.loadWord();
            this.word <<= count;
            this.bitsAvailable -= count;
          }
        };
        _proto.readBits = function readBits(size) {
          var bits = Math.min(this.bitsAvailable, size);
          var valu = this.word >>> 32 - bits;
          if (size > 32) {
            logger.error("Cannot read more than 32 bits at a time");
          }
          this.bitsAvailable -= bits;
          if (this.bitsAvailable > 0) {
            this.word <<= bits;
          } else if (this.bytesAvailable > 0) {
            this.loadWord();
          } else {
            throw new Error("no bits available");
          }
          bits = size - bits;
          if (bits > 0 && this.bitsAvailable) {
            return valu << bits | this.readBits(bits);
          } else {
            return valu;
          }
        };
        _proto.skipLZ = function skipLZ() {
          var leadingZeroCount;
          for (leadingZeroCount = 0;leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {
            if ((this.word & 2147483648 >>> leadingZeroCount) !== 0) {
              this.word <<= leadingZeroCount;
              this.bitsAvailable -= leadingZeroCount;
              return leadingZeroCount;
            }
          }
          this.loadWord();
          return leadingZeroCount + this.skipLZ();
        };
        _proto.skipUEG = function skipUEG() {
          this.skipBits(1 + this.skipLZ());
        };
        _proto.skipEG = function skipEG() {
          this.skipBits(1 + this.skipLZ());
        };
        _proto.readUEG = function readUEG() {
          var clz = this.skipLZ();
          return this.readBits(clz + 1) - 1;
        };
        _proto.readEG = function readEG() {
          var valu = this.readUEG();
          if (1 & valu) {
            return 1 + valu >>> 1;
          } else {
            return -1 * (valu >>> 1);
          }
        };
        _proto.readBoolean = function readBoolean() {
          return this.readBits(1) === 1;
        };
        _proto.readUByte = function readUByte() {
          return this.readBits(8);
        };
        _proto.readUShort = function readUShort() {
          return this.readBits(16);
        };
        _proto.readUInt = function readUInt() {
          return this.readBits(32);
        };
        _proto.skipScalingList = function skipScalingList(count) {
          var lastScale = 8;
          var nextScale = 8;
          var deltaScale;
          for (var j = 0;j < count; j++) {
            if (nextScale !== 0) {
              deltaScale = this.readEG();
              nextScale = (lastScale + deltaScale + 256) % 256;
            }
            lastScale = nextScale === 0 ? lastScale : nextScale;
          }
        };
        _proto.readSPS = function readSPS() {
          var frameCropLeftOffset = 0;
          var frameCropRightOffset = 0;
          var frameCropTopOffset = 0;
          var frameCropBottomOffset = 0;
          var numRefFramesInPicOrderCntCycle;
          var scalingListCount;
          var i;
          var readUByte = this.readUByte.bind(this);
          var readBits = this.readBits.bind(this);
          var readUEG = this.readUEG.bind(this);
          var readBoolean = this.readBoolean.bind(this);
          var skipBits = this.skipBits.bind(this);
          var skipEG = this.skipEG.bind(this);
          var skipUEG = this.skipUEG.bind(this);
          var skipScalingList = this.skipScalingList.bind(this);
          readUByte();
          var profileIdc = readUByte();
          readBits(5);
          skipBits(3);
          readUByte();
          skipUEG();
          if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {
            var chromaFormatIdc = readUEG();
            if (chromaFormatIdc === 3) {
              skipBits(1);
            }
            skipUEG();
            skipUEG();
            skipBits(1);
            if (readBoolean()) {
              scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
              for (i = 0;i < scalingListCount; i++) {
                if (readBoolean()) {
                  if (i < 6) {
                    skipScalingList(16);
                  } else {
                    skipScalingList(64);
                  }
                }
              }
            }
          }
          skipUEG();
          var picOrderCntType = readUEG();
          if (picOrderCntType === 0) {
            readUEG();
          } else if (picOrderCntType === 1) {
            skipBits(1);
            skipEG();
            skipEG();
            numRefFramesInPicOrderCntCycle = readUEG();
            for (i = 0;i < numRefFramesInPicOrderCntCycle; i++) {
              skipEG();
            }
          }
          skipUEG();
          skipBits(1);
          var picWidthInMbsMinus1 = readUEG();
          var picHeightInMapUnitsMinus1 = readUEG();
          var frameMbsOnlyFlag = readBits(1);
          if (frameMbsOnlyFlag === 0) {
            skipBits(1);
          }
          skipBits(1);
          if (readBoolean()) {
            frameCropLeftOffset = readUEG();
            frameCropRightOffset = readUEG();
            frameCropTopOffset = readUEG();
            frameCropBottomOffset = readUEG();
          }
          var pixelRatio = [1, 1];
          if (readBoolean()) {
            if (readBoolean()) {
              var aspectRatioIdc = readUByte();
              switch (aspectRatioIdc) {
                case 1:
                  pixelRatio = [1, 1];
                  break;
                case 2:
                  pixelRatio = [12, 11];
                  break;
                case 3:
                  pixelRatio = [10, 11];
                  break;
                case 4:
                  pixelRatio = [16, 11];
                  break;
                case 5:
                  pixelRatio = [40, 33];
                  break;
                case 6:
                  pixelRatio = [24, 11];
                  break;
                case 7:
                  pixelRatio = [20, 11];
                  break;
                case 8:
                  pixelRatio = [32, 11];
                  break;
                case 9:
                  pixelRatio = [80, 33];
                  break;
                case 10:
                  pixelRatio = [18, 11];
                  break;
                case 11:
                  pixelRatio = [15, 11];
                  break;
                case 12:
                  pixelRatio = [64, 33];
                  break;
                case 13:
                  pixelRatio = [160, 99];
                  break;
                case 14:
                  pixelRatio = [4, 3];
                  break;
                case 15:
                  pixelRatio = [3, 2];
                  break;
                case 16:
                  pixelRatio = [2, 1];
                  break;
                case 255: {
                  pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];
                  break;
                }
              }
            }
          }
          return {
            width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),
            height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),
            pixelRatio
          };
        };
        _proto.readSliceType = function readSliceType() {
          this.readUByte();
          this.readUEG();
          return this.readUEG();
        };
        return ExpGolomb2;
      }();
      var AvcVideoParser = /* @__PURE__ */ function(_BaseVideoParser) {
        _inheritsLoose(AvcVideoParser2, _BaseVideoParser);
        function AvcVideoParser2() {
          return _BaseVideoParser.apply(this, arguments) || this;
        }
        var _proto = AvcVideoParser2.prototype;
        _proto.parseAVCPES = function parseAVCPES(track, textTrack, pes, last, duration) {
          var _this = this;
          var units = this.parseAVCNALu(track, pes.data);
          var VideoSample = this.VideoSample;
          var push2;
          var spsfound = false;
          pes.data = null;
          if (VideoSample && units.length && !track.audFound) {
            this.pushAccessUnit(VideoSample, track);
            VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, "");
          }
          units.forEach(function(unit) {
            var _VideoSample2;
            switch (unit.type) {
              case 1: {
                var iskey = false;
                push2 = true;
                var data = unit.data;
                if (spsfound && data.length > 4) {
                  var sliceType = new ExpGolomb(data).readSliceType();
                  if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {
                    iskey = true;
                  }
                }
                if (iskey) {
                  var _VideoSample;
                  if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {
                    _this.pushAccessUnit(VideoSample, track);
                    VideoSample = _this.VideoSample = null;
                  }
                }
                if (!VideoSample) {
                  VideoSample = _this.VideoSample = _this.createVideoSample(true, pes.pts, pes.dts, "");
                }
                VideoSample.frame = true;
                VideoSample.key = iskey;
                break;
              }
              case 5:
                push2 = true;
                if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {
                  _this.pushAccessUnit(VideoSample, track);
                  VideoSample = _this.VideoSample = null;
                }
                if (!VideoSample) {
                  VideoSample = _this.VideoSample = _this.createVideoSample(true, pes.pts, pes.dts, "");
                }
                VideoSample.key = true;
                VideoSample.frame = true;
                break;
              case 6: {
                push2 = true;
                parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);
                break;
              }
              case 7: {
                var _track$pixelRatio, _track$pixelRatio2;
                push2 = true;
                spsfound = true;
                var sps = unit.data;
                var expGolombDecoder = new ExpGolomb(sps);
                var config = expGolombDecoder.readSPS();
                if (!track.sps || track.width !== config.width || track.height !== config.height || ((_track$pixelRatio = track.pixelRatio) == null ? undefined : _track$pixelRatio[0]) !== config.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? undefined : _track$pixelRatio2[1]) !== config.pixelRatio[1]) {
                  track.width = config.width;
                  track.height = config.height;
                  track.pixelRatio = config.pixelRatio;
                  track.sps = [sps];
                  track.duration = duration;
                  var codecarray = sps.subarray(1, 4);
                  var codecstring = "avc1.";
                  for (var i = 0;i < 3; i++) {
                    var h = codecarray[i].toString(16);
                    if (h.length < 2) {
                      h = "0" + h;
                    }
                    codecstring += h;
                  }
                  track.codec = codecstring;
                }
                break;
              }
              case 8:
                push2 = true;
                track.pps = [unit.data];
                break;
              case 9:
                push2 = true;
                track.audFound = true;
                if (VideoSample) {
                  _this.pushAccessUnit(VideoSample, track);
                }
                VideoSample = _this.VideoSample = _this.createVideoSample(false, pes.pts, pes.dts, "");
                break;
              case 12:
                push2 = true;
                break;
              default:
                push2 = false;
                if (VideoSample) {
                  VideoSample.debug += "unknown NAL " + unit.type + " ";
                }
                break;
            }
            if (VideoSample && push2) {
              var _units = VideoSample.units;
              _units.push(unit);
            }
          });
          if (last && VideoSample) {
            this.pushAccessUnit(VideoSample, track);
            this.VideoSample = null;
          }
        };
        _proto.parseAVCNALu = function parseAVCNALu(track, array) {
          var len = array.byteLength;
          var state = track.naluState || 0;
          var lastState = state;
          var units = [];
          var i = 0;
          var value;
          var overflow;
          var unitType;
          var lastUnitStart = -1;
          var lastUnitType = 0;
          if (state === -1) {
            lastUnitStart = 0;
            lastUnitType = array[0] & 31;
            state = 0;
            i = 1;
          }
          while (i < len) {
            value = array[i++];
            if (!state) {
              state = value ? 0 : 1;
              continue;
            }
            if (state === 1) {
              state = value ? 0 : 2;
              continue;
            }
            if (!value) {
              state = 3;
            } else if (value === 1) {
              overflow = i - state - 1;
              if (lastUnitStart >= 0) {
                var unit = {
                  data: array.subarray(lastUnitStart, overflow),
                  type: lastUnitType
                };
                units.push(unit);
              } else {
                var lastUnit = this.getLastNalUnit(track.samples);
                if (lastUnit) {
                  if (lastState && i <= 4 - lastState) {
                    if (lastUnit.state) {
                      lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);
                    }
                  }
                  if (overflow > 0) {
                    lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));
                    lastUnit.state = 0;
                  }
                }
              }
              if (i < len) {
                unitType = array[i] & 31;
                lastUnitStart = i;
                lastUnitType = unitType;
                state = 0;
              } else {
                state = -1;
              }
            } else {
              state = 0;
            }
          }
          if (lastUnitStart >= 0 && state >= 0) {
            var _unit = {
              data: array.subarray(lastUnitStart, len),
              type: lastUnitType,
              state
            };
            units.push(_unit);
          }
          if (units.length === 0) {
            var _lastUnit = this.getLastNalUnit(track.samples);
            if (_lastUnit) {
              _lastUnit.data = appendUint8Array(_lastUnit.data, array);
            }
          }
          track.naluState = state;
          return units;
        };
        return AvcVideoParser2;
      }(BaseVideoParser);
      var SampleAesDecrypter = /* @__PURE__ */ function() {
        function SampleAesDecrypter2(observer, config, keyData) {
          this.keyData = undefined;
          this.decrypter = undefined;
          this.keyData = keyData;
          this.decrypter = new Decrypter(config, {
            removePKCS7Padding: false
          });
        }
        var _proto = SampleAesDecrypter2.prototype;
        _proto.decryptBuffer = function decryptBuffer(encryptedData) {
          return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);
        };
        _proto.decryptAacSample = function decryptAacSample(samples, sampleIndex, callback) {
          var _this = this;
          var curUnit = samples[sampleIndex].unit;
          if (curUnit.length <= 16) {
            return;
          }
          var encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);
          var encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);
          this.decryptBuffer(encryptedBuffer).then(function(decryptedBuffer) {
            var decryptedData = new Uint8Array(decryptedBuffer);
            curUnit.set(decryptedData, 16);
            if (!_this.decrypter.isSync()) {
              _this.decryptAacSamples(samples, sampleIndex + 1, callback);
            }
          });
        };
        _proto.decryptAacSamples = function decryptAacSamples(samples, sampleIndex, callback) {
          for (;; sampleIndex++) {
            if (sampleIndex >= samples.length) {
              callback();
              return;
            }
            if (samples[sampleIndex].unit.length < 32) {
              continue;
            }
            this.decryptAacSample(samples, sampleIndex, callback);
            if (!this.decrypter.isSync()) {
              return;
            }
          }
        };
        _proto.getAvcEncryptedData = function getAvcEncryptedData(decodedData) {
          var encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;
          var encryptedData = new Int8Array(encryptedDataLen);
          var outputPos = 0;
          for (var inputPos = 32;inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {
            encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);
          }
          return encryptedData;
        };
        _proto.getAvcDecryptedUnit = function getAvcDecryptedUnit(decodedData, decryptedData) {
          var uint8DecryptedData = new Uint8Array(decryptedData);
          var inputPos = 0;
          for (var outputPos = 32;outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {
            decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);
          }
          return decodedData;
        };
        _proto.decryptAvcSample = function decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {
          var _this2 = this;
          var decodedData = discardEPB(curUnit.data);
          var encryptedData = this.getAvcEncryptedData(decodedData);
          this.decryptBuffer(encryptedData.buffer).then(function(decryptedBuffer) {
            curUnit.data = _this2.getAvcDecryptedUnit(decodedData, decryptedBuffer);
            if (!_this2.decrypter.isSync()) {
              _this2.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);
            }
          });
        };
        _proto.decryptAvcSamples = function decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {
          if (samples instanceof Uint8Array) {
            throw new Error("Cannot decrypt samples of type Uint8Array");
          }
          for (;; sampleIndex++, unitIndex = 0) {
            if (sampleIndex >= samples.length) {
              callback();
              return;
            }
            var curUnits = samples[sampleIndex].units;
            for (;; unitIndex++) {
              if (unitIndex >= curUnits.length) {
                break;
              }
              var curUnit = curUnits[unitIndex];
              if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {
                continue;
              }
              this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);
              if (!this.decrypter.isSync()) {
                return;
              }
            }
          }
        };
        return SampleAesDecrypter2;
      }();
      var PACKET_LENGTH = 188;
      var TSDemuxer = /* @__PURE__ */ function() {
        function TSDemuxer2(observer, config, typeSupported) {
          this.observer = undefined;
          this.config = undefined;
          this.typeSupported = undefined;
          this.sampleAes = null;
          this.pmtParsed = false;
          this.audioCodec = undefined;
          this.videoCodec = undefined;
          this._duration = 0;
          this._pmtId = -1;
          this._videoTrack = undefined;
          this._audioTrack = undefined;
          this._id3Track = undefined;
          this._txtTrack = undefined;
          this.aacOverFlow = null;
          this.remainderData = null;
          this.videoParser = undefined;
          this.observer = observer;
          this.config = config;
          this.typeSupported = typeSupported;
          this.videoParser = new AvcVideoParser;
        }
        TSDemuxer2.probe = function probe(data) {
          var syncOffset = TSDemuxer2.syncOffset(data);
          if (syncOffset > 0) {
            logger.warn("MPEG2-TS detected but first sync word found @ offset " + syncOffset);
          }
          return syncOffset !== -1;
        };
        TSDemuxer2.syncOffset = function syncOffset(data) {
          var length = data.length;
          var scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;
          var i = 0;
          while (i < scanwindow) {
            var foundPat = false;
            var packetStart = -1;
            var tsPackets = 0;
            for (var j = i;j < length; j += PACKET_LENGTH) {
              if (data[j] === 71 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 71)) {
                tsPackets++;
                if (packetStart === -1) {
                  packetStart = j;
                  if (packetStart !== 0) {
                    scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;
                  }
                }
                if (!foundPat) {
                  foundPat = parsePID(data, j) === 0;
                }
                if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {
                  return packetStart;
                }
              } else if (tsPackets) {
                return -1;
              } else {
                break;
              }
            }
            i++;
          }
          return -1;
        };
        TSDemuxer2.createTrack = function createTrack(type, duration) {
          return {
            container: type === "video" || type === "audio" ? "video/mp2t" : undefined,
            type,
            id: RemuxerTrackIdConfig[type],
            pid: -1,
            inputTimeScale: 90000,
            sequenceNumber: 0,
            samples: [],
            dropped: 0,
            duration: type === "audio" ? duration : undefined
          };
        };
        var _proto = TSDemuxer2.prototype;
        _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
          this.pmtParsed = false;
          this._pmtId = -1;
          this._videoTrack = TSDemuxer2.createTrack("video");
          this._audioTrack = TSDemuxer2.createTrack("audio", trackDuration);
          this._id3Track = TSDemuxer2.createTrack("id3");
          this._txtTrack = TSDemuxer2.createTrack("text");
          this._audioTrack.segmentCodec = "aac";
          this.aacOverFlow = null;
          this.remainderData = null;
          this.audioCodec = audioCodec;
          this.videoCodec = videoCodec;
          this._duration = trackDuration;
        };
        _proto.resetTimeStamp = function resetTimeStamp() {
        };
        _proto.resetContiguity = function resetContiguity() {
          var _audioTrack = this._audioTrack, _videoTrack = this._videoTrack, _id3Track = this._id3Track;
          if (_audioTrack) {
            _audioTrack.pesData = null;
          }
          if (_videoTrack) {
            _videoTrack.pesData = null;
          }
          if (_id3Track) {
            _id3Track.pesData = null;
          }
          this.aacOverFlow = null;
          this.remainderData = null;
        };
        _proto.demux = function demux(data, timeOffset, isSampleAes, flush) {
          if (isSampleAes === undefined) {
            isSampleAes = false;
          }
          if (flush === undefined) {
            flush = false;
          }
          if (!isSampleAes) {
            this.sampleAes = null;
          }
          var pes;
          var videoTrack = this._videoTrack;
          var audioTrack = this._audioTrack;
          var id3Track = this._id3Track;
          var textTrack = this._txtTrack;
          var videoPid = videoTrack.pid;
          var videoData = videoTrack.pesData;
          var audioPid = audioTrack.pid;
          var id3Pid = id3Track.pid;
          var audioData = audioTrack.pesData;
          var id3Data = id3Track.pesData;
          var unknownPID = null;
          var pmtParsed = this.pmtParsed;
          var pmtId = this._pmtId;
          var len = data.length;
          if (this.remainderData) {
            data = appendUint8Array(this.remainderData, data);
            len = data.length;
            this.remainderData = null;
          }
          if (len < PACKET_LENGTH && !flush) {
            this.remainderData = data;
            return {
              audioTrack,
              videoTrack,
              id3Track,
              textTrack
            };
          }
          var syncOffset = Math.max(0, TSDemuxer2.syncOffset(data));
          len -= (len - syncOffset) % PACKET_LENGTH;
          if (len < data.byteLength && !flush) {
            this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);
          }
          var tsPacketErrors = 0;
          for (var start = syncOffset;start < len; start += PACKET_LENGTH) {
            if (data[start] === 71) {
              var stt = !!(data[start + 1] & 64);
              var pid = parsePID(data, start);
              var atf = (data[start + 3] & 48) >> 4;
              var offset = undefined;
              if (atf > 1) {
                offset = start + 5 + data[start + 4];
                if (offset === start + PACKET_LENGTH) {
                  continue;
                }
              } else {
                offset = start + 4;
              }
              switch (pid) {
                case videoPid:
                  if (stt) {
                    if (videoData && (pes = parsePES(videoData))) {
                      this.videoParser.parseAVCPES(videoTrack, textTrack, pes, false, this._duration);
                    }
                    videoData = {
                      data: [],
                      size: 0
                    };
                  }
                  if (videoData) {
                    videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));
                    videoData.size += start + PACKET_LENGTH - offset;
                  }
                  break;
                case audioPid:
                  if (stt) {
                    if (audioData && (pes = parsePES(audioData))) {
                      switch (audioTrack.segmentCodec) {
                        case "aac":
                          this.parseAACPES(audioTrack, pes);
                          break;
                        case "mp3":
                          this.parseMPEGPES(audioTrack, pes);
                          break;
                        case "ac3":
                          {
                            this.parseAC3PES(audioTrack, pes);
                          }
                          break;
                      }
                    }
                    audioData = {
                      data: [],
                      size: 0
                    };
                  }
                  if (audioData) {
                    audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));
                    audioData.size += start + PACKET_LENGTH - offset;
                  }
                  break;
                case id3Pid:
                  if (stt) {
                    if (id3Data && (pes = parsePES(id3Data))) {
                      this.parseID3PES(id3Track, pes);
                    }
                    id3Data = {
                      data: [],
                      size: 0
                    };
                  }
                  if (id3Data) {
                    id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));
                    id3Data.size += start + PACKET_LENGTH - offset;
                  }
                  break;
                case 0:
                  if (stt) {
                    offset += data[offset] + 1;
                  }
                  pmtId = this._pmtId = parsePAT(data, offset);
                  break;
                case pmtId: {
                  if (stt) {
                    offset += data[offset] + 1;
                  }
                  var parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes, this.observer);
                  videoPid = parsedPIDs.videoPid;
                  if (videoPid > 0) {
                    videoTrack.pid = videoPid;
                    videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;
                  }
                  audioPid = parsedPIDs.audioPid;
                  if (audioPid > 0) {
                    audioTrack.pid = audioPid;
                    audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;
                  }
                  id3Pid = parsedPIDs.id3Pid;
                  if (id3Pid > 0) {
                    id3Track.pid = id3Pid;
                  }
                  if (unknownPID !== null && !pmtParsed) {
                    logger.warn("MPEG-TS PMT found at " + start + " after unknown PID '" + unknownPID + "'. Backtracking to sync byte @" + syncOffset + " to parse all TS packets.");
                    unknownPID = null;
                    start = syncOffset - 188;
                  }
                  pmtParsed = this.pmtParsed = true;
                  break;
                }
                case 17:
                case 8191:
                  break;
                default:
                  unknownPID = pid;
                  break;
              }
            } else {
              tsPacketErrors++;
            }
          }
          if (tsPacketErrors > 0) {
            emitParsingError(this.observer, new Error("Found " + tsPacketErrors + " TS packet/s that do not start with 0x47"));
          }
          videoTrack.pesData = videoData;
          audioTrack.pesData = audioData;
          id3Track.pesData = id3Data;
          var demuxResult = {
            audioTrack,
            videoTrack,
            id3Track,
            textTrack
          };
          if (flush) {
            this.extractRemainingSamples(demuxResult);
          }
          return demuxResult;
        };
        _proto.flush = function flush() {
          var remainderData = this.remainderData;
          this.remainderData = null;
          var result;
          if (remainderData) {
            result = this.demux(remainderData, -1, false, true);
          } else {
            result = {
              videoTrack: this._videoTrack,
              audioTrack: this._audioTrack,
              id3Track: this._id3Track,
              textTrack: this._txtTrack
            };
          }
          this.extractRemainingSamples(result);
          if (this.sampleAes) {
            return this.decrypt(result, this.sampleAes);
          }
          return result;
        };
        _proto.extractRemainingSamples = function extractRemainingSamples(demuxResult) {
          var { audioTrack, videoTrack, id3Track, textTrack } = demuxResult;
          var videoData = videoTrack.pesData;
          var audioData = audioTrack.pesData;
          var id3Data = id3Track.pesData;
          var pes;
          if (videoData && (pes = parsePES(videoData))) {
            this.videoParser.parseAVCPES(videoTrack, textTrack, pes, true, this._duration);
            videoTrack.pesData = null;
          } else {
            videoTrack.pesData = videoData;
          }
          if (audioData && (pes = parsePES(audioData))) {
            switch (audioTrack.segmentCodec) {
              case "aac":
                this.parseAACPES(audioTrack, pes);
                break;
              case "mp3":
                this.parseMPEGPES(audioTrack, pes);
                break;
              case "ac3":
                {
                  this.parseAC3PES(audioTrack, pes);
                }
                break;
            }
            audioTrack.pesData = null;
          } else {
            if (audioData != null && audioData.size) {
              logger.log("last AAC PES packet truncated,might overlap between fragments");
            }
            audioTrack.pesData = audioData;
          }
          if (id3Data && (pes = parsePES(id3Data))) {
            this.parseID3PES(id3Track, pes);
            id3Track.pesData = null;
          } else {
            id3Track.pesData = id3Data;
          }
        };
        _proto.demuxSampleAes = function demuxSampleAes(data, keyData, timeOffset) {
          var demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);
          var sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);
          return this.decrypt(demuxResult, sampleAes);
        };
        _proto.decrypt = function decrypt(demuxResult, sampleAes) {
          return new Promise(function(resolve) {
            var { audioTrack, videoTrack } = demuxResult;
            if (audioTrack.samples && audioTrack.segmentCodec === "aac") {
              sampleAes.decryptAacSamples(audioTrack.samples, 0, function() {
                if (videoTrack.samples) {
                  sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function() {
                    resolve(demuxResult);
                  });
                } else {
                  resolve(demuxResult);
                }
              });
            } else if (videoTrack.samples) {
              sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, function() {
                resolve(demuxResult);
              });
            }
          });
        };
        _proto.destroy = function destroy() {
          this._duration = 0;
        };
        _proto.parseAACPES = function parseAACPES(track, pes) {
          var startOffset = 0;
          var aacOverFlow = this.aacOverFlow;
          var data = pes.data;
          if (aacOverFlow) {
            this.aacOverFlow = null;
            var frameMissingBytes = aacOverFlow.missing;
            var sampleLength = aacOverFlow.sample.unit.byteLength;
            if (frameMissingBytes === -1) {
              data = appendUint8Array(aacOverFlow.sample.unit, data);
            } else {
              var frameOverflowBytes = sampleLength - frameMissingBytes;
              aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);
              track.samples.push(aacOverFlow.sample);
              startOffset = aacOverFlow.missing;
            }
          }
          var offset;
          var len;
          for (offset = startOffset, len = data.length;offset < len - 1; offset++) {
            if (isHeader$1(data, offset)) {
              break;
            }
          }
          if (offset !== startOffset) {
            var reason;
            var recoverable = offset < len - 1;
            if (recoverable) {
              reason = "AAC PES did not start with ADTS header,offset:" + offset;
            } else {
              reason = "No ADTS header found in AAC PES";
            }
            emitParsingError(this.observer, new Error(reason), recoverable);
            if (!recoverable) {
              return;
            }
          }
          initTrackConfig(track, this.observer, data, offset, this.audioCodec);
          var pts;
          if (pes.pts !== undefined) {
            pts = pes.pts;
          } else if (aacOverFlow) {
            var frameDuration = getFrameDuration(track.samplerate);
            pts = aacOverFlow.sample.pts + frameDuration;
          } else {
            logger.warn("[tsdemuxer]: AAC PES unknown PTS");
            return;
          }
          var frameIndex = 0;
          var frame;
          while (offset < len) {
            frame = appendFrame$1(track, data, offset, pts, frameIndex);
            offset += frame.length;
            if (!frame.missing) {
              frameIndex++;
              for (;offset < len - 1; offset++) {
                if (isHeader$1(data, offset)) {
                  break;
                }
              }
            } else {
              this.aacOverFlow = frame;
              break;
            }
          }
        };
        _proto.parseMPEGPES = function parseMPEGPES(track, pes) {
          var data = pes.data;
          var length = data.length;
          var frameIndex = 0;
          var offset = 0;
          var pts = pes.pts;
          if (pts === undefined) {
            logger.warn("[tsdemuxer]: MPEG PES unknown PTS");
            return;
          }
          while (offset < length) {
            if (isHeader(data, offset)) {
              var frame = appendFrame(track, data, offset, pts, frameIndex);
              if (frame) {
                offset += frame.length;
                frameIndex++;
              } else {
                break;
              }
            } else {
              offset++;
            }
          }
        };
        _proto.parseAC3PES = function parseAC3PES(track, pes) {
          {
            var data = pes.data;
            var pts = pes.pts;
            if (pts === undefined) {
              logger.warn("[tsdemuxer]: AC3 PES unknown PTS");
              return;
            }
            var length = data.length;
            var frameIndex = 0;
            var offset = 0;
            var parsed;
            while (offset < length && (parsed = _appendFrame(track, data, offset, pts, frameIndex++)) > 0) {
              offset += parsed;
            }
          }
        };
        _proto.parseID3PES = function parseID3PES(id3Track, pes) {
          if (pes.pts === undefined) {
            logger.warn("[tsdemuxer]: ID3 PES unknown PTS");
            return;
          }
          var id3Sample = _extends({}, pes, {
            type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,
            duration: Number.POSITIVE_INFINITY
          });
          id3Track.samples.push(id3Sample);
        };
        return TSDemuxer2;
      }();
      function parsePID(data, offset) {
        return ((data[offset + 1] & 31) << 8) + data[offset + 2];
      }
      function parsePAT(data, offset) {
        return (data[offset + 10] & 31) << 8 | data[offset + 11];
      }
      function parsePMT(data, offset, typeSupported, isSampleAes, observer) {
        var result = {
          audioPid: -1,
          videoPid: -1,
          id3Pid: -1,
          segmentVideoCodec: "avc",
          segmentAudioCodec: "aac"
        };
        var sectionLength = (data[offset + 1] & 15) << 8 | data[offset + 2];
        var tableEnd = offset + 3 + sectionLength - 4;
        var programInfoLength = (data[offset + 10] & 15) << 8 | data[offset + 11];
        offset += 12 + programInfoLength;
        while (offset < tableEnd) {
          var pid = parsePID(data, offset);
          var esInfoLength = (data[offset + 3] & 15) << 8 | data[offset + 4];
          switch (data[offset]) {
            case 207:
              if (!isSampleAes) {
                logEncryptedSamplesFoundInUnencryptedStream("ADTS AAC");
                break;
              }
            case 15:
              if (result.audioPid === -1) {
                result.audioPid = pid;
              }
              break;
            case 21:
              if (result.id3Pid === -1) {
                result.id3Pid = pid;
              }
              break;
            case 219:
              if (!isSampleAes) {
                logEncryptedSamplesFoundInUnencryptedStream("H.264");
                break;
              }
            case 27:
              if (result.videoPid === -1) {
                result.videoPid = pid;
                result.segmentVideoCodec = "avc";
              }
              break;
            case 3:
            case 4:
              if (!typeSupported.mpeg && !typeSupported.mp3) {
                logger.log("MPEG audio found, not supported in this browser");
              } else if (result.audioPid === -1) {
                result.audioPid = pid;
                result.segmentAudioCodec = "mp3";
              }
              break;
            case 193:
              if (!isSampleAes) {
                logEncryptedSamplesFoundInUnencryptedStream("AC-3");
                break;
              }
            case 129:
              {
                if (!typeSupported.ac3) {
                  logger.log("AC-3 audio found, not supported in this browser");
                } else if (result.audioPid === -1) {
                  result.audioPid = pid;
                  result.segmentAudioCodec = "ac3";
                }
              }
              break;
            case 6:
              if (result.audioPid === -1 && esInfoLength > 0) {
                var parsePos = offset + 5;
                var remaining = esInfoLength;
                while (remaining > 2) {
                  var descriptorId = data[parsePos];
                  switch (descriptorId) {
                    case 106:
                      {
                        if (typeSupported.ac3 !== true) {
                          logger.log("AC-3 audio found, not supported in this browser for now");
                        } else {
                          result.audioPid = pid;
                          result.segmentAudioCodec = "ac3";
                        }
                      }
                      break;
                  }
                  var descriptorLen = data[parsePos + 1] + 2;
                  parsePos += descriptorLen;
                  remaining -= descriptorLen;
                }
              }
              break;
            case 194:
            case 135:
              emitParsingError(observer, new Error("Unsupported EC-3 in M2TS found"));
              return result;
            case 36:
              emitParsingError(observer, new Error("Unsupported HEVC in M2TS found"));
              return result;
          }
          offset += esInfoLength + 5;
        }
        return result;
      }
      function emitParsingError(observer, error2, levelRetry) {
        logger.warn("parsing error: " + error2.message);
        observer.emit(Events.ERROR, Events.ERROR, {
          type: ErrorTypes2.MEDIA_ERROR,
          details: ErrorDetails.FRAG_PARSING_ERROR,
          fatal: false,
          levelRetry,
          error: error2,
          reason: error2.message
        });
      }
      function logEncryptedSamplesFoundInUnencryptedStream(type) {
        logger.log(type + " with AES-128-CBC encryption found in unencrypted stream");
      }
      function parsePES(stream) {
        var i = 0;
        var frag;
        var pesLen;
        var pesHdrLen;
        var pesPts;
        var pesDts;
        var data = stream.data;
        if (!stream || stream.size === 0) {
          return null;
        }
        while (data[0].length < 19 && data.length > 1) {
          data[0] = appendUint8Array(data[0], data[1]);
          data.splice(1, 1);
        }
        frag = data[0];
        var pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];
        if (pesPrefix === 1) {
          pesLen = (frag[4] << 8) + frag[5];
          if (pesLen && pesLen > stream.size - 6) {
            return null;
          }
          var pesFlags = frag[7];
          if (pesFlags & 192) {
            pesPts = (frag[9] & 14) * 536870912 + (frag[10] & 255) * 4194304 + (frag[11] & 254) * 16384 + (frag[12] & 255) * 128 + (frag[13] & 254) / 2;
            if (pesFlags & 64) {
              pesDts = (frag[14] & 14) * 536870912 + (frag[15] & 255) * 4194304 + (frag[16] & 254) * 16384 + (frag[17] & 255) * 128 + (frag[18] & 254) / 2;
              if (pesPts - pesDts > 60 * 90000) {
                logger.warn(Math.round((pesPts - pesDts) / 90000) + "s delta between PTS and DTS, align them");
                pesPts = pesDts;
              }
            } else {
              pesDts = pesPts;
            }
          }
          pesHdrLen = frag[8];
          var payloadStartOffset = pesHdrLen + 9;
          if (stream.size <= payloadStartOffset) {
            return null;
          }
          stream.size -= payloadStartOffset;
          var pesData = new Uint8Array(stream.size);
          for (var j = 0, dataLen = data.length;j < dataLen; j++) {
            frag = data[j];
            var len = frag.byteLength;
            if (payloadStartOffset) {
              if (payloadStartOffset > len) {
                payloadStartOffset -= len;
                continue;
              } else {
                frag = frag.subarray(payloadStartOffset);
                len -= payloadStartOffset;
                payloadStartOffset = 0;
              }
            }
            pesData.set(frag, i);
            i += len;
          }
          if (pesLen) {
            pesLen -= pesHdrLen + 3;
          }
          return {
            data: pesData,
            pts: pesPts,
            dts: pesDts,
            len: pesLen
          };
        }
        return null;
      }
      var MP3Demuxer = /* @__PURE__ */ function(_BaseAudioDemuxer) {
        _inheritsLoose(MP3Demuxer2, _BaseAudioDemuxer);
        function MP3Demuxer2() {
          return _BaseAudioDemuxer.apply(this, arguments) || this;
        }
        var _proto = MP3Demuxer2.prototype;
        _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {
          _BaseAudioDemuxer.prototype.resetInitSegment.call(this, initSegment, audioCodec, videoCodec, trackDuration);
          this._audioTrack = {
            container: "audio/mpeg",
            type: "audio",
            id: 2,
            pid: -1,
            sequenceNumber: 0,
            segmentCodec: "mp3",
            samples: [],
            manifestCodec: audioCodec,
            duration: trackDuration,
            inputTimeScale: 90000,
            dropped: 0
          };
        };
        MP3Demuxer2.probe = function probe$1(data) {
          if (!data) {
            return false;
          }
          var id3Data = getID3Data(data, 0);
          var offset = (id3Data == null ? undefined : id3Data.length) || 0;
          if (id3Data && data[offset] === 11 && data[offset + 1] === 119 && getTimeStamp(id3Data) !== undefined && getAudioBSID(data, offset) <= 16) {
            return false;
          }
          for (var length = data.length;offset < length; offset++) {
            if (probe(data, offset)) {
              logger.log("MPEG Audio sync word found !");
              return true;
            }
          }
          return false;
        };
        _proto.canParse = function canParse$1(data, offset) {
          return canParse(data, offset);
        };
        _proto.appendFrame = function appendFrame$1(track, data, offset) {
          if (this.basePTS === null) {
            return;
          }
          return appendFrame(track, data, offset, this.basePTS, this.frameIndex);
        };
        return MP3Demuxer2;
      }(BaseAudioDemuxer);
      var AAC = /* @__PURE__ */ function() {
        function AAC2() {
        }
        AAC2.getSilentFrame = function getSilentFrame(codec, channelCount) {
          switch (codec) {
            case "mp4a.40.2":
              if (channelCount === 1) {
                return new Uint8Array([0, 200, 0, 128, 35, 128]);
              } else if (channelCount === 2) {
                return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);
              } else if (channelCount === 3) {
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);
              } else if (channelCount === 4) {
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);
              } else if (channelCount === 5) {
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);
              } else if (channelCount === 6) {
                return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);
              }
              break;
            default:
              if (channelCount === 1) {
                return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
              } else if (channelCount === 2) {
                return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
              } else if (channelCount === 3) {
                return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);
              }
              break;
          }
          return;
        };
        return AAC2;
      }();
      var UINT32_MAX = Math.pow(2, 32) - 1;
      var MP4 = /* @__PURE__ */ function() {
        function MP42() {
        }
        MP42.init = function init() {
          MP42.types = {
            avc1: [],
            avcC: [],
            btrt: [],
            dinf: [],
            dref: [],
            esds: [],
            ftyp: [],
            hdlr: [],
            mdat: [],
            mdhd: [],
            mdia: [],
            mfhd: [],
            minf: [],
            moof: [],
            moov: [],
            mp4a: [],
            ".mp3": [],
            dac3: [],
            "ac-3": [],
            mvex: [],
            mvhd: [],
            pasp: [],
            sdtp: [],
            stbl: [],
            stco: [],
            stsc: [],
            stsd: [],
            stsz: [],
            stts: [],
            tfdt: [],
            tfhd: [],
            traf: [],
            trak: [],
            trun: [],
            trex: [],
            tkhd: [],
            vmhd: [],
            smhd: []
          };
          var i;
          for (i in MP42.types) {
            if (MP42.types.hasOwnProperty(i)) {
              MP42.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];
            }
          }
          var videoHdlr = new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            118,
            105,
            100,
            101,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            86,
            105,
            100,
            101,
            111,
            72,
            97,
            110,
            100,
            108,
            101,
            114,
            0
          ]);
          var audioHdlr = new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            115,
            111,
            117,
            110,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            83,
            111,
            117,
            110,
            100,
            72,
            97,
            110,
            100,
            108,
            101,
            114,
            0
          ]);
          MP42.HDLR_TYPES = {
            video: videoHdlr,
            audio: audioHdlr
          };
          var dref = new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            12,
            117,
            114,
            108,
            32,
            0,
            0,
            0,
            1
          ]);
          var stco = new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]);
          MP42.STTS = MP42.STSC = MP42.STCO = stco;
          MP42.STSZ = new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]);
          MP42.VMHD = new Uint8Array([
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]);
          MP42.SMHD = new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
          ]);
          MP42.STSD = new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1
          ]);
          var majorBrand = new Uint8Array([105, 115, 111, 109]);
          var avc1Brand = new Uint8Array([97, 118, 99, 49]);
          var minorVersion = new Uint8Array([0, 0, 0, 1]);
          MP42.FTYP = MP42.box(MP42.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);
          MP42.DINF = MP42.box(MP42.types.dinf, MP42.box(MP42.types.dref, dref));
        };
        MP42.box = function box(type) {
          var size = 8;
          for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
            payload[_key - 1] = arguments[_key];
          }
          var i = payload.length;
          var len = i;
          while (i--) {
            size += payload[i].byteLength;
          }
          var result = new Uint8Array(size);
          result[0] = size >> 24 & 255;
          result[1] = size >> 16 & 255;
          result[2] = size >> 8 & 255;
          result[3] = size & 255;
          result.set(type, 4);
          for (i = 0, size = 8;i < len; i++) {
            result.set(payload[i], size);
            size += payload[i].byteLength;
          }
          return result;
        };
        MP42.hdlr = function hdlr(type) {
          return MP42.box(MP42.types.hdlr, MP42.HDLR_TYPES[type]);
        };
        MP42.mdat = function mdat(data) {
          return MP42.box(MP42.types.mdat, data);
        };
        MP42.mdhd = function mdhd(timescale, duration) {
          duration *= timescale;
          var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
          var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
          return MP42.box(MP42.types.mdhd, new Uint8Array([
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            3,
            timescale >> 24 & 255,
            timescale >> 16 & 255,
            timescale >> 8 & 255,
            timescale & 255,
            upperWordDuration >> 24,
            upperWordDuration >> 16 & 255,
            upperWordDuration >> 8 & 255,
            upperWordDuration & 255,
            lowerWordDuration >> 24,
            lowerWordDuration >> 16 & 255,
            lowerWordDuration >> 8 & 255,
            lowerWordDuration & 255,
            85,
            196,
            0,
            0
          ]));
        };
        MP42.mdia = function mdia(track) {
          return MP42.box(MP42.types.mdia, MP42.mdhd(track.timescale, track.duration), MP42.hdlr(track.type), MP42.minf(track));
        };
        MP42.mfhd = function mfhd(sequenceNumber) {
          return MP42.box(MP42.types.mfhd, new Uint8Array([
            0,
            0,
            0,
            0,
            sequenceNumber >> 24,
            sequenceNumber >> 16 & 255,
            sequenceNumber >> 8 & 255,
            sequenceNumber & 255
          ]));
        };
        MP42.minf = function minf(track) {
          if (track.type === "audio") {
            return MP42.box(MP42.types.minf, MP42.box(MP42.types.smhd, MP42.SMHD), MP42.DINF, MP42.stbl(track));
          } else {
            return MP42.box(MP42.types.minf, MP42.box(MP42.types.vmhd, MP42.VMHD), MP42.DINF, MP42.stbl(track));
          }
        };
        MP42.moof = function moof(sn, baseMediaDecodeTime, track) {
          return MP42.box(MP42.types.moof, MP42.mfhd(sn), MP42.traf(track, baseMediaDecodeTime));
        };
        MP42.moov = function moov(tracks) {
          var i = tracks.length;
          var boxes = [];
          while (i--) {
            boxes[i] = MP42.trak(tracks[i]);
          }
          return MP42.box.apply(null, [MP42.types.moov, MP42.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP42.mvex(tracks)));
        };
        MP42.mvex = function mvex(tracks) {
          var i = tracks.length;
          var boxes = [];
          while (i--) {
            boxes[i] = MP42.trex(tracks[i]);
          }
          return MP42.box.apply(null, [MP42.types.mvex].concat(boxes));
        };
        MP42.mvhd = function mvhd(timescale, duration) {
          duration *= timescale;
          var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
          var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
          var bytes = new Uint8Array([
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            3,
            timescale >> 24 & 255,
            timescale >> 16 & 255,
            timescale >> 8 & 255,
            timescale & 255,
            upperWordDuration >> 24,
            upperWordDuration >> 16 & 255,
            upperWordDuration >> 8 & 255,
            upperWordDuration & 255,
            lowerWordDuration >> 24,
            lowerWordDuration >> 16 & 255,
            lowerWordDuration >> 8 & 255,
            lowerWordDuration & 255,
            0,
            1,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            64,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            255,
            255,
            255,
            255
          ]);
          return MP42.box(MP42.types.mvhd, bytes);
        };
        MP42.sdtp = function sdtp(track) {
          var samples = track.samples || [];
          var bytes = new Uint8Array(4 + samples.length);
          var i;
          var flags;
          for (i = 0;i < samples.length; i++) {
            flags = samples[i].flags;
            bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
          }
          return MP42.box(MP42.types.sdtp, bytes);
        };
        MP42.stbl = function stbl(track) {
          return MP42.box(MP42.types.stbl, MP42.stsd(track), MP42.box(MP42.types.stts, MP42.STTS), MP42.box(MP42.types.stsc, MP42.STSC), MP42.box(MP42.types.stsz, MP42.STSZ), MP42.box(MP42.types.stco, MP42.STCO));
        };
        MP42.avc1 = function avc1(track) {
          var sps = [];
          var pps = [];
          var i;
          var data;
          var len;
          for (i = 0;i < track.sps.length; i++) {
            data = track.sps[i];
            len = data.byteLength;
            sps.push(len >>> 8 & 255);
            sps.push(len & 255);
            sps = sps.concat(Array.prototype.slice.call(data));
          }
          for (i = 0;i < track.pps.length; i++) {
            data = track.pps[i];
            len = data.byteLength;
            pps.push(len >>> 8 & 255);
            pps.push(len & 255);
            pps = pps.concat(Array.prototype.slice.call(data));
          }
          var avcc = MP42.box(MP42.types.avcC, new Uint8Array([
            1,
            sps[3],
            sps[4],
            sps[5],
            252 | 3,
            224 | track.sps.length
          ].concat(sps).concat([
            track.pps.length
          ]).concat(pps)));
          var width = track.width;
          var height = track.height;
          var hSpacing = track.pixelRatio[0];
          var vSpacing = track.pixelRatio[1];
          return MP42.box(MP42.types.avc1, new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            width >> 8 & 255,
            width & 255,
            height >> 8 & 255,
            height & 255,
            0,
            72,
            0,
            0,
            0,
            72,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            18,
            100,
            97,
            105,
            108,
            121,
            109,
            111,
            116,
            105,
            111,
            110,
            47,
            104,
            108,
            115,
            46,
            106,
            115,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            24,
            17,
            17
          ]), avcc, MP42.box(MP42.types.btrt, new Uint8Array([
            0,
            28,
            156,
            128,
            0,
            45,
            198,
            192,
            0,
            45,
            198,
            192
          ])), MP42.box(MP42.types.pasp, new Uint8Array([
            hSpacing >> 24,
            hSpacing >> 16 & 255,
            hSpacing >> 8 & 255,
            hSpacing & 255,
            vSpacing >> 24,
            vSpacing >> 16 & 255,
            vSpacing >> 8 & 255,
            vSpacing & 255
          ])));
        };
        MP42.esds = function esds(track) {
          var configlen = track.config.length;
          return new Uint8Array([
            0,
            0,
            0,
            0,
            3,
            23 + configlen,
            0,
            1,
            0,
            4,
            15 + configlen,
            64,
            21,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            5
          ].concat([configlen]).concat(track.config).concat([6, 1, 2]));
        };
        MP42.audioStsd = function audioStsd(track) {
          var samplerate = track.samplerate;
          return new Uint8Array([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            track.channelCount,
            0,
            16,
            0,
            0,
            0,
            0,
            samplerate >> 8 & 255,
            samplerate & 255,
            0,
            0
          ]);
        };
        MP42.mp4a = function mp4a(track) {
          return MP42.box(MP42.types.mp4a, MP42.audioStsd(track), MP42.box(MP42.types.esds, MP42.esds(track)));
        };
        MP42.mp3 = function mp3(track) {
          return MP42.box(MP42.types[".mp3"], MP42.audioStsd(track));
        };
        MP42.ac3 = function ac3(track) {
          return MP42.box(MP42.types["ac-3"], MP42.audioStsd(track), MP42.box(MP42.types.dac3, track.config));
        };
        MP42.stsd = function stsd(track) {
          if (track.type === "audio") {
            if (track.segmentCodec === "mp3" && track.codec === "mp3") {
              return MP42.box(MP42.types.stsd, MP42.STSD, MP42.mp3(track));
            }
            if (track.segmentCodec === "ac3") {
              return MP42.box(MP42.types.stsd, MP42.STSD, MP42.ac3(track));
            }
            return MP42.box(MP42.types.stsd, MP42.STSD, MP42.mp4a(track));
          } else {
            return MP42.box(MP42.types.stsd, MP42.STSD, MP42.avc1(track));
          }
        };
        MP42.tkhd = function tkhd(track) {
          var id = track.id;
          var duration = track.duration * track.timescale;
          var width = track.width;
          var height = track.height;
          var upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));
          var lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));
          return MP42.box(MP42.types.tkhd, new Uint8Array([
            1,
            0,
            0,
            7,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            3,
            id >> 24 & 255,
            id >> 16 & 255,
            id >> 8 & 255,
            id & 255,
            0,
            0,
            0,
            0,
            upperWordDuration >> 24,
            upperWordDuration >> 16 & 255,
            upperWordDuration >> 8 & 255,
            upperWordDuration & 255,
            lowerWordDuration >> 24,
            lowerWordDuration >> 16 & 255,
            lowerWordDuration >> 8 & 255,
            lowerWordDuration & 255,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            64,
            0,
            0,
            0,
            width >> 8 & 255,
            width & 255,
            0,
            0,
            height >> 8 & 255,
            height & 255,
            0,
            0
          ]));
        };
        MP42.traf = function traf(track, baseMediaDecodeTime) {
          var sampleDependencyTable = MP42.sdtp(track);
          var id = track.id;
          var upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));
          var lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));
          return MP42.box(MP42.types.traf, MP42.box(MP42.types.tfhd, new Uint8Array([
            0,
            0,
            0,
            0,
            id >> 24,
            id >> 16 & 255,
            id >> 8 & 255,
            id & 255
          ])), MP42.box(MP42.types.tfdt, new Uint8Array([
            1,
            0,
            0,
            0,
            upperWordBaseMediaDecodeTime >> 24,
            upperWordBaseMediaDecodeTime >> 16 & 255,
            upperWordBaseMediaDecodeTime >> 8 & 255,
            upperWordBaseMediaDecodeTime & 255,
            lowerWordBaseMediaDecodeTime >> 24,
            lowerWordBaseMediaDecodeTime >> 16 & 255,
            lowerWordBaseMediaDecodeTime >> 8 & 255,
            lowerWordBaseMediaDecodeTime & 255
          ])), MP42.trun(track, sampleDependencyTable.length + 16 + 20 + 8 + 16 + 8 + 8), sampleDependencyTable);
        };
        MP42.trak = function trak(track) {
          track.duration = track.duration || 4294967295;
          return MP42.box(MP42.types.trak, MP42.tkhd(track), MP42.mdia(track));
        };
        MP42.trex = function trex(track) {
          var id = track.id;
          return MP42.box(MP42.types.trex, new Uint8Array([
            0,
            0,
            0,
            0,
            id >> 24,
            id >> 16 & 255,
            id >> 8 & 255,
            id & 255,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
            1
          ]));
        };
        MP42.trun = function trun(track, offset) {
          var samples = track.samples || [];
          var len = samples.length;
          var arraylen = 12 + 16 * len;
          var array = new Uint8Array(arraylen);
          var i;
          var sample;
          var duration;
          var size;
          var flags;
          var cts;
          offset += 8 + arraylen;
          array.set([
            track.type === "video" ? 1 : 0,
            0,
            15,
            1,
            len >>> 24 & 255,
            len >>> 16 & 255,
            len >>> 8 & 255,
            len & 255,
            offset >>> 24 & 255,
            offset >>> 16 & 255,
            offset >>> 8 & 255,
            offset & 255
          ], 0);
          for (i = 0;i < len; i++) {
            sample = samples[i];
            duration = sample.duration;
            size = sample.size;
            flags = sample.flags;
            cts = sample.cts;
            array.set([
              duration >>> 24 & 255,
              duration >>> 16 & 255,
              duration >>> 8 & 255,
              duration & 255,
              size >>> 24 & 255,
              size >>> 16 & 255,
              size >>> 8 & 255,
              size & 255,
              flags.isLeading << 2 | flags.dependsOn,
              flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync,
              flags.degradPrio & 240 << 8,
              flags.degradPrio & 15,
              cts >>> 24 & 255,
              cts >>> 16 & 255,
              cts >>> 8 & 255,
              cts & 255
            ], 12 + 16 * i);
          }
          return MP42.box(MP42.types.trun, array);
        };
        MP42.initSegment = function initSegment(tracks) {
          if (!MP42.types) {
            MP42.init();
          }
          var movie = MP42.moov(tracks);
          var result = appendUint8Array(MP42.FTYP, movie);
          return result;
        };
        return MP42;
      }();
      MP4.types = undefined;
      MP4.HDLR_TYPES = undefined;
      MP4.STTS = undefined;
      MP4.STSC = undefined;
      MP4.STCO = undefined;
      MP4.STSZ = undefined;
      MP4.VMHD = undefined;
      MP4.SMHD = undefined;
      MP4.STSD = undefined;
      MP4.FTYP = undefined;
      MP4.DINF = undefined;
      var MPEG_TS_CLOCK_FREQ_HZ = 90000;
      function toTimescaleFromBase(baseTime, destScale, srcBase, round) {
        if (srcBase === undefined) {
          srcBase = 1;
        }
        if (round === undefined) {
          round = false;
        }
        var result = baseTime * destScale * srcBase;
        return round ? Math.round(result) : result;
      }
      function toTimescaleFromScale(baseTime, destScale, srcScale, round) {
        if (srcScale === undefined) {
          srcScale = 1;
        }
        if (round === undefined) {
          round = false;
        }
        return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);
      }
      function toMsFromMpegTsClock(baseTime, round) {
        if (round === undefined) {
          round = false;
        }
        return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);
      }
      function toMpegTsClockFromTimescale(baseTime, srcScale) {
        if (srcScale === undefined) {
          srcScale = 1;
        }
        return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);
      }
      var MAX_SILENT_FRAME_DURATION = 10 * 1000;
      var AAC_SAMPLES_PER_FRAME = 1024;
      var MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;
      var AC3_SAMPLES_PER_FRAME = 1536;
      var chromeVersion = null;
      var safariWebkitVersion = null;
      var MP4Remuxer = /* @__PURE__ */ function() {
        function MP4Remuxer2(observer, config, typeSupported, vendor) {
          this.observer = undefined;
          this.config = undefined;
          this.typeSupported = undefined;
          this.ISGenerated = false;
          this._initPTS = null;
          this._initDTS = null;
          this.nextAvcDts = null;
          this.nextAudioPts = null;
          this.videoSampleDuration = null;
          this.isAudioContiguous = false;
          this.isVideoContiguous = false;
          this.videoTrackConfig = undefined;
          this.observer = observer;
          this.config = config;
          this.typeSupported = typeSupported;
          this.ISGenerated = false;
          if (chromeVersion === null) {
            var userAgent = navigator.userAgent || "";
            var result = userAgent.match(/Chrome\/(\d+)/i);
            chromeVersion = result ? parseInt(result[1]) : 0;
          }
          if (safariWebkitVersion === null) {
            var _result = navigator.userAgent.match(/Safari\/(\d+)/i);
            safariWebkitVersion = _result ? parseInt(_result[1]) : 0;
          }
        }
        var _proto = MP4Remuxer2.prototype;
        _proto.destroy = function destroy() {
          this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;
        };
        _proto.resetTimeStamp = function resetTimeStamp(defaultTimeStamp) {
          logger.log("[mp4-remuxer]: initPTS & initDTS reset");
          this._initPTS = this._initDTS = defaultTimeStamp;
        };
        _proto.resetNextTimestamp = function resetNextTimestamp() {
          logger.log("[mp4-remuxer]: reset next timestamp");
          this.isVideoContiguous = false;
          this.isAudioContiguous = false;
        };
        _proto.resetInitSegment = function resetInitSegment() {
          logger.log("[mp4-remuxer]: ISGenerated flag reset");
          this.ISGenerated = false;
          this.videoTrackConfig = undefined;
        };
        _proto.getVideoStartPts = function getVideoStartPts(videoSamples) {
          var rolloverDetected = false;
          var firstPts = videoSamples[0].pts;
          var startPTS = videoSamples.reduce(function(minPTS, sample) {
            var pts = sample.pts;
            var delta = pts - minPTS;
            if (delta < -4294967296) {
              rolloverDetected = true;
              pts = normalizePts(pts, firstPts);
              delta = pts - minPTS;
            }
            if (delta > 0) {
              return minPTS;
            }
            return pts;
          }, firstPts);
          if (rolloverDetected) {
            logger.debug("PTS rollover detected");
          }
          return startPTS;
        };
        _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {
          var video;
          var audio;
          var initSegment;
          var text;
          var id3;
          var independent;
          var audioTimeOffset = timeOffset;
          var videoTimeOffset = timeOffset;
          var hasAudio = audioTrack.pid > -1;
          var hasVideo = videoTrack.pid > -1;
          var length = videoTrack.samples.length;
          var enoughAudioSamples = audioTrack.samples.length > 0;
          var enoughVideoSamples = flush && length > 0 || length > 1;
          var canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;
          if (canRemuxAvc) {
            if (this.ISGenerated) {
              var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;
              var config = this.videoTrackConfig;
              if (config && (videoTrack.width !== config.width || videoTrack.height !== config.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? undefined : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config.pixelRatio) == null ? undefined : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? undefined : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config.pixelRatio) == null ? undefined : _config$pixelRatio2[1]))) {
                this.resetInitSegment();
              }
            } else {
              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
            }
            var isVideoContiguous = this.isVideoContiguous;
            var firstKeyFrameIndex = -1;
            var firstKeyFramePTS;
            if (enoughVideoSamples) {
              firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);
              if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {
                independent = true;
                if (firstKeyFrameIndex > 0) {
                  logger.warn("[mp4-remuxer]: Dropped " + firstKeyFrameIndex + " out of " + length + " video samples due to a missing keyframe");
                  var startPTS = this.getVideoStartPts(videoTrack.samples);
                  videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);
                  videoTrack.dropped += firstKeyFrameIndex;
                  videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;
                  firstKeyFramePTS = videoTimeOffset;
                } else if (firstKeyFrameIndex === -1) {
                  logger.warn("[mp4-remuxer]: No keyframe found out of " + length + " video samples");
                  independent = false;
                }
              }
            }
            if (this.ISGenerated) {
              if (enoughAudioSamples && enoughVideoSamples) {
                var _startPTS = this.getVideoStartPts(videoTrack.samples);
                var tsDelta = normalizePts(audioTrack.samples[0].pts, _startPTS) - _startPTS;
                var audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;
                audioTimeOffset += Math.max(0, audiovideoTimestampDelta);
                videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);
              }
              if (enoughAudioSamples) {
                if (!audioTrack.samplerate) {
                  logger.warn("[mp4-remuxer]: regenerate InitSegment as audio detected");
                  initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
                }
                audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);
                if (enoughVideoSamples) {
                  var audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;
                  if (!videoTrack.inputTimeScale) {
                    logger.warn("[mp4-remuxer]: regenerate InitSegment as video detected");
                    initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);
                  }
                  video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);
                }
              } else if (enoughVideoSamples) {
                video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);
              }
              if (video) {
                video.firstKeyFrame = firstKeyFrameIndex;
                video.independent = firstKeyFrameIndex !== -1;
                video.firstKeyFramePTS = firstKeyFramePTS;
              }
            }
          }
          if (this.ISGenerated && this._initPTS && this._initDTS) {
            if (id3Track.samples.length) {
              id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);
            }
            if (textTrack.samples.length) {
              text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);
            }
          }
          return {
            audio,
            video,
            initSegment,
            independent,
            text,
            id3
          };
        };
        _proto.generateIS = function generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {
          var audioSamples = audioTrack.samples;
          var videoSamples = videoTrack.samples;
          var typeSupported = this.typeSupported;
          var tracks = {};
          var _initPTS = this._initPTS;
          var computePTSDTS = !_initPTS || accurateTimeOffset;
          var container = "audio/mp4";
          var initPTS;
          var initDTS;
          var timescale;
          if (computePTSDTS) {
            initPTS = initDTS = Infinity;
          }
          if (audioTrack.config && audioSamples.length) {
            audioTrack.timescale = audioTrack.samplerate;
            switch (audioTrack.segmentCodec) {
              case "mp3":
                if (typeSupported.mpeg) {
                  container = "audio/mpeg";
                  audioTrack.codec = "";
                } else if (typeSupported.mp3) {
                  audioTrack.codec = "mp3";
                }
                break;
              case "ac3":
                audioTrack.codec = "ac-3";
                break;
            }
            tracks.audio = {
              id: "audio",
              container,
              codec: audioTrack.codec,
              initSegment: audioTrack.segmentCodec === "mp3" && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),
              metadata: {
                channelCount: audioTrack.channelCount
              }
            };
            if (computePTSDTS) {
              timescale = audioTrack.inputTimeScale;
              if (!_initPTS || timescale !== _initPTS.timescale) {
                initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);
              } else {
                computePTSDTS = false;
              }
            }
          }
          if (videoTrack.sps && videoTrack.pps && videoSamples.length) {
            videoTrack.timescale = videoTrack.inputTimeScale;
            tracks.video = {
              id: "main",
              container: "video/mp4",
              codec: videoTrack.codec,
              initSegment: MP4.initSegment([videoTrack]),
              metadata: {
                width: videoTrack.width,
                height: videoTrack.height
              }
            };
            if (computePTSDTS) {
              timescale = videoTrack.inputTimeScale;
              if (!_initPTS || timescale !== _initPTS.timescale) {
                var startPTS = this.getVideoStartPts(videoSamples);
                var startOffset = Math.round(timescale * timeOffset);
                initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);
                initPTS = Math.min(initPTS, startPTS - startOffset);
              } else {
                computePTSDTS = false;
              }
            }
            this.videoTrackConfig = {
              width: videoTrack.width,
              height: videoTrack.height,
              pixelRatio: videoTrack.pixelRatio
            };
          }
          if (Object.keys(tracks).length) {
            this.ISGenerated = true;
            if (computePTSDTS) {
              this._initPTS = {
                baseTime: initPTS,
                timescale
              };
              this._initDTS = {
                baseTime: initDTS,
                timescale
              };
            } else {
              initPTS = timescale = undefined;
            }
            return {
              tracks,
              initPTS,
              timescale
            };
          }
        };
        _proto.remuxVideo = function remuxVideo(track, timeOffset, contiguous, audioTrackLength) {
          var timeScale = track.inputTimeScale;
          var inputSamples = track.samples;
          var outputSamples = [];
          var nbSamples = inputSamples.length;
          var initPTS = this._initPTS;
          var nextAvcDts = this.nextAvcDts;
          var offset = 8;
          var mp4SampleDuration = this.videoSampleDuration;
          var firstDTS;
          var lastDTS;
          var minPTS = Number.POSITIVE_INFINITY;
          var maxPTS = Number.NEGATIVE_INFINITY;
          var sortSamples = false;
          if (!contiguous || nextAvcDts === null) {
            var pts = timeOffset * timeScale;
            var cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);
            if (chromeVersion && nextAvcDts !== null && Math.abs(pts - cts - nextAvcDts) < 15000) {
              contiguous = true;
            } else {
              nextAvcDts = pts - cts;
            }
          }
          var initTime = initPTS.baseTime * timeScale / initPTS.timescale;
          for (var i = 0;i < nbSamples; i++) {
            var sample = inputSamples[i];
            sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);
            sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);
            if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {
              sortSamples = true;
            }
          }
          if (sortSamples) {
            inputSamples.sort(function(a, b) {
              var deltadts = a.dts - b.dts;
              var deltapts = a.pts - b.pts;
              return deltadts || deltapts;
            });
          }
          firstDTS = inputSamples[0].dts;
          lastDTS = inputSamples[inputSamples.length - 1].dts;
          var inputDuration = lastDTS - firstDTS;
          var averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;
          if (contiguous) {
            var delta = firstDTS - nextAvcDts;
            var foundHole = delta > averageSampleDuration;
            var foundOverlap = delta < -1;
            if (foundHole || foundOverlap) {
              if (foundHole) {
                logger.warn("AVC: " + toMsFromMpegTsClock(delta, true) + " ms (" + delta + "dts) hole between fragments detected at " + timeOffset.toFixed(3));
              } else {
                logger.warn("AVC: " + toMsFromMpegTsClock(-delta, true) + " ms (" + delta + "dts) overlapping between fragments detected at " + timeOffset.toFixed(3));
              }
              if (!foundOverlap || nextAvcDts >= inputSamples[0].pts || chromeVersion) {
                firstDTS = nextAvcDts;
                var firstPTS = inputSamples[0].pts - delta;
                if (foundHole) {
                  inputSamples[0].dts = firstDTS;
                  inputSamples[0].pts = firstPTS;
                } else {
                  for (var _i = 0;_i < inputSamples.length; _i++) {
                    if (inputSamples[_i].dts > firstPTS) {
                      break;
                    }
                    inputSamples[_i].dts -= delta;
                    inputSamples[_i].pts -= delta;
                  }
                }
                logger.log("Video: Initial PTS/DTS adjusted: " + toMsFromMpegTsClock(firstPTS, true) + "/" + toMsFromMpegTsClock(firstDTS, true) + ", delta: " + toMsFromMpegTsClock(delta, true) + " ms");
              }
            }
          }
          firstDTS = Math.max(0, firstDTS);
          var nbNalu = 0;
          var naluLen = 0;
          var dtsStep = firstDTS;
          for (var _i2 = 0;_i2 < nbSamples; _i2++) {
            var _sample = inputSamples[_i2];
            var units = _sample.units;
            var nbUnits = units.length;
            var sampleLen = 0;
            for (var j = 0;j < nbUnits; j++) {
              sampleLen += units[j].data.length;
            }
            naluLen += sampleLen;
            nbNalu += nbUnits;
            _sample.length = sampleLen;
            if (_sample.dts < dtsStep) {
              _sample.dts = dtsStep;
              dtsStep += averageSampleDuration / 4 | 0 || 1;
            } else {
              dtsStep = _sample.dts;
            }
            minPTS = Math.min(_sample.pts, minPTS);
            maxPTS = Math.max(_sample.pts, maxPTS);
          }
          lastDTS = inputSamples[nbSamples - 1].dts;
          var mdatSize = naluLen + 4 * nbNalu + 8;
          var mdat;
          try {
            mdat = new Uint8Array(mdatSize);
          } catch (err) {
            this.observer.emit(Events.ERROR, Events.ERROR, {
              type: ErrorTypes2.MUX_ERROR,
              details: ErrorDetails.REMUX_ALLOC_ERROR,
              fatal: false,
              error: err,
              bytes: mdatSize,
              reason: "fail allocating video mdat " + mdatSize
            });
            return;
          }
          var view = new DataView(mdat.buffer);
          view.setUint32(0, mdatSize);
          mdat.set(MP4.types.mdat, 4);
          var stretchedLastFrame = false;
          var minDtsDelta = Number.POSITIVE_INFINITY;
          var minPtsDelta = Number.POSITIVE_INFINITY;
          var maxDtsDelta = Number.NEGATIVE_INFINITY;
          var maxPtsDelta = Number.NEGATIVE_INFINITY;
          for (var _i3 = 0;_i3 < nbSamples; _i3++) {
            var _VideoSample = inputSamples[_i3];
            var VideoSampleUnits = _VideoSample.units;
            var mp4SampleLength = 0;
            for (var _j = 0, _nbUnits = VideoSampleUnits.length;_j < _nbUnits; _j++) {
              var unit = VideoSampleUnits[_j];
              var unitData = unit.data;
              var unitDataLen = unit.data.byteLength;
              view.setUint32(offset, unitDataLen);
              offset += 4;
              mdat.set(unitData, offset);
              offset += unitDataLen;
              mp4SampleLength += 4 + unitDataLen;
            }
            var ptsDelta = undefined;
            if (_i3 < nbSamples - 1) {
              mp4SampleDuration = inputSamples[_i3 + 1].dts - _VideoSample.dts;
              ptsDelta = inputSamples[_i3 + 1].pts - _VideoSample.pts;
            } else {
              var config = this.config;
              var lastFrameDuration = _i3 > 0 ? _VideoSample.dts - inputSamples[_i3 - 1].dts : averageSampleDuration;
              ptsDelta = _i3 > 0 ? _VideoSample.pts - inputSamples[_i3 - 1].pts : averageSampleDuration;
              if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {
                var gapTolerance = Math.floor(config.maxBufferHole * timeScale);
                var deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - _VideoSample.pts;
                if (deltaToFrameEnd > gapTolerance) {
                  mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;
                  if (mp4SampleDuration < 0) {
                    mp4SampleDuration = lastFrameDuration;
                  } else {
                    stretchedLastFrame = true;
                  }
                  logger.log("[mp4-remuxer]: It is approximately " + deltaToFrameEnd / 90 + " ms to the next segment; using duration " + mp4SampleDuration / 90 + " ms for the last video frame.");
                } else {
                  mp4SampleDuration = lastFrameDuration;
                }
              } else {
                mp4SampleDuration = lastFrameDuration;
              }
            }
            var compositionTimeOffset = Math.round(_VideoSample.pts - _VideoSample.dts);
            minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);
            maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);
            minPtsDelta = Math.min(minPtsDelta, ptsDelta);
            maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);
            outputSamples.push(new Mp4Sample(_VideoSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));
          }
          if (outputSamples.length) {
            if (chromeVersion) {
              if (chromeVersion < 70) {
                var flags = outputSamples[0].flags;
                flags.dependsOn = 2;
                flags.isNonSync = 0;
              }
            } else if (safariWebkitVersion) {
              if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {
                logger.warn("Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.");
                var dts = firstDTS;
                for (var _i4 = 0, len = outputSamples.length;_i4 < len; _i4++) {
                  var nextDts = dts + outputSamples[_i4].duration;
                  var _pts = dts + outputSamples[_i4].cts;
                  if (_i4 < len - 1) {
                    var nextPts = nextDts + outputSamples[_i4 + 1].cts;
                    outputSamples[_i4].duration = nextPts - _pts;
                  } else {
                    outputSamples[_i4].duration = _i4 ? outputSamples[_i4 - 1].duration : averageSampleDuration;
                  }
                  outputSamples[_i4].cts = 0;
                  dts = nextDts;
                }
              }
            }
          }
          mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;
          this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;
          this.videoSampleDuration = mp4SampleDuration;
          this.isVideoContiguous = true;
          var moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends({}, track, {
            samples: outputSamples
          }));
          var type = "video";
          var data = {
            data1: moof,
            data2: mdat,
            startPTS: minPTS / timeScale,
            endPTS: (maxPTS + mp4SampleDuration) / timeScale,
            startDTS: firstDTS / timeScale,
            endDTS: nextAvcDts / timeScale,
            type,
            hasAudio: false,
            hasVideo: true,
            nb: outputSamples.length,
            dropped: track.dropped
          };
          track.samples = [];
          track.dropped = 0;
          return data;
        };
        _proto.getSamplesPerFrame = function getSamplesPerFrame(track) {
          switch (track.segmentCodec) {
            case "mp3":
              return MPEG_AUDIO_SAMPLE_PER_FRAME;
            case "ac3":
              return AC3_SAMPLES_PER_FRAME;
            default:
              return AAC_SAMPLES_PER_FRAME;
          }
        };
        _proto.remuxAudio = function remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {
          var inputTimeScale = track.inputTimeScale;
          var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
          var scaleFactor = inputTimeScale / mp4timeScale;
          var mp4SampleDuration = this.getSamplesPerFrame(track);
          var inputSampleDuration = mp4SampleDuration * scaleFactor;
          var initPTS = this._initPTS;
          var rawMPEG = track.segmentCodec === "mp3" && this.typeSupported.mpeg;
          var outputSamples = [];
          var alignedWithVideo = videoTimeOffset !== undefined;
          var inputSamples = track.samples;
          var offset = rawMPEG ? 0 : 8;
          var nextAudioPts = this.nextAudioPts || -1;
          var timeOffsetMpegTS = timeOffset * inputTimeScale;
          var initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;
          this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);
          inputSamples.forEach(function(sample2) {
            sample2.pts = normalizePts(sample2.pts - initTime, timeOffsetMpegTS);
          });
          if (!contiguous || nextAudioPts < 0) {
            inputSamples = inputSamples.filter(function(sample2) {
              return sample2.pts >= 0;
            });
            if (!inputSamples.length) {
              return;
            }
            if (videoTimeOffset === 0) {
              nextAudioPts = 0;
            } else if (accurateTimeOffset && !alignedWithVideo) {
              nextAudioPts = Math.max(0, timeOffsetMpegTS);
            } else {
              nextAudioPts = inputSamples[0].pts;
            }
          }
          if (track.segmentCodec === "aac") {
            var maxAudioFramesDrift = this.config.maxAudioFramesDrift;
            for (var i = 0, nextPts = nextAudioPts;i < inputSamples.length; i++) {
              var sample = inputSamples[i];
              var pts = sample.pts;
              var delta = pts - nextPts;
              var duration = Math.abs(1000 * delta / inputTimeScale);
              if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {
                if (i === 0) {
                  logger.warn("Audio frame @ " + (pts / inputTimeScale).toFixed(3) + "s overlaps nextAudioPts by " + Math.round(1000 * delta / inputTimeScale) + " ms.");
                  this.nextAudioPts = nextAudioPts = nextPts = pts;
                }
              } else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {
                var missing = Math.round(delta / inputSampleDuration);
                nextPts = pts - missing * inputSampleDuration;
                if (nextPts < 0) {
                  missing--;
                  nextPts += inputSampleDuration;
                }
                if (i === 0) {
                  this.nextAudioPts = nextAudioPts = nextPts;
                }
                logger.warn("[mp4-remuxer]: Injecting " + missing + " audio frame @ " + (nextPts / inputTimeScale).toFixed(3) + "s due to " + Math.round(1000 * delta / inputTimeScale) + " ms gap.");
                for (var j = 0;j < missing; j++) {
                  var newStamp = Math.max(nextPts, 0);
                  var fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
                  if (!fillFrame) {
                    logger.log("[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.");
                    fillFrame = sample.unit.subarray();
                  }
                  inputSamples.splice(i, 0, {
                    unit: fillFrame,
                    pts: newStamp
                  });
                  nextPts += inputSampleDuration;
                  i++;
                }
              }
              sample.pts = nextPts;
              nextPts += inputSampleDuration;
            }
          }
          var firstPTS = null;
          var lastPTS = null;
          var mdat;
          var mdatSize = 0;
          var sampleLength = inputSamples.length;
          while (sampleLength--) {
            mdatSize += inputSamples[sampleLength].unit.byteLength;
          }
          for (var _j2 = 0, _nbSamples = inputSamples.length;_j2 < _nbSamples; _j2++) {
            var audioSample = inputSamples[_j2];
            var unit = audioSample.unit;
            var _pts2 = audioSample.pts;
            if (lastPTS !== null) {
              var prevSample = outputSamples[_j2 - 1];
              prevSample.duration = Math.round((_pts2 - lastPTS) / scaleFactor);
            } else {
              if (contiguous && track.segmentCodec === "aac") {
                _pts2 = nextAudioPts;
              }
              firstPTS = _pts2;
              if (mdatSize > 0) {
                mdatSize += offset;
                try {
                  mdat = new Uint8Array(mdatSize);
                } catch (err) {
                  this.observer.emit(Events.ERROR, Events.ERROR, {
                    type: ErrorTypes2.MUX_ERROR,
                    details: ErrorDetails.REMUX_ALLOC_ERROR,
                    fatal: false,
                    error: err,
                    bytes: mdatSize,
                    reason: "fail allocating audio mdat " + mdatSize
                  });
                  return;
                }
                if (!rawMPEG) {
                  var view = new DataView(mdat.buffer);
                  view.setUint32(0, mdatSize);
                  mdat.set(MP4.types.mdat, 4);
                }
              } else {
                return;
              }
            }
            mdat.set(unit, offset);
            var unitLen = unit.byteLength;
            offset += unitLen;
            outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));
            lastPTS = _pts2;
          }
          var nbSamples = outputSamples.length;
          if (!nbSamples) {
            return;
          }
          var lastSample = outputSamples[outputSamples.length - 1];
          this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;
          var moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {
            samples: outputSamples
          }));
          track.samples = [];
          var start = firstPTS / inputTimeScale;
          var end = nextAudioPts / inputTimeScale;
          var type = "audio";
          var audioData = {
            data1: moof,
            data2: mdat,
            startPTS: start,
            endPTS: end,
            startDTS: start,
            endDTS: end,
            type,
            hasAudio: true,
            hasVideo: false,
            nb: nbSamples
          };
          this.isAudioContiguous = true;
          return audioData;
        };
        _proto.remuxEmptyAudio = function remuxEmptyAudio(track, timeOffset, contiguous, videoData) {
          var inputTimeScale = track.inputTimeScale;
          var mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;
          var scaleFactor = inputTimeScale / mp4timeScale;
          var nextAudioPts = this.nextAudioPts;
          var initDTS = this._initDTS;
          var init90kHz = initDTS.baseTime * 90000 / initDTS.timescale;
          var startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;
          var endDTS = videoData.endDTS * inputTimeScale + init90kHz;
          var frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;
          var nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);
          var silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);
          logger.warn("[mp4-remuxer]: remux empty Audio");
          if (!silentFrame) {
            logger.trace("[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec");
            return;
          }
          var samples = [];
          for (var i = 0;i < nbSamples; i++) {
            var stamp = startDTS + i * frameDuration;
            samples.push({
              unit: silentFrame,
              pts: stamp,
              dts: stamp
            });
          }
          track.samples = samples;
          return this.remuxAudio(track, timeOffset, contiguous, false);
        };
        return MP4Remuxer2;
      }();
      function normalizePts(value, reference) {
        var offset;
        if (reference === null) {
          return value;
        }
        if (reference < value) {
          offset = -8589934592;
        } else {
          offset = 8589934592;
        }
        while (Math.abs(value - reference) > 4294967296) {
          value += offset;
        }
        return value;
      }
      function findKeyframeIndex(samples) {
        for (var i = 0;i < samples.length; i++) {
          if (samples[i].key) {
            return i;
          }
        }
        return -1;
      }
      function flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {
        var length = track.samples.length;
        if (!length) {
          return;
        }
        var inputTimeScale = track.inputTimeScale;
        for (var index = 0;index < length; index++) {
          var sample = track.samples[index];
          sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
          sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
        }
        var samples = track.samples;
        track.samples = [];
        return {
          samples
        };
      }
      function flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {
        var length = track.samples.length;
        if (!length) {
          return;
        }
        var inputTimeScale = track.inputTimeScale;
        for (var index = 0;index < length; index++) {
          var sample = track.samples[index];
          sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;
        }
        track.samples.sort(function(a, b) {
          return a.pts - b.pts;
        });
        var samples = track.samples;
        track.samples = [];
        return {
          samples
        };
      }
      var Mp4Sample = function Mp4Sample(isKeyframe, duration, size, cts) {
        this.size = undefined;
        this.duration = undefined;
        this.cts = undefined;
        this.flags = undefined;
        this.duration = duration;
        this.size = size;
        this.cts = cts;
        this.flags = {
          isLeading: 0,
          isDependedOn: 0,
          hasRedundancy: 0,
          degradPrio: 0,
          dependsOn: isKeyframe ? 2 : 1,
          isNonSync: isKeyframe ? 0 : 1
        };
      };
      var PassThroughRemuxer = /* @__PURE__ */ function() {
        function PassThroughRemuxer2() {
          this.emitInitSegment = false;
          this.audioCodec = undefined;
          this.videoCodec = undefined;
          this.initData = undefined;
          this.initPTS = null;
          this.initTracks = undefined;
          this.lastEndTime = null;
        }
        var _proto = PassThroughRemuxer2.prototype;
        _proto.destroy = function destroy() {
        };
        _proto.resetTimeStamp = function resetTimeStamp(defaultInitPTS) {
          this.initPTS = defaultInitPTS;
          this.lastEndTime = null;
        };
        _proto.resetNextTimestamp = function resetNextTimestamp() {
          this.lastEndTime = null;
        };
        _proto.resetInitSegment = function resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {
          this.audioCodec = audioCodec;
          this.videoCodec = videoCodec;
          this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));
          this.emitInitSegment = true;
        };
        _proto.generateInitSegment = function generateInitSegment(initSegment) {
          var audioCodec = this.audioCodec, videoCodec = this.videoCodec;
          if (!(initSegment != null && initSegment.byteLength)) {
            this.initTracks = undefined;
            this.initData = undefined;
            return;
          }
          var initData = this.initData = parseInitSegment(initSegment);
          if (initData.audio) {
            audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);
          }
          if (initData.video) {
            videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);
          }
          var tracks = {};
          if (initData.audio && initData.video) {
            tracks.audiovideo = {
              container: "video/mp4",
              codec: audioCodec + "," + videoCodec,
              initSegment,
              id: "main"
            };
          } else if (initData.audio) {
            tracks.audio = {
              container: "audio/mp4",
              codec: audioCodec,
              initSegment,
              id: "audio"
            };
          } else if (initData.video) {
            tracks.video = {
              container: "video/mp4",
              codec: videoCodec,
              initSegment,
              id: "main"
            };
          } else {
            logger.warn("[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.");
          }
          this.initTracks = tracks;
        };
        _proto.remux = function remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {
          var _initData, _initData2;
          var initPTS = this.initPTS, lastEndTime = this.lastEndTime;
          var result = {
            audio: undefined,
            video: undefined,
            text: textTrack,
            id3: id3Track,
            initSegment: undefined
          };
          if (!isFiniteNumber(lastEndTime)) {
            lastEndTime = this.lastEndTime = timeOffset || 0;
          }
          var data = videoTrack.samples;
          if (!(data != null && data.length)) {
            return result;
          }
          var initSegment = {
            initPTS: undefined,
            timescale: 1
          };
          var initData = this.initData;
          if (!((_initData = initData) != null && _initData.length)) {
            this.generateInitSegment(data);
            initData = this.initData;
          }
          if (!((_initData2 = initData) != null && _initData2.length)) {
            logger.warn("[passthrough-remuxer.ts]: Failed to generate initSegment.");
            return result;
          }
          if (this.emitInitSegment) {
            initSegment.tracks = this.initTracks;
            this.emitInitSegment = false;
          }
          var duration = getDuration(data, initData);
          var startDTS = getStartDTS(initData, data);
          var decodeTime = startDTS === null ? timeOffset : startDTS;
          if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {
            initSegment.initPTS = decodeTime - timeOffset;
            if (initPTS && initPTS.timescale === 1) {
              logger.warn("Adjusting initPTS by " + (initSegment.initPTS - initPTS.baseTime));
            }
            this.initPTS = initPTS = {
              baseTime: initSegment.initPTS,
              timescale: 1
            };
          }
          var startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;
          var endTime = startTime + duration;
          offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);
          if (duration > 0) {
            this.lastEndTime = endTime;
          } else {
            logger.warn("Duration parsed from mp4 should be greater than zero");
            this.resetNextTimestamp();
          }
          var hasAudio = !!initData.audio;
          var hasVideo = !!initData.video;
          var type = "";
          if (hasAudio) {
            type += "audio";
          }
          if (hasVideo) {
            type += "video";
          }
          var track = {
            data1: data,
            startPTS: startTime,
            startDTS: startTime,
            endPTS: endTime,
            endDTS: endTime,
            type,
            hasAudio,
            hasVideo,
            nb: 1,
            dropped: 0
          };
          result.audio = track.type === "audio" ? track : undefined;
          result.video = track.type !== "audio" ? track : undefined;
          result.initSegment = initSegment;
          result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);
          if (textTrack.samples.length) {
            result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);
          }
          return result;
        };
        return PassThroughRemuxer2;
      }();
      function isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {
        if (initPTS === null) {
          return true;
        }
        var minDuration = Math.max(duration, 1);
        var startTime = startDTS - initPTS.baseTime / initPTS.timescale;
        return Math.abs(startTime - timeOffset) > minDuration;
      }
      function getParsedTrackCodec(track, type) {
        var parsedCodec = track == null ? undefined : track.codec;
        if (parsedCodec && parsedCodec.length > 4) {
          return parsedCodec;
        }
        if (type === ElementaryStreamTypes.AUDIO) {
          if (parsedCodec === "ec-3" || parsedCodec === "ac-3" || parsedCodec === "alac") {
            return parsedCodec;
          }
          if (parsedCodec === "fLaC" || parsedCodec === "Opus") {
            var preferManagedMediaSource = false;
            return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);
          }
          var result = "mp4a.40.5";
          logger.info('Parsed audio codec "' + parsedCodec + '" or audio object type not handled. Using "' + result + '"');
          return result;
        }
        logger.warn('Unhandled video codec "' + parsedCodec + '"');
        if (parsedCodec === "hvc1" || parsedCodec === "hev1") {
          return "hvc1.1.6.L120.90";
        }
        if (parsedCodec === "av01") {
          return "av01.0.04M.08";
        }
        return "avc1.42e01e";
      }
      var now;
      try {
        now = self.performance.now.bind(self.performance);
      } catch (err) {
        logger.debug("Unable to use Performance API on this environment");
        now = optionalSelf == null ? undefined : optionalSelf.Date.now;
      }
      var muxConfig = [{
        demux: MP4Demuxer,
        remux: PassThroughRemuxer
      }, {
        demux: TSDemuxer,
        remux: MP4Remuxer
      }, {
        demux: AACDemuxer,
        remux: MP4Remuxer
      }, {
        demux: MP3Demuxer,
        remux: MP4Remuxer
      }];
      {
        muxConfig.splice(2, 0, {
          demux: AC3Demuxer,
          remux: MP4Remuxer
        });
      }
      var Transmuxer = /* @__PURE__ */ function() {
        function Transmuxer2(observer, typeSupported, config, vendor, id) {
          this.async = false;
          this.observer = undefined;
          this.typeSupported = undefined;
          this.config = undefined;
          this.vendor = undefined;
          this.id = undefined;
          this.demuxer = undefined;
          this.remuxer = undefined;
          this.decrypter = undefined;
          this.probe = undefined;
          this.decryptionPromise = null;
          this.transmuxConfig = undefined;
          this.currentTransmuxState = undefined;
          this.observer = observer;
          this.typeSupported = typeSupported;
          this.config = config;
          this.vendor = vendor;
          this.id = id;
        }
        var _proto = Transmuxer2.prototype;
        _proto.configure = function configure(transmuxConfig) {
          this.transmuxConfig = transmuxConfig;
          if (this.decrypter) {
            this.decrypter.reset();
          }
        };
        _proto.push = function push(data, decryptdata, chunkMeta, state) {
          var _this = this;
          var stats = chunkMeta.transmuxing;
          stats.executeStart = now();
          var uintData = new Uint8Array(data);
          var currentTransmuxState = this.currentTransmuxState, transmuxConfig = this.transmuxConfig;
          if (state) {
            this.currentTransmuxState = state;
          }
          var _ref = state || currentTransmuxState, contiguous = _ref.contiguous, discontinuity = _ref.discontinuity, trackSwitch = _ref.trackSwitch, accurateTimeOffset = _ref.accurateTimeOffset, timeOffset = _ref.timeOffset, initSegmentChange = _ref.initSegmentChange;
          var { audioCodec, videoCodec, defaultInitPts, duration, initSegmentData } = transmuxConfig;
          var keyData = getEncryptionType(uintData, decryptdata);
          if (keyData && keyData.method === "AES-128") {
            var decrypter = this.getDecrypter();
            if (decrypter.isSync()) {
              var decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);
              var loadingParts = chunkMeta.part > -1;
              if (loadingParts) {
                decryptedData = decrypter.flush();
              }
              if (!decryptedData) {
                stats.executeEnd = now();
                return emptyResult(chunkMeta);
              }
              uintData = new Uint8Array(decryptedData);
            } else {
              this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(function(decryptedData2) {
                var result2 = _this.push(decryptedData2, null, chunkMeta);
                _this.decryptionPromise = null;
                return result2;
              });
              return this.decryptionPromise;
            }
          }
          var resetMuxers = this.needsProbing(discontinuity, trackSwitch);
          if (resetMuxers) {
            var error2 = this.configureTransmuxer(uintData);
            if (error2) {
              logger.warn("[transmuxer] " + error2.message);
              this.observer.emit(Events.ERROR, Events.ERROR, {
                type: ErrorTypes2.MEDIA_ERROR,
                details: ErrorDetails.FRAG_PARSING_ERROR,
                fatal: false,
                error: error2,
                reason: error2.message
              });
              stats.executeEnd = now();
              return emptyResult(chunkMeta);
            }
          }
          if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {
            this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);
          }
          if (discontinuity || initSegmentChange || resetMuxers) {
            this.resetInitialTimestamp(defaultInitPts);
          }
          if (!contiguous) {
            this.resetContiguity();
          }
          var result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);
          var currentState = this.currentTransmuxState;
          currentState.contiguous = true;
          currentState.discontinuity = false;
          currentState.trackSwitch = false;
          stats.executeEnd = now();
          return result;
        };
        _proto.flush = function flush(chunkMeta) {
          var _this2 = this;
          var stats = chunkMeta.transmuxing;
          stats.executeStart = now();
          var decrypter = this.decrypter, currentTransmuxState = this.currentTransmuxState, decryptionPromise = this.decryptionPromise;
          if (decryptionPromise) {
            return decryptionPromise.then(function() {
              return _this2.flush(chunkMeta);
            });
          }
          var transmuxResults = [];
          var timeOffset = currentTransmuxState.timeOffset;
          if (decrypter) {
            var decryptedData = decrypter.flush();
            if (decryptedData) {
              transmuxResults.push(this.push(decryptedData, null, chunkMeta));
            }
          }
          var demuxer = this.demuxer, remuxer = this.remuxer;
          if (!demuxer || !remuxer) {
            stats.executeEnd = now();
            return [emptyResult(chunkMeta)];
          }
          var demuxResultOrPromise = demuxer.flush(timeOffset);
          if (isPromise(demuxResultOrPromise)) {
            return demuxResultOrPromise.then(function(demuxResult) {
              _this2.flushRemux(transmuxResults, demuxResult, chunkMeta);
              return transmuxResults;
            });
          }
          this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);
          return transmuxResults;
        };
        _proto.flushRemux = function flushRemux(transmuxResults, demuxResult, chunkMeta) {
          var { audioTrack, videoTrack, id3Track, textTrack } = demuxResult;
          var _this$currentTransmux = this.currentTransmuxState, accurateTimeOffset = _this$currentTransmux.accurateTimeOffset, timeOffset = _this$currentTransmux.timeOffset;
          logger.log("[transmuxer.ts]: Flushed fragment " + chunkMeta.sn + (chunkMeta.part > -1 ? " p: " + chunkMeta.part : "") + " of level " + chunkMeta.level);
          var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);
          transmuxResults.push({
            remuxResult,
            chunkMeta
          });
          chunkMeta.transmuxing.executeEnd = now();
        };
        _proto.resetInitialTimestamp = function resetInitialTimestamp(defaultInitPts) {
          var demuxer = this.demuxer, remuxer = this.remuxer;
          if (!demuxer || !remuxer) {
            return;
          }
          demuxer.resetTimeStamp(defaultInitPts);
          remuxer.resetTimeStamp(defaultInitPts);
        };
        _proto.resetContiguity = function resetContiguity() {
          var demuxer = this.demuxer, remuxer = this.remuxer;
          if (!demuxer || !remuxer) {
            return;
          }
          demuxer.resetContiguity();
          remuxer.resetNextTimestamp();
        };
        _proto.resetInitSegment = function resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {
          var demuxer = this.demuxer, remuxer = this.remuxer;
          if (!demuxer || !remuxer) {
            return;
          }
          demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);
          remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);
        };
        _proto.destroy = function destroy() {
          if (this.demuxer) {
            this.demuxer.destroy();
            this.demuxer = undefined;
          }
          if (this.remuxer) {
            this.remuxer.destroy();
            this.remuxer = undefined;
          }
        };
        _proto.transmux = function transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {
          var result;
          if (keyData && keyData.method === "SAMPLE-AES") {
            result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);
          } else {
            result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);
          }
          return result;
        };
        _proto.transmuxUnencrypted = function transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {
          var _demux = this.demuxer.demux(data, timeOffset, false, !this.config.progressive), audioTrack = _demux.audioTrack, videoTrack = _demux.videoTrack, id3Track = _demux.id3Track, textTrack = _demux.textTrack;
          var remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);
          return {
            remuxResult,
            chunkMeta
          };
        };
        _proto.transmuxSampleAes = function transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {
          var _this3 = this;
          return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(function(demuxResult) {
            var remuxResult = _this3.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, _this3.id);
            return {
              remuxResult,
              chunkMeta
            };
          });
        };
        _proto.configureTransmuxer = function configureTransmuxer(data) {
          var config = this.config, observer = this.observer, typeSupported = this.typeSupported, vendor = this.vendor;
          var mux;
          for (var i = 0, len = muxConfig.length;i < len; i++) {
            var _muxConfig$i$demux;
            if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data)) {
              mux = muxConfig[i];
              break;
            }
          }
          if (!mux) {
            return new Error("Failed to find demuxer by probing fragment data");
          }
          var demuxer = this.demuxer;
          var remuxer = this.remuxer;
          var Remuxer = mux.remux;
          var Demuxer = mux.demux;
          if (!remuxer || !(remuxer instanceof Remuxer)) {
            this.remuxer = new Remuxer(observer, config, typeSupported, vendor);
          }
          if (!demuxer || !(demuxer instanceof Demuxer)) {
            this.demuxer = new Demuxer(observer, config, typeSupported);
            this.probe = Demuxer.probe;
          }
        };
        _proto.needsProbing = function needsProbing(discontinuity, trackSwitch) {
          return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;
        };
        _proto.getDecrypter = function getDecrypter() {
          var decrypter = this.decrypter;
          if (!decrypter) {
            decrypter = this.decrypter = new Decrypter(this.config);
          }
          return decrypter;
        };
        return Transmuxer2;
      }();
      function getEncryptionType(data, decryptData) {
        var encryptionType = null;
        if (data.byteLength > 0 && (decryptData == null ? undefined : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {
          encryptionType = decryptData;
        }
        return encryptionType;
      }
      var emptyResult = function emptyResult(chunkMeta) {
        return {
          remuxResult: {},
          chunkMeta
        };
      };
      function isPromise(p) {
        return "then" in p && p.then instanceof Function;
      }
      var TransmuxConfig = function TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {
        this.audioCodec = undefined;
        this.videoCodec = undefined;
        this.initSegmentData = undefined;
        this.duration = undefined;
        this.defaultInitPts = undefined;
        this.audioCodec = audioCodec;
        this.videoCodec = videoCodec;
        this.initSegmentData = initSegmentData;
        this.duration = duration;
        this.defaultInitPts = defaultInitPts || null;
      };
      var TransmuxState = function TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {
        this.discontinuity = undefined;
        this.contiguous = undefined;
        this.accurateTimeOffset = undefined;
        this.trackSwitch = undefined;
        this.timeOffset = undefined;
        this.initSegmentChange = undefined;
        this.discontinuity = discontinuity;
        this.contiguous = contiguous;
        this.accurateTimeOffset = accurateTimeOffset;
        this.trackSwitch = trackSwitch;
        this.timeOffset = timeOffset;
        this.initSegmentChange = initSegmentChange;
      };
      var eventemitter3 = { exports: {} };
      (function(module2) {
        var has = Object.prototype.hasOwnProperty, prefix = "~";
        function Events2() {
        }
        if (Object.create) {
          Events2.prototype = Object.create(null);
          if (!new Events2().__proto__)
            prefix = false;
        }
        function EE(fn, context, once) {
          this.fn = fn;
          this.context = context;
          this.once = once || false;
        }
        function addListener(emitter, event, fn, context, once) {
          if (typeof fn !== "function") {
            throw new TypeError("The listener must be a function");
          }
          var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
          if (!emitter._events[evt])
            emitter._events[evt] = listener, emitter._eventsCount++;
          else if (!emitter._events[evt].fn)
            emitter._events[evt].push(listener);
          else
            emitter._events[evt] = [emitter._events[evt], listener];
          return emitter;
        }
        function clearEvent(emitter, evt) {
          if (--emitter._eventsCount === 0)
            emitter._events = new Events2;
          else
            delete emitter._events[evt];
        }
        function EventEmitter2() {
          this._events = new Events2;
          this._eventsCount = 0;
        }
        EventEmitter2.prototype.eventNames = function eventNames() {
          var names = [], events, name;
          if (this._eventsCount === 0)
            return names;
          for (name in events = this._events) {
            if (has.call(events, name))
              names.push(prefix ? name.slice(1) : name);
          }
          if (Object.getOwnPropertySymbols) {
            return names.concat(Object.getOwnPropertySymbols(events));
          }
          return names;
        };
        EventEmitter2.prototype.listeners = function listeners(event) {
          var evt = prefix ? prefix + event : event, handlers = this._events[evt];
          if (!handlers)
            return [];
          if (handlers.fn)
            return [handlers.fn];
          for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
            ee[i] = handlers[i].fn;
          }
          return ee;
        };
        EventEmitter2.prototype.listenerCount = function listenerCount(event) {
          var evt = prefix ? prefix + event : event, listeners = this._events[evt];
          if (!listeners)
            return 0;
          if (listeners.fn)
            return 1;
          return listeners.length;
        };
        EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt])
            return false;
          var listeners = this._events[evt], len = arguments.length, args, i;
          if (listeners.fn) {
            if (listeners.once)
              this.removeListener(event, listeners.fn, undefined, true);
            switch (len) {
              case 1:
                return listeners.fn.call(listeners.context), true;
              case 2:
                return listeners.fn.call(listeners.context, a1), true;
              case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
              case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
              case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
              case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
            }
            for (i = 1, args = new Array(len - 1);i < len; i++) {
              args[i - 1] = arguments[i];
            }
            listeners.fn.apply(listeners.context, args);
          } else {
            var length = listeners.length, j;
            for (i = 0;i < length; i++) {
              if (listeners[i].once)
                this.removeListener(event, listeners[i].fn, undefined, true);
              switch (len) {
                case 1:
                  listeners[i].fn.call(listeners[i].context);
                  break;
                case 2:
                  listeners[i].fn.call(listeners[i].context, a1);
                  break;
                case 3:
                  listeners[i].fn.call(listeners[i].context, a1, a2);
                  break;
                case 4:
                  listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                  break;
                default:
                  if (!args)
                    for (j = 1, args = new Array(len - 1);j < len; j++) {
                      args[j - 1] = arguments[j];
                    }
                  listeners[i].fn.apply(listeners[i].context, args);
              }
            }
          }
          return true;
        };
        EventEmitter2.prototype.on = function on(event, fn, context) {
          return addListener(this, event, fn, context, false);
        };
        EventEmitter2.prototype.once = function once(event, fn, context) {
          return addListener(this, event, fn, context, true);
        };
        EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
          var evt = prefix ? prefix + event : event;
          if (!this._events[evt])
            return this;
          if (!fn) {
            clearEvent(this, evt);
            return this;
          }
          var listeners = this._events[evt];
          if (listeners.fn) {
            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
              clearEvent(this, evt);
            }
          } else {
            for (var i = 0, events = [], length = listeners.length;i < length; i++) {
              if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                events.push(listeners[i]);
              }
            }
            if (events.length)
              this._events[evt] = events.length === 1 ? events[0] : events;
            else
              clearEvent(this, evt);
          }
          return this;
        };
        EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
          var evt;
          if (event) {
            evt = prefix ? prefix + event : event;
            if (this._events[evt])
              clearEvent(this, evt);
          } else {
            this._events = new Events2;
            this._eventsCount = 0;
          }
          return this;
        };
        EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
        EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
        EventEmitter2.prefixed = prefix;
        EventEmitter2.EventEmitter = EventEmitter2;
        {
          module2.exports = EventEmitter2;
        }
      })(eventemitter3);
      var eventemitter3Exports = eventemitter3.exports;
      var EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
      if (typeof __IN_WORKER__ !== "undefined" && __IN_WORKER__) {
        startWorker(self);
      }
      function startWorker(self2) {
        var observer = new EventEmitter;
        var forwardMessage = function forwardMessage(ev, data) {
          self2.postMessage({
            event: ev,
            data
          });
        };
        observer.on(Events.FRAG_DECRYPTED, forwardMessage);
        observer.on(Events.ERROR, forwardMessage);
        var forwardWorkerLogs = function forwardWorkerLogs() {
          var _loop = function _loop(logFn2) {
            var func = function func(message) {
              forwardMessage("workerLog", {
                logType: logFn2,
                message
              });
            };
            logger[logFn2] = func;
          };
          for (var logFn in logger) {
            _loop(logFn);
          }
        };
        self2.addEventListener("message", function(ev) {
          var data = ev.data;
          switch (data.cmd) {
            case "init": {
              var config = JSON.parse(data.config);
              self2.transmuxer = new Transmuxer(observer, data.typeSupported, config, "", data.id);
              enableLogs(config.debug, data.id);
              forwardWorkerLogs();
              forwardMessage("init", null);
              break;
            }
            case "configure": {
              self2.transmuxer.configure(data.config);
              break;
            }
            case "demux": {
              var transmuxResult = self2.transmuxer.push(data.data, data.decryptdata, data.chunkMeta, data.state);
              if (isPromise(transmuxResult)) {
                self2.transmuxer.async = true;
                transmuxResult.then(function(data2) {
                  emitTransmuxComplete(self2, data2);
                }).catch(function(error2) {
                  forwardMessage(Events.ERROR, {
                    type: ErrorTypes2.MEDIA_ERROR,
                    details: ErrorDetails.FRAG_PARSING_ERROR,
                    chunkMeta: data.chunkMeta,
                    fatal: false,
                    error: error2,
                    err: error2,
                    reason: "transmuxer-worker push error"
                  });
                });
              } else {
                self2.transmuxer.async = false;
                emitTransmuxComplete(self2, transmuxResult);
              }
              break;
            }
            case "flush": {
              var id = data.chunkMeta;
              var _transmuxResult = self2.transmuxer.flush(id);
              var asyncFlush = isPromise(_transmuxResult);
              if (asyncFlush || self2.transmuxer.async) {
                if (!isPromise(_transmuxResult)) {
                  _transmuxResult = Promise.resolve(_transmuxResult);
                }
                _transmuxResult.then(function(results) {
                  handleFlushResult(self2, results, id);
                }).catch(function(error2) {
                  forwardMessage(Events.ERROR, {
                    type: ErrorTypes2.MEDIA_ERROR,
                    details: ErrorDetails.FRAG_PARSING_ERROR,
                    chunkMeta: data.chunkMeta,
                    fatal: false,
                    error: error2,
                    err: error2,
                    reason: "transmuxer-worker flush error"
                  });
                });
              } else {
                handleFlushResult(self2, _transmuxResult, id);
              }
              break;
            }
          }
        });
      }
      function emitTransmuxComplete(self2, transmuxResult) {
        if (isEmptyResult(transmuxResult.remuxResult)) {
          return false;
        }
        var transferable = [];
        var _transmuxResult$remux = transmuxResult.remuxResult, audio = _transmuxResult$remux.audio, video = _transmuxResult$remux.video;
        if (audio) {
          addToTransferable(transferable, audio);
        }
        if (video) {
          addToTransferable(transferable, video);
        }
        self2.postMessage({
          event: "transmuxComplete",
          data: transmuxResult
        }, transferable);
        return true;
      }
      function addToTransferable(transferable, track) {
        if (track.data1) {
          transferable.push(track.data1.buffer);
        }
        if (track.data2) {
          transferable.push(track.data2.buffer);
        }
      }
      function handleFlushResult(self2, results, chunkMeta) {
        var parsed = results.reduce(function(parsed2, result) {
          return emitTransmuxComplete(self2, result) || parsed2;
        }, false);
        if (!parsed) {
          self2.postMessage({
            event: "transmuxComplete",
            data: results[0]
          });
        }
        self2.postMessage({
          event: "flush",
          data: chunkMeta
        });
      }
      function isEmptyResult(remuxResult) {
        return !remuxResult.audio && !remuxResult.video && !remuxResult.text && !remuxResult.id3 && !remuxResult.initSegment;
      }
      function hasUMDWorker() {
        return typeof __HLS_WORKER_BUNDLE__ === "function";
      }
      function injectWorker() {
        var blob = new self.Blob(["var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(" + __HLS_WORKER_BUNDLE__.toString() + ")(true);"], {
          type: "text/javascript"
        });
        var objectURL = self.URL.createObjectURL(blob);
        var worker = new self.Worker(objectURL);
        return {
          worker,
          objectURL
        };
      }
      function loadWorker(path) {
        var scriptURL = new self.URL(path, self.location.href).href;
        var worker = new self.Worker(scriptURL);
        return {
          worker,
          scriptURL
        };
      }
      var TransmuxerInterface = /* @__PURE__ */ function() {
        function TransmuxerInterface2(hls, id, onTransmuxComplete, onFlush) {
          var _this = this;
          this.error = null;
          this.hls = undefined;
          this.id = undefined;
          this.observer = undefined;
          this.frag = null;
          this.part = null;
          this.useWorker = undefined;
          this.workerContext = null;
          this.onwmsg = undefined;
          this.transmuxer = null;
          this.onTransmuxComplete = undefined;
          this.onFlush = undefined;
          var config = hls.config;
          this.hls = hls;
          this.id = id;
          this.useWorker = !!config.enableWorker;
          this.onTransmuxComplete = onTransmuxComplete;
          this.onFlush = onFlush;
          var forwardMessage = function forwardMessage(ev, data) {
            data = data || {};
            data.frag = _this.frag;
            data.id = _this.id;
            if (ev === Events.ERROR) {
              _this.error = data.error;
            }
            _this.hls.trigger(ev, data);
          };
          this.observer = new EventEmitter;
          this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);
          this.observer.on(Events.ERROR, forwardMessage);
          var MediaSource = getMediaSource(config.preferManagedMediaSource) || {
            isTypeSupported: function isTypeSupported() {
              return false;
            }
          };
          var m2tsTypeSupported = {
            mpeg: MediaSource.isTypeSupported("audio/mpeg"),
            mp3: MediaSource.isTypeSupported('audio/mp4; codecs="mp3"'),
            ac3: MediaSource.isTypeSupported('audio/mp4; codecs="ac-3"')
          };
          if (this.useWorker && typeof Worker !== "undefined") {
            var canCreateWorker = config.workerPath || hasUMDWorker();
            if (canCreateWorker) {
              try {
                if (config.workerPath) {
                  logger.log("loading Web Worker " + config.workerPath + ' for "' + id + '"');
                  this.workerContext = loadWorker(config.workerPath);
                } else {
                  logger.log('injecting Web Worker for "' + id + '"');
                  this.workerContext = injectWorker();
                }
                this.onwmsg = function(event) {
                  return _this.onWorkerMessage(event);
                };
                var worker = this.workerContext.worker;
                worker.addEventListener("message", this.onwmsg);
                worker.onerror = function(event) {
                  var error2 = new Error(event.message + "  (" + event.filename + ":" + event.lineno + ")");
                  config.enableWorker = false;
                  logger.warn('Error in "' + id + '" Web Worker, fallback to inline');
                  _this.hls.trigger(Events.ERROR, {
                    type: ErrorTypes2.OTHER_ERROR,
                    details: ErrorDetails.INTERNAL_EXCEPTION,
                    fatal: false,
                    event: "demuxerWorker",
                    error: error2
                  });
                };
                worker.postMessage({
                  cmd: "init",
                  typeSupported: m2tsTypeSupported,
                  vendor: "",
                  id,
                  config: JSON.stringify(config)
                });
              } catch (err) {
                logger.warn('Error setting up "' + id + '" Web Worker, fallback to inline', err);
                this.resetWorker();
                this.error = null;
                this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, "", id);
              }
              return;
            }
          }
          this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, "", id);
        }
        var _proto = TransmuxerInterface2.prototype;
        _proto.resetWorker = function resetWorker() {
          if (this.workerContext) {
            var _this$workerContext = this.workerContext, worker = _this$workerContext.worker, objectURL = _this$workerContext.objectURL;
            if (objectURL) {
              self.URL.revokeObjectURL(objectURL);
            }
            worker.removeEventListener("message", this.onwmsg);
            worker.onerror = null;
            worker.terminate();
            this.workerContext = null;
          }
        };
        _proto.destroy = function destroy() {
          if (this.workerContext) {
            this.resetWorker();
            this.onwmsg = undefined;
          } else {
            var transmuxer = this.transmuxer;
            if (transmuxer) {
              transmuxer.destroy();
              this.transmuxer = null;
            }
          }
          var observer = this.observer;
          if (observer) {
            observer.removeAllListeners();
          }
          this.frag = null;
          this.observer = null;
          this.hls = null;
        };
        _proto.push = function push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {
          var _frag$initSegment, _lastFrag$initSegment, _this2 = this;
          chunkMeta.transmuxing.start = self.performance.now();
          var transmuxer = this.transmuxer;
          var timeOffset = part ? part.start : frag.start;
          var decryptdata = frag.decryptdata;
          var lastFrag = this.frag;
          var discontinuity = !(lastFrag && frag.cc === lastFrag.cc);
          var trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);
          var snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;
          var partDiff = this.part ? chunkMeta.part - this.part.index : -1;
          var progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? undefined : lastFrag.stats.chunkCount);
          var contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));
          var now2 = self.performance.now();
          if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {
            frag.stats.parsing.start = now2;
          }
          if (part && (partDiff || !contiguous)) {
            part.stats.parsing.start = now2;
          }
          var initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? undefined : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? undefined : _lastFrag$initSegment.url));
          var state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);
          if (!contiguous || discontinuity || initSegmentChange) {
            logger.log("[transmuxer-interface, " + frag.type + "]: Starting new transmux session for sn: " + chunkMeta.sn + " p: " + chunkMeta.part + " level: " + chunkMeta.level + " id: " + chunkMeta.id + `
        discontinuity: ` + discontinuity + `
        trackSwitch: ` + trackSwitch + `
        contiguous: ` + contiguous + `
        accurateTimeOffset: ` + accurateTimeOffset + `
        timeOffset: ` + timeOffset + `
        initSegmentChange: ` + initSegmentChange);
            var config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);
            this.configureTransmuxer(config);
          }
          this.frag = frag;
          this.part = part;
          if (this.workerContext) {
            this.workerContext.worker.postMessage({
              cmd: "demux",
              data,
              decryptdata,
              chunkMeta,
              state
            }, data instanceof ArrayBuffer ? [data] : []);
          } else if (transmuxer) {
            var _transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);
            if (isPromise(_transmuxResult)) {
              transmuxer.async = true;
              _transmuxResult.then(function(data2) {
                _this2.handleTransmuxComplete(data2);
              }).catch(function(error2) {
                _this2.transmuxerError(error2, chunkMeta, "transmuxer-interface push error");
              });
            } else {
              transmuxer.async = false;
              this.handleTransmuxComplete(_transmuxResult);
            }
          }
        };
        _proto.flush = function flush(chunkMeta) {
          var _this3 = this;
          chunkMeta.transmuxing.start = self.performance.now();
          var transmuxer = this.transmuxer;
          if (this.workerContext) {
            this.workerContext.worker.postMessage({
              cmd: "flush",
              chunkMeta
            });
          } else if (transmuxer) {
            var _transmuxResult2 = transmuxer.flush(chunkMeta);
            var asyncFlush = isPromise(_transmuxResult2);
            if (asyncFlush || transmuxer.async) {
              if (!isPromise(_transmuxResult2)) {
                _transmuxResult2 = Promise.resolve(_transmuxResult2);
              }
              _transmuxResult2.then(function(data) {
                _this3.handleFlushResult(data, chunkMeta);
              }).catch(function(error2) {
                _this3.transmuxerError(error2, chunkMeta, "transmuxer-interface flush error");
              });
            } else {
              this.handleFlushResult(_transmuxResult2, chunkMeta);
            }
          }
        };
        _proto.transmuxerError = function transmuxerError(error2, chunkMeta, reason) {
          if (!this.hls) {
            return;
          }
          this.error = error2;
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes2.MEDIA_ERROR,
            details: ErrorDetails.FRAG_PARSING_ERROR,
            chunkMeta,
            frag: this.frag || undefined,
            fatal: false,
            error: error2,
            err: error2,
            reason
          });
        };
        _proto.handleFlushResult = function handleFlushResult(results, chunkMeta) {
          var _this4 = this;
          results.forEach(function(result) {
            _this4.handleTransmuxComplete(result);
          });
          this.onFlush(chunkMeta);
        };
        _proto.onWorkerMessage = function onWorkerMessage(event) {
          var data = event.data;
          if (!(data != null && data.event)) {
            logger.warn("worker message received with no " + (data ? "event name" : "data"));
            return;
          }
          var hls = this.hls;
          if (!this.hls) {
            return;
          }
          switch (data.event) {
            case "init": {
              var _this$workerContext2;
              var objectURL = (_this$workerContext2 = this.workerContext) == null ? undefined : _this$workerContext2.objectURL;
              if (objectURL) {
                self.URL.revokeObjectURL(objectURL);
              }
              break;
            }
            case "transmuxComplete": {
              this.handleTransmuxComplete(data.data);
              break;
            }
            case "flush": {
              this.onFlush(data.data);
              break;
            }
            case "workerLog":
              if (logger[data.data.logType]) {
                logger[data.data.logType](data.data.message);
              }
              break;
            default: {
              data.data = data.data || {};
              data.data.frag = this.frag;
              data.data.id = this.id;
              hls.trigger(data.event, data.data);
              break;
            }
          }
        };
        _proto.configureTransmuxer = function configureTransmuxer(config) {
          var transmuxer = this.transmuxer;
          if (this.workerContext) {
            this.workerContext.worker.postMessage({
              cmd: "configure",
              config
            });
          } else if (transmuxer) {
            transmuxer.configure(config);
          }
        };
        _proto.handleTransmuxComplete = function handleTransmuxComplete(result) {
          result.chunkMeta.transmuxing.end = self.performance.now();
          this.onTransmuxComplete(result);
        };
        return TransmuxerInterface2;
      }();
      function subtitleOptionsIdentical(trackList1, trackList2) {
        if (trackList1.length !== trackList2.length) {
          return false;
        }
        for (var i = 0;i < trackList1.length; i++) {
          if (!mediaAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {
            return false;
          }
        }
        return true;
      }
      function mediaAttributesIdentical(attrs1, attrs2, customAttributes) {
        var stableRenditionId = attrs1["STABLE-RENDITION-ID"];
        if (stableRenditionId && !customAttributes) {
          return stableRenditionId === attrs2["STABLE-RENDITION-ID"];
        }
        return !(customAttributes || ["LANGUAGE", "NAME", "CHARACTERISTICS", "AUTOSELECT", "DEFAULT", "FORCED", "ASSOC-LANGUAGE"]).some(function(subtitleAttribute) {
          return attrs1[subtitleAttribute] !== attrs2[subtitleAttribute];
        });
      }
      function subtitleTrackMatchesTextTrack(subtitleTrack, textTrack) {
        return textTrack.label.toLowerCase() === subtitleTrack.name.toLowerCase() && (!textTrack.language || textTrack.language.toLowerCase() === (subtitleTrack.lang || "").toLowerCase());
      }
      var TICK_INTERVAL$2 = 100;
      var AudioStreamController = /* @__PURE__ */ function(_BaseStreamController) {
        _inheritsLoose(AudioStreamController2, _BaseStreamController);
        function AudioStreamController2(hls, fragmentTracker, keyLoader) {
          var _this;
          _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, "[audio-stream-controller]", PlaylistLevelType.AUDIO) || this;
          _this.videoBuffer = null;
          _this.videoTrackCC = -1;
          _this.waitingVideoCC = -1;
          _this.bufferedTrack = null;
          _this.switchingTrack = null;
          _this.trackId = -1;
          _this.waitingData = null;
          _this.mainDetails = null;
          _this.flushing = false;
          _this.bufferFlushed = false;
          _this.cachedTrackLoadedData = null;
          _this._registerListeners();
          return _this;
        }
        var _proto = AudioStreamController2.prototype;
        _proto.onHandlerDestroying = function onHandlerDestroying() {
          this._unregisterListeners();
          _BaseStreamController.prototype.onHandlerDestroying.call(this);
          this.mainDetails = null;
          this.bufferedTrack = null;
          this.switchingTrack = null;
        };
        _proto._registerListeners = function _registerListeners() {
          var hls = this.hls;
          hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
          hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
          hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
          hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
          hls.on(Events.ERROR, this.onError, this);
          hls.on(Events.BUFFER_RESET, this.onBufferReset, this);
          hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
          hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
          hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
          hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
          hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        };
        _proto._unregisterListeners = function _unregisterListeners() {
          var hls = this.hls;
          hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
          hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);
          hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
          hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
          hls.off(Events.ERROR, this.onError, this);
          hls.off(Events.BUFFER_RESET, this.onBufferReset, this);
          hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
          hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
          hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
          hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
          hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        };
        _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {
          var { frag, id, initPTS, timescale } = _ref;
          if (id === "main") {
            var cc = frag.cc;
            this.initPTS[frag.cc] = {
              baseTime: initPTS,
              timescale
            };
            this.log("InitPTS for cc: " + cc + " found from main: " + initPTS);
            this.videoTrackCC = cc;
            if (this.state === State.WAITING_INIT_PTS) {
              this.tick();
            }
          }
        };
        _proto.startLoad = function startLoad(startPosition) {
          if (!this.levels) {
            this.startPosition = startPosition;
            this.state = State.STOPPED;
            return;
          }
          var lastCurrentTime = this.lastCurrentTime;
          this.stopLoad();
          this.setInterval(TICK_INTERVAL$2);
          if (lastCurrentTime > 0 && startPosition === -1) {
            this.log("Override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
            startPosition = lastCurrentTime;
            this.state = State.IDLE;
          } else {
            this.loadedmetadata = false;
            this.state = State.WAITING_TRACK;
          }
          this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
          this.tick();
        };
        _proto.doTick = function doTick() {
          switch (this.state) {
            case State.IDLE:
              this.doTickIdle();
              break;
            case State.WAITING_TRACK: {
              var _levels$trackId;
              var levels = this.levels, trackId = this.trackId;
              var details = levels == null ? undefined : (_levels$trackId = levels[trackId]) == null ? undefined : _levels$trackId.details;
              if (details) {
                if (this.waitForCdnTuneIn(details)) {
                  break;
                }
                this.state = State.WAITING_INIT_PTS;
              }
              break;
            }
            case State.FRAG_LOADING_WAITING_RETRY: {
              var _this$media;
              var now2 = performance.now();
              var retryDate = this.retryDate;
              if (!retryDate || now2 >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {
                var _levels = this.levels, _trackId = this.trackId;
                this.log("RetryDate reached, switch back to IDLE state");
                this.resetStartWhenNotLoaded((_levels == null ? undefined : _levels[_trackId]) || null);
                this.state = State.IDLE;
              }
              break;
            }
            case State.WAITING_INIT_PTS: {
              var waitingData = this.waitingData;
              if (waitingData) {
                var { frag, part, cache, complete } = waitingData;
                if (this.initPTS[frag.cc] !== undefined) {
                  this.waitingData = null;
                  this.waitingVideoCC = -1;
                  this.state = State.FRAG_LOADING;
                  var payload = cache.flush();
                  var data = {
                    frag,
                    part,
                    payload,
                    networkDetails: null
                  };
                  this._handleFragmentLoadProgress(data);
                  if (complete) {
                    _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, data);
                  }
                } else if (this.videoTrackCC !== this.waitingVideoCC) {
                  this.log("Waiting fragment cc (" + frag.cc + ") cancelled because video is at cc " + this.videoTrackCC);
                  this.clearWaitingFragment();
                } else {
                  var pos = this.getLoadPosition();
                  var bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);
                  var waitingFragmentAtPosition = fragmentWithinToleranceTest(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);
                  if (waitingFragmentAtPosition < 0) {
                    this.log("Waiting fragment cc (" + frag.cc + ") @ " + frag.start + " cancelled because another fragment at " + bufferInfo.end + " is needed");
                    this.clearWaitingFragment();
                  }
                }
              } else {
                this.state = State.IDLE;
              }
            }
          }
          this.onTickEnd();
        };
        _proto.clearWaitingFragment = function clearWaitingFragment() {
          var waitingData = this.waitingData;
          if (waitingData) {
            this.fragmentTracker.removeFragment(waitingData.frag);
            this.waitingData = null;
            this.waitingVideoCC = -1;
            this.state = State.IDLE;
          }
        };
        _proto.resetLoadingState = function resetLoadingState() {
          this.clearWaitingFragment();
          _BaseStreamController.prototype.resetLoadingState.call(this);
        };
        _proto.onTickEnd = function onTickEnd() {
          var media = this.media;
          if (!(media != null && media.readyState)) {
            return;
          }
          this.lastCurrentTime = media.currentTime;
        };
        _proto.doTickIdle = function doTickIdle() {
          var hls = this.hls, levels = this.levels, media = this.media, trackId = this.trackId;
          var config = hls.config;
          if (!this.buffering || !media && (this.startFragRequested || !config.startFragPrefetch) || !(levels != null && levels[trackId])) {
            return;
          }
          var levelInfo = levels[trackId];
          var trackDetails = levelInfo.details;
          if (!trackDetails || trackDetails.live && this.levelLastLoaded !== levelInfo || this.waitForCdnTuneIn(trackDetails)) {
            this.state = State.WAITING_TRACK;
            return;
          }
          var bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;
          if (this.bufferFlushed && bufferable) {
            this.bufferFlushed = false;
            this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);
          }
          var bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);
          if (bufferInfo === null) {
            return;
          }
          var bufferedTrack = this.bufferedTrack, switchingTrack = this.switchingTrack;
          if (!switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {
            hls.trigger(Events.BUFFER_EOS, {
              type: "audio"
            });
            this.state = State.ENDED;
            return;
          }
          var mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, PlaylistLevelType.MAIN);
          var bufferLen = bufferInfo.len;
          var maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? undefined : mainBufferInfo.len);
          var fragments = trackDetails.fragments;
          var start = fragments[0].start;
          var targetBufferTime = this.flushing ? this.getLoadPosition() : bufferInfo.end;
          if (switchingTrack && media) {
            var pos = this.getLoadPosition();
            if (bufferedTrack && !mediaAttributesIdentical(switchingTrack.attrs, bufferedTrack.attrs)) {
              targetBufferTime = pos;
            }
            if (trackDetails.PTSKnown && pos < start) {
              if (bufferInfo.end > start || bufferInfo.nextStart) {
                this.log("Alt audio track ahead of main track, seek to start of alt audio track");
                media.currentTime = start + 0.05;
              }
            }
          }
          if (bufferLen >= maxBufLen && !switchingTrack && targetBufferTime < fragments[fragments.length - 1].start) {
            return;
          }
          var frag = this.getNextFragment(targetBufferTime, trackDetails);
          var atGap = false;
          if (frag && this.isLoopLoading(frag, targetBufferTime)) {
            atGap = !!frag.gap;
            frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
          }
          if (!frag) {
            this.bufferFlushed = true;
            return;
          }
          var atBufferSyncLimit = mainBufferInfo && frag.start > mainBufferInfo.end + trackDetails.targetduration;
          if (atBufferSyncLimit || !(mainBufferInfo != null && mainBufferInfo.len) && bufferInfo.len) {
            var mainFrag = this.getAppendedFrag(frag.start, PlaylistLevelType.MAIN);
            if (mainFrag === null) {
              return;
            }
            atGap || (atGap = !!mainFrag.gap || !!atBufferSyncLimit && mainBufferInfo.len === 0);
            if (atBufferSyncLimit && !atGap || atGap && bufferInfo.nextStart && bufferInfo.nextStart < mainFrag.end) {
              return;
            }
          }
          this.loadFragment(frag, levelInfo, targetBufferTime);
        };
        _proto.getMaxBufferLength = function getMaxBufferLength(mainBufferLength) {
          var maxConfigBuffer = _BaseStreamController.prototype.getMaxBufferLength.call(this);
          if (!mainBufferLength) {
            return maxConfigBuffer;
          }
          return Math.min(Math.max(maxConfigBuffer, mainBufferLength), this.config.maxMaxBufferLength);
        };
        _proto.onMediaDetaching = function onMediaDetaching() {
          this.videoBuffer = null;
          this.bufferFlushed = this.flushing = false;
          _BaseStreamController.prototype.onMediaDetaching.call(this);
        };
        _proto.onAudioTracksUpdated = function onAudioTracksUpdated(event, _ref2) {
          var audioTracks = _ref2.audioTracks;
          this.resetTransmuxer();
          this.levels = audioTracks.map(function(mediaPlaylist) {
            return new Level(mediaPlaylist);
          });
        };
        _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {
          var altAudio = !!data.url;
          this.trackId = data.id;
          var fragCurrent = this.fragCurrent;
          if (fragCurrent) {
            fragCurrent.abortRequests();
            this.removeUnbufferedFrags(fragCurrent.start);
          }
          this.resetLoadingState();
          if (!altAudio) {
            this.resetTransmuxer();
          } else {
            this.setInterval(TICK_INTERVAL$2);
          }
          if (altAudio) {
            this.switchingTrack = data;
            this.state = State.IDLE;
            this.flushAudioIfNeeded(data);
          } else {
            this.switchingTrack = null;
            this.bufferedTrack = data;
            this.state = State.STOPPED;
          }
          this.tick();
        };
        _proto.onManifestLoading = function onManifestLoading() {
          this.fragmentTracker.removeAllFragments();
          this.startPosition = this.lastCurrentTime = 0;
          this.bufferFlushed = this.flushing = false;
          this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null;
          this.startFragRequested = false;
          this.trackId = this.videoTrackCC = this.waitingVideoCC = -1;
        };
        _proto.onLevelLoaded = function onLevelLoaded(event, data) {
          this.mainDetails = data.details;
          if (this.cachedTrackLoadedData !== null) {
            this.hls.trigger(Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);
            this.cachedTrackLoadedData = null;
          }
        };
        _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {
          var _track$details;
          if (this.mainDetails == null) {
            this.cachedTrackLoadedData = data;
            return;
          }
          var levels = this.levels;
          var { details: newDetails, id: trackId } = data;
          if (!levels) {
            this.warn("Audio tracks were reset while loading level " + trackId);
            return;
          }
          this.log("Audio track " + trackId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "]" + (newDetails.lastPartSn ? "[part-" + newDetails.lastPartSn + "-" + newDetails.lastPartIndex + "]" : "") + ",duration:" + newDetails.totalduration);
          var track = levels[trackId];
          var sliding = 0;
          if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {
            this.checkLiveUpdate(newDetails);
            var mainDetails = this.mainDetails;
            if (newDetails.deltaUpdateFailed || !mainDetails) {
              return;
            }
            if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
              alignMediaPlaylistByPDT(newDetails, mainDetails);
              sliding = newDetails.fragments[0].start;
            } else {
              var _this$levelLastLoaded;
              sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? undefined : _this$levelLastLoaded.details);
            }
          }
          track.details = newDetails;
          this.levelLastLoaded = track;
          if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
            this.setStartPosition(this.mainDetails || newDetails, sliding);
          }
          if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {
            this.state = State.IDLE;
          }
          this.tick();
        };
        _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {
          var _frag$initSegment;
          var { frag, part, payload } = data;
          var config = this.config, trackId = this.trackId, levels = this.levels;
          if (!levels) {
            this.warn("Audio tracks were reset while fragment load was in progress. Fragment " + frag.sn + " of level " + frag.level + " will not be buffered");
            return;
          }
          var track = levels[trackId];
          if (!track) {
            this.warn("Audio track is undefined on fragment load progress");
            return;
          }
          var details = track.details;
          if (!details) {
            this.warn("Audio track details undefined on fragment load progress");
            this.removeUnbufferedFrags(frag.start);
            return;
          }
          var audioCodec = config.defaultAudioCodec || track.audioCodec || "mp4a.40.2";
          var transmuxer = this.transmuxer;
          if (!transmuxer) {
            transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
          }
          var initPTS = this.initPTS[frag.cc];
          var initSegmentData = (_frag$initSegment = frag.initSegment) == null ? undefined : _frag$initSegment.data;
          if (initPTS !== undefined) {
            var accurateTimeOffset = false;
            var partIndex = part ? part.index : -1;
            var partial = partIndex !== -1;
            var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
            transmuxer.push(payload, initSegmentData, audioCodec, "", frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
          } else {
            this.log("Unknown video PTS for cc " + frag.cc + ", waiting for video PTS before demuxing audio frag " + frag.sn + " of [" + details.startSN + " ," + details.endSN + "],track " + trackId);
            var _this$waitingData = this.waitingData = this.waitingData || {
              frag,
              part,
              cache: new ChunkCache,
              complete: false
            }, cache = _this$waitingData.cache;
            cache.push(new Uint8Array(payload));
            this.waitingVideoCC = this.videoTrackCC;
            this.state = State.WAITING_INIT_PTS;
          }
        };
        _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {
          if (this.waitingData) {
            this.waitingData.complete = true;
            return;
          }
          _BaseStreamController.prototype._handleFragmentLoadComplete.call(this, fragLoadedData);
        };
        _proto.onBufferReset = function onBufferReset() {
          this.mediaBuffer = this.videoBuffer = null;
          this.loadedmetadata = false;
        };
        _proto.onBufferCreated = function onBufferCreated(event, data) {
          var audioTrack = data.tracks.audio;
          if (audioTrack) {
            this.mediaBuffer = audioTrack.buffer || null;
          }
          if (data.tracks.video) {
            this.videoBuffer = data.tracks.video.buffer || null;
          }
        };
        _proto.onFragBuffered = function onFragBuffered(event, data) {
          var { frag, part } = data;
          if (frag.type !== PlaylistLevelType.AUDIO) {
            if (!this.loadedmetadata && frag.type === PlaylistLevelType.MAIN) {
              var bufferable = this.videoBuffer || this.media;
              if (bufferable) {
                var bufferedTimeRanges = BufferHelper.getBuffered(bufferable);
                if (bufferedTimeRanges.length) {
                  this.loadedmetadata = true;
                }
              }
            }
            return;
          }
          if (this.fragContextChanged(frag)) {
            this.warn("Fragment " + frag.sn + (part ? " p: " + part.index : "") + " of level " + frag.level + " finished buffering, but was aborted. state: " + this.state + ", audioSwitch: " + (this.switchingTrack ? this.switchingTrack.name : "false"));
            return;
          }
          if (frag.sn !== "initSegment") {
            this.fragPrevious = frag;
            var track = this.switchingTrack;
            if (track) {
              this.bufferedTrack = track;
              this.switchingTrack = null;
              this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));
            }
          }
          this.fragBufferedComplete(frag, part);
        };
        _proto.onError = function onError(event, data) {
          var _data$context;
          if (data.fatal) {
            this.state = State.ERROR;
            return;
          }
          switch (data.details) {
            case ErrorDetails.FRAG_GAP:
            case ErrorDetails.FRAG_PARSING_ERROR:
            case ErrorDetails.FRAG_DECRYPT_ERROR:
            case ErrorDetails.FRAG_LOAD_ERROR:
            case ErrorDetails.FRAG_LOAD_TIMEOUT:
            case ErrorDetails.KEY_LOAD_ERROR:
            case ErrorDetails.KEY_LOAD_TIMEOUT:
              this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);
              break;
            case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:
            case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:
            case ErrorDetails.LEVEL_PARSING_ERROR:
              if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? undefined : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {
                this.state = State.IDLE;
              }
              break;
            case ErrorDetails.BUFFER_APPEND_ERROR:
            case ErrorDetails.BUFFER_FULL_ERROR:
              if (!data.parent || data.parent !== "audio") {
                return;
              }
              if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {
                this.resetLoadingState();
                return;
              }
              if (this.reduceLengthAndFlushBuffer(data)) {
                this.bufferedTrack = null;
                _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio");
              }
              break;
            case ErrorDetails.INTERNAL_EXCEPTION:
              this.recoverWorkerError(data);
              break;
          }
        };
        _proto.onBufferFlushing = function onBufferFlushing(event, _ref3) {
          var type = _ref3.type;
          if (type !== ElementaryStreamTypes.VIDEO) {
            this.flushing = true;
          }
        };
        _proto.onBufferFlushed = function onBufferFlushed(event, _ref4) {
          var type = _ref4.type;
          if (type !== ElementaryStreamTypes.VIDEO) {
            this.flushing = false;
            this.bufferFlushed = true;
            if (this.state === State.ENDED) {
              this.state = State.IDLE;
            }
            var mediaBuffer = this.mediaBuffer || this.media;
            if (mediaBuffer) {
              this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.AUDIO);
              this.tick();
            }
          }
        };
        _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {
          var _id3$samples;
          var id = "audio";
          var hls = this.hls;
          var { remuxResult, chunkMeta } = transmuxResult;
          var context = this.getCurrentContext(chunkMeta);
          if (!context) {
            this.resetWhenMissingContext(chunkMeta);
            return;
          }
          var { frag, part, level } = context;
          var details = level.details;
          var { audio, text, id3, initSegment } = remuxResult;
          if (this.fragContextChanged(frag) || !details) {
            this.fragmentTracker.removeFragment(frag);
            return;
          }
          this.state = State.PARSING;
          if (this.switchingTrack && audio) {
            this.completeAudioSwitch(this.switchingTrack);
          }
          if (initSegment != null && initSegment.tracks) {
            var mapFragment = frag.initSegment || frag;
            this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);
            hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {
              frag: mapFragment,
              id,
              tracks: initSegment.tracks
            });
          }
          if (audio) {
            var { startPTS, endPTS, startDTS, endDTS } = audio;
            if (part) {
              part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
                startPTS,
                endPTS,
                startDTS,
                endDTS
              };
            }
            frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);
            this.bufferFragmentData(audio, frag, part, chunkMeta);
          }
          if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {
            var emittedID3 = _extends({
              id,
              frag,
              details
            }, id3);
            hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);
          }
          if (text) {
            var emittedText = _extends({
              id,
              frag,
              details
            }, text);
            hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);
          }
        };
        _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
          if (this.state !== State.PARSING) {
            return;
          }
          if (tracks.video) {
            delete tracks.video;
          }
          var track = tracks.audio;
          if (!track) {
            return;
          }
          track.id = "audio";
          var variantAudioCodecs = currentLevel.audioCodec;
          this.log("Init audio buffer, container:" + track.container + ", codecs[level/parsed]=[" + variantAudioCodecs + "/" + track.codec + "]");
          if (variantAudioCodecs && variantAudioCodecs.split(",").length === 1) {
            track.levelCodec = variantAudioCodecs;
          }
          this.hls.trigger(Events.BUFFER_CODECS, tracks);
          var initSegment = track.initSegment;
          if (initSegment != null && initSegment.byteLength) {
            var segment = {
              type: "audio",
              frag,
              part: null,
              chunkMeta,
              parent: frag.type,
              data: initSegment
            };
            this.hls.trigger(Events.BUFFER_APPENDING, segment);
          }
          this.tickImmediate();
        };
        _proto.loadFragment = function loadFragment(frag, track, targetBufferTime) {
          var fragState = this.fragmentTracker.getState(frag);
          this.fragCurrent = frag;
          if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
            var _track$details2;
            if (frag.sn === "initSegment") {
              this._loadInitSegment(frag, track);
            } else if ((_track$details2 = track.details) != null && _track$details2.live && !this.initPTS[frag.cc]) {
              this.log("Waiting for video PTS in continuity counter " + frag.cc + " of live stream before loading audio fragment " + frag.sn + " of level " + this.trackId);
              this.state = State.WAITING_INIT_PTS;
              var mainDetails = this.mainDetails;
              if (mainDetails && mainDetails.fragments[0].start !== track.details.fragments[0].start) {
                alignMediaPlaylistByPDT(track.details, mainDetails);
              }
            } else {
              this.startFragRequested = true;
              _BaseStreamController.prototype.loadFragment.call(this, frag, track, targetBufferTime);
            }
          } else {
            this.clearTrackerIfNeeded(frag);
          }
        };
        _proto.flushAudioIfNeeded = function flushAudioIfNeeded(switchingTrack) {
          var media = this.media, bufferedTrack = this.bufferedTrack;
          var bufferedAttributes = bufferedTrack == null ? undefined : bufferedTrack.attrs;
          var switchAttributes = switchingTrack.attrs;
          if (media && bufferedAttributes && (bufferedAttributes.CHANNELS !== switchAttributes.CHANNELS || bufferedTrack.name !== switchingTrack.name || bufferedTrack.lang !== switchingTrack.lang)) {
            this.log("Switching audio track : flushing all audio");
            _BaseStreamController.prototype.flushMainBuffer.call(this, 0, Number.POSITIVE_INFINITY, "audio");
            this.bufferedTrack = null;
          }
        };
        _proto.completeAudioSwitch = function completeAudioSwitch(switchingTrack) {
          var hls = this.hls;
          this.flushAudioIfNeeded(switchingTrack);
          this.bufferedTrack = switchingTrack;
          this.switchingTrack = null;
          hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));
        };
        return AudioStreamController2;
      }(BaseStreamController);
      var AudioTrackController = /* @__PURE__ */ function(_BasePlaylistControll) {
        _inheritsLoose(AudioTrackController2, _BasePlaylistControll);
        function AudioTrackController2(hls) {
          var _this;
          _this = _BasePlaylistControll.call(this, hls, "[audio-track-controller]") || this;
          _this.tracks = [];
          _this.groupIds = null;
          _this.tracksInGroup = [];
          _this.trackId = -1;
          _this.currentTrack = null;
          _this.selectDefaultTrack = true;
          _this.registerListeners();
          return _this;
        }
        var _proto = AudioTrackController2.prototype;
        _proto.registerListeners = function registerListeners() {
          var hls = this.hls;
          hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
          hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
          hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
          hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
          hls.on(Events.ERROR, this.onError, this);
        };
        _proto.unregisterListeners = function unregisterListeners() {
          var hls = this.hls;
          hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
          hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
          hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
          hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);
          hls.off(Events.ERROR, this.onError, this);
        };
        _proto.destroy = function destroy() {
          this.unregisterListeners();
          this.tracks.length = 0;
          this.tracksInGroup.length = 0;
          this.currentTrack = null;
          _BasePlaylistControll.prototype.destroy.call(this);
        };
        _proto.onManifestLoading = function onManifestLoading() {
          this.tracks = [];
          this.tracksInGroup = [];
          this.groupIds = null;
          this.currentTrack = null;
          this.trackId = -1;
          this.selectDefaultTrack = true;
        };
        _proto.onManifestParsed = function onManifestParsed(event, data) {
          this.tracks = data.audioTracks || [];
        };
        _proto.onAudioTrackLoaded = function onAudioTrackLoaded(event, data) {
          var { id, groupId, details } = data;
          var trackInActiveGroup = this.tracksInGroup[id];
          if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {
            this.warn("Audio track with id:" + id + " and group:" + groupId + " not found in active group " + (trackInActiveGroup == null ? undefined : trackInActiveGroup.groupId));
            return;
          }
          var curDetails = trackInActiveGroup.details;
          trackInActiveGroup.details = data.details;
          this.log("Audio track " + id + ' "' + trackInActiveGroup.name + '" lang:' + trackInActiveGroup.lang + " group:" + groupId + " loaded [" + details.startSN + "-" + details.endSN + "]");
          if (id === this.trackId) {
            this.playlistLoaded(id, data, curDetails);
          }
        };
        _proto.onLevelLoading = function onLevelLoading(event, data) {
          this.switchLevel(data.level);
        };
        _proto.onLevelSwitching = function onLevelSwitching(event, data) {
          this.switchLevel(data.level);
        };
        _proto.switchLevel = function switchLevel(levelIndex) {
          var levelInfo = this.hls.levels[levelIndex];
          if (!levelInfo) {
            return;
          }
          var audioGroups = levelInfo.audioGroups || null;
          var currentGroups = this.groupIds;
          var currentTrack = this.currentTrack;
          if (!audioGroups || (currentGroups == null ? undefined : currentGroups.length) !== (audioGroups == null ? undefined : audioGroups.length) || audioGroups != null && audioGroups.some(function(groupId) {
            return (currentGroups == null ? undefined : currentGroups.indexOf(groupId)) === -1;
          })) {
            this.groupIds = audioGroups;
            this.trackId = -1;
            this.currentTrack = null;
            var audioTracks = this.tracks.filter(function(track) {
              return !audioGroups || audioGroups.indexOf(track.groupId) !== -1;
            });
            if (audioTracks.length) {
              if (this.selectDefaultTrack && !audioTracks.some(function(track) {
                return track.default;
              })) {
                this.selectDefaultTrack = false;
              }
              audioTracks.forEach(function(track, i) {
                track.id = i;
              });
            } else if (!currentTrack && !this.tracksInGroup.length) {
              return;
            }
            this.tracksInGroup = audioTracks;
            var audioPreference = this.hls.config.audioPreference;
            if (!currentTrack && audioPreference) {
              var groupIndex = findMatchingOption(audioPreference, audioTracks, audioMatchPredicate);
              if (groupIndex > -1) {
                currentTrack = audioTracks[groupIndex];
              } else {
                var allIndex = findMatchingOption(audioPreference, this.tracks);
                currentTrack = this.tracks[allIndex];
              }
            }
            var trackId = this.findTrackId(currentTrack);
            if (trackId === -1 && currentTrack) {
              trackId = this.findTrackId(null);
            }
            var audioTracksUpdated = {
              audioTracks
            };
            this.log("Updating audio tracks, " + audioTracks.length + " track(s) found in group(s): " + (audioGroups == null ? undefined : audioGroups.join(",")));
            this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);
            var selectedTrackId = this.trackId;
            if (trackId !== -1 && selectedTrackId === -1) {
              this.setAudioTrack(trackId);
            } else if (audioTracks.length && selectedTrackId === -1) {
              var _this$groupIds;
              var error2 = new Error("No audio track selected for current audio group-ID(s): " + ((_this$groupIds = this.groupIds) == null ? undefined : _this$groupIds.join(",")) + " track count: " + audioTracks.length);
              this.warn(error2.message);
              this.hls.trigger(Events.ERROR, {
                type: ErrorTypes2.MEDIA_ERROR,
                details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,
                fatal: true,
                error: error2
              });
            }
          } else if (this.shouldReloadPlaylist(currentTrack)) {
            this.setAudioTrack(this.trackId);
          }
        };
        _proto.onError = function onError(event, data) {
          if (data.fatal || !data.context) {
            return;
          }
          if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {
            this.requestScheduled = -1;
            this.checkRetry(data);
          }
        };
        _proto.setAudioOption = function setAudioOption(audioOption) {
          var hls = this.hls;
          hls.config.audioPreference = audioOption;
          if (audioOption) {
            var allAudioTracks = this.allAudioTracks;
            this.selectDefaultTrack = false;
            if (allAudioTracks.length) {
              var currentTrack = this.currentTrack;
              if (currentTrack && matchesOption(audioOption, currentTrack, audioMatchPredicate)) {
                return currentTrack;
              }
              var groupIndex = findMatchingOption(audioOption, this.tracksInGroup, audioMatchPredicate);
              if (groupIndex > -1) {
                var track = this.tracksInGroup[groupIndex];
                this.setAudioTrack(groupIndex);
                return track;
              } else if (currentTrack) {
                var searchIndex = hls.loadLevel;
                if (searchIndex === -1) {
                  searchIndex = hls.firstAutoLevel;
                }
                var switchIndex = findClosestLevelWithAudioGroup(audioOption, hls.levels, allAudioTracks, searchIndex, audioMatchPredicate);
                if (switchIndex === -1) {
                  return null;
                }
                hls.nextLoadLevel = switchIndex;
              }
              if (audioOption.channels || audioOption.audioCodec) {
                var withoutCodecAndChannelsMatch = findMatchingOption(audioOption, allAudioTracks);
                if (withoutCodecAndChannelsMatch > -1) {
                  return allAudioTracks[withoutCodecAndChannelsMatch];
                }
              }
            }
          }
          return null;
        };
        _proto.setAudioTrack = function setAudioTrack(newId) {
          var tracks = this.tracksInGroup;
          if (newId < 0 || newId >= tracks.length) {
            this.warn("Invalid audio track id: " + newId);
            return;
          }
          this.clearTimer();
          this.selectDefaultTrack = false;
          var lastTrack = this.currentTrack;
          var track = tracks[newId];
          var trackLoaded = track.details && !track.details.live;
          if (newId === this.trackId && track === lastTrack && trackLoaded) {
            return;
          }
          this.log("Switching to audio-track " + newId + ' "' + track.name + '" lang:' + track.lang + " group:" + track.groupId + " channels:" + track.channels);
          this.trackId = newId;
          this.currentTrack = track;
          this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));
          if (trackLoaded) {
            return;
          }
          var hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? undefined : lastTrack.details, track.details);
          this.loadPlaylist(hlsUrlParameters);
        };
        _proto.findTrackId = function findTrackId(currentTrack) {
          var audioTracks = this.tracksInGroup;
          for (var i = 0;i < audioTracks.length; i++) {
            var track = audioTracks[i];
            if (this.selectDefaultTrack && !track.default) {
              continue;
            }
            if (!currentTrack || matchesOption(currentTrack, track, audioMatchPredicate)) {
              return i;
            }
          }
          if (currentTrack) {
            var { name, lang, assocLang, characteristics, audioCodec, channels } = currentTrack;
            for (var _i = 0;_i < audioTracks.length; _i++) {
              var _track = audioTracks[_i];
              if (matchesOption({
                name,
                lang,
                assocLang,
                characteristics,
                audioCodec,
                channels
              }, _track, audioMatchPredicate)) {
                return _i;
              }
            }
            for (var _i2 = 0;_i2 < audioTracks.length; _i2++) {
              var _track2 = audioTracks[_i2];
              if (mediaAttributesIdentical(currentTrack.attrs, _track2.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) {
                return _i2;
              }
            }
            for (var _i3 = 0;_i3 < audioTracks.length; _i3++) {
              var _track3 = audioTracks[_i3];
              if (mediaAttributesIdentical(currentTrack.attrs, _track3.attrs, ["LANGUAGE"])) {
                return _i3;
              }
            }
          }
          return -1;
        };
        _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
          var audioTrack = this.currentTrack;
          if (this.shouldLoadPlaylist(audioTrack) && audioTrack) {
            _BasePlaylistControll.prototype.loadPlaylist.call(this);
            var id = audioTrack.id;
            var groupId = audioTrack.groupId;
            var url2 = audioTrack.url;
            if (hlsUrlParameters) {
              try {
                url2 = hlsUrlParameters.addDirectives(url2);
              } catch (error2) {
                this.warn("Could not construct new URL with HLS Delivery Directives: " + error2);
              }
            }
            this.log("loading audio-track playlist " + id + ' "' + audioTrack.name + '" lang:' + audioTrack.lang + " group:" + groupId);
            this.clearTimer();
            this.hls.trigger(Events.AUDIO_TRACK_LOADING, {
              url: url2,
              id,
              groupId,
              deliveryDirectives: hlsUrlParameters || null
            });
          }
        };
        _createClass(AudioTrackController2, [{
          key: "allAudioTracks",
          get: function get() {
            return this.tracks;
          }
        }, {
          key: "audioTracks",
          get: function get() {
            return this.tracksInGroup;
          }
        }, {
          key: "audioTrack",
          get: function get() {
            return this.trackId;
          },
          set: function set(newId) {
            this.selectDefaultTrack = false;
            this.setAudioTrack(newId);
          }
        }]);
        return AudioTrackController2;
      }(BasePlaylistController);
      var TICK_INTERVAL$1 = 500;
      var SubtitleStreamController = /* @__PURE__ */ function(_BaseStreamController) {
        _inheritsLoose(SubtitleStreamController2, _BaseStreamController);
        function SubtitleStreamController2(hls, fragmentTracker, keyLoader) {
          var _this;
          _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, "[subtitle-stream-controller]", PlaylistLevelType.SUBTITLE) || this;
          _this.currentTrackId = -1;
          _this.tracksBuffered = [];
          _this.mainDetails = null;
          _this._registerListeners();
          return _this;
        }
        var _proto = SubtitleStreamController2.prototype;
        _proto.onHandlerDestroying = function onHandlerDestroying() {
          this._unregisterListeners();
          _BaseStreamController.prototype.onHandlerDestroying.call(this);
          this.mainDetails = null;
        };
        _proto._registerListeners = function _registerListeners() {
          var hls = this.hls;
          hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
          hls.on(Events.ERROR, this.onError, this);
          hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
          hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
          hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
          hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
          hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
          hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        };
        _proto._unregisterListeners = function _unregisterListeners() {
          var hls = this.hls;
          hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
          hls.off(Events.ERROR, this.onError, this);
          hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
          hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);
          hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
          hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);
          hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
          hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        };
        _proto.startLoad = function startLoad(startPosition) {
          this.stopLoad();
          this.state = State.IDLE;
          this.setInterval(TICK_INTERVAL$1);
          this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
          this.tick();
        };
        _proto.onManifestLoading = function onManifestLoading() {
          this.mainDetails = null;
          this.fragmentTracker.removeAllFragments();
        };
        _proto.onMediaDetaching = function onMediaDetaching() {
          this.tracksBuffered = [];
          _BaseStreamController.prototype.onMediaDetaching.call(this);
        };
        _proto.onLevelLoaded = function onLevelLoaded(event, data) {
          this.mainDetails = data.details;
        };
        _proto.onSubtitleFragProcessed = function onSubtitleFragProcessed(event, data) {
          var { frag, success } = data;
          this.fragPrevious = frag;
          this.state = State.IDLE;
          if (!success) {
            return;
          }
          var buffered = this.tracksBuffered[this.currentTrackId];
          if (!buffered) {
            return;
          }
          var timeRange;
          var fragStart = frag.start;
          for (var i = 0;i < buffered.length; i++) {
            if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {
              timeRange = buffered[i];
              break;
            }
          }
          var fragEnd = frag.start + frag.duration;
          if (timeRange) {
            timeRange.end = fragEnd;
          } else {
            timeRange = {
              start: fragStart,
              end: fragEnd
            };
            buffered.push(timeRange);
          }
          this.fragmentTracker.fragBuffered(frag);
          this.fragBufferedComplete(frag, null);
        };
        _proto.onBufferFlushing = function onBufferFlushing(event, data) {
          var { startOffset, endOffset } = data;
          if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {
            var endOffsetSubtitles = endOffset - 1;
            if (endOffsetSubtitles <= 0) {
              return;
            }
            data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);
            this.tracksBuffered.forEach(function(buffered) {
              for (var i = 0;i < buffered.length; ) {
                if (buffered[i].end <= endOffsetSubtitles) {
                  buffered.shift();
                  continue;
                } else if (buffered[i].start < endOffsetSubtitles) {
                  buffered[i].start = endOffsetSubtitles;
                } else {
                  break;
                }
                i++;
              }
            });
            this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);
          }
        };
        _proto.onFragBuffered = function onFragBuffered(event, data) {
          if (!this.loadedmetadata && data.frag.type === PlaylistLevelType.MAIN) {
            var _this$media;
            if ((_this$media = this.media) != null && _this$media.buffered.length) {
              this.loadedmetadata = true;
            }
          }
        };
        _proto.onError = function onError(event, data) {
          var frag = data.frag;
          if ((frag == null ? undefined : frag.type) === PlaylistLevelType.SUBTITLE) {
            if (data.details === ErrorDetails.FRAG_GAP) {
              this.fragmentTracker.fragBuffered(frag, true);
            }
            if (this.fragCurrent) {
              this.fragCurrent.abortRequests();
            }
            if (this.state !== State.STOPPED) {
              this.state = State.IDLE;
            }
          }
        };
        _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, _ref) {
          var _this2 = this;
          var subtitleTracks = _ref.subtitleTracks;
          if (this.levels && subtitleOptionsIdentical(this.levels, subtitleTracks)) {
            this.levels = subtitleTracks.map(function(mediaPlaylist) {
              return new Level(mediaPlaylist);
            });
            return;
          }
          this.tracksBuffered = [];
          this.levels = subtitleTracks.map(function(mediaPlaylist) {
            var level = new Level(mediaPlaylist);
            _this2.tracksBuffered[level.id] = [];
            return level;
          });
          this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);
          this.fragPrevious = null;
          this.mediaBuffer = null;
        };
        _proto.onSubtitleTrackSwitch = function onSubtitleTrackSwitch(event, data) {
          var _this$levels;
          this.currentTrackId = data.id;
          if (!((_this$levels = this.levels) != null && _this$levels.length) || this.currentTrackId === -1) {
            this.clearInterval();
            return;
          }
          var currentTrack = this.levels[this.currentTrackId];
          if (currentTrack != null && currentTrack.details) {
            this.mediaBuffer = this.mediaBufferTimeRanges;
          } else {
            this.mediaBuffer = null;
          }
          if (currentTrack) {
            this.setInterval(TICK_INTERVAL$1);
          }
        };
        _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {
          var _track$details;
          var currentTrackId = this.currentTrackId, levels = this.levels;
          var { details: newDetails, id: trackId } = data;
          if (!levels) {
            this.warn("Subtitle tracks were reset while loading level " + trackId);
            return;
          }
          var track = levels[trackId];
          if (trackId >= levels.length || !track) {
            return;
          }
          this.log("Subtitle track " + trackId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "]" + (newDetails.lastPartSn ? "[part-" + newDetails.lastPartSn + "-" + newDetails.lastPartIndex + "]" : "") + ",duration:" + newDetails.totalduration);
          this.mediaBuffer = this.mediaBufferTimeRanges;
          var sliding = 0;
          if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {
            var mainDetails = this.mainDetails;
            if (newDetails.deltaUpdateFailed || !mainDetails) {
              return;
            }
            var mainSlidingStartFragment = mainDetails.fragments[0];
            if (!track.details) {
              if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {
                alignMediaPlaylistByPDT(newDetails, mainDetails);
                sliding = newDetails.fragments[0].start;
              } else if (mainSlidingStartFragment) {
                sliding = mainSlidingStartFragment.start;
                addSliding(newDetails, sliding);
              }
            } else {
              var _this$levelLastLoaded;
              sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? undefined : _this$levelLastLoaded.details);
              if (sliding === 0 && mainSlidingStartFragment) {
                sliding = mainSlidingStartFragment.start;
                addSliding(newDetails, sliding);
              }
            }
          }
          track.details = newDetails;
          this.levelLastLoaded = track;
          if (trackId !== currentTrackId) {
            return;
          }
          if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {
            this.setStartPosition(this.mainDetails || newDetails, sliding);
          }
          this.tick();
          if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {
            var foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);
            if (!foundFrag) {
              this.warn("Subtitle playlist not aligned with playback");
              track.details = undefined;
            }
          }
        };
        _proto._handleFragmentLoadComplete = function _handleFragmentLoadComplete(fragLoadedData) {
          var _this3 = this;
          var { frag, payload } = fragLoadedData;
          var decryptData = frag.decryptdata;
          var hls = this.hls;
          if (this.fragContextChanged(frag)) {
            return;
          }
          if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === "AES-128") {
            var startTime = performance.now();
            this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(function(err) {
              hls.trigger(Events.ERROR, {
                type: ErrorTypes2.MEDIA_ERROR,
                details: ErrorDetails.FRAG_DECRYPT_ERROR,
                fatal: false,
                error: err,
                reason: err.message,
                frag
              });
              throw err;
            }).then(function(decryptedData) {
              var endTime = performance.now();
              hls.trigger(Events.FRAG_DECRYPTED, {
                frag,
                payload: decryptedData,
                stats: {
                  tstart: startTime,
                  tdecrypt: endTime
                }
              });
            }).catch(function(err) {
              _this3.warn(err.name + ": " + err.message);
              _this3.state = State.IDLE;
            });
          }
        };
        _proto.doTick = function doTick() {
          if (!this.media) {
            this.state = State.IDLE;
            return;
          }
          if (this.state === State.IDLE) {
            var currentTrackId = this.currentTrackId, levels = this.levels;
            var track = levels == null ? undefined : levels[currentTrackId];
            if (!track || !levels.length || !track.details) {
              return;
            }
            var config = this.config;
            var currentTime = this.getLoadPosition();
            var bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);
            var { end: targetBufferTime, len: bufferLen } = bufferedInfo;
            var mainBufferInfo = this.getFwdBufferInfo(this.media, PlaylistLevelType.MAIN);
            var trackDetails = track.details;
            var maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? undefined : mainBufferInfo.len) + trackDetails.levelTargetDuration;
            if (bufferLen > maxBufLen) {
              return;
            }
            var fragments = trackDetails.fragments;
            var fragLen = fragments.length;
            var end = trackDetails.edge;
            var foundFrag = null;
            var fragPrevious = this.fragPrevious;
            if (targetBufferTime < end) {
              var tolerance = config.maxFragLookUpTolerance;
              var lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;
              foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);
              if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {
                foundFrag = fragments[0];
              }
            } else {
              foundFrag = fragments[fragLen - 1];
            }
            if (!foundFrag) {
              return;
            }
            foundFrag = this.mapToInitFragWhenRequired(foundFrag);
            if (foundFrag.sn !== "initSegment") {
              var curSNIdx = foundFrag.sn - trackDetails.startSN;
              var prevFrag = fragments[curSNIdx - 1];
              if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {
                foundFrag = prevFrag;
              }
            }
            if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {
              this.loadFragment(foundFrag, track, targetBufferTime);
            }
          }
        };
        _proto.getMaxBufferLength = function getMaxBufferLength(mainBufferLength) {
          var maxConfigBuffer = _BaseStreamController.prototype.getMaxBufferLength.call(this);
          if (!mainBufferLength) {
            return maxConfigBuffer;
          }
          return Math.max(maxConfigBuffer, mainBufferLength);
        };
        _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {
          this.fragCurrent = frag;
          if (frag.sn === "initSegment") {
            this._loadInitSegment(frag, level);
          } else {
            this.startFragRequested = true;
            _BaseStreamController.prototype.loadFragment.call(this, frag, level, targetBufferTime);
          }
        };
        _createClass(SubtitleStreamController2, [{
          key: "mediaBufferTimeRanges",
          get: function get() {
            return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);
          }
        }]);
        return SubtitleStreamController2;
      }(BaseStreamController);
      var BufferableInstance = function BufferableInstance(timeranges) {
        this.buffered = undefined;
        var getRange = function getRange(name, index, length) {
          index = index >>> 0;
          if (index > length - 1) {
            throw new DOMException("Failed to execute '" + name + "' on 'TimeRanges': The index provided (" + index + ") is greater than the maximum bound (" + length + ")");
          }
          return timeranges[index][name];
        };
        this.buffered = {
          get length() {
            return timeranges.length;
          },
          end: function end(index) {
            return getRange("end", index, timeranges.length);
          },
          start: function start(index) {
            return getRange("start", index, timeranges.length);
          }
        };
      };
      var SubtitleTrackController = /* @__PURE__ */ function(_BasePlaylistControll) {
        _inheritsLoose(SubtitleTrackController2, _BasePlaylistControll);
        function SubtitleTrackController2(hls) {
          var _this;
          _this = _BasePlaylistControll.call(this, hls, "[subtitle-track-controller]") || this;
          _this.media = null;
          _this.tracks = [];
          _this.groupIds = null;
          _this.tracksInGroup = [];
          _this.trackId = -1;
          _this.currentTrack = null;
          _this.selectDefaultTrack = true;
          _this.queuedDefaultTrack = -1;
          _this.asyncPollTrackChange = function() {
            return _this.pollTrackChange(0);
          };
          _this.useTextTrackPolling = false;
          _this.subtitlePollingInterval = -1;
          _this._subtitleDisplay = true;
          _this.onTextTracksChanged = function() {
            if (!_this.useTextTrackPolling) {
              self.clearInterval(_this.subtitlePollingInterval);
            }
            if (!_this.media || !_this.hls.config.renderTextTracksNatively) {
              return;
            }
            var textTrack = null;
            var tracks = filterSubtitleTracks(_this.media.textTracks);
            for (var i = 0;i < tracks.length; i++) {
              if (tracks[i].mode === "hidden") {
                textTrack = tracks[i];
              } else if (tracks[i].mode === "showing") {
                textTrack = tracks[i];
                break;
              }
            }
            var trackId = _this.findTrackForTextTrack(textTrack);
            if (_this.subtitleTrack !== trackId) {
              _this.setSubtitleTrack(trackId);
            }
          };
          _this.registerListeners();
          return _this;
        }
        var _proto = SubtitleTrackController2.prototype;
        _proto.destroy = function destroy() {
          this.unregisterListeners();
          this.tracks.length = 0;
          this.tracksInGroup.length = 0;
          this.currentTrack = null;
          this.onTextTracksChanged = this.asyncPollTrackChange = null;
          _BasePlaylistControll.prototype.destroy.call(this);
        };
        _proto.registerListeners = function registerListeners() {
          var hls = this.hls;
          hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
          hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
          hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
          hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
          hls.on(Events.ERROR, this.onError, this);
        };
        _proto.unregisterListeners = function unregisterListeners() {
          var hls = this.hls;
          hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
          hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);
          hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);
          hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);
          hls.off(Events.ERROR, this.onError, this);
        };
        _proto.onMediaAttached = function onMediaAttached(event, data) {
          this.media = data.media;
          if (!this.media) {
            return;
          }
          if (this.queuedDefaultTrack > -1) {
            this.subtitleTrack = this.queuedDefaultTrack;
            this.queuedDefaultTrack = -1;
          }
          this.useTextTrackPolling = !(this.media.textTracks && ("onchange" in this.media.textTracks));
          if (this.useTextTrackPolling) {
            this.pollTrackChange(500);
          } else {
            this.media.textTracks.addEventListener("change", this.asyncPollTrackChange);
          }
        };
        _proto.pollTrackChange = function pollTrackChange(timeout) {
          self.clearInterval(this.subtitlePollingInterval);
          this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, timeout);
        };
        _proto.onMediaDetaching = function onMediaDetaching() {
          if (!this.media) {
            return;
          }
          self.clearInterval(this.subtitlePollingInterval);
          if (!this.useTextTrackPolling) {
            this.media.textTracks.removeEventListener("change", this.asyncPollTrackChange);
          }
          if (this.trackId > -1) {
            this.queuedDefaultTrack = this.trackId;
          }
          var textTracks = filterSubtitleTracks(this.media.textTracks);
          textTracks.forEach(function(track) {
            clearCurrentCues(track);
          });
          this.subtitleTrack = -1;
          this.media = null;
        };
        _proto.onManifestLoading = function onManifestLoading() {
          this.tracks = [];
          this.groupIds = null;
          this.tracksInGroup = [];
          this.trackId = -1;
          this.currentTrack = null;
          this.selectDefaultTrack = true;
        };
        _proto.onManifestParsed = function onManifestParsed(event, data) {
          this.tracks = data.subtitleTracks;
        };
        _proto.onSubtitleTrackLoaded = function onSubtitleTrackLoaded(event, data) {
          var { id, groupId, details } = data;
          var trackInActiveGroup = this.tracksInGroup[id];
          if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {
            this.warn("Subtitle track with id:" + id + " and group:" + groupId + " not found in active group " + (trackInActiveGroup == null ? undefined : trackInActiveGroup.groupId));
            return;
          }
          var curDetails = trackInActiveGroup.details;
          trackInActiveGroup.details = data.details;
          this.log("Subtitle track " + id + ' "' + trackInActiveGroup.name + '" lang:' + trackInActiveGroup.lang + " group:" + groupId + " loaded [" + details.startSN + "-" + details.endSN + "]");
          if (id === this.trackId) {
            this.playlistLoaded(id, data, curDetails);
          }
        };
        _proto.onLevelLoading = function onLevelLoading(event, data) {
          this.switchLevel(data.level);
        };
        _proto.onLevelSwitching = function onLevelSwitching(event, data) {
          this.switchLevel(data.level);
        };
        _proto.switchLevel = function switchLevel(levelIndex) {
          var levelInfo = this.hls.levels[levelIndex];
          if (!levelInfo) {
            return;
          }
          var subtitleGroups = levelInfo.subtitleGroups || null;
          var currentGroups = this.groupIds;
          var currentTrack = this.currentTrack;
          if (!subtitleGroups || (currentGroups == null ? undefined : currentGroups.length) !== (subtitleGroups == null ? undefined : subtitleGroups.length) || subtitleGroups != null && subtitleGroups.some(function(groupId) {
            return (currentGroups == null ? undefined : currentGroups.indexOf(groupId)) === -1;
          })) {
            this.groupIds = subtitleGroups;
            this.trackId = -1;
            this.currentTrack = null;
            var subtitleTracks = this.tracks.filter(function(track) {
              return !subtitleGroups || subtitleGroups.indexOf(track.groupId) !== -1;
            });
            if (subtitleTracks.length) {
              if (this.selectDefaultTrack && !subtitleTracks.some(function(track) {
                return track.default;
              })) {
                this.selectDefaultTrack = false;
              }
              subtitleTracks.forEach(function(track, i) {
                track.id = i;
              });
            } else if (!currentTrack && !this.tracksInGroup.length) {
              return;
            }
            this.tracksInGroup = subtitleTracks;
            var subtitlePreference = this.hls.config.subtitlePreference;
            if (!currentTrack && subtitlePreference) {
              this.selectDefaultTrack = false;
              var groupIndex = findMatchingOption(subtitlePreference, subtitleTracks);
              if (groupIndex > -1) {
                currentTrack = subtitleTracks[groupIndex];
              } else {
                var allIndex = findMatchingOption(subtitlePreference, this.tracks);
                currentTrack = this.tracks[allIndex];
              }
            }
            var trackId = this.findTrackId(currentTrack);
            if (trackId === -1 && currentTrack) {
              trackId = this.findTrackId(null);
            }
            var subtitleTracksUpdated = {
              subtitleTracks
            };
            this.log("Updating subtitle tracks, " + subtitleTracks.length + ' track(s) found in "' + (subtitleGroups == null ? undefined : subtitleGroups.join(",")) + '" group-id');
            this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);
            if (trackId !== -1 && this.trackId === -1) {
              this.setSubtitleTrack(trackId);
            }
          } else if (this.shouldReloadPlaylist(currentTrack)) {
            this.setSubtitleTrack(this.trackId);
          }
        };
        _proto.findTrackId = function findTrackId(currentTrack) {
          var tracks = this.tracksInGroup;
          var selectDefault = this.selectDefaultTrack;
          for (var i = 0;i < tracks.length; i++) {
            var track = tracks[i];
            if (selectDefault && !track.default || !selectDefault && !currentTrack) {
              continue;
            }
            if (!currentTrack || matchesOption(track, currentTrack)) {
              return i;
            }
          }
          if (currentTrack) {
            for (var _i = 0;_i < tracks.length; _i++) {
              var _track = tracks[_i];
              if (mediaAttributesIdentical(currentTrack.attrs, _track.attrs, ["LANGUAGE", "ASSOC-LANGUAGE", "CHARACTERISTICS"])) {
                return _i;
              }
            }
            for (var _i2 = 0;_i2 < tracks.length; _i2++) {
              var _track2 = tracks[_i2];
              if (mediaAttributesIdentical(currentTrack.attrs, _track2.attrs, ["LANGUAGE"])) {
                return _i2;
              }
            }
          }
          return -1;
        };
        _proto.findTrackForTextTrack = function findTrackForTextTrack(textTrack) {
          if (textTrack) {
            var tracks = this.tracksInGroup;
            for (var i = 0;i < tracks.length; i++) {
              var track = tracks[i];
              if (subtitleTrackMatchesTextTrack(track, textTrack)) {
                return i;
              }
            }
          }
          return -1;
        };
        _proto.onError = function onError(event, data) {
          if (data.fatal || !data.context) {
            return;
          }
          if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {
            this.checkRetry(data);
          }
        };
        _proto.setSubtitleOption = function setSubtitleOption(subtitleOption) {
          this.hls.config.subtitlePreference = subtitleOption;
          if (subtitleOption) {
            var allSubtitleTracks = this.allSubtitleTracks;
            this.selectDefaultTrack = false;
            if (allSubtitleTracks.length) {
              var currentTrack = this.currentTrack;
              if (currentTrack && matchesOption(subtitleOption, currentTrack)) {
                return currentTrack;
              }
              var groupIndex = findMatchingOption(subtitleOption, this.tracksInGroup);
              if (groupIndex > -1) {
                var track = this.tracksInGroup[groupIndex];
                this.setSubtitleTrack(groupIndex);
                return track;
              } else if (currentTrack) {
                return null;
              } else {
                var allIndex = findMatchingOption(subtitleOption, allSubtitleTracks);
                if (allIndex > -1) {
                  return allSubtitleTracks[allIndex];
                }
              }
            }
          }
          return null;
        };
        _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
          _BasePlaylistControll.prototype.loadPlaylist.call(this);
          var currentTrack = this.currentTrack;
          if (this.shouldLoadPlaylist(currentTrack) && currentTrack) {
            var id = currentTrack.id;
            var groupId = currentTrack.groupId;
            var url2 = currentTrack.url;
            if (hlsUrlParameters) {
              try {
                url2 = hlsUrlParameters.addDirectives(url2);
              } catch (error2) {
                this.warn("Could not construct new URL with HLS Delivery Directives: " + error2);
              }
            }
            this.log("Loading subtitle playlist for id " + id);
            this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {
              url: url2,
              id,
              groupId,
              deliveryDirectives: hlsUrlParameters || null
            });
          }
        };
        _proto.toggleTrackModes = function toggleTrackModes() {
          var media = this.media;
          if (!media) {
            return;
          }
          var textTracks = filterSubtitleTracks(media.textTracks);
          var currentTrack = this.currentTrack;
          var nextTrack;
          if (currentTrack) {
            nextTrack = textTracks.filter(function(textTrack) {
              return subtitleTrackMatchesTextTrack(currentTrack, textTrack);
            })[0];
            if (!nextTrack) {
              this.warn('Unable to find subtitle TextTrack with name "' + currentTrack.name + '" and language "' + currentTrack.lang + '"');
            }
          }
          [].slice.call(textTracks).forEach(function(track) {
            if (track.mode !== "disabled" && track !== nextTrack) {
              track.mode = "disabled";
            }
          });
          if (nextTrack) {
            var mode = this.subtitleDisplay ? "showing" : "hidden";
            if (nextTrack.mode !== mode) {
              nextTrack.mode = mode;
            }
          }
        };
        _proto.setSubtitleTrack = function setSubtitleTrack(newId) {
          var tracks = this.tracksInGroup;
          if (!this.media) {
            this.queuedDefaultTrack = newId;
            return;
          }
          if (newId < -1 || newId >= tracks.length || !isFiniteNumber(newId)) {
            this.warn("Invalid subtitle track id: " + newId);
            return;
          }
          this.clearTimer();
          this.selectDefaultTrack = false;
          var lastTrack = this.currentTrack;
          var track = tracks[newId] || null;
          this.trackId = newId;
          this.currentTrack = track;
          this.toggleTrackModes();
          if (!track) {
            this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {
              id: newId
            });
            return;
          }
          var trackLoaded = !!track.details && !track.details.live;
          if (newId === this.trackId && track === lastTrack && trackLoaded) {
            return;
          }
          this.log("Switching to subtitle-track " + newId + (track ? ' "' + track.name + '" lang:' + track.lang + " group:" + track.groupId : ""));
          var { id, groupId: _track$groupId } = track, groupId = _track$groupId === undefined ? "" : _track$groupId, name = track.name, type = track.type, url2 = track.url;
          this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {
            id,
            groupId,
            name,
            type,
            url: url2
          });
          var hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? undefined : lastTrack.details, track.details);
          this.loadPlaylist(hlsUrlParameters);
        };
        _createClass(SubtitleTrackController2, [{
          key: "subtitleDisplay",
          get: function get() {
            return this._subtitleDisplay;
          },
          set: function set(value) {
            this._subtitleDisplay = value;
            if (this.trackId > -1) {
              this.toggleTrackModes();
            }
          }
        }, {
          key: "allSubtitleTracks",
          get: function get() {
            return this.tracks;
          }
        }, {
          key: "subtitleTracks",
          get: function get() {
            return this.tracksInGroup;
          }
        }, {
          key: "subtitleTrack",
          get: function get() {
            return this.trackId;
          },
          set: function set(newId) {
            this.selectDefaultTrack = false;
            this.setSubtitleTrack(newId);
          }
        }]);
        return SubtitleTrackController2;
      }(BasePlaylistController);
      var BufferOperationQueue = /* @__PURE__ */ function() {
        function BufferOperationQueue2(sourceBufferReference) {
          this.buffers = undefined;
          this.queues = {
            video: [],
            audio: [],
            audiovideo: []
          };
          this.buffers = sourceBufferReference;
        }
        var _proto = BufferOperationQueue2.prototype;
        _proto.append = function append(operation, type, pending) {
          var queue = this.queues[type];
          queue.push(operation);
          if (queue.length === 1 && !pending) {
            this.executeNext(type);
          }
        };
        _proto.insertAbort = function insertAbort(operation, type) {
          var queue = this.queues[type];
          queue.unshift(operation);
          this.executeNext(type);
        };
        _proto.appendBlocker = function appendBlocker(type) {
          var execute;
          var promise = new Promise(function(resolve) {
            execute = resolve;
          });
          var operation = {
            execute,
            onStart: function onStart() {
            },
            onComplete: function onComplete() {
            },
            onError: function onError() {
            }
          };
          this.append(operation, type);
          return promise;
        };
        _proto.executeNext = function executeNext(type) {
          var queue = this.queues[type];
          if (queue.length) {
            var operation = queue[0];
            try {
              operation.execute();
            } catch (error2) {
              logger.warn('[buffer-operation-queue]: Exception executing "' + type + '" SourceBuffer operation: ' + error2);
              operation.onError(error2);
              var sb = this.buffers[type];
              if (!(sb != null && sb.updating)) {
                this.shiftAndExecuteNext(type);
              }
            }
          }
        };
        _proto.shiftAndExecuteNext = function shiftAndExecuteNext(type) {
          this.queues[type].shift();
          this.executeNext(type);
        };
        _proto.current = function current(type) {
          return this.queues[type][0];
        };
        return BufferOperationQueue2;
      }();
      var VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\.[^.,]+)+/;
      var BufferController = /* @__PURE__ */ function() {
        function BufferController2(hls) {
          var _this = this;
          this.details = null;
          this._objectUrl = null;
          this.operationQueue = undefined;
          this.listeners = undefined;
          this.hls = undefined;
          this.bufferCodecEventsExpected = 0;
          this._bufferCodecEventsTotal = 0;
          this.media = null;
          this.mediaSource = null;
          this.lastMpegAudioChunk = null;
          this.appendSource = undefined;
          this.appendErrors = {
            audio: 0,
            video: 0,
            audiovideo: 0
          };
          this.tracks = {};
          this.pendingTracks = {};
          this.sourceBuffer = undefined;
          this.log = undefined;
          this.warn = undefined;
          this.error = undefined;
          this._onEndStreaming = function(event) {
            if (!_this.hls) {
              return;
            }
            _this.hls.pauseBuffering();
          };
          this._onStartStreaming = function(event) {
            if (!_this.hls) {
              return;
            }
            _this.hls.resumeBuffering();
          };
          this._onMediaSourceOpen = function() {
            var { media, mediaSource } = _this;
            _this.log("Media source opened");
            if (media) {
              media.removeEventListener("emptied", _this._onMediaEmptied);
              _this.updateMediaElementDuration();
              _this.hls.trigger(Events.MEDIA_ATTACHED, {
                media,
                mediaSource
              });
            }
            if (mediaSource) {
              mediaSource.removeEventListener("sourceopen", _this._onMediaSourceOpen);
            }
            _this.checkPendingTracks();
          };
          this._onMediaSourceClose = function() {
            _this.log("Media source closed");
          };
          this._onMediaSourceEnded = function() {
            _this.log("Media source ended");
          };
          this._onMediaEmptied = function() {
            var { mediaSrc, _objectUrl } = _this;
            if (mediaSrc !== _objectUrl) {
              logger.error("Media element src was set while attaching MediaSource (" + _objectUrl + " > " + mediaSrc + ")");
            }
          };
          this.hls = hls;
          var logPrefix = "[buffer-controller]";
          this.appendSource = isManagedMediaSource(getMediaSource(hls.config.preferManagedMediaSource));
          this.log = logger.log.bind(logger, logPrefix);
          this.warn = logger.warn.bind(logger, logPrefix);
          this.error = logger.error.bind(logger, logPrefix);
          this._initSourceBuffer();
          this.registerListeners();
        }
        var _proto = BufferController2.prototype;
        _proto.hasSourceTypes = function hasSourceTypes() {
          return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;
        };
        _proto.destroy = function destroy() {
          this.unregisterListeners();
          this.details = null;
          this.lastMpegAudioChunk = null;
          this.hls = null;
        };
        _proto.registerListeners = function registerListeners() {
          var hls = this.hls;
          hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
          hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
          hls.on(Events.BUFFER_RESET, this.onBufferReset, this);
          hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);
          hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
          hls.on(Events.BUFFER_EOS, this.onBufferEos, this);
          hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
          hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
          hls.on(Events.FRAG_PARSED, this.onFragParsed, this);
          hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);
        };
        _proto.unregisterListeners = function unregisterListeners() {
          var hls = this.hls;
          hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
          hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
          hls.off(Events.BUFFER_RESET, this.onBufferReset, this);
          hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);
          hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
          hls.off(Events.BUFFER_EOS, this.onBufferEos, this);
          hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
          hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);
          hls.off(Events.FRAG_PARSED, this.onFragParsed, this);
          hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);
        };
        _proto._initSourceBuffer = function _initSourceBuffer() {
          this.sourceBuffer = {};
          this.operationQueue = new BufferOperationQueue(this.sourceBuffer);
          this.listeners = {
            audio: [],
            video: [],
            audiovideo: []
          };
          this.appendErrors = {
            audio: 0,
            video: 0,
            audiovideo: 0
          };
          this.lastMpegAudioChunk = null;
        };
        _proto.onManifestLoading = function onManifestLoading() {
          this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;
          this.details = null;
        };
        _proto.onManifestParsed = function onManifestParsed(event, data) {
          var codecEvents = 2;
          if (data.audio && !data.video || !data.altAudio || false) {
            codecEvents = 1;
          }
          this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;
          this.log(this.bufferCodecEventsExpected + " bufferCodec event(s) expected");
        };
        _proto.onMediaAttaching = function onMediaAttaching(event, data) {
          var media = this.media = data.media;
          var MediaSource = getMediaSource(this.appendSource);
          if (media && MediaSource) {
            var _ms$constructor;
            var ms = this.mediaSource = new MediaSource;
            this.log("created media source: " + ((_ms$constructor = ms.constructor) == null ? undefined : _ms$constructor.name));
            ms.addEventListener("sourceopen", this._onMediaSourceOpen);
            ms.addEventListener("sourceended", this._onMediaSourceEnded);
            ms.addEventListener("sourceclose", this._onMediaSourceClose);
            if (this.appendSource) {
              ms.addEventListener("startstreaming", this._onStartStreaming);
              ms.addEventListener("endstreaming", this._onEndStreaming);
            }
            var objectUrl = this._objectUrl = self.URL.createObjectURL(ms);
            if (this.appendSource) {
              try {
                media.removeAttribute("src");
                var MMS = self.ManagedMediaSource;
                media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;
                removeSourceChildren(media);
                addSource(media, objectUrl);
                media.load();
              } catch (error2) {
                media.src = objectUrl;
              }
            } else {
              media.src = objectUrl;
            }
            media.addEventListener("emptied", this._onMediaEmptied);
          }
        };
        _proto.onMediaDetaching = function onMediaDetaching() {
          var media = this.media, mediaSource = this.mediaSource, _objectUrl = this._objectUrl;
          if (mediaSource) {
            this.log("media source detaching");
            if (mediaSource.readyState === "open") {
              try {
                mediaSource.endOfStream();
              } catch (err) {
                this.warn("onMediaDetaching: " + err.message + " while calling endOfStream");
              }
            }
            this.onBufferReset();
            mediaSource.removeEventListener("sourceopen", this._onMediaSourceOpen);
            mediaSource.removeEventListener("sourceended", this._onMediaSourceEnded);
            mediaSource.removeEventListener("sourceclose", this._onMediaSourceClose);
            if (this.appendSource) {
              mediaSource.removeEventListener("startstreaming", this._onStartStreaming);
              mediaSource.removeEventListener("endstreaming", this._onEndStreaming);
            }
            if (media) {
              media.removeEventListener("emptied", this._onMediaEmptied);
              if (_objectUrl) {
                self.URL.revokeObjectURL(_objectUrl);
              }
              if (this.mediaSrc === _objectUrl) {
                media.removeAttribute("src");
                if (this.appendSource) {
                  removeSourceChildren(media);
                }
                media.load();
              } else {
                this.warn("media|source.src was changed by a third party - skip cleanup");
              }
            }
            this.mediaSource = null;
            this.media = null;
            this._objectUrl = null;
            this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;
            this.pendingTracks = {};
            this.tracks = {};
          }
          this.hls.trigger(Events.MEDIA_DETACHED, undefined);
        };
        _proto.onBufferReset = function onBufferReset() {
          var _this2 = this;
          this.getSourceBufferTypes().forEach(function(type) {
            _this2.resetBuffer(type);
          });
          this._initSourceBuffer();
          this.hls.resumeBuffering();
        };
        _proto.resetBuffer = function resetBuffer(type) {
          var sb = this.sourceBuffer[type];
          try {
            if (sb) {
              var _this$mediaSource;
              this.removeBufferListeners(type);
              this.sourceBuffer[type] = undefined;
              if ((_this$mediaSource = this.mediaSource) != null && _this$mediaSource.sourceBuffers.length) {
                this.mediaSource.removeSourceBuffer(sb);
              }
            }
          } catch (err) {
            this.warn("onBufferReset " + type, err);
          }
        };
        _proto.onBufferCodecs = function onBufferCodecs(event, data) {
          var _this3 = this;
          var sourceBufferCount = this.getSourceBufferTypes().length;
          var trackNames = Object.keys(data);
          trackNames.forEach(function(trackName) {
            if (sourceBufferCount) {
              var track = _this3.tracks[trackName];
              if (track && typeof track.buffer.changeType === "function") {
                var _trackCodec;
                var _data$trackName = data[trackName], id = _data$trackName.id, codec = _data$trackName.codec, levelCodec = _data$trackName.levelCodec, container = _data$trackName.container, metadata = _data$trackName.metadata;
                var currentCodecFull = pickMostCompleteCodecName(track.codec, track.levelCodec);
                var currentCodec = currentCodecFull == null ? undefined : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, "$1");
                var trackCodec = pickMostCompleteCodecName(codec, levelCodec);
                var nextCodec = (_trackCodec = trackCodec) == null ? undefined : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, "$1");
                if (trackCodec && currentCodec !== nextCodec) {
                  if (trackName.slice(0, 5) === "audio") {
                    trackCodec = getCodecCompatibleName(trackCodec, _this3.appendSource);
                  }
                  var mimeType = container + ";codecs=" + trackCodec;
                  _this3.appendChangeType(trackName, mimeType);
                  _this3.log("switching codec " + currentCodecFull + " to " + trackCodec);
                  _this3.tracks[trackName] = {
                    buffer: track.buffer,
                    codec,
                    container,
                    levelCodec,
                    metadata,
                    id
                  };
                }
              }
            } else {
              _this3.pendingTracks[trackName] = data[trackName];
            }
          });
          if (sourceBufferCount) {
            return;
          }
          var bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);
          if (this.bufferCodecEventsExpected !== bufferCodecEventsExpected) {
            this.log(bufferCodecEventsExpected + " bufferCodec event(s) expected " + trackNames.join(","));
            this.bufferCodecEventsExpected = bufferCodecEventsExpected;
          }
          if (this.mediaSource && this.mediaSource.readyState === "open") {
            this.checkPendingTracks();
          }
        };
        _proto.appendChangeType = function appendChangeType(type, mimeType) {
          var _this4 = this;
          var operationQueue = this.operationQueue;
          var operation = {
            execute: function execute() {
              var sb = _this4.sourceBuffer[type];
              if (sb) {
                _this4.log("changing " + type + " sourceBuffer type to " + mimeType);
                sb.changeType(mimeType);
              }
              operationQueue.shiftAndExecuteNext(type);
            },
            onStart: function onStart() {
            },
            onComplete: function onComplete() {
            },
            onError: function onError(error2) {
              _this4.warn("Failed to change " + type + " SourceBuffer type", error2);
            }
          };
          operationQueue.append(operation, type, !!this.pendingTracks[type]);
        };
        _proto.onBufferAppending = function onBufferAppending(event, eventData) {
          var _this5 = this;
          var hls = this.hls, operationQueue = this.operationQueue, tracks = this.tracks;
          var { data, type, frag, part, chunkMeta } = eventData;
          var chunkStats = chunkMeta.buffering[type];
          var bufferAppendingStart = self.performance.now();
          chunkStats.start = bufferAppendingStart;
          var fragBuffering = frag.stats.buffering;
          var partBuffering = part ? part.stats.buffering : null;
          if (fragBuffering.start === 0) {
            fragBuffering.start = bufferAppendingStart;
          }
          if (partBuffering && partBuffering.start === 0) {
            partBuffering.start = bufferAppendingStart;
          }
          var audioTrack = tracks.audio;
          var checkTimestampOffset = false;
          if (type === "audio" && (audioTrack == null ? undefined : audioTrack.container) === "audio/mpeg") {
            checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;
            this.lastMpegAudioChunk = chunkMeta;
          }
          var fragStart = frag.start;
          var operation = {
            execute: function execute() {
              chunkStats.executeStart = self.performance.now();
              if (checkTimestampOffset) {
                var sb = _this5.sourceBuffer[type];
                if (sb) {
                  var delta = fragStart - sb.timestampOffset;
                  if (Math.abs(delta) >= 0.1) {
                    _this5.log("Updating audio SourceBuffer timestampOffset to " + fragStart + " (delta: " + delta + ") sn: " + frag.sn + ")");
                    sb.timestampOffset = fragStart;
                  }
                }
              }
              _this5.appendExecutor(data, type);
            },
            onStart: function onStart() {
            },
            onComplete: function onComplete() {
              var end = self.performance.now();
              chunkStats.executeEnd = chunkStats.end = end;
              if (fragBuffering.first === 0) {
                fragBuffering.first = end;
              }
              if (partBuffering && partBuffering.first === 0) {
                partBuffering.first = end;
              }
              var sourceBuffer = _this5.sourceBuffer;
              var timeRanges = {};
              for (var _type in sourceBuffer) {
                timeRanges[_type] = BufferHelper.getBuffered(sourceBuffer[_type]);
              }
              _this5.appendErrors[type] = 0;
              if (type === "audio" || type === "video") {
                _this5.appendErrors.audiovideo = 0;
              } else {
                _this5.appendErrors.audio = 0;
                _this5.appendErrors.video = 0;
              }
              _this5.hls.trigger(Events.BUFFER_APPENDED, {
                type,
                frag,
                part,
                chunkMeta,
                parent: frag.type,
                timeRanges
              });
            },
            onError: function onError(error2) {
              var event2 = {
                type: ErrorTypes2.MEDIA_ERROR,
                parent: frag.type,
                details: ErrorDetails.BUFFER_APPEND_ERROR,
                sourceBufferName: type,
                frag,
                part,
                chunkMeta,
                error: error2,
                err: error2,
                fatal: false
              };
              if (error2.code === DOMException.QUOTA_EXCEEDED_ERR) {
                event2.details = ErrorDetails.BUFFER_FULL_ERROR;
              } else {
                var appendErrorCount = ++_this5.appendErrors[type];
                event2.details = ErrorDetails.BUFFER_APPEND_ERROR;
                _this5.warn("Failed " + appendErrorCount + "/" + hls.config.appendErrorMaxRetry + ' times to append segment in "' + type + '" sourceBuffer');
                if (appendErrorCount >= hls.config.appendErrorMaxRetry) {
                  event2.fatal = true;
                }
              }
              hls.trigger(Events.ERROR, event2);
            }
          };
          operationQueue.append(operation, type, !!this.pendingTracks[type]);
        };
        _proto.onBufferFlushing = function onBufferFlushing(event, data) {
          var _this6 = this;
          var operationQueue = this.operationQueue;
          var flushOperation = function flushOperation(type) {
            return {
              execute: _this6.removeExecutor.bind(_this6, type, data.startOffset, data.endOffset),
              onStart: function onStart() {
              },
              onComplete: function onComplete() {
                _this6.hls.trigger(Events.BUFFER_FLUSHED, {
                  type
                });
              },
              onError: function onError(error2) {
                _this6.warn("Failed to remove from " + type + " SourceBuffer", error2);
              }
            };
          };
          if (data.type) {
            operationQueue.append(flushOperation(data.type), data.type);
          } else {
            this.getSourceBufferTypes().forEach(function(type) {
              operationQueue.append(flushOperation(type), type);
            });
          }
        };
        _proto.onFragParsed = function onFragParsed(event, data) {
          var _this7 = this;
          var { frag, part } = data;
          var buffersAppendedTo = [];
          var elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;
          if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {
            buffersAppendedTo.push("audiovideo");
          } else {
            if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {
              buffersAppendedTo.push("audio");
            }
            if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {
              buffersAppendedTo.push("video");
            }
          }
          var onUnblocked = function onUnblocked() {
            var now2 = self.performance.now();
            frag.stats.buffering.end = now2;
            if (part) {
              part.stats.buffering.end = now2;
            }
            var stats = part ? part.stats : frag.stats;
            _this7.hls.trigger(Events.FRAG_BUFFERED, {
              frag,
              part,
              stats,
              id: frag.type
            });
          };
          if (buffersAppendedTo.length === 0) {
            this.warn("Fragments must have at least one ElementaryStreamType set. type: " + frag.type + " level: " + frag.level + " sn: " + frag.sn);
          }
          this.blockBuffers(onUnblocked, buffersAppendedTo);
        };
        _proto.onFragChanged = function onFragChanged(event, data) {
          this.trimBuffers();
        };
        _proto.onBufferEos = function onBufferEos(event, data) {
          var _this8 = this;
          var ended = this.getSourceBufferTypes().reduce(function(acc, type) {
            var sb = _this8.sourceBuffer[type];
            if (sb && (!data.type || data.type === type)) {
              sb.ending = true;
              if (!sb.ended) {
                sb.ended = true;
                _this8.log(type + " sourceBuffer now EOS");
              }
            }
            return acc && !!(!sb || sb.ended);
          }, true);
          if (ended) {
            this.log("Queueing mediaSource.endOfStream()");
            this.blockBuffers(function() {
              _this8.getSourceBufferTypes().forEach(function(type) {
                var sb = _this8.sourceBuffer[type];
                if (sb) {
                  sb.ending = false;
                }
              });
              var mediaSource = _this8.mediaSource;
              if (!mediaSource || mediaSource.readyState !== "open") {
                if (mediaSource) {
                  _this8.log("Could not call mediaSource.endOfStream(). mediaSource.readyState: " + mediaSource.readyState);
                }
                return;
              }
              _this8.log("Calling mediaSource.endOfStream()");
              mediaSource.endOfStream();
            });
          }
        };
        _proto.onLevelUpdated = function onLevelUpdated(event, _ref) {
          var details = _ref.details;
          if (!details.fragments.length) {
            return;
          }
          this.details = details;
          if (this.getSourceBufferTypes().length) {
            this.blockBuffers(this.updateMediaElementDuration.bind(this));
          } else {
            this.updateMediaElementDuration();
          }
        };
        _proto.trimBuffers = function trimBuffers() {
          var hls = this.hls, details = this.details, media = this.media;
          if (!media || details === null) {
            return;
          }
          var sourceBufferTypes = this.getSourceBufferTypes();
          if (!sourceBufferTypes.length) {
            return;
          }
          var config = hls.config;
          var currentTime = media.currentTime;
          var targetDuration = details.levelTargetDuration;
          var backBufferLength = details.live && config.liveBackBufferLength !== null ? config.liveBackBufferLength : config.backBufferLength;
          if (isFiniteNumber(backBufferLength) && backBufferLength > 0) {
            var maxBackBufferLength = Math.max(backBufferLength, targetDuration);
            var targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;
            this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);
          }
          if (isFiniteNumber(config.frontBufferFlushThreshold) && config.frontBufferFlushThreshold > 0) {
            var frontBufferLength = Math.max(config.maxBufferLength, config.frontBufferFlushThreshold);
            var maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);
            var targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;
            this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);
          }
        };
        _proto.flushBackBuffer = function flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {
          var _this9 = this;
          var details = this.details, sourceBuffer = this.sourceBuffer;
          var sourceBufferTypes = this.getSourceBufferTypes();
          sourceBufferTypes.forEach(function(type) {
            var sb = sourceBuffer[type];
            if (sb) {
              var buffered = BufferHelper.getBuffered(sb);
              if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {
                _this9.hls.trigger(Events.BACK_BUFFER_REACHED, {
                  bufferEnd: targetBackBufferPosition
                });
                if (details != null && details.live) {
                  _this9.hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {
                    bufferEnd: targetBackBufferPosition
                  });
                } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {
                  _this9.log("Cannot flush " + type + " back buffer while SourceBuffer is in ended state");
                  return;
                }
                _this9.hls.trigger(Events.BUFFER_FLUSHING, {
                  startOffset: 0,
                  endOffset: targetBackBufferPosition,
                  type
                });
              }
            }
          });
        };
        _proto.flushFrontBuffer = function flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {
          var _this10 = this;
          var sourceBuffer = this.sourceBuffer;
          var sourceBufferTypes = this.getSourceBufferTypes();
          sourceBufferTypes.forEach(function(type) {
            var sb = sourceBuffer[type];
            if (sb) {
              var buffered = BufferHelper.getBuffered(sb);
              var numBufferedRanges = buffered.length;
              if (numBufferedRanges < 2) {
                return;
              }
              var bufferStart = buffered.start(numBufferedRanges - 1);
              var bufferEnd = buffered.end(numBufferedRanges - 1);
              if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {
                return;
              } else if (sb.ended && currentTime - bufferEnd < 2 * targetDuration) {
                _this10.log("Cannot flush " + type + " front buffer while SourceBuffer is in ended state");
                return;
              }
              _this10.hls.trigger(Events.BUFFER_FLUSHING, {
                startOffset: bufferStart,
                endOffset: Infinity,
                type
              });
            }
          });
        };
        _proto.updateMediaElementDuration = function updateMediaElementDuration() {
          if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== "open") {
            return;
          }
          var details = this.details, hls = this.hls, media = this.media, mediaSource = this.mediaSource;
          var levelDuration = details.fragments[0].start + details.totalduration;
          var mediaDuration = media.duration;
          var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;
          if (details.live && hls.config.liveDurationInfinity) {
            mediaSource.duration = Infinity;
            this.updateSeekableRange(details);
          } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {
            this.log("Updating Media Source duration to " + levelDuration.toFixed(3));
            mediaSource.duration = levelDuration;
          }
        };
        _proto.updateSeekableRange = function updateSeekableRange(levelDetails) {
          var mediaSource = this.mediaSource;
          var fragments = levelDetails.fragments;
          var len = fragments.length;
          if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {
            var start = Math.max(0, fragments[0].start);
            var end = Math.max(start, start + levelDetails.totalduration);
            this.log("Media Source duration is set to " + mediaSource.duration + ". Setting seekable range to " + start + "-" + end + ".");
            mediaSource.setLiveSeekableRange(start, end);
          }
        };
        _proto.checkPendingTracks = function checkPendingTracks() {
          var bufferCodecEventsExpected = this.bufferCodecEventsExpected, operationQueue = this.operationQueue, pendingTracks = this.pendingTracks;
          var pendingTracksCount = Object.keys(pendingTracks).length;
          if (pendingTracksCount && (!bufferCodecEventsExpected || pendingTracksCount === 2 || ("audiovideo" in pendingTracks))) {
            this.createSourceBuffers(pendingTracks);
            this.pendingTracks = {};
            var buffers = this.getSourceBufferTypes();
            if (buffers.length) {
              this.hls.trigger(Events.BUFFER_CREATED, {
                tracks: this.tracks
              });
              buffers.forEach(function(type) {
                operationQueue.executeNext(type);
              });
            } else {
              var error2 = new Error("could not create source buffer for media codec(s)");
              this.hls.trigger(Events.ERROR, {
                type: ErrorTypes2.MEDIA_ERROR,
                details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,
                fatal: true,
                error: error2,
                reason: error2.message
              });
            }
          }
        };
        _proto.createSourceBuffers = function createSourceBuffers(tracks) {
          var _this11 = this;
          var sourceBuffer = this.sourceBuffer, mediaSource = this.mediaSource;
          if (!mediaSource) {
            throw Error("createSourceBuffers called when mediaSource was null");
          }
          var _loop = function _loop(trackName2) {
            if (!sourceBuffer[trackName2]) {
              var _track$levelCodec;
              var track = tracks[trackName2];
              if (!track) {
                throw Error("source buffer exists for track " + trackName2 + ", however track does not");
              }
              var codec = ((_track$levelCodec = track.levelCodec) == null ? undefined : _track$levelCodec.indexOf(",")) === -1 ? track.levelCodec : track.codec;
              if (codec) {
                if (trackName2.slice(0, 5) === "audio") {
                  codec = getCodecCompatibleName(codec, _this11.appendSource);
                }
              }
              var mimeType = track.container + ";codecs=" + codec;
              _this11.log("creating sourceBuffer(" + mimeType + ")");
              try {
                var sb = sourceBuffer[trackName2] = mediaSource.addSourceBuffer(mimeType);
                var sbName = trackName2;
                _this11.addBufferListener(sbName, "updatestart", _this11._onSBUpdateStart);
                _this11.addBufferListener(sbName, "updateend", _this11._onSBUpdateEnd);
                _this11.addBufferListener(sbName, "error", _this11._onSBUpdateError);
                if (_this11.appendSource) {
                  _this11.addBufferListener(sbName, "bufferedchange", function(type, event) {
                    var removedRanges = event.removedRanges;
                    if (removedRanges != null && removedRanges.length) {
                      _this11.hls.trigger(Events.BUFFER_FLUSHED, {
                        type: trackName2
                      });
                    }
                  });
                }
                _this11.tracks[trackName2] = {
                  buffer: sb,
                  codec,
                  container: track.container,
                  levelCodec: track.levelCodec,
                  metadata: track.metadata,
                  id: track.id
                };
              } catch (err) {
                _this11.error("error while trying to add sourceBuffer: " + err.message);
                _this11.hls.trigger(Events.ERROR, {
                  type: ErrorTypes2.MEDIA_ERROR,
                  details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,
                  fatal: false,
                  error: err,
                  sourceBufferName: trackName2,
                  mimeType
                });
              }
            }
          };
          for (var trackName in tracks) {
            _loop(trackName);
          }
        };
        _proto._onSBUpdateStart = function _onSBUpdateStart(type) {
          var operationQueue = this.operationQueue;
          var operation = operationQueue.current(type);
          operation.onStart();
        };
        _proto._onSBUpdateEnd = function _onSBUpdateEnd(type) {
          var _this$mediaSource2;
          if (((_this$mediaSource2 = this.mediaSource) == null ? undefined : _this$mediaSource2.readyState) === "closed") {
            this.resetBuffer(type);
            return;
          }
          var operationQueue = this.operationQueue;
          var operation = operationQueue.current(type);
          operation.onComplete();
          operationQueue.shiftAndExecuteNext(type);
        };
        _proto._onSBUpdateError = function _onSBUpdateError(type, event) {
          var _this$mediaSource3;
          var error2 = new Error(type + " SourceBuffer error. MediaSource readyState: " + ((_this$mediaSource3 = this.mediaSource) == null ? undefined : _this$mediaSource3.readyState));
          this.error("" + error2, event);
          this.hls.trigger(Events.ERROR, {
            type: ErrorTypes2.MEDIA_ERROR,
            details: ErrorDetails.BUFFER_APPENDING_ERROR,
            sourceBufferName: type,
            error: error2,
            fatal: false
          });
          var operation = this.operationQueue.current(type);
          if (operation) {
            operation.onError(error2);
          }
        };
        _proto.removeExecutor = function removeExecutor(type, startOffset, endOffset) {
          var media = this.media, mediaSource = this.mediaSource, operationQueue = this.operationQueue, sourceBuffer = this.sourceBuffer;
          var sb = sourceBuffer[type];
          if (!media || !mediaSource || !sb) {
            this.warn("Attempting to remove from the " + type + " SourceBuffer, but it does not exist");
            operationQueue.shiftAndExecuteNext(type);
            return;
          }
          var mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;
          var msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;
          var removeStart = Math.max(0, startOffset);
          var removeEnd = Math.min(endOffset, mediaDuration, msDuration);
          if (removeEnd > removeStart && (!sb.ending || sb.ended)) {
            sb.ended = false;
            this.log("Removing [" + removeStart + "," + removeEnd + "] from the " + type + " SourceBuffer");
            sb.remove(removeStart, removeEnd);
          } else {
            operationQueue.shiftAndExecuteNext(type);
          }
        };
        _proto.appendExecutor = function appendExecutor(data, type) {
          var sb = this.sourceBuffer[type];
          if (!sb) {
            if (!this.pendingTracks[type]) {
              throw new Error("Attempting to append to the " + type + " SourceBuffer, but it does not exist");
            }
            return;
          }
          sb.ended = false;
          sb.appendBuffer(data);
        };
        _proto.blockBuffers = function blockBuffers(onUnblocked, buffers) {
          var _this12 = this;
          if (buffers === undefined) {
            buffers = this.getSourceBufferTypes();
          }
          if (!buffers.length) {
            this.log("Blocking operation requested, but no SourceBuffers exist");
            Promise.resolve().then(onUnblocked);
            return;
          }
          var operationQueue = this.operationQueue;
          var blockingOperations = buffers.map(function(type) {
            return operationQueue.appendBlocker(type);
          });
          Promise.all(blockingOperations).then(function() {
            onUnblocked();
            buffers.forEach(function(type) {
              var sb = _this12.sourceBuffer[type];
              if (!(sb != null && sb.updating)) {
                operationQueue.shiftAndExecuteNext(type);
              }
            });
          });
        };
        _proto.getSourceBufferTypes = function getSourceBufferTypes() {
          return Object.keys(this.sourceBuffer);
        };
        _proto.addBufferListener = function addBufferListener(type, event, fn) {
          var buffer = this.sourceBuffer[type];
          if (!buffer) {
            return;
          }
          var listener = fn.bind(this, type);
          this.listeners[type].push({
            event,
            listener
          });
          buffer.addEventListener(event, listener);
        };
        _proto.removeBufferListeners = function removeBufferListeners(type) {
          var buffer = this.sourceBuffer[type];
          if (!buffer) {
            return;
          }
          this.listeners[type].forEach(function(l) {
            buffer.removeEventListener(l.event, l.listener);
          });
        };
        _createClass(BufferController2, [{
          key: "mediaSrc",
          get: function get() {
            var _this$media, _this$media$querySele;
            var media = ((_this$media = this.media) == null ? undefined : (_this$media$querySele = _this$media.querySelector) == null ? undefined : _this$media$querySele.call(_this$media, "source")) || this.media;
            return media == null ? undefined : media.src;
          }
        }]);
        return BufferController2;
      }();
      function removeSourceChildren(node) {
        var sourceChildren = node.querySelectorAll("source");
        [].slice.call(sourceChildren).forEach(function(source) {
          node.removeChild(source);
        });
      }
      function addSource(media, url2) {
        var source = self.document.createElement("source");
        source.type = "video/mp4";
        source.src = url2;
        media.appendChild(source);
      }
      var specialCea608CharsCodes = {
        42: 225,
        92: 233,
        94: 237,
        95: 243,
        96: 250,
        123: 231,
        124: 247,
        125: 209,
        126: 241,
        127: 9608,
        128: 174,
        129: 176,
        130: 189,
        131: 191,
        132: 8482,
        133: 162,
        134: 163,
        135: 9834,
        136: 224,
        137: 32,
        138: 232,
        139: 226,
        140: 234,
        141: 238,
        142: 244,
        143: 251,
        144: 193,
        145: 201,
        146: 211,
        147: 218,
        148: 220,
        149: 252,
        150: 8216,
        151: 161,
        152: 42,
        153: 8217,
        154: 9473,
        155: 169,
        156: 8480,
        157: 8226,
        158: 8220,
        159: 8221,
        160: 192,
        161: 194,
        162: 199,
        163: 200,
        164: 202,
        165: 203,
        166: 235,
        167: 206,
        168: 207,
        169: 239,
        170: 212,
        171: 217,
        172: 249,
        173: 219,
        174: 171,
        175: 187,
        176: 195,
        177: 227,
        178: 205,
        179: 204,
        180: 236,
        181: 210,
        182: 242,
        183: 213,
        184: 245,
        185: 123,
        186: 125,
        187: 92,
        188: 94,
        189: 95,
        190: 124,
        191: 8764,
        192: 196,
        193: 228,
        194: 214,
        195: 246,
        196: 223,
        197: 165,
        198: 164,
        199: 9475,
        200: 197,
        201: 229,
        202: 216,
        203: 248,
        204: 9487,
        205: 9491,
        206: 9495,
        207: 9499
      };
      var getCharForByte = function getCharForByte(_byte) {
        return String.fromCharCode(specialCea608CharsCodes[_byte] || _byte);
      };
      var NR_ROWS = 15;
      var NR_COLS = 100;
      var rowsLowCh1 = {
        17: 1,
        18: 3,
        21: 5,
        22: 7,
        23: 9,
        16: 11,
        19: 12,
        20: 14
      };
      var rowsHighCh1 = {
        17: 2,
        18: 4,
        21: 6,
        22: 8,
        23: 10,
        19: 13,
        20: 15
      };
      var rowsLowCh2 = {
        25: 1,
        26: 3,
        29: 5,
        30: 7,
        31: 9,
        24: 11,
        27: 12,
        28: 14
      };
      var rowsHighCh2 = {
        25: 2,
        26: 4,
        29: 6,
        30: 8,
        31: 10,
        27: 13,
        28: 15
      };
      var backgroundColors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
      var CaptionsLogger = /* @__PURE__ */ function() {
        function CaptionsLogger2() {
          this.time = null;
          this.verboseLevel = 0;
        }
        var _proto = CaptionsLogger2.prototype;
        _proto.log = function log(severity, msg) {
          if (this.verboseLevel >= severity) {
            var m = typeof msg === "function" ? msg() : msg;
            logger.log(this.time + " [" + severity + "] " + m);
          }
        };
        return CaptionsLogger2;
      }();
      var numArrayToHexArray = function numArrayToHexArray(numArray) {
        var hexArray = [];
        for (var j = 0;j < numArray.length; j++) {
          hexArray.push(numArray[j].toString(16));
        }
        return hexArray;
      };
      var PenState = /* @__PURE__ */ function() {
        function PenState2() {
          this.foreground = "white";
          this.underline = false;
          this.italics = false;
          this.background = "black";
          this.flash = false;
        }
        var _proto2 = PenState2.prototype;
        _proto2.reset = function reset() {
          this.foreground = "white";
          this.underline = false;
          this.italics = false;
          this.background = "black";
          this.flash = false;
        };
        _proto2.setStyles = function setStyles(styles) {
          var attribs = ["foreground", "underline", "italics", "background", "flash"];
          for (var i = 0;i < attribs.length; i++) {
            var style = attribs[i];
            if (styles.hasOwnProperty(style)) {
              this[style] = styles[style];
            }
          }
        };
        _proto2.isDefault = function isDefault() {
          return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
        };
        _proto2.equals = function equals(other) {
          return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;
        };
        _proto2.copy = function copy(newPenState) {
          this.foreground = newPenState.foreground;
          this.underline = newPenState.underline;
          this.italics = newPenState.italics;
          this.background = newPenState.background;
          this.flash = newPenState.flash;
        };
        _proto2.toString = function toString() {
          return "color=" + this.foreground + ", underline=" + this.underline + ", italics=" + this.italics + ", background=" + this.background + ", flash=" + this.flash;
        };
        return PenState2;
      }();
      var StyledUnicodeChar = /* @__PURE__ */ function() {
        function StyledUnicodeChar2() {
          this.uchar = " ";
          this.penState = new PenState;
        }
        var _proto3 = StyledUnicodeChar2.prototype;
        _proto3.reset = function reset() {
          this.uchar = " ";
          this.penState.reset();
        };
        _proto3.setChar = function setChar(uchar, newPenState) {
          this.uchar = uchar;
          this.penState.copy(newPenState);
        };
        _proto3.setPenState = function setPenState(newPenState) {
          this.penState.copy(newPenState);
        };
        _proto3.equals = function equals(other) {
          return this.uchar === other.uchar && this.penState.equals(other.penState);
        };
        _proto3.copy = function copy(newChar) {
          this.uchar = newChar.uchar;
          this.penState.copy(newChar.penState);
        };
        _proto3.isEmpty = function isEmpty() {
          return this.uchar === " " && this.penState.isDefault();
        };
        return StyledUnicodeChar2;
      }();
      var Row = /* @__PURE__ */ function() {
        function Row2(logger2) {
          this.chars = [];
          this.pos = 0;
          this.currPenState = new PenState;
          this.cueStartTime = null;
          this.logger = undefined;
          for (var i = 0;i < NR_COLS; i++) {
            this.chars.push(new StyledUnicodeChar);
          }
          this.logger = logger2;
        }
        var _proto4 = Row2.prototype;
        _proto4.equals = function equals(other) {
          for (var i = 0;i < NR_COLS; i++) {
            if (!this.chars[i].equals(other.chars[i])) {
              return false;
            }
          }
          return true;
        };
        _proto4.copy = function copy(other) {
          for (var i = 0;i < NR_COLS; i++) {
            this.chars[i].copy(other.chars[i]);
          }
        };
        _proto4.isEmpty = function isEmpty() {
          var empty = true;
          for (var i = 0;i < NR_COLS; i++) {
            if (!this.chars[i].isEmpty()) {
              empty = false;
              break;
            }
          }
          return empty;
        };
        _proto4.setCursor = function setCursor(absPos) {
          if (this.pos !== absPos) {
            this.pos = absPos;
          }
          if (this.pos < 0) {
            this.logger.log(3, "Negative cursor position " + this.pos);
            this.pos = 0;
          } else if (this.pos > NR_COLS) {
            this.logger.log(3, "Too large cursor position " + this.pos);
            this.pos = NR_COLS;
          }
        };
        _proto4.moveCursor = function moveCursor(relPos) {
          var newPos = this.pos + relPos;
          if (relPos > 1) {
            for (var i = this.pos + 1;i < newPos + 1; i++) {
              this.chars[i].setPenState(this.currPenState);
            }
          }
          this.setCursor(newPos);
        };
        _proto4.backSpace = function backSpace() {
          this.moveCursor(-1);
          this.chars[this.pos].setChar(" ", this.currPenState);
        };
        _proto4.insertChar = function insertChar(_byte2) {
          var _this = this;
          if (_byte2 >= 144) {
            this.backSpace();
          }
          var _char = getCharForByte(_byte2);
          if (this.pos >= NR_COLS) {
            this.logger.log(0, function() {
              return "Cannot insert " + _byte2.toString(16) + " (" + _char + ") at position " + _this.pos + ". Skipping it!";
            });
            return;
          }
          this.chars[this.pos].setChar(_char, this.currPenState);
          this.moveCursor(1);
        };
        _proto4.clearFromPos = function clearFromPos(startPos) {
          var i;
          for (i = startPos;i < NR_COLS; i++) {
            this.chars[i].reset();
          }
        };
        _proto4.clear = function clear() {
          this.clearFromPos(0);
          this.pos = 0;
          this.currPenState.reset();
        };
        _proto4.clearToEndOfRow = function clearToEndOfRow() {
          this.clearFromPos(this.pos);
        };
        _proto4.getTextString = function getTextString() {
          var chars = [];
          var empty = true;
          for (var i = 0;i < NR_COLS; i++) {
            var _char2 = this.chars[i].uchar;
            if (_char2 !== " ") {
              empty = false;
            }
            chars.push(_char2);
          }
          if (empty) {
            return "";
          } else {
            return chars.join("");
          }
        };
        _proto4.setPenStyles = function setPenStyles(styles) {
          this.currPenState.setStyles(styles);
          var currChar = this.chars[this.pos];
          currChar.setPenState(this.currPenState);
        };
        return Row2;
      }();
      var CaptionScreen = /* @__PURE__ */ function() {
        function CaptionScreen2(logger2) {
          this.rows = [];
          this.currRow = NR_ROWS - 1;
          this.nrRollUpRows = null;
          this.lastOutputScreen = null;
          this.logger = undefined;
          for (var i = 0;i < NR_ROWS; i++) {
            this.rows.push(new Row(logger2));
          }
          this.logger = logger2;
        }
        var _proto5 = CaptionScreen2.prototype;
        _proto5.reset = function reset() {
          for (var i = 0;i < NR_ROWS; i++) {
            this.rows[i].clear();
          }
          this.currRow = NR_ROWS - 1;
        };
        _proto5.equals = function equals(other) {
          var equal = true;
          for (var i = 0;i < NR_ROWS; i++) {
            if (!this.rows[i].equals(other.rows[i])) {
              equal = false;
              break;
            }
          }
          return equal;
        };
        _proto5.copy = function copy(other) {
          for (var i = 0;i < NR_ROWS; i++) {
            this.rows[i].copy(other.rows[i]);
          }
        };
        _proto5.isEmpty = function isEmpty() {
          var empty = true;
          for (var i = 0;i < NR_ROWS; i++) {
            if (!this.rows[i].isEmpty()) {
              empty = false;
              break;
            }
          }
          return empty;
        };
        _proto5.backSpace = function backSpace() {
          var row = this.rows[this.currRow];
          row.backSpace();
        };
        _proto5.clearToEndOfRow = function clearToEndOfRow() {
          var row = this.rows[this.currRow];
          row.clearToEndOfRow();
        };
        _proto5.insertChar = function insertChar(_char3) {
          var row = this.rows[this.currRow];
          row.insertChar(_char3);
        };
        _proto5.setPen = function setPen(styles) {
          var row = this.rows[this.currRow];
          row.setPenStyles(styles);
        };
        _proto5.moveCursor = function moveCursor(relPos) {
          var row = this.rows[this.currRow];
          row.moveCursor(relPos);
        };
        _proto5.setCursor = function setCursor(absPos) {
          this.logger.log(2, "setCursor: " + absPos);
          var row = this.rows[this.currRow];
          row.setCursor(absPos);
        };
        _proto5.setPAC = function setPAC(pacData) {
          this.logger.log(2, function() {
            return "pacData = " + JSON.stringify(pacData);
          });
          var newRow = pacData.row - 1;
          if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {
            newRow = this.nrRollUpRows - 1;
          }
          if (this.nrRollUpRows && this.currRow !== newRow) {
            for (var i = 0;i < NR_ROWS; i++) {
              this.rows[i].clear();
            }
            var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
            var lastOutputScreen = this.lastOutputScreen;
            if (lastOutputScreen) {
              var prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;
              var time = this.logger.time;
              if (prevLineTime !== null && time !== null && prevLineTime < time) {
                for (var _i = 0;_i < this.nrRollUpRows; _i++) {
                  this.rows[newRow - this.nrRollUpRows + _i + 1].copy(lastOutputScreen.rows[topRowIndex + _i]);
                }
              }
            }
          }
          this.currRow = newRow;
          var row = this.rows[this.currRow];
          if (pacData.indent !== null) {
            var indent = pacData.indent;
            var prevPos = Math.max(indent - 1, 0);
            row.setCursor(pacData.indent);
            pacData.color = row.chars[prevPos].penState.foreground;
          }
          var styles = {
            foreground: pacData.color,
            underline: pacData.underline,
            italics: pacData.italics,
            background: "black",
            flash: false
          };
          this.setPen(styles);
        };
        _proto5.setBkgData = function setBkgData(bkgData) {
          this.logger.log(2, function() {
            return "bkgData = " + JSON.stringify(bkgData);
          });
          this.backSpace();
          this.setPen(bkgData);
          this.insertChar(32);
        };
        _proto5.setRollUpRows = function setRollUpRows(nrRows) {
          this.nrRollUpRows = nrRows;
        };
        _proto5.rollUp = function rollUp() {
          var _this2 = this;
          if (this.nrRollUpRows === null) {
            this.logger.log(3, "roll_up but nrRollUpRows not set yet");
            return;
          }
          this.logger.log(1, function() {
            return _this2.getDisplayText();
          });
          var topRowIndex = this.currRow + 1 - this.nrRollUpRows;
          var topRow = this.rows.splice(topRowIndex, 1)[0];
          topRow.clear();
          this.rows.splice(this.currRow, 0, topRow);
          this.logger.log(2, "Rolling up");
        };
        _proto5.getDisplayText = function getDisplayText(asOneRow) {
          asOneRow = asOneRow || false;
          var displayText = [];
          var text = "";
          var rowNr = -1;
          for (var i = 0;i < NR_ROWS; i++) {
            var rowText = this.rows[i].getTextString();
            if (rowText) {
              rowNr = i + 1;
              if (asOneRow) {
                displayText.push("Row " + rowNr + ": '" + rowText + "'");
              } else {
                displayText.push(rowText.trim());
              }
            }
          }
          if (displayText.length > 0) {
            if (asOneRow) {
              text = "[" + displayText.join(" | ") + "]";
            } else {
              text = displayText.join(`
`);
            }
          }
          return text;
        };
        _proto5.getTextAndFormat = function getTextAndFormat() {
          return this.rows;
        };
        return CaptionScreen2;
      }();
      var Cea608Channel = /* @__PURE__ */ function() {
        function Cea608Channel2(channelNumber, outputFilter, logger2) {
          this.chNr = undefined;
          this.outputFilter = undefined;
          this.mode = undefined;
          this.verbose = undefined;
          this.displayedMemory = undefined;
          this.nonDisplayedMemory = undefined;
          this.lastOutputScreen = undefined;
          this.currRollUpRow = undefined;
          this.writeScreen = undefined;
          this.cueStartTime = undefined;
          this.logger = undefined;
          this.chNr = channelNumber;
          this.outputFilter = outputFilter;
          this.mode = null;
          this.verbose = 0;
          this.displayedMemory = new CaptionScreen(logger2);
          this.nonDisplayedMemory = new CaptionScreen(logger2);
          this.lastOutputScreen = new CaptionScreen(logger2);
          this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
          this.writeScreen = this.displayedMemory;
          this.mode = null;
          this.cueStartTime = null;
          this.logger = logger2;
        }
        var _proto6 = Cea608Channel2.prototype;
        _proto6.reset = function reset() {
          this.mode = null;
          this.displayedMemory.reset();
          this.nonDisplayedMemory.reset();
          this.lastOutputScreen.reset();
          this.outputFilter.reset();
          this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];
          this.writeScreen = this.displayedMemory;
          this.mode = null;
          this.cueStartTime = null;
        };
        _proto6.getHandler = function getHandler() {
          return this.outputFilter;
        };
        _proto6.setHandler = function setHandler(newHandler) {
          this.outputFilter = newHandler;
        };
        _proto6.setPAC = function setPAC(pacData) {
          this.writeScreen.setPAC(pacData);
        };
        _proto6.setBkgData = function setBkgData(bkgData) {
          this.writeScreen.setBkgData(bkgData);
        };
        _proto6.setMode = function setMode(newMode) {
          if (newMode === this.mode) {
            return;
          }
          this.mode = newMode;
          this.logger.log(2, function() {
            return "MODE=" + newMode;
          });
          if (this.mode === "MODE_POP-ON") {
            this.writeScreen = this.nonDisplayedMemory;
          } else {
            this.writeScreen = this.displayedMemory;
            this.writeScreen.reset();
          }
          if (this.mode !== "MODE_ROLL-UP") {
            this.displayedMemory.nrRollUpRows = null;
            this.nonDisplayedMemory.nrRollUpRows = null;
          }
          this.mode = newMode;
        };
        _proto6.insertChars = function insertChars(chars) {
          var _this3 = this;
          for (var i = 0;i < chars.length; i++) {
            this.writeScreen.insertChar(chars[i]);
          }
          var screen = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
          this.logger.log(2, function() {
            return screen + ": " + _this3.writeScreen.getDisplayText(true);
          });
          if (this.mode === "MODE_PAINT-ON" || this.mode === "MODE_ROLL-UP") {
            this.logger.log(1, function() {
              return "DISPLAYED: " + _this3.displayedMemory.getDisplayText(true);
            });
            this.outputDataUpdate();
          }
        };
        _proto6.ccRCL = function ccRCL() {
          this.logger.log(2, "RCL - Resume Caption Loading");
          this.setMode("MODE_POP-ON");
        };
        _proto6.ccBS = function ccBS() {
          this.logger.log(2, "BS - BackSpace");
          if (this.mode === "MODE_TEXT") {
            return;
          }
          this.writeScreen.backSpace();
          if (this.writeScreen === this.displayedMemory) {
            this.outputDataUpdate();
          }
        };
        _proto6.ccAOF = function ccAOF() {
        };
        _proto6.ccAON = function ccAON() {
        };
        _proto6.ccDER = function ccDER() {
          this.logger.log(2, "DER- Delete to End of Row");
          this.writeScreen.clearToEndOfRow();
          this.outputDataUpdate();
        };
        _proto6.ccRU = function ccRU(nrRows) {
          this.logger.log(2, "RU(" + nrRows + ") - Roll Up");
          this.writeScreen = this.displayedMemory;
          this.setMode("MODE_ROLL-UP");
          this.writeScreen.setRollUpRows(nrRows);
        };
        _proto6.ccFON = function ccFON() {
          this.logger.log(2, "FON - Flash On");
          this.writeScreen.setPen({
            flash: true
          });
        };
        _proto6.ccRDC = function ccRDC() {
          this.logger.log(2, "RDC - Resume Direct Captioning");
          this.setMode("MODE_PAINT-ON");
        };
        _proto6.ccTR = function ccTR() {
          this.logger.log(2, "TR");
          this.setMode("MODE_TEXT");
        };
        _proto6.ccRTD = function ccRTD() {
          this.logger.log(2, "RTD");
          this.setMode("MODE_TEXT");
        };
        _proto6.ccEDM = function ccEDM() {
          this.logger.log(2, "EDM - Erase Displayed Memory");
          this.displayedMemory.reset();
          this.outputDataUpdate(true);
        };
        _proto6.ccCR = function ccCR() {
          this.logger.log(2, "CR - Carriage Return");
          this.writeScreen.rollUp();
          this.outputDataUpdate(true);
        };
        _proto6.ccENM = function ccENM() {
          this.logger.log(2, "ENM - Erase Non-displayed Memory");
          this.nonDisplayedMemory.reset();
        };
        _proto6.ccEOC = function ccEOC() {
          var _this4 = this;
          this.logger.log(2, "EOC - End Of Caption");
          if (this.mode === "MODE_POP-ON") {
            var tmp = this.displayedMemory;
            this.displayedMemory = this.nonDisplayedMemory;
            this.nonDisplayedMemory = tmp;
            this.writeScreen = this.nonDisplayedMemory;
            this.logger.log(1, function() {
              return "DISP: " + _this4.displayedMemory.getDisplayText();
            });
          }
          this.outputDataUpdate(true);
        };
        _proto6.ccTO = function ccTO(nrCols) {
          this.logger.log(2, "TO(" + nrCols + ") - Tab Offset");
          this.writeScreen.moveCursor(nrCols);
        };
        _proto6.ccMIDROW = function ccMIDROW(secondByte) {
          var styles = {
            flash: false
          };
          styles.underline = secondByte % 2 === 1;
          styles.italics = secondByte >= 46;
          if (!styles.italics) {
            var colorIndex = Math.floor(secondByte / 2) - 16;
            var colors = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
            styles.foreground = colors[colorIndex];
          } else {
            styles.foreground = "white";
          }
          this.logger.log(2, "MIDROW: " + JSON.stringify(styles));
          this.writeScreen.setPen(styles);
        };
        _proto6.outputDataUpdate = function outputDataUpdate(dispatch) {
          if (dispatch === undefined) {
            dispatch = false;
          }
          var time = this.logger.time;
          if (time === null) {
            return;
          }
          if (this.outputFilter) {
            if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {
              this.cueStartTime = time;
            } else {
              if (!this.displayedMemory.equals(this.lastOutputScreen)) {
                this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);
                if (dispatch && this.outputFilter.dispatchCue) {
                  this.outputFilter.dispatchCue();
                }
                this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;
              }
            }
            this.lastOutputScreen.copy(this.displayedMemory);
          }
        };
        _proto6.cueSplitAtTime = function cueSplitAtTime(t) {
          if (this.outputFilter) {
            if (!this.displayedMemory.isEmpty()) {
              if (this.outputFilter.newCue) {
                this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);
              }
              this.cueStartTime = t;
            }
          }
        };
        return Cea608Channel2;
      }();
      var Cea608Parser = /* @__PURE__ */ function() {
        function Cea608Parser2(field, out1, out2) {
          this.channels = undefined;
          this.currentChannel = 0;
          this.cmdHistory = createCmdHistory();
          this.logger = undefined;
          var logger2 = this.logger = new CaptionsLogger;
          this.channels = [null, new Cea608Channel(field, out1, logger2), new Cea608Channel(field + 1, out2, logger2)];
        }
        var _proto7 = Cea608Parser2.prototype;
        _proto7.getHandler = function getHandler(channel) {
          return this.channels[channel].getHandler();
        };
        _proto7.setHandler = function setHandler(channel, newHandler) {
          this.channels[channel].setHandler(newHandler);
        };
        _proto7.addData = function addData(time, byteList) {
          var _this5 = this;
          this.logger.time = time;
          var _loop = function _loop(i2) {
            var a = byteList[i2] & 127;
            var b = byteList[i2 + 1] & 127;
            var cmdFound = false;
            var charsFound = null;
            if (a === 0 && b === 0) {
              return 0;
            } else {
              _this5.logger.log(3, function() {
                return "[" + numArrayToHexArray([byteList[i2], byteList[i2 + 1]]) + "] -> (" + numArrayToHexArray([a, b]) + ")";
              });
            }
            var cmdHistory = _this5.cmdHistory;
            var isControlCode = a >= 16 && a <= 31;
            if (isControlCode) {
              if (hasCmdRepeated(a, b, cmdHistory)) {
                setLastCmd(null, null, cmdHistory);
                _this5.logger.log(3, function() {
                  return "Repeated command (" + numArrayToHexArray([a, b]) + ") is dropped";
                });
                return 0;
              }
              setLastCmd(a, b, _this5.cmdHistory);
              cmdFound = _this5.parseCmd(a, b);
              if (!cmdFound) {
                cmdFound = _this5.parseMidrow(a, b);
              }
              if (!cmdFound) {
                cmdFound = _this5.parsePAC(a, b);
              }
              if (!cmdFound) {
                cmdFound = _this5.parseBackgroundAttributes(a, b);
              }
            } else {
              setLastCmd(null, null, cmdHistory);
            }
            if (!cmdFound) {
              charsFound = _this5.parseChars(a, b);
              if (charsFound) {
                var currChNr = _this5.currentChannel;
                if (currChNr && currChNr > 0) {
                  var channel = _this5.channels[currChNr];
                  channel.insertChars(charsFound);
                } else {
                  _this5.logger.log(2, "No channel found yet. TEXT-MODE?");
                }
              }
            }
            if (!cmdFound && !charsFound) {
              _this5.logger.log(2, function() {
                return "Couldn't parse cleaned data " + numArrayToHexArray([a, b]) + " orig: " + numArrayToHexArray([byteList[i2], byteList[i2 + 1]]);
              });
            }
          }, _ret;
          for (var i = 0;i < byteList.length; i += 2) {
            _ret = _loop(i);
            if (_ret === 0)
              continue;
          }
        };
        _proto7.parseCmd = function parseCmd(a, b) {
          var cond1 = (a === 20 || a === 28 || a === 21 || a === 29) && b >= 32 && b <= 47;
          var cond2 = (a === 23 || a === 31) && b >= 33 && b <= 35;
          if (!(cond1 || cond2)) {
            return false;
          }
          var chNr = a === 20 || a === 21 || a === 23 ? 1 : 2;
          var channel = this.channels[chNr];
          if (a === 20 || a === 21 || a === 28 || a === 29) {
            if (b === 32) {
              channel.ccRCL();
            } else if (b === 33) {
              channel.ccBS();
            } else if (b === 34) {
              channel.ccAOF();
            } else if (b === 35) {
              channel.ccAON();
            } else if (b === 36) {
              channel.ccDER();
            } else if (b === 37) {
              channel.ccRU(2);
            } else if (b === 38) {
              channel.ccRU(3);
            } else if (b === 39) {
              channel.ccRU(4);
            } else if (b === 40) {
              channel.ccFON();
            } else if (b === 41) {
              channel.ccRDC();
            } else if (b === 42) {
              channel.ccTR();
            } else if (b === 43) {
              channel.ccRTD();
            } else if (b === 44) {
              channel.ccEDM();
            } else if (b === 45) {
              channel.ccCR();
            } else if (b === 46) {
              channel.ccENM();
            } else if (b === 47) {
              channel.ccEOC();
            }
          } else {
            channel.ccTO(b - 32);
          }
          this.currentChannel = chNr;
          return true;
        };
        _proto7.parseMidrow = function parseMidrow(a, b) {
          var chNr = 0;
          if ((a === 17 || a === 25) && b >= 32 && b <= 47) {
            if (a === 17) {
              chNr = 1;
            } else {
              chNr = 2;
            }
            if (chNr !== this.currentChannel) {
              this.logger.log(0, "Mismatch channel in midrow parsing");
              return false;
            }
            var channel = this.channels[chNr];
            if (!channel) {
              return false;
            }
            channel.ccMIDROW(b);
            this.logger.log(3, function() {
              return "MIDROW (" + numArrayToHexArray([a, b]) + ")";
            });
            return true;
          }
          return false;
        };
        _proto7.parsePAC = function parsePAC(a, b) {
          var row;
          var case1 = (a >= 17 && a <= 23 || a >= 25 && a <= 31) && b >= 64 && b <= 127;
          var case2 = (a === 16 || a === 24) && b >= 64 && b <= 95;
          if (!(case1 || case2)) {
            return false;
          }
          var chNr = a <= 23 ? 1 : 2;
          if (b >= 64 && b <= 95) {
            row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];
          } else {
            row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];
          }
          var channel = this.channels[chNr];
          if (!channel) {
            return false;
          }
          channel.setPAC(this.interpretPAC(row, b));
          this.currentChannel = chNr;
          return true;
        };
        _proto7.interpretPAC = function interpretPAC(row, _byte3) {
          var pacIndex;
          var pacData = {
            color: null,
            italics: false,
            indent: null,
            underline: false,
            row
          };
          if (_byte3 > 95) {
            pacIndex = _byte3 - 96;
          } else {
            pacIndex = _byte3 - 64;
          }
          pacData.underline = (pacIndex & 1) === 1;
          if (pacIndex <= 13) {
            pacData.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(pacIndex / 2)];
          } else if (pacIndex <= 15) {
            pacData.italics = true;
            pacData.color = "white";
          } else {
            pacData.indent = Math.floor((pacIndex - 16) / 2) * 4;
          }
          return pacData;
        };
        _proto7.parseChars = function parseChars(a, b) {
          var channelNr;
          var charCodes = null;
          var charCode1 = null;
          if (a >= 25) {
            channelNr = 2;
            charCode1 = a - 8;
          } else {
            channelNr = 1;
            charCode1 = a;
          }
          if (charCode1 >= 17 && charCode1 <= 19) {
            var oneCode;
            if (charCode1 === 17) {
              oneCode = b + 80;
            } else if (charCode1 === 18) {
              oneCode = b + 112;
            } else {
              oneCode = b + 144;
            }
            this.logger.log(2, function() {
              return "Special char '" + getCharForByte(oneCode) + "' in channel " + channelNr;
            });
            charCodes = [oneCode];
          } else if (a >= 32 && a <= 127) {
            charCodes = b === 0 ? [a] : [a, b];
          }
          if (charCodes) {
            this.logger.log(3, function() {
              return "Char codes =  " + numArrayToHexArray(charCodes).join(",");
            });
          }
          return charCodes;
        };
        _proto7.parseBackgroundAttributes = function parseBackgroundAttributes(a, b) {
          var case1 = (a === 16 || a === 24) && b >= 32 && b <= 47;
          var case2 = (a === 23 || a === 31) && b >= 45 && b <= 47;
          if (!(case1 || case2)) {
            return false;
          }
          var index;
          var bkgData = {};
          if (a === 16 || a === 24) {
            index = Math.floor((b - 32) / 2);
            bkgData.background = backgroundColors[index];
            if (b % 2 === 1) {
              bkgData.background = bkgData.background + "_semi";
            }
          } else if (b === 45) {
            bkgData.background = "transparent";
          } else {
            bkgData.foreground = "black";
            if (b === 47) {
              bkgData.underline = true;
            }
          }
          var chNr = a <= 23 ? 1 : 2;
          var channel = this.channels[chNr];
          channel.setBkgData(bkgData);
          return true;
        };
        _proto7.reset = function reset() {
          for (var i = 0;i < Object.keys(this.channels).length; i++) {
            var channel = this.channels[i];
            if (channel) {
              channel.reset();
            }
          }
          setLastCmd(null, null, this.cmdHistory);
        };
        _proto7.cueSplitAtTime = function cueSplitAtTime(t) {
          for (var i = 0;i < this.channels.length; i++) {
            var channel = this.channels[i];
            if (channel) {
              channel.cueSplitAtTime(t);
            }
          }
        };
        return Cea608Parser2;
      }();
      function setLastCmd(a, b, cmdHistory) {
        cmdHistory.a = a;
        cmdHistory.b = b;
      }
      function hasCmdRepeated(a, b, cmdHistory) {
        return cmdHistory.a === a && cmdHistory.b === b;
      }
      function createCmdHistory() {
        return {
          a: null,
          b: null
        };
      }
      var OutputFilter = /* @__PURE__ */ function() {
        function OutputFilter2(timelineController, trackName) {
          this.timelineController = undefined;
          this.cueRanges = [];
          this.trackName = undefined;
          this.startTime = null;
          this.endTime = null;
          this.screen = null;
          this.timelineController = timelineController;
          this.trackName = trackName;
        }
        var _proto = OutputFilter2.prototype;
        _proto.dispatchCue = function dispatchCue() {
          if (this.startTime === null) {
            return;
          }
          this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);
          this.startTime = null;
        };
        _proto.newCue = function newCue(startTime, endTime, screen) {
          if (this.startTime === null || this.startTime > startTime) {
            this.startTime = startTime;
          }
          this.endTime = endTime;
          this.screen = screen;
          this.timelineController.createCaptionsTrack(this.trackName);
        };
        _proto.reset = function reset() {
          this.cueRanges = [];
          this.startTime = null;
        };
        return OutputFilter2;
      }();
      var VTTCue = function() {
        if (optionalSelf != null && optionalSelf.VTTCue) {
          return self.VTTCue;
        }
        var AllowedDirections = ["", "lr", "rl"];
        var AllowedAlignments = ["start", "middle", "end", "left", "right"];
        function isAllowedValue(allowed, value) {
          if (typeof value !== "string") {
            return false;
          }
          if (!Array.isArray(allowed)) {
            return false;
          }
          var lcValue = value.toLowerCase();
          if (~allowed.indexOf(lcValue)) {
            return lcValue;
          }
          return false;
        }
        function findDirectionSetting(value) {
          return isAllowedValue(AllowedDirections, value);
        }
        function findAlignSetting(value) {
          return isAllowedValue(AllowedAlignments, value);
        }
        function extend(obj) {
          for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
            rest[_key - 1] = arguments[_key];
          }
          var i = 1;
          for (;i < arguments.length; i++) {
            var cobj = arguments[i];
            for (var p in cobj) {
              obj[p] = cobj[p];
            }
          }
          return obj;
        }
        function VTTCue2(startTime, endTime, text) {
          var cue = this;
          var baseObj = {
            enumerable: true
          };
          cue.hasBeenReset = false;
          var _id = "";
          var _pauseOnExit = false;
          var _startTime = startTime;
          var _endTime = endTime;
          var _text = text;
          var _region = null;
          var _vertical = "";
          var _snapToLines = true;
          var _line = "auto";
          var _lineAlign = "start";
          var _position = 50;
          var _positionAlign = "middle";
          var _size = 50;
          var _align = "middle";
          Object.defineProperty(cue, "id", extend({}, baseObj, {
            get: function get() {
              return _id;
            },
            set: function set(value) {
              _id = "" + value;
            }
          }));
          Object.defineProperty(cue, "pauseOnExit", extend({}, baseObj, {
            get: function get() {
              return _pauseOnExit;
            },
            set: function set(value) {
              _pauseOnExit = !!value;
            }
          }));
          Object.defineProperty(cue, "startTime", extend({}, baseObj, {
            get: function get() {
              return _startTime;
            },
            set: function set(value) {
              if (typeof value !== "number") {
                throw new TypeError("Start time must be set to a number.");
              }
              _startTime = value;
              this.hasBeenReset = true;
            }
          }));
          Object.defineProperty(cue, "endTime", extend({}, baseObj, {
            get: function get() {
              return _endTime;
            },
            set: function set(value) {
              if (typeof value !== "number") {
                throw new TypeError("End time must be set to a number.");
              }
              _endTime = value;
              this.hasBeenReset = true;
            }
          }));
          Object.defineProperty(cue, "text", extend({}, baseObj, {
            get: function get() {
              return _text;
            },
            set: function set(value) {
              _text = "" + value;
              this.hasBeenReset = true;
            }
          }));
          Object.defineProperty(cue, "region", extend({}, baseObj, {
            get: function get() {
              return _region;
            },
            set: function set(value) {
              _region = value;
              this.hasBeenReset = true;
            }
          }));
          Object.defineProperty(cue, "vertical", extend({}, baseObj, {
            get: function get() {
              return _vertical;
            },
            set: function set(value) {
              var setting = findDirectionSetting(value);
              if (setting === false) {
                throw new SyntaxError("An invalid or illegal string was specified.");
              }
              _vertical = setting;
              this.hasBeenReset = true;
            }
          }));
          Object.defineProperty(cue, "snapToLines", extend({}, baseObj, {
            get: function get() {
              return _snapToLines;
            },
            set: function set(value) {
              _snapToLines = !!value;
              this.hasBeenReset = true;
            }
          }));
          Object.defineProperty(cue, "line", extend({}, baseObj, {
            get: function get() {
              return _line;
            },
            set: function set(value) {
              if (typeof value !== "number" && value !== "auto") {
                throw new SyntaxError("An invalid number or illegal string was specified.");
              }
              _line = value;
              this.hasBeenReset = true;
            }
          }));
          Object.defineProperty(cue, "lineAlign", extend({}, baseObj, {
            get: function get() {
              return _lineAlign;
            },
            set: function set(value) {
              var setting = findAlignSetting(value);
              if (!setting) {
                throw new SyntaxError("An invalid or illegal string was specified.");
              }
              _lineAlign = setting;
              this.hasBeenReset = true;
            }
          }));
          Object.defineProperty(cue, "position", extend({}, baseObj, {
            get: function get() {
              return _position;
            },
            set: function set(value) {
              if (value < 0 || value > 100) {
                throw new Error("Position must be between 0 and 100.");
              }
              _position = value;
              this.hasBeenReset = true;
            }
          }));
          Object.defineProperty(cue, "positionAlign", extend({}, baseObj, {
            get: function get() {
              return _positionAlign;
            },
            set: function set(value) {
              var setting = findAlignSetting(value);
              if (!setting) {
                throw new SyntaxError("An invalid or illegal string was specified.");
              }
              _positionAlign = setting;
              this.hasBeenReset = true;
            }
          }));
          Object.defineProperty(cue, "size", extend({}, baseObj, {
            get: function get() {
              return _size;
            },
            set: function set(value) {
              if (value < 0 || value > 100) {
                throw new Error("Size must be between 0 and 100.");
              }
              _size = value;
              this.hasBeenReset = true;
            }
          }));
          Object.defineProperty(cue, "align", extend({}, baseObj, {
            get: function get() {
              return _align;
            },
            set: function set(value) {
              var setting = findAlignSetting(value);
              if (!setting) {
                throw new SyntaxError("An invalid or illegal string was specified.");
              }
              _align = setting;
              this.hasBeenReset = true;
            }
          }));
          cue.displayState = undefined;
        }
        VTTCue2.prototype.getCueAsHTML = function() {
          var WebVTT = self.WebVTT;
          return WebVTT.convertCueToDOMTree(self, this.text);
        };
        return VTTCue2;
      }();
      var StringDecoder = /* @__PURE__ */ function() {
        function StringDecoder2() {
        }
        var _proto = StringDecoder2.prototype;
        _proto.decode = function decode(data, options) {
          if (!data) {
            return "";
          }
          if (typeof data !== "string") {
            throw new Error("Error - expected string data.");
          }
          return decodeURIComponent(encodeURIComponent(data));
        };
        return StringDecoder2;
      }();
      function parseTimeStamp(input) {
        function computeSeconds(h, m2, s, f) {
          return (h | 0) * 3600 + (m2 | 0) * 60 + (s | 0) + parseFloat(f || 0);
        }
        var m = input.match(/^(?:(\d+):)?(\d{2}):(\d{2})(\.\d+)?/);
        if (!m) {
          return null;
        }
        if (parseFloat(m[2]) > 59) {
          return computeSeconds(m[2], m[3], 0, m[4]);
        }
        return computeSeconds(m[1], m[2], m[3], m[4]);
      }
      var Settings = /* @__PURE__ */ function() {
        function Settings2() {
          this.values = Object.create(null);
        }
        var _proto2 = Settings2.prototype;
        _proto2.set = function set(k, v) {
          if (!this.get(k) && v !== "") {
            this.values[k] = v;
          }
        };
        _proto2.get = function get(k, dflt, defaultKey) {
          if (defaultKey) {
            return this.has(k) ? this.values[k] : dflt[defaultKey];
          }
          return this.has(k) ? this.values[k] : dflt;
        };
        _proto2.has = function has(k) {
          return k in this.values;
        };
        _proto2.alt = function alt(k, v, a) {
          for (var n = 0;n < a.length; ++n) {
            if (v === a[n]) {
              this.set(k, v);
              break;
            }
          }
        };
        _proto2.integer = function integer(k, v) {
          if (/^-?\d+$/.test(v)) {
            this.set(k, parseInt(v, 10));
          }
        };
        _proto2.percent = function percent(k, v) {
          if (/^([\d]{1,3})(\.[\d]*)?%$/.test(v)) {
            var percent = parseFloat(v);
            if (percent >= 0 && percent <= 100) {
              this.set(k, percent);
              return true;
            }
          }
          return false;
        };
        return Settings2;
      }();
      function parseOptions(input, callback, keyValueDelim, groupDelim) {
        var groups = groupDelim ? input.split(groupDelim) : [input];
        for (var i in groups) {
          if (typeof groups[i] !== "string") {
            continue;
          }
          var kv = groups[i].split(keyValueDelim);
          if (kv.length !== 2) {
            continue;
          }
          var _k = kv[0];
          var _v = kv[1];
          callback(_k, _v);
        }
      }
      var defaults = new VTTCue(0, 0, "");
      var center = defaults.align === "middle" ? "middle" : "center";
      function parseCue(input, cue, regionList) {
        var oInput = input;
        function consumeTimeStamp() {
          var ts = parseTimeStamp(input);
          if (ts === null) {
            throw new Error("Malformed timestamp: " + oInput);
          }
          input = input.replace(/^[^\sa-zA-Z-]+/, "");
          return ts;
        }
        function consumeCueSettings(input2, cue2) {
          var settings = new Settings;
          parseOptions(input2, function(k, v) {
            var vals;
            switch (k) {
              case "region":
                for (var i = regionList.length - 1;i >= 0; i--) {
                  if (regionList[i].id === v) {
                    settings.set(k, regionList[i].region);
                    break;
                  }
                }
                break;
              case "vertical":
                settings.alt(k, v, ["rl", "lr"]);
                break;
              case "line":
                vals = v.split(",");
                settings.integer(k, vals[0]);
                if (settings.percent(k, vals[0])) {
                  settings.set("snapToLines", false);
                }
                settings.alt(k, vals[0], ["auto"]);
                if (vals.length === 2) {
                  settings.alt("lineAlign", vals[1], ["start", center, "end"]);
                }
                break;
              case "position":
                vals = v.split(",");
                settings.percent(k, vals[0]);
                if (vals.length === 2) {
                  settings.alt("positionAlign", vals[1], ["start", center, "end", "line-left", "line-right", "auto"]);
                }
                break;
              case "size":
                settings.percent(k, v);
                break;
              case "align":
                settings.alt(k, v, ["start", center, "end", "left", "right"]);
                break;
            }
          }, /:/, /\s/);
          cue2.region = settings.get("region", null);
          cue2.vertical = settings.get("vertical", "");
          var line = settings.get("line", "auto");
          if (line === "auto" && defaults.line === -1) {
            line = -1;
          }
          cue2.line = line;
          cue2.lineAlign = settings.get("lineAlign", "start");
          cue2.snapToLines = settings.get("snapToLines", true);
          cue2.size = settings.get("size", 100);
          cue2.align = settings.get("align", center);
          var position = settings.get("position", "auto");
          if (position === "auto" && defaults.position === 50) {
            position = cue2.align === "start" || cue2.align === "left" ? 0 : cue2.align === "end" || cue2.align === "right" ? 100 : 50;
          }
          cue2.position = position;
        }
        function skipWhitespace() {
          input = input.replace(/^\s+/, "");
        }
        skipWhitespace();
        cue.startTime = consumeTimeStamp();
        skipWhitespace();
        if (input.slice(0, 3) !== "-->") {
          throw new Error("Malformed time stamp (time stamps must be separated by '-->'): " + oInput);
        }
        input = input.slice(3);
        skipWhitespace();
        cue.endTime = consumeTimeStamp();
        skipWhitespace();
        consumeCueSettings(input, cue);
      }
      function fixLineBreaks(input) {
        return input.replace(/<br(?: \/)?>/gi, `
`);
      }
      var VTTParser = /* @__PURE__ */ function() {
        function VTTParser2() {
          this.state = "INITIAL";
          this.buffer = "";
          this.decoder = new StringDecoder;
          this.regionList = [];
          this.cue = null;
          this.oncue = undefined;
          this.onparsingerror = undefined;
          this.onflush = undefined;
        }
        var _proto3 = VTTParser2.prototype;
        _proto3.parse = function parse(data) {
          var _this = this;
          if (data) {
            _this.buffer += _this.decoder.decode(data, {
              stream: true
            });
          }
          function collectNextLine() {
            var buffer = _this.buffer;
            var pos = 0;
            buffer = fixLineBreaks(buffer);
            while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== `
`) {
              ++pos;
            }
            var line2 = buffer.slice(0, pos);
            if (buffer[pos] === "\r") {
              ++pos;
            }
            if (buffer[pos] === `
`) {
              ++pos;
            }
            _this.buffer = buffer.slice(pos);
            return line2;
          }
          function parseHeader2(input) {
            parseOptions(input, function(k, v) {
            }, /:/);
          }
          try {
            var line = "";
            if (_this.state === "INITIAL") {
              if (!/\r\n|\n/.test(_this.buffer)) {
                return this;
              }
              line = collectNextLine();
              var m = line.match(/^(ï»¿)?WEBVTT([ \t].*)?$/);
              if (!(m != null && m[0])) {
                throw new Error("Malformed WebVTT signature.");
              }
              _this.state = "HEADER";
            }
            var alreadyCollectedLine = false;
            while (_this.buffer) {
              if (!/\r\n|\n/.test(_this.buffer)) {
                return this;
              }
              if (!alreadyCollectedLine) {
                line = collectNextLine();
              } else {
                alreadyCollectedLine = false;
              }
              switch (_this.state) {
                case "HEADER":
                  if (/:/.test(line)) {
                    parseHeader2(line);
                  } else if (!line) {
                    _this.state = "ID";
                  }
                  continue;
                case "NOTE":
                  if (!line) {
                    _this.state = "ID";
                  }
                  continue;
                case "ID":
                  if (/^NOTE($|[ \t])/.test(line)) {
                    _this.state = "NOTE";
                    break;
                  }
                  if (!line) {
                    continue;
                  }
                  _this.cue = new VTTCue(0, 0, "");
                  _this.state = "CUE";
                  if (line.indexOf("-->") === -1) {
                    _this.cue.id = line;
                    continue;
                  }
                case "CUE":
                  if (!_this.cue) {
                    _this.state = "BADCUE";
                    continue;
                  }
                  try {
                    parseCue(line, _this.cue, _this.regionList);
                  } catch (e) {
                    _this.cue = null;
                    _this.state = "BADCUE";
                    continue;
                  }
                  _this.state = "CUETEXT";
                  continue;
                case "CUETEXT":
                  {
                    var hasSubstring = line.indexOf("-->") !== -1;
                    if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                      if (_this.oncue && _this.cue) {
                        _this.oncue(_this.cue);
                      }
                      _this.cue = null;
                      _this.state = "ID";
                      continue;
                    }
                    if (_this.cue === null) {
                      continue;
                    }
                    if (_this.cue.text) {
                      _this.cue.text += `
`;
                    }
                    _this.cue.text += line;
                  }
                  continue;
                case "BADCUE":
                  if (!line) {
                    _this.state = "ID";
                  }
              }
            }
          } catch (e) {
            if (_this.state === "CUETEXT" && _this.cue && _this.oncue) {
              _this.oncue(_this.cue);
            }
            _this.cue = null;
            _this.state = _this.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
          }
          return this;
        };
        _proto3.flush = function flush() {
          var _this = this;
          try {
            if (_this.cue || _this.state === "HEADER") {
              _this.buffer += `

`;
              _this.parse();
            }
            if (_this.state === "INITIAL" || _this.state === "BADWEBVTT") {
              throw new Error("Malformed WebVTT signature.");
            }
          } catch (e) {
            if (_this.onparsingerror) {
              _this.onparsingerror(e);
            }
          }
          if (_this.onflush) {
            _this.onflush();
          }
          return this;
        };
        return VTTParser2;
      }();
      var LINEBREAKS = /\r\n|\n\r|\n|\r/g;
      var startsWith = function startsWith(inputString, searchString, position) {
        if (position === undefined) {
          position = 0;
        }
        return inputString.slice(position, position + searchString.length) === searchString;
      };
      var cueString2millis = function cueString2millis(timeString) {
        var ts = parseInt(timeString.slice(-3));
        var secs = parseInt(timeString.slice(-6, -4));
        var mins = parseInt(timeString.slice(-9, -7));
        var hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(":"))) : 0;
        if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {
          throw Error("Malformed X-TIMESTAMP-MAP: Local:" + timeString);
        }
        ts += 1000 * secs;
        ts += 60 * 1000 * mins;
        ts += 60 * 60 * 1000 * hours;
        return ts;
      };
      var hash = function hash(text) {
        var hash2 = 5381;
        var i = text.length;
        while (i) {
          hash2 = hash2 * 33 ^ text.charCodeAt(--i);
        }
        return (hash2 >>> 0).toString();
      };
      function generateCueId(startTime, endTime, text) {
        return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);
      }
      var calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {
        var currCC = vttCCs[cc];
        var prevCC = vttCCs[currCC.prevCC];
        if (!prevCC || !prevCC.new && currCC.new) {
          vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;
          currCC.new = false;
          return;
        }
        while ((_prevCC = prevCC) != null && _prevCC.new) {
          var _prevCC;
          vttCCs.ccOffset += currCC.start - prevCC.start;
          currCC.new = false;
          currCC = prevCC;
          prevCC = vttCCs[currCC.prevCC];
        }
        vttCCs.presentationOffset = presentationTime;
      };
      function parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {
        var parser = new VTTParser;
        var vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, `
`).split(`
`);
        var cues = [];
        var init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;
        var cueTime = "00:00.000";
        var timestampMapMPEGTS = 0;
        var timestampMapLOCAL = 0;
        var parsingError;
        var inHeader = true;
        parser.oncue = function(cue) {
          var currCC = vttCCs[cc];
          var cueOffset = vttCCs.ccOffset;
          var webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 90000;
          if (currCC != null && currCC.new) {
            if (timestampMapLOCAL !== undefined) {
              cueOffset = vttCCs.ccOffset = currCC.start;
            } else {
              calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);
            }
          }
          if (webVttMpegTsMapOffset) {
            if (!initPTS) {
              parsingError = new Error("Missing initPTS for VTT MPEGTS");
              return;
            }
            cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;
          }
          var duration = cue.endTime - cue.startTime;
          var startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;
          cue.startTime = Math.max(startTime, 0);
          cue.endTime = Math.max(startTime + duration, 0);
          var text = cue.text.trim();
          cue.text = decodeURIComponent(encodeURIComponent(text));
          if (!cue.id) {
            cue.id = generateCueId(cue.startTime, cue.endTime, text);
          }
          if (cue.endTime > 0) {
            cues.push(cue);
          }
        };
        parser.onparsingerror = function(error2) {
          parsingError = error2;
        };
        parser.onflush = function() {
          if (parsingError) {
            errorCallBack(parsingError);
            return;
          }
          callBack(cues);
        };
        vttLines.forEach(function(line) {
          if (inHeader) {
            if (startsWith(line, "X-TIMESTAMP-MAP=")) {
              inHeader = false;
              line.slice(16).split(",").forEach(function(timestamp) {
                if (startsWith(timestamp, "LOCAL:")) {
                  cueTime = timestamp.slice(6);
                } else if (startsWith(timestamp, "MPEGTS:")) {
                  timestampMapMPEGTS = parseInt(timestamp.slice(7));
                }
              });
              try {
                timestampMapLOCAL = cueString2millis(cueTime) / 1000;
              } catch (error2) {
                parsingError = error2;
              }
              return;
            } else if (line === "") {
              inHeader = false;
            }
          }
          parser.parse(line + `
`);
        });
        parser.flush();
      }
      var IMSC1_CODEC = "stpp.ttml.im1t";
      var HMSF_REGEX = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;
      var TIME_UNIT_REGEX = /^(\d*(?:\.\d*)?)(h|m|s|ms|f|t)$/;
      var textAlignToLineAlign = {
        left: "start",
        center: "center",
        right: "end",
        start: "start",
        end: "end"
      };
      function parseIMSC1(payload, initPTS, callBack, errorCallBack) {
        var results = findBox(new Uint8Array(payload), ["mdat"]);
        if (results.length === 0) {
          errorCallBack(new Error("Could not parse IMSC1 mdat"));
          return;
        }
        var ttmlList = results.map(function(mdat) {
          return utf8ArrayToStr(mdat);
        });
        var syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);
        try {
          ttmlList.forEach(function(ttml) {
            return callBack(parseTTML(ttml, syncTime));
          });
        } catch (error2) {
          errorCallBack(error2);
        }
      }
      function parseTTML(ttml, syncTime) {
        var parser = new DOMParser;
        var xmlDoc = parser.parseFromString(ttml, "text/xml");
        var tt = xmlDoc.getElementsByTagName("tt")[0];
        if (!tt) {
          throw new Error("Invalid ttml");
        }
        var defaultRateInfo = {
          frameRate: 30,
          subFrameRate: 1,
          frameRateMultiplier: 0,
          tickRate: 0
        };
        var rateInfo = Object.keys(defaultRateInfo).reduce(function(result, key) {
          result[key] = tt.getAttribute("ttp:" + key) || defaultRateInfo[key];
          return result;
        }, {});
        var trim = tt.getAttribute("xml:space") !== "preserve";
        var styleElements = collectionToDictionary(getElementCollection(tt, "styling", "style"));
        var regionElements = collectionToDictionary(getElementCollection(tt, "layout", "region"));
        var cueElements = getElementCollection(tt, "body", "[begin]");
        return [].map.call(cueElements, function(cueElement) {
          var cueText = getTextContent(cueElement, trim);
          if (!cueText || !cueElement.hasAttribute("begin")) {
            return null;
          }
          var startTime = parseTtmlTime(cueElement.getAttribute("begin"), rateInfo);
          var duration = parseTtmlTime(cueElement.getAttribute("dur"), rateInfo);
          var endTime = parseTtmlTime(cueElement.getAttribute("end"), rateInfo);
          if (startTime === null) {
            throw timestampParsingError(cueElement);
          }
          if (endTime === null) {
            if (duration === null) {
              throw timestampParsingError(cueElement);
            }
            endTime = startTime + duration;
          }
          var cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);
          cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);
          var region = regionElements[cueElement.getAttribute("region")];
          var style = styleElements[cueElement.getAttribute("style")];
          var styles = getTtmlStyles(region, style, styleElements);
          var textAlign = styles.textAlign;
          if (textAlign) {
            var lineAlign = textAlignToLineAlign[textAlign];
            if (lineAlign) {
              cue.lineAlign = lineAlign;
            }
            cue.align = textAlign;
          }
          _extends(cue, styles);
          return cue;
        }).filter(function(cue) {
          return cue !== null;
        });
      }
      function getElementCollection(fromElement, parentName, childName) {
        var parent = fromElement.getElementsByTagName(parentName)[0];
        if (parent) {
          return [].slice.call(parent.querySelectorAll(childName));
        }
        return [];
      }
      function collectionToDictionary(elementsWithId) {
        return elementsWithId.reduce(function(dict, element) {
          var id = element.getAttribute("xml:id");
          if (id) {
            dict[id] = element;
          }
          return dict;
        }, {});
      }
      function getTextContent(element, trim) {
        return [].slice.call(element.childNodes).reduce(function(str, node, i) {
          var _node$childNodes;
          if (node.nodeName === "br" && i) {
            return str + `
`;
          }
          if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {
            return getTextContent(node, trim);
          } else if (trim) {
            return str + node.textContent.trim().replace(/\s+/g, " ");
          }
          return str + node.textContent;
        }, "");
      }
      function getTtmlStyles(region, style, styleElements) {
        var ttsNs = "http://www.w3.org/ns/ttml#styling";
        var regionStyle = null;
        var styleAttributes = [
          "displayAlign",
          "textAlign",
          "color",
          "backgroundColor",
          "fontSize",
          "fontFamily"
        ];
        var regionStyleName = region != null && region.hasAttribute("style") ? region.getAttribute("style") : null;
        if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {
          regionStyle = styleElements[regionStyleName];
        }
        return styleAttributes.reduce(function(styles, name) {
          var value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);
          if (value) {
            styles[name] = value;
          }
          return styles;
        }, {});
      }
      function getAttributeNS(element, ns, name) {
        if (!element) {
          return null;
        }
        return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;
      }
      function timestampParsingError(node) {
        return new Error("Could not parse ttml timestamp " + node);
      }
      function parseTtmlTime(timeAttributeValue, rateInfo) {
        if (!timeAttributeValue) {
          return null;
        }
        var seconds = parseTimeStamp(timeAttributeValue);
        if (seconds === null) {
          if (HMSF_REGEX.test(timeAttributeValue)) {
            seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);
          } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {
            seconds = parseTimeUnits(timeAttributeValue, rateInfo);
          }
        }
        return seconds;
      }
      function parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {
        var m = HMSF_REGEX.exec(timeAttributeValue);
        var frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;
        return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;
      }
      function parseTimeUnits(timeAttributeValue, rateInfo) {
        var m = TIME_UNIT_REGEX.exec(timeAttributeValue);
        var value = Number(m[1]);
        var unit = m[2];
        switch (unit) {
          case "h":
            return value * 3600;
          case "m":
            return value * 60;
          case "ms":
            return value * 1000;
          case "f":
            return value / rateInfo.frameRate;
          case "t":
            return value / rateInfo.tickRate;
        }
        return value;
      }
      var TimelineController = /* @__PURE__ */ function() {
        function TimelineController2(hls) {
          this.hls = undefined;
          this.media = null;
          this.config = undefined;
          this.enabled = true;
          this.Cues = undefined;
          this.textTracks = [];
          this.tracks = [];
          this.initPTS = [];
          this.unparsedVttFrags = [];
          this.captionsTracks = {};
          this.nonNativeCaptionsTracks = {};
          this.cea608Parser1 = undefined;
          this.cea608Parser2 = undefined;
          this.lastCc = -1;
          this.lastSn = -1;
          this.lastPartIndex = -1;
          this.prevCC = -1;
          this.vttCCs = newVTTCCs();
          this.captionsProperties = undefined;
          this.hls = hls;
          this.config = hls.config;
          this.Cues = hls.config.cueHandler;
          this.captionsProperties = {
            textTrack1: {
              label: this.config.captionsTextTrack1Label,
              languageCode: this.config.captionsTextTrack1LanguageCode
            },
            textTrack2: {
              label: this.config.captionsTextTrack2Label,
              languageCode: this.config.captionsTextTrack2LanguageCode
            },
            textTrack3: {
              label: this.config.captionsTextTrack3Label,
              languageCode: this.config.captionsTextTrack3LanguageCode
            },
            textTrack4: {
              label: this.config.captionsTextTrack4Label,
              languageCode: this.config.captionsTextTrack4LanguageCode
            }
          };
          hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
          hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
          hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
          hls.on(Events.FRAG_LOADING, this.onFragLoading, this);
          hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);
          hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
          hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
          hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
          hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
          hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
        }
        var _proto = TimelineController2.prototype;
        _proto.destroy = function destroy() {
          var hls = this.hls;
          hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
          hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
          hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);
          hls.off(Events.FRAG_LOADING, this.onFragLoading, this);
          hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);
          hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);
          hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);
          hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);
          hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);
          hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);
          this.hls = this.config = null;
          this.cea608Parser1 = this.cea608Parser2 = undefined;
        };
        _proto.initCea608Parsers = function initCea608Parsers() {
          if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) {
            var channel1 = new OutputFilter(this, "textTrack1");
            var channel2 = new OutputFilter(this, "textTrack2");
            var channel3 = new OutputFilter(this, "textTrack3");
            var channel4 = new OutputFilter(this, "textTrack4");
            this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);
            this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);
          }
        };
        _proto.addCues = function addCues(trackName, startTime, endTime, screen, cueRanges) {
          var merged = false;
          for (var i = cueRanges.length;i--; ) {
            var cueRange = cueRanges[i];
            var overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);
            if (overlap >= 0) {
              cueRange[0] = Math.min(cueRange[0], startTime);
              cueRange[1] = Math.max(cueRange[1], endTime);
              merged = true;
              if (overlap / (endTime - startTime) > 0.5) {
                return;
              }
            }
          }
          if (!merged) {
            cueRanges.push([startTime, endTime]);
          }
          if (this.config.renderTextTracksNatively) {
            var track = this.captionsTracks[trackName];
            this.Cues.newCue(track, startTime, endTime, screen);
          } else {
            var cues = this.Cues.newCue(null, startTime, endTime, screen);
            this.hls.trigger(Events.CUES_PARSED, {
              type: "captions",
              cues,
              track: trackName
            });
          }
        };
        _proto.onInitPtsFound = function onInitPtsFound(event, _ref) {
          var _this = this;
          var { frag, id, initPTS, timescale } = _ref;
          var unparsedVttFrags = this.unparsedVttFrags;
          if (id === "main") {
            this.initPTS[frag.cc] = {
              baseTime: initPTS,
              timescale
            };
          }
          if (unparsedVttFrags.length) {
            this.unparsedVttFrags = [];
            unparsedVttFrags.forEach(function(frag2) {
              _this.onFragLoaded(Events.FRAG_LOADED, frag2);
            });
          }
        };
        _proto.getExistingTrack = function getExistingTrack(label, language) {
          var media = this.media;
          if (media) {
            for (var i = 0;i < media.textTracks.length; i++) {
              var textTrack = media.textTracks[i];
              if (canReuseVttTextTrack(textTrack, {
                name: label,
                lang: language,
                attrs: {}
              })) {
                return textTrack;
              }
            }
          }
          return null;
        };
        _proto.createCaptionsTrack = function createCaptionsTrack(trackName) {
          if (this.config.renderTextTracksNatively) {
            this.createNativeTrack(trackName);
          } else {
            this.createNonNativeTrack(trackName);
          }
        };
        _proto.createNativeTrack = function createNativeTrack(trackName) {
          if (this.captionsTracks[trackName]) {
            return;
          }
          var captionsProperties = this.captionsProperties, captionsTracks = this.captionsTracks, media = this.media;
          var _captionsProperties$t = captionsProperties[trackName], label = _captionsProperties$t.label, languageCode = _captionsProperties$t.languageCode;
          var existingTrack = this.getExistingTrack(label, languageCode);
          if (!existingTrack) {
            var textTrack = this.createTextTrack("captions", label, languageCode);
            if (textTrack) {
              textTrack[trackName] = true;
              captionsTracks[trackName] = textTrack;
            }
          } else {
            captionsTracks[trackName] = existingTrack;
            clearCurrentCues(captionsTracks[trackName]);
            sendAddTrackEvent(captionsTracks[trackName], media);
          }
        };
        _proto.createNonNativeTrack = function createNonNativeTrack(trackName) {
          if (this.nonNativeCaptionsTracks[trackName]) {
            return;
          }
          var trackProperties = this.captionsProperties[trackName];
          if (!trackProperties) {
            return;
          }
          var label = trackProperties.label;
          var track = {
            _id: trackName,
            label,
            kind: "captions",
            default: trackProperties.media ? !!trackProperties.media.default : false,
            closedCaptions: trackProperties.media
          };
          this.nonNativeCaptionsTracks[trackName] = track;
          this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
            tracks: [track]
          });
        };
        _proto.createTextTrack = function createTextTrack(kind, label, lang) {
          var media = this.media;
          if (!media) {
            return;
          }
          return media.addTextTrack(kind, label, lang);
        };
        _proto.onMediaAttaching = function onMediaAttaching(event, data) {
          this.media = data.media;
          this._cleanTracks();
        };
        _proto.onMediaDetaching = function onMediaDetaching() {
          var captionsTracks = this.captionsTracks;
          Object.keys(captionsTracks).forEach(function(trackName) {
            clearCurrentCues(captionsTracks[trackName]);
            delete captionsTracks[trackName];
          });
          this.nonNativeCaptionsTracks = {};
        };
        _proto.onManifestLoading = function onManifestLoading() {
          this.lastCc = -1;
          this.lastSn = -1;
          this.lastPartIndex = -1;
          this.prevCC = -1;
          this.vttCCs = newVTTCCs();
          this._cleanTracks();
          this.tracks = [];
          this.captionsTracks = {};
          this.nonNativeCaptionsTracks = {};
          this.textTracks = [];
          this.unparsedVttFrags = [];
          this.initPTS = [];
          if (this.cea608Parser1 && this.cea608Parser2) {
            this.cea608Parser1.reset();
            this.cea608Parser2.reset();
          }
        };
        _proto._cleanTracks = function _cleanTracks() {
          var media = this.media;
          if (!media) {
            return;
          }
          var textTracks = media.textTracks;
          if (textTracks) {
            for (var i = 0;i < textTracks.length; i++) {
              clearCurrentCues(textTracks[i]);
            }
          }
        };
        _proto.onSubtitleTracksUpdated = function onSubtitleTracksUpdated(event, data) {
          var _this2 = this;
          var tracks = data.subtitleTracks || [];
          var hasIMSC1 = tracks.some(function(track) {
            return track.textCodec === IMSC1_CODEC;
          });
          if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {
            var listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);
            if (listIsIdentical) {
              this.tracks = tracks;
              return;
            }
            this.textTracks = [];
            this.tracks = tracks;
            if (this.config.renderTextTracksNatively) {
              var media = this.media;
              var inUseTracks = media ? filterSubtitleTracks(media.textTracks) : null;
              this.tracks.forEach(function(track, index) {
                var textTrack;
                if (inUseTracks) {
                  var inUseTrack = null;
                  for (var i = 0;i < inUseTracks.length; i++) {
                    if (inUseTracks[i] && canReuseVttTextTrack(inUseTracks[i], track)) {
                      inUseTrack = inUseTracks[i];
                      inUseTracks[i] = null;
                      break;
                    }
                  }
                  if (inUseTrack) {
                    textTrack = inUseTrack;
                  }
                }
                if (textTrack) {
                  clearCurrentCues(textTrack);
                } else {
                  var textTrackKind = captionsOrSubtitlesFromCharacteristics(track);
                  textTrack = _this2.createTextTrack(textTrackKind, track.name, track.lang);
                  if (textTrack) {
                    textTrack.mode = "disabled";
                  }
                }
                if (textTrack) {
                  _this2.textTracks.push(textTrack);
                }
              });
              if (inUseTracks != null && inUseTracks.length) {
                var unusedTextTracks = inUseTracks.filter(function(t) {
                  return t !== null;
                }).map(function(t) {
                  return t.label;
                });
                if (unusedTextTracks.length) {
                  logger.warn("Media element contains unused subtitle tracks: " + unusedTextTracks.join(", ") + ". Replace media element for each source to clear TextTracks and captions menu.");
                }
              }
            } else if (this.tracks.length) {
              var tracksList = this.tracks.map(function(track) {
                return {
                  label: track.name,
                  kind: track.type.toLowerCase(),
                  default: track.default,
                  subtitleTrack: track
                };
              });
              this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {
                tracks: tracksList
              });
            }
          }
        };
        _proto.onManifestLoaded = function onManifestLoaded(event, data) {
          var _this3 = this;
          if (this.config.enableCEA708Captions && data.captions) {
            data.captions.forEach(function(captionsTrack) {
              var instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);
              if (!instreamIdMatch) {
                return;
              }
              var trackName = "textTrack" + instreamIdMatch[1];
              var trackProperties = _this3.captionsProperties[trackName];
              if (!trackProperties) {
                return;
              }
              trackProperties.label = captionsTrack.name;
              if (captionsTrack.lang) {
                trackProperties.languageCode = captionsTrack.lang;
              }
              trackProperties.media = captionsTrack;
            });
          }
        };
        _proto.closedCaptionsForLevel = function closedCaptionsForLevel(frag) {
          var level = this.hls.levels[frag.level];
          return level == null ? undefined : level.attrs["CLOSED-CAPTIONS"];
        };
        _proto.onFragLoading = function onFragLoading(event, data) {
          if (this.enabled && data.frag.type === PlaylistLevelType.MAIN) {
            var _data$part$index, _data$part;
            var cea608Parser1 = this.cea608Parser1, cea608Parser2 = this.cea608Parser2, lastSn = this.lastSn;
            var _data$frag = data.frag, cc = _data$frag.cc, sn = _data$frag.sn;
            var partIndex = (_data$part$index = (_data$part = data.part) == null ? undefined : _data$part.index) != null ? _data$part$index : -1;
            if (cea608Parser1 && cea608Parser2) {
              if (sn !== lastSn + 1 || sn === lastSn && partIndex !== this.lastPartIndex + 1 || cc !== this.lastCc) {
                cea608Parser1.reset();
                cea608Parser2.reset();
              }
            }
            this.lastCc = cc;
            this.lastSn = sn;
            this.lastPartIndex = partIndex;
          }
        };
        _proto.onFragLoaded = function onFragLoaded(event, data) {
          var { frag, payload } = data;
          if (frag.type === PlaylistLevelType.SUBTITLE) {
            if (payload.byteLength) {
              var decryptData = frag.decryptdata;
              var decrypted = "stats" in data;
              if (decryptData == null || !decryptData.encrypted || decrypted) {
                var trackPlaylistMedia = this.tracks[frag.level];
                var vttCCs = this.vttCCs;
                if (!vttCCs[frag.cc]) {
                  vttCCs[frag.cc] = {
                    start: frag.start,
                    prevCC: this.prevCC,
                    new: true
                  };
                  this.prevCC = frag.cc;
                }
                if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {
                  this._parseIMSC1(frag, payload);
                } else {
                  this._parseVTTs(data);
                }
              }
            } else {
              this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
                success: false,
                frag,
                error: new Error("Empty subtitle payload")
              });
            }
          }
        };
        _proto._parseIMSC1 = function _parseIMSC1(frag, payload) {
          var _this4 = this;
          var hls = this.hls;
          parseIMSC1(payload, this.initPTS[frag.cc], function(cues) {
            _this4._appendCues(cues, frag.level);
            hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
              success: true,
              frag
            });
          }, function(error2) {
            logger.log("Failed to parse IMSC1: " + error2);
            hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
              success: false,
              frag,
              error: error2
            });
          });
        };
        _proto._parseVTTs = function _parseVTTs(data) {
          var _frag$initSegment, _this5 = this;
          var { frag, payload } = data;
          var initPTS = this.initPTS, unparsedVttFrags = this.unparsedVttFrags;
          var maxAvCC = initPTS.length - 1;
          if (!initPTS[frag.cc] && maxAvCC === -1) {
            unparsedVttFrags.push(data);
            return;
          }
          var hls = this.hls;
          var payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)) : payload;
          parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, function(cues) {
            _this5._appendCues(cues, frag.level);
            hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
              success: true,
              frag
            });
          }, function(error2) {
            var missingInitPTS = error2.message === "Missing initPTS for VTT MPEGTS";
            if (missingInitPTS) {
              unparsedVttFrags.push(data);
            } else {
              _this5._fallbackToIMSC1(frag, payload);
            }
            logger.log("Failed to parse VTT cue: " + error2);
            if (missingInitPTS && maxAvCC > frag.cc) {
              return;
            }
            hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {
              success: false,
              frag,
              error: error2
            });
          });
        };
        _proto._fallbackToIMSC1 = function _fallbackToIMSC1(frag, payload) {
          var _this6 = this;
          var trackPlaylistMedia = this.tracks[frag.level];
          if (!trackPlaylistMedia.textCodec) {
            parseIMSC1(payload, this.initPTS[frag.cc], function() {
              trackPlaylistMedia.textCodec = IMSC1_CODEC;
              _this6._parseIMSC1(frag, payload);
            }, function() {
              trackPlaylistMedia.textCodec = "wvtt";
            });
          }
        };
        _proto._appendCues = function _appendCues(cues, fragLevel) {
          var hls = this.hls;
          if (this.config.renderTextTracksNatively) {
            var textTrack = this.textTracks[fragLevel];
            if (!textTrack || textTrack.mode === "disabled") {
              return;
            }
            cues.forEach(function(cue) {
              return addCueToTrack(textTrack, cue);
            });
          } else {
            var currentTrack = this.tracks[fragLevel];
            if (!currentTrack) {
              return;
            }
            var track = currentTrack.default ? "default" : "subtitles" + fragLevel;
            hls.trigger(Events.CUES_PARSED, {
              type: "subtitles",
              cues,
              track
            });
          }
        };
        _proto.onFragDecrypted = function onFragDecrypted(event, data) {
          var frag = data.frag;
          if (frag.type === PlaylistLevelType.SUBTITLE) {
            this.onFragLoaded(Events.FRAG_LOADED, data);
          }
        };
        _proto.onSubtitleTracksCleared = function onSubtitleTracksCleared() {
          this.tracks = [];
          this.captionsTracks = {};
        };
        _proto.onFragParsingUserdata = function onFragParsingUserdata(event, data) {
          this.initCea608Parsers();
          var cea608Parser1 = this.cea608Parser1, cea608Parser2 = this.cea608Parser2;
          if (!this.enabled || !cea608Parser1 || !cea608Parser2) {
            return;
          }
          var { frag, samples } = data;
          if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === "NONE") {
            return;
          }
          for (var i = 0;i < samples.length; i++) {
            var ccBytes = samples[i].bytes;
            if (ccBytes) {
              var ccdatas = this.extractCea608Data(ccBytes);
              cea608Parser1.addData(samples[i].pts, ccdatas[0]);
              cea608Parser2.addData(samples[i].pts, ccdatas[1]);
            }
          }
        };
        _proto.onBufferFlushing = function onBufferFlushing(event, _ref2) {
          var { startOffset, endOffset, endOffsetSubtitles, type } = _ref2;
          var media = this.media;
          if (!media || media.currentTime < endOffset) {
            return;
          }
          if (!type || type === "video") {
            var captionsTracks = this.captionsTracks;
            Object.keys(captionsTracks).forEach(function(trackName) {
              return removeCuesInRange(captionsTracks[trackName], startOffset, endOffset);
            });
          }
          if (this.config.renderTextTracksNatively) {
            if (startOffset === 0 && endOffsetSubtitles !== undefined) {
              var textTracks = this.textTracks;
              Object.keys(textTracks).forEach(function(trackName) {
                return removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles);
              });
            }
          }
        };
        _proto.extractCea608Data = function extractCea608Data(byteArray) {
          var actualCCBytes = [[], []];
          var count = byteArray[0] & 31;
          var position = 2;
          for (var j = 0;j < count; j++) {
            var tmpByte = byteArray[position++];
            var ccbyte1 = 127 & byteArray[position++];
            var ccbyte2 = 127 & byteArray[position++];
            if (ccbyte1 === 0 && ccbyte2 === 0) {
              continue;
            }
            var ccValid = (4 & tmpByte) !== 0;
            if (ccValid) {
              var ccType = 3 & tmpByte;
              if (ccType === 0 || ccType === 1) {
                actualCCBytes[ccType].push(ccbyte1);
                actualCCBytes[ccType].push(ccbyte2);
              }
            }
          }
          return actualCCBytes;
        };
        return TimelineController2;
      }();
      function captionsOrSubtitlesFromCharacteristics(track) {
        if (track.characteristics) {
          if (/transcribes-spoken-dialog/gi.test(track.characteristics) && /describes-music-and-sound/gi.test(track.characteristics)) {
            return "captions";
          }
        }
        return "subtitles";
      }
      function canReuseVttTextTrack(inUseTrack, manifestTrack) {
        return !!inUseTrack && inUseTrack.kind === captionsOrSubtitlesFromCharacteristics(manifestTrack) && subtitleTrackMatchesTextTrack(manifestTrack, inUseTrack);
      }
      function intersection(x1, x2, y1, y2) {
        return Math.min(x2, y2) - Math.max(x1, y1);
      }
      function newVTTCCs() {
        return {
          ccOffset: 0,
          presentationOffset: 0,
          0: {
            start: 0,
            prevCC: -1,
            new: true
          }
        };
      }
      var CapLevelController = /* @__PURE__ */ function() {
        function CapLevelController2(hls) {
          this.hls = undefined;
          this.autoLevelCapping = undefined;
          this.firstLevel = undefined;
          this.media = undefined;
          this.restrictedLevels = undefined;
          this.timer = undefined;
          this.clientRect = undefined;
          this.streamController = undefined;
          this.hls = hls;
          this.autoLevelCapping = Number.POSITIVE_INFINITY;
          this.firstLevel = -1;
          this.media = null;
          this.restrictedLevels = [];
          this.timer = undefined;
          this.clientRect = null;
          this.registerListeners();
        }
        var _proto = CapLevelController2.prototype;
        _proto.setStreamController = function setStreamController(streamController) {
          this.streamController = streamController;
        };
        _proto.destroy = function destroy() {
          if (this.hls) {
            this.unregisterListener();
          }
          if (this.timer) {
            this.stopCapping();
          }
          this.media = null;
          this.clientRect = null;
          this.hls = this.streamController = null;
        };
        _proto.registerListeners = function registerListeners() {
          var hls = this.hls;
          hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
          hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
          hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
          hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
          hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);
          hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        };
        _proto.unregisterListener = function unregisterListener() {
          var hls = this.hls;
          hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);
          hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
          hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
          hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
          hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);
          hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
        };
        _proto.onFpsDropLevelCapping = function onFpsDropLevelCapping(event, data) {
          var level = this.hls.levels[data.droppedLevel];
          if (this.isLevelAllowed(level)) {
            this.restrictedLevels.push({
              bitrate: level.bitrate,
              height: level.height,
              width: level.width
            });
          }
        };
        _proto.onMediaAttaching = function onMediaAttaching(event, data) {
          this.media = data.media instanceof HTMLVideoElement ? data.media : null;
          this.clientRect = null;
          if (this.timer && this.hls.levels.length) {
            this.detectPlayerSize();
          }
        };
        _proto.onManifestParsed = function onManifestParsed(event, data) {
          var hls = this.hls;
          this.restrictedLevels = [];
          this.firstLevel = data.firstLevel;
          if (hls.config.capLevelToPlayerSize && data.video) {
            this.startCapping();
          }
        };
        _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {
          if (this.timer && isFiniteNumber(this.autoLevelCapping)) {
            this.detectPlayerSize();
          }
        };
        _proto.onBufferCodecs = function onBufferCodecs(event, data) {
          var hls = this.hls;
          if (hls.config.capLevelToPlayerSize && data.video) {
            this.startCapping();
          }
        };
        _proto.onMediaDetaching = function onMediaDetaching() {
          this.stopCapping();
        };
        _proto.detectPlayerSize = function detectPlayerSize() {
          if (this.media) {
            if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {
              this.clientRect = null;
              return;
            }
            var levels = this.hls.levels;
            if (levels.length) {
              var hls = this.hls;
              var maxLevel = this.getMaxLevel(levels.length - 1);
              if (maxLevel !== this.autoLevelCapping) {
                logger.log("Setting autoLevelCapping to " + maxLevel + ": " + levels[maxLevel].height + "p@" + levels[maxLevel].bitrate + " for media " + this.mediaWidth + "x" + this.mediaHeight);
              }
              hls.autoLevelCapping = maxLevel;
              if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {
                this.streamController.nextLevelSwitch();
              }
              this.autoLevelCapping = hls.autoLevelCapping;
            }
          }
        };
        _proto.getMaxLevel = function getMaxLevel(capLevelIndex) {
          var _this = this;
          var levels = this.hls.levels;
          if (!levels.length) {
            return -1;
          }
          var validLevels = levels.filter(function(level, index) {
            return _this.isLevelAllowed(level) && index <= capLevelIndex;
          });
          this.clientRect = null;
          return CapLevelController2.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);
        };
        _proto.startCapping = function startCapping() {
          if (this.timer) {
            return;
          }
          this.autoLevelCapping = Number.POSITIVE_INFINITY;
          self.clearInterval(this.timer);
          this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);
          this.detectPlayerSize();
        };
        _proto.stopCapping = function stopCapping() {
          this.restrictedLevels = [];
          this.firstLevel = -1;
          this.autoLevelCapping = Number.POSITIVE_INFINITY;
          if (this.timer) {
            self.clearInterval(this.timer);
            this.timer = undefined;
          }
        };
        _proto.getDimensions = function getDimensions() {
          if (this.clientRect) {
            return this.clientRect;
          }
          var media = this.media;
          var boundsRect = {
            width: 0,
            height: 0
          };
          if (media) {
            var clientRect = media.getBoundingClientRect();
            boundsRect.width = clientRect.width;
            boundsRect.height = clientRect.height;
            if (!boundsRect.width && !boundsRect.height) {
              boundsRect.width = clientRect.right - clientRect.left || media.width || 0;
              boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;
            }
          }
          this.clientRect = boundsRect;
          return boundsRect;
        };
        _proto.isLevelAllowed = function isLevelAllowed(level) {
          var restrictedLevels = this.restrictedLevels;
          return !restrictedLevels.some(function(restrictedLevel) {
            return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;
          });
        };
        CapLevelController2.getMaxLevelByMediaSize = function getMaxLevelByMediaSize(levels, width, height) {
          if (!(levels != null && levels.length)) {
            return -1;
          }
          var atGreatestBandwidth = function atGreatestBandwidth(curLevel, nextLevel) {
            if (!nextLevel) {
              return true;
            }
            return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;
          };
          var maxLevelIndex = levels.length - 1;
          var squareSize = Math.max(width, height);
          for (var i = 0;i < levels.length; i += 1) {
            var level = levels[i];
            if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {
              maxLevelIndex = i;
              break;
            }
          }
          return maxLevelIndex;
        };
        _createClass(CapLevelController2, [{
          key: "mediaWidth",
          get: function get() {
            return this.getDimensions().width * this.contentScaleFactor;
          }
        }, {
          key: "mediaHeight",
          get: function get() {
            return this.getDimensions().height * this.contentScaleFactor;
          }
        }, {
          key: "contentScaleFactor",
          get: function get() {
            var pixelRatio = 1;
            if (!this.hls.config.ignoreDevicePixelRatio) {
              try {
                pixelRatio = self.devicePixelRatio;
              } catch (e) {
              }
            }
            return pixelRatio;
          }
        }]);
        return CapLevelController2;
      }();
      var FPSController = /* @__PURE__ */ function() {
        function FPSController2(hls) {
          this.hls = undefined;
          this.isVideoPlaybackQualityAvailable = false;
          this.timer = undefined;
          this.media = null;
          this.lastTime = undefined;
          this.lastDroppedFrames = 0;
          this.lastDecodedFrames = 0;
          this.streamController = undefined;
          this.hls = hls;
          this.registerListeners();
        }
        var _proto = FPSController2.prototype;
        _proto.setStreamController = function setStreamController(streamController) {
          this.streamController = streamController;
        };
        _proto.registerListeners = function registerListeners() {
          this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
        };
        _proto.unregisterListeners = function unregisterListeners() {
          this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);
        };
        _proto.destroy = function destroy() {
          if (this.timer) {
            clearInterval(this.timer);
          }
          this.unregisterListeners();
          this.isVideoPlaybackQualityAvailable = false;
          this.media = null;
        };
        _proto.onMediaAttaching = function onMediaAttaching(event, data) {
          var config = this.hls.config;
          if (config.capLevelOnFPSDrop) {
            var media = data.media instanceof self.HTMLVideoElement ? data.media : null;
            this.media = media;
            if (media && typeof media.getVideoPlaybackQuality === "function") {
              this.isVideoPlaybackQualityAvailable = true;
            }
            self.clearInterval(this.timer);
            this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);
          }
        };
        _proto.checkFPS = function checkFPS(video, decodedFrames, droppedFrames) {
          var currentTime = performance.now();
          if (decodedFrames) {
            if (this.lastTime) {
              var currentPeriod = currentTime - this.lastTime;
              var currentDropped = droppedFrames - this.lastDroppedFrames;
              var currentDecoded = decodedFrames - this.lastDecodedFrames;
              var droppedFPS = 1000 * currentDropped / currentPeriod;
              var hls = this.hls;
              hls.trigger(Events.FPS_DROP, {
                currentDropped,
                currentDecoded,
                totalDroppedFrames: droppedFrames
              });
              if (droppedFPS > 0) {
                if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {
                  var currentLevel = hls.currentLevel;
                  logger.warn("drop FPS ratio greater than max allowed value for currentLevel: " + currentLevel);
                  if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {
                    currentLevel = currentLevel - 1;
                    hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {
                      level: currentLevel,
                      droppedLevel: hls.currentLevel
                    });
                    hls.autoLevelCapping = currentLevel;
                    this.streamController.nextLevelSwitch();
                  }
                }
              }
            }
            this.lastTime = currentTime;
            this.lastDroppedFrames = droppedFrames;
            this.lastDecodedFrames = decodedFrames;
          }
        };
        _proto.checkFPSInterval = function checkFPSInterval() {
          var video = this.media;
          if (video) {
            if (this.isVideoPlaybackQualityAvailable) {
              var videoPlaybackQuality = video.getVideoPlaybackQuality();
              this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);
            } else {
              this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);
            }
          }
        };
        return FPSController2;
      }();
      var LOGGER_PREFIX = "[eme]";
      var EMEController = /* @__PURE__ */ function() {
        function EMEController2(hls) {
          this.hls = undefined;
          this.config = undefined;
          this.media = null;
          this.keyFormatPromise = null;
          this.keySystemAccessPromises = {};
          this._requestLicenseFailureCount = 0;
          this.mediaKeySessions = [];
          this.keyIdToKeySessionPromise = {};
          this.setMediaKeysQueue = EMEController2.CDMCleanupPromise ? [EMEController2.CDMCleanupPromise] : [];
          this.onMediaEncrypted = this._onMediaEncrypted.bind(this);
          this.onWaitingForKey = this._onWaitingForKey.bind(this);
          this.debug = logger.debug.bind(logger, LOGGER_PREFIX);
          this.log = logger.log.bind(logger, LOGGER_PREFIX);
          this.warn = logger.warn.bind(logger, LOGGER_PREFIX);
          this.error = logger.error.bind(logger, LOGGER_PREFIX);
          this.hls = hls;
          this.config = hls.config;
          this.registerListeners();
        }
        var _proto = EMEController2.prototype;
        _proto.destroy = function destroy() {
          this.unregisterListeners();
          this.onMediaDetached();
          var config = this.config;
          config.requestMediaKeySystemAccessFunc = null;
          config.licenseXhrSetup = config.licenseResponseCallback = undefined;
          config.drmSystems = config.drmSystemOptions = {};
          this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;
          this.config = null;
        };
        _proto.registerListeners = function registerListeners() {
          this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);
          this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
        };
        _proto.unregisterListeners = function unregisterListeners() {
          this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);
          this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
        };
        _proto.getLicenseServerUrl = function getLicenseServerUrl(keySystem) {
          var _this$config = this.config, drmSystems = _this$config.drmSystems, widevineLicenseUrl = _this$config.widevineLicenseUrl;
          var keySystemConfiguration = drmSystems[keySystem];
          if (keySystemConfiguration) {
            return keySystemConfiguration.licenseUrl;
          }
          if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {
            return widevineLicenseUrl;
          }
          throw new Error('no license server URL configured for key-system "' + keySystem + '"');
        };
        _proto.getServerCertificateUrl = function getServerCertificateUrl(keySystem) {
          var drmSystems = this.config.drmSystems;
          var keySystemConfiguration = drmSystems[keySystem];
          if (keySystemConfiguration) {
            return keySystemConfiguration.serverCertificateUrl;
          } else {
            this.log('No Server Certificate in config.drmSystems["' + keySystem + '"]');
          }
        };
        _proto.attemptKeySystemAccess = function attemptKeySystemAccess(keySystemsToAttempt) {
          var _this = this;
          var levels = this.hls.levels;
          var uniqueCodec = function uniqueCodec(value, i, a) {
            return !!value && a.indexOf(value) === i;
          };
          var audioCodecs = levels.map(function(level) {
            return level.audioCodec;
          }).filter(uniqueCodec);
          var videoCodecs = levels.map(function(level) {
            return level.videoCodec;
          }).filter(uniqueCodec);
          if (audioCodecs.length + videoCodecs.length === 0) {
            videoCodecs.push("avc1.42e01e");
          }
          return new Promise(function(resolve, reject) {
            var attempt = function attempt(keySystems) {
              var keySystem = keySystems.shift();
              _this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then(function(mediaKeys) {
                return resolve({
                  keySystem,
                  mediaKeys
                });
              }).catch(function(error2) {
                if (keySystems.length) {
                  attempt(keySystems);
                } else if (error2 instanceof EMEKeyError) {
                  reject(error2);
                } else {
                  reject(new EMEKeyError({
                    type: ErrorTypes2.KEY_SYSTEM_ERROR,
                    details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,
                    error: error2,
                    fatal: true
                  }, error2.message));
                }
              });
            };
            attempt(keySystemsToAttempt);
          });
        };
        _proto.requestMediaKeySystemAccess = function requestMediaKeySystemAccess$1(keySystem, supportedConfigurations) {
          var requestMediaKeySystemAccessFunc = this.config.requestMediaKeySystemAccessFunc;
          if (!(typeof requestMediaKeySystemAccessFunc === "function")) {
            var errMessage = "Configured requestMediaKeySystemAccess is not a function " + requestMediaKeySystemAccessFunc;
            if (requestMediaKeySystemAccess === null && self.location.protocol === "http:") {
              errMessage = "navigator.requestMediaKeySystemAccess is not available over insecure protocol " + location.protocol;
            }
            return Promise.reject(new Error(errMessage));
          }
          return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);
        };
        _proto.getMediaKeysPromise = function getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {
          var _this2 = this;
          var mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);
          var keySystemAccessPromises = this.keySystemAccessPromises[keySystem];
          var keySystemAccess = keySystemAccessPromises == null ? undefined : keySystemAccessPromises.keySystemAccess;
          if (!keySystemAccess) {
            this.log('Requesting encrypted media "' + keySystem + '" key-system access with config: ' + JSON.stringify(mediaKeySystemConfigs));
            keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);
            var _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {
              keySystemAccess
            };
            keySystemAccess.catch(function(error2) {
              _this2.log('Failed to obtain access to key-system "' + keySystem + '": ' + error2);
            });
            return keySystemAccess.then(function(mediaKeySystemAccess) {
              _this2.log('Access for key-system "' + mediaKeySystemAccess.keySystem + '" obtained');
              var certificateRequest = _this2.fetchServerCertificate(keySystem);
              _this2.log('Create media-keys for "' + keySystem + '"');
              _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then(function(mediaKeys) {
                _this2.log('Media-keys created for "' + keySystem + '"');
                return certificateRequest.then(function(certificate) {
                  if (certificate) {
                    return _this2.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);
                  }
                  return mediaKeys;
                });
              });
              _keySystemAccessPromises.mediaKeys.catch(function(error2) {
                _this2.error('Failed to create media-keys for "' + keySystem + '"}: ' + error2);
              });
              return _keySystemAccessPromises.mediaKeys;
            });
          }
          return keySystemAccess.then(function() {
            return keySystemAccessPromises.mediaKeys;
          });
        };
        _proto.createMediaKeySessionContext = function createMediaKeySessionContext(_ref) {
          var { decryptdata, keySystem, mediaKeys } = _ref;
          this.log('Creating key-system session "' + keySystem + '" keyId: ' + Hex.hexDump(decryptdata.keyId || []));
          var mediaKeysSession = mediaKeys.createSession();
          var mediaKeySessionContext = {
            decryptdata,
            keySystem,
            mediaKeys,
            mediaKeysSession,
            keyStatus: "status-pending"
          };
          this.mediaKeySessions.push(mediaKeySessionContext);
          return mediaKeySessionContext;
        };
        _proto.renewKeySession = function renewKeySession(mediaKeySessionContext) {
          var decryptdata = mediaKeySessionContext.decryptdata;
          if (decryptdata.pssh) {
            var keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);
            var _keyId = this.getKeyIdString(decryptdata);
            var scheme = "cenc";
            this.keyIdToKeySessionPromise[_keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, "expired");
          } else {
            this.warn("Could not renew expired session. Missing pssh initData.");
          }
          this.removeSession(mediaKeySessionContext);
        };
        _proto.getKeyIdString = function getKeyIdString(decryptdata) {
          if (!decryptdata) {
            throw new Error("Could not read keyId of undefined decryptdata");
          }
          if (decryptdata.keyId === null) {
            throw new Error("keyId is null");
          }
          return Hex.hexDump(decryptdata.keyId);
        };
        _proto.updateKeySession = function updateKeySession(mediaKeySessionContext, data) {
          var _mediaKeySessionConte;
          var keySession = mediaKeySessionContext.mediaKeysSession;
          this.log('Updating key-session "' + keySession.sessionId + '" for keyID ' + Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? undefined : _mediaKeySessionConte.keyId) || []) + `
      } (data length: ` + (data ? data.byteLength : data) + ")");
          return keySession.update(data);
        };
        _proto.selectKeySystemFormat = function selectKeySystemFormat(frag) {
          var keyFormats = Object.keys(frag.levelkeys || {});
          if (!this.keyFormatPromise) {
            this.log("Selecting key-system from fragment (sn: " + frag.sn + " " + frag.type + ": " + frag.level + ") key formats " + keyFormats.join(", "));
            this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
          }
          return this.keyFormatPromise;
        };
        _proto.getKeyFormatPromise = function getKeyFormatPromise(keyFormats) {
          var _this3 = this;
          return new Promise(function(resolve, reject) {
            var keySystemsInConfig = getKeySystemsForConfig(_this3.config);
            var keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter(function(value) {
              return !!value && keySystemsInConfig.indexOf(value) !== -1;
            });
            return _this3.getKeySystemSelectionPromise(keySystemsToAttempt).then(function(_ref2) {
              var keySystem = _ref2.keySystem;
              var keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);
              if (keySystemFormat) {
                resolve(keySystemFormat);
              } else {
                reject(new Error('Unable to find format for key-system "' + keySystem + '"'));
              }
            }).catch(reject);
          });
        };
        _proto.loadKey = function loadKey(data) {
          var _this4 = this;
          var decryptdata = data.keyInfo.decryptdata;
          var keyId = this.getKeyIdString(decryptdata);
          var keyDetails = "(keyId: " + keyId + ' format: "' + decryptdata.keyFormat + '" method: ' + decryptdata.method + " uri: " + decryptdata.uri + ")";
          this.log("Starting session for key " + keyDetails);
          var keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];
          if (!keySessionContextPromise) {
            keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(function(_ref3) {
              var { keySystem, mediaKeys } = _ref3;
              _this4.throwIfDestroyed();
              _this4.log("Handle encrypted media sn: " + data.frag.sn + " " + data.frag.type + ": " + data.frag.level + " using key " + keyDetails);
              return _this4.attemptSetMediaKeys(keySystem, mediaKeys).then(function() {
                _this4.throwIfDestroyed();
                var keySessionContext = _this4.createMediaKeySessionContext({
                  keySystem,
                  mediaKeys,
                  decryptdata
                });
                var scheme = "cenc";
                return _this4.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, "playlist-key");
              });
            });
            keySessionContextPromise.catch(function(error2) {
              return _this4.handleError(error2);
            });
          }
          return keySessionContextPromise;
        };
        _proto.throwIfDestroyed = function throwIfDestroyed(message) {
          if (!this.hls) {
            throw new Error("invalid state");
          }
        };
        _proto.handleError = function handleError(error2) {
          if (!this.hls) {
            return;
          }
          this.error(error2.message);
          if (error2 instanceof EMEKeyError) {
            this.hls.trigger(Events.ERROR, error2.data);
          } else {
            this.hls.trigger(Events.ERROR, {
              type: ErrorTypes2.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_NO_KEYS,
              error: error2,
              fatal: true
            });
          }
        };
        _proto.getKeySystemForKeyPromise = function getKeySystemForKeyPromise(decryptdata) {
          var keyId = this.getKeyIdString(decryptdata);
          var mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];
          if (!mediaKeySessionContext) {
            var keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);
            var keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);
            return this.attemptKeySystemAccess(keySystemsToAttempt);
          }
          return mediaKeySessionContext;
        };
        _proto.getKeySystemSelectionPromise = function getKeySystemSelectionPromise(keySystemsToAttempt) {
          if (!keySystemsToAttempt.length) {
            keySystemsToAttempt = getKeySystemsForConfig(this.config);
          }
          if (keySystemsToAttempt.length === 0) {
            throw new EMEKeyError({
              type: ErrorTypes2.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,
              fatal: true
            }, "Missing key-system license configuration options " + JSON.stringify({
              drmSystems: this.config.drmSystems
            }));
          }
          return this.attemptKeySystemAccess(keySystemsToAttempt);
        };
        _proto._onMediaEncrypted = function _onMediaEncrypted(event) {
          var _this5 = this;
          var { initDataType, initData } = event;
          var logMessage = '"' + event.type + '" event: init data type: "' + initDataType + '"';
          this.debug(logMessage);
          if (initData === null) {
            return;
          }
          var keyId;
          var keySystemDomain;
          if (initDataType === "sinf" && this.config.drmSystems[KeySystems.FAIRPLAY]) {
            var json = bin2str(new Uint8Array(initData));
            try {
              var sinf = base64Decode(JSON.parse(json).sinf);
              var tenc = parseSinf(new Uint8Array(sinf));
              if (!tenc) {
                throw new Error("'schm' box missing or not cbcs/cenc with schi > tenc");
              }
              keyId = tenc.subarray(8, 24);
              keySystemDomain = KeySystems.FAIRPLAY;
            } catch (error2) {
              this.warn(logMessage + " Failed to parse sinf: " + error2);
              return;
            }
          } else {
            var psshResults = parseMultiPssh(initData);
            var psshInfo = psshResults.filter(function(pssh) {
              return pssh.systemId === KeySystemIds.WIDEVINE;
            })[0];
            if (!psshInfo) {
              if (psshResults.length === 0 || psshResults.some(function(pssh) {
                return !pssh.systemId;
              })) {
                this.warn(logMessage + " contains incomplete or invalid pssh data");
              } else {
                this.log("ignoring " + logMessage + " for " + psshResults.map(function(pssh) {
                  return keySystemIdToKeySystemDomain(pssh.systemId);
                }).join(",") + " pssh data in favor of playlist keys");
              }
              return;
            }
            keySystemDomain = keySystemIdToKeySystemDomain(psshInfo.systemId);
            if (psshInfo.version === 0 && psshInfo.data) {
              var offset = psshInfo.data.length - 22;
              keyId = psshInfo.data.subarray(offset, offset + 16);
            }
          }
          if (!keySystemDomain || !keyId) {
            return;
          }
          var keyIdHex = Hex.hexDump(keyId);
          var keyIdToKeySessionPromise = this.keyIdToKeySessionPromise, mediaKeySessions = this.mediaKeySessions;
          var keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];
          var _loop = function _loop() {
            var keyContext = mediaKeySessions[i];
            var decryptdata = keyContext.decryptdata;
            if (!decryptdata.keyId) {
              return 0;
            }
            var oldKeyIdHex = Hex.hexDump(decryptdata.keyId);
            if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, "").indexOf(keyIdHex) !== -1) {
              keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];
              if (decryptdata.pssh) {
                return 1;
              }
              delete keyIdToKeySessionPromise[oldKeyIdHex];
              decryptdata.pssh = new Uint8Array(initData);
              decryptdata.keyId = keyId;
              keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(function() {
                return _this5.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, "encrypted-event-key-match");
              });
              return 1;
            }
          }, _ret;
          for (var i = 0;i < mediaKeySessions.length; i++) {
            _ret = _loop();
            if (_ret === 0)
              continue;
            if (_ret === 1)
              break;
          }
          if (!keySessionContextPromise) {
            keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([keySystemDomain]).then(function(_ref4) {
              var _keySystemToKeySystem;
              var { keySystem, mediaKeys } = _ref4;
              _this5.throwIfDestroyed();
              var decryptdata = new LevelKey("ISO-23001-7", keyIdHex, (_keySystemToKeySystem = keySystemDomainToKeySystemFormat(keySystem)) != null ? _keySystemToKeySystem : "");
              decryptdata.pssh = new Uint8Array(initData);
              decryptdata.keyId = keyId;
              return _this5.attemptSetMediaKeys(keySystem, mediaKeys).then(function() {
                _this5.throwIfDestroyed();
                var keySessionContext = _this5.createMediaKeySessionContext({
                  decryptdata,
                  keySystem,
                  mediaKeys
                });
                return _this5.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, "encrypted-event-no-match");
              });
            });
          }
          keySessionContextPromise.catch(function(error2) {
            return _this5.handleError(error2);
          });
        };
        _proto._onWaitingForKey = function _onWaitingForKey(event) {
          this.log('"' + event.type + '" event');
        };
        _proto.attemptSetMediaKeys = function attemptSetMediaKeys(keySystem, mediaKeys) {
          var _this6 = this;
          var queue = this.setMediaKeysQueue.slice();
          this.log('Setting media-keys for "' + keySystem + '"');
          var setMediaKeysPromise = Promise.all(queue).then(function() {
            if (!_this6.media) {
              throw new Error("Attempted to set mediaKeys without media element attached");
            }
            return _this6.media.setMediaKeys(mediaKeys);
          });
          this.setMediaKeysQueue.push(setMediaKeysPromise);
          return setMediaKeysPromise.then(function() {
            _this6.log('Media-keys set for "' + keySystem + '"');
            queue.push(setMediaKeysPromise);
            _this6.setMediaKeysQueue = _this6.setMediaKeysQueue.filter(function(p) {
              return queue.indexOf(p) === -1;
            });
          });
        };
        _proto.generateRequestWithPreferredKeySession = function generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {
          var _this$config$drmSyste, _this$config$drmSyste2, _this7 = this;
          var generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? undefined : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? undefined : _this$config$drmSyste2.generateRequest;
          if (generateRequestFilter) {
            try {
              var mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);
              if (!mappedInitData) {
                throw new Error("Invalid response from configured generateRequest filter");
              }
              initDataType = mappedInitData.initDataType;
              initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;
            } catch (error2) {
              var _this$hls;
              this.warn(error2.message);
              if ((_this$hls = this.hls) != null && _this$hls.config.debug) {
                throw error2;
              }
            }
          }
          if (initData === null) {
            this.log('Skipping key-session request for "' + reason + '" (no initData)');
            return Promise.resolve(context);
          }
          var keyId = this.getKeyIdString(context.decryptdata);
          this.log('Generating key-session request for "' + reason + '": ' + keyId + " (init data type: " + initDataType + " length: " + (initData ? initData.byteLength : null) + ")");
          var licenseStatus = new EventEmitter;
          var onmessage = context._onmessage = function(event) {
            var keySession = context.mediaKeysSession;
            if (!keySession) {
              licenseStatus.emit("error", new Error("invalid state"));
              return;
            }
            var { messageType, message } = event;
            _this7.log('"' + messageType + '" message event for session "' + keySession.sessionId + '" message size: ' + message.byteLength);
            if (messageType === "license-request" || messageType === "license-renewal") {
              _this7.renewLicense(context, message).catch(function(error2) {
                _this7.handleError(error2);
                licenseStatus.emit("error", error2);
              });
            } else if (messageType === "license-release") {
              if (context.keySystem === KeySystems.FAIRPLAY) {
                _this7.updateKeySession(context, strToUtf8array("acknowledged"));
                _this7.removeSession(context);
              }
            } else {
              _this7.warn('unhandled media key message type "' + messageType + '"');
            }
          };
          var onkeystatuseschange = context._onkeystatuseschange = function(event) {
            var keySession = context.mediaKeysSession;
            if (!keySession) {
              licenseStatus.emit("error", new Error("invalid state"));
              return;
            }
            _this7.onKeyStatusChange(context);
            var keyStatus = context.keyStatus;
            licenseStatus.emit("keyStatus", keyStatus);
            if (keyStatus === "expired") {
              _this7.warn(context.keySystem + " expired for key " + keyId);
              _this7.renewKeySession(context);
            }
          };
          context.mediaKeysSession.addEventListener("message", onmessage);
          context.mediaKeysSession.addEventListener("keystatuseschange", onkeystatuseschange);
          var keyUsablePromise = new Promise(function(resolve, reject) {
            licenseStatus.on("error", reject);
            licenseStatus.on("keyStatus", function(keyStatus) {
              if (keyStatus.startsWith("usable")) {
                resolve();
              } else if (keyStatus === "output-restricted") {
                reject(new EMEKeyError({
                  type: ErrorTypes2.KEY_SYSTEM_ERROR,
                  details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,
                  fatal: false
                }, "HDCP level output restricted"));
              } else if (keyStatus === "internal-error") {
                reject(new EMEKeyError({
                  type: ErrorTypes2.KEY_SYSTEM_ERROR,
                  details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,
                  fatal: true
                }, 'key status changed to "' + keyStatus + '"'));
              } else if (keyStatus === "expired") {
                reject(new Error("key expired while generating request"));
              } else {
                _this7.warn('unhandled key status change "' + keyStatus + '"');
              }
            });
          });
          return context.mediaKeysSession.generateRequest(initDataType, initData).then(function() {
            var _context$mediaKeysSes;
            _this7.log('Request generated for key-session "' + ((_context$mediaKeysSes = context.mediaKeysSession) == null ? undefined : _context$mediaKeysSes.sessionId) + '" keyId: ' + keyId);
          }).catch(function(error2) {
            throw new EMEKeyError({
              type: ErrorTypes2.KEY_SYSTEM_ERROR,
              details: ErrorDetails.KEY_SYSTEM_NO_SESSION,
              error: error2,
              fatal: false
            }, "Error generating key-session request: " + error2);
          }).then(function() {
            return keyUsablePromise;
          }).catch(function(error2) {
            licenseStatus.removeAllListeners();
            _this7.removeSession(context);
            throw error2;
          }).then(function() {
            licenseStatus.removeAllListeners();
            return context;
          });
        };
        _proto.onKeyStatusChange = function onKeyStatusChange(mediaKeySessionContext) {
          var _this8 = this;
          mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach(function(status2, keyId) {
            _this8.log('key status change "' + status2 + '" for keyStatuses keyId: ' + Hex.hexDump("buffer" in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId)) + " session keyId: " + Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || [])) + " uri: " + mediaKeySessionContext.decryptdata.uri);
            mediaKeySessionContext.keyStatus = status2;
          });
        };
        _proto.fetchServerCertificate = function fetchServerCertificate(keySystem) {
          var config = this.config;
          var Loader = config.loader;
          var certLoader = new Loader(config);
          var url2 = this.getServerCertificateUrl(keySystem);
          if (!url2) {
            return Promise.resolve();
          }
          this.log('Fetching server certificate for "' + keySystem + '"');
          return new Promise(function(resolve, reject) {
            var loaderContext = {
              responseType: "arraybuffer",
              url: url2
            };
            var loadPolicy = config.certLoadPolicy.default;
            var loaderConfig = {
              loadPolicy,
              timeout: loadPolicy.maxLoadTimeMs,
              maxRetry: 0,
              retryDelay: 0,
              maxRetryDelay: 0
            };
            var loaderCallbacks = {
              onSuccess: function onSuccess(response, stats, context, networkDetails) {
                resolve(response.data);
              },
              onError: function onError(response, contex, networkDetails, stats) {
                reject(new EMEKeyError({
                  type: ErrorTypes2.KEY_SYSTEM_ERROR,
                  details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                  fatal: true,
                  networkDetails,
                  response: _objectSpread2({
                    url: loaderContext.url,
                    data: undefined
                  }, response)
                }, '"' + keySystem + '" certificate request failed (' + url2 + "). Status: " + response.code + " (" + response.text + ")"));
              },
              onTimeout: function onTimeout(stats, context, networkDetails) {
                reject(new EMEKeyError({
                  type: ErrorTypes2.KEY_SYSTEM_ERROR,
                  details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,
                  fatal: true,
                  networkDetails,
                  response: {
                    url: loaderContext.url,
                    data: undefined
                  }
                }, '"' + keySystem + '" certificate request timed out (' + url2 + ")"));
              },
              onAbort: function onAbort(stats, context, networkDetails) {
                reject(new Error("aborted"));
              }
            };
            certLoader.load(loaderContext, loaderConfig, loaderCallbacks);
          });
        };
        _proto.setMediaKeysServerCertificate = function setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {
          var _this9 = this;
          return new Promise(function(resolve, reject) {
            mediaKeys.setServerCertificate(cert).then(function(success) {
              _this9.log("setServerCertificate " + (success ? "success" : "not supported by CDM") + " (" + (cert == null ? undefined : cert.byteLength) + ') on "' + keySystem + '"');
              resolve(mediaKeys);
            }).catch(function(error2) {
              reject(new EMEKeyError({
                type: ErrorTypes2.KEY_SYSTEM_ERROR,
                details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,
                error: error2,
                fatal: true
              }, error2.message));
            });
          });
        };
        _proto.renewLicense = function renewLicense(context, keyMessage) {
          var _this10 = this;
          return this.requestLicense(context, new Uint8Array(keyMessage)).then(function(data) {
            return _this10.updateKeySession(context, new Uint8Array(data)).catch(function(error2) {
              throw new EMEKeyError({
                type: ErrorTypes2.KEY_SYSTEM_ERROR,
                details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,
                error: error2,
                fatal: true
              }, error2.message);
            });
          });
        };
        _proto.unpackPlayReadyKeyMessage = function unpackPlayReadyKeyMessage(xhr, licenseChallenge) {
          var xmlString = String.fromCharCode.apply(null, new Uint16Array(licenseChallenge.buffer));
          if (!xmlString.includes("PlayReadyKeyMessage")) {
            xhr.setRequestHeader("Content-Type", "text/xml; charset=utf-8");
            return licenseChallenge;
          }
          var keyMessageXml = new DOMParser().parseFromString(xmlString, "application/xml");
          var headers = keyMessageXml.querySelectorAll("HttpHeader");
          if (headers.length > 0) {
            var header;
            for (var i = 0, len = headers.length;i < len; i++) {
              var _header$querySelector, _header$querySelector2;
              header = headers[i];
              var name = (_header$querySelector = header.querySelector("name")) == null ? undefined : _header$querySelector.textContent;
              var _value = (_header$querySelector2 = header.querySelector("value")) == null ? undefined : _header$querySelector2.textContent;
              if (name && _value) {
                xhr.setRequestHeader(name, _value);
              }
            }
          }
          var challengeElement = keyMessageXml.querySelector("Challenge");
          var challengeText = challengeElement == null ? undefined : challengeElement.textContent;
          if (!challengeText) {
            throw new Error("Cannot find <Challenge> in key message");
          }
          return strToUtf8array(atob(challengeText));
        };
        _proto.setupLicenseXHR = function setupLicenseXHR(xhr, url2, keysListItem, licenseChallenge) {
          var _this11 = this;
          var licenseXhrSetup = this.config.licenseXhrSetup;
          if (!licenseXhrSetup) {
            xhr.open("POST", url2, true);
            return Promise.resolve({
              xhr,
              licenseChallenge
            });
          }
          return Promise.resolve().then(function() {
            if (!keysListItem.decryptdata) {
              throw new Error("Key removed");
            }
            return licenseXhrSetup.call(_this11.hls, xhr, url2, keysListItem, licenseChallenge);
          }).catch(function(error2) {
            if (!keysListItem.decryptdata) {
              throw error2;
            }
            xhr.open("POST", url2, true);
            return licenseXhrSetup.call(_this11.hls, xhr, url2, keysListItem, licenseChallenge);
          }).then(function(licenseXhrSetupResult) {
            if (!xhr.readyState) {
              xhr.open("POST", url2, true);
            }
            var finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;
            return {
              xhr,
              licenseChallenge: finalLicenseChallenge
            };
          });
        };
        _proto.requestLicense = function requestLicense(keySessionContext, licenseChallenge) {
          var _this12 = this;
          var keyLoadPolicy = this.config.keyLoadPolicy.default;
          return new Promise(function(resolve, reject) {
            var url2 = _this12.getLicenseServerUrl(keySessionContext.keySystem);
            _this12.log("Sending license request to URL: " + url2);
            var xhr = new XMLHttpRequest;
            xhr.responseType = "arraybuffer";
            xhr.onreadystatechange = function() {
              if (!_this12.hls || !keySessionContext.mediaKeysSession) {
                return reject(new Error("invalid state"));
              }
              if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                  _this12._requestLicenseFailureCount = 0;
                  var data = xhr.response;
                  _this12.log("License received " + (data instanceof ArrayBuffer ? data.byteLength : data));
                  var licenseResponseCallback = _this12.config.licenseResponseCallback;
                  if (licenseResponseCallback) {
                    try {
                      data = licenseResponseCallback.call(_this12.hls, xhr, url2, keySessionContext);
                    } catch (error2) {
                      _this12.error(error2);
                    }
                  }
                  resolve(data);
                } else {
                  var retryConfig = keyLoadPolicy.errorRetry;
                  var maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;
                  _this12._requestLicenseFailureCount++;
                  if (_this12._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {
                    reject(new EMEKeyError({
                      type: ErrorTypes2.KEY_SYSTEM_ERROR,
                      details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,
                      fatal: true,
                      networkDetails: xhr,
                      response: {
                        url: url2,
                        data: undefined,
                        code: xhr.status,
                        text: xhr.statusText
                      }
                    }, "License Request XHR failed (" + url2 + "). Status: " + xhr.status + " (" + xhr.statusText + ")"));
                  } else {
                    var attemptsLeft = maxNumRetry - _this12._requestLicenseFailureCount + 1;
                    _this12.warn("Retrying license request, " + attemptsLeft + " attempts left");
                    _this12.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);
                  }
                }
              }
            };
            if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {
              keySessionContext.licenseXhr.abort();
            }
            keySessionContext.licenseXhr = xhr;
            _this12.setupLicenseXHR(xhr, url2, keySessionContext, licenseChallenge).then(function(_ref5) {
              var { xhr: xhr2, licenseChallenge: licenseChallenge2 } = _ref5;
              if (keySessionContext.keySystem == KeySystems.PLAYREADY) {
                licenseChallenge2 = _this12.unpackPlayReadyKeyMessage(xhr2, licenseChallenge2);
              }
              xhr2.send(licenseChallenge2);
            });
          });
        };
        _proto.onMediaAttached = function onMediaAttached(event, data) {
          if (!this.config.emeEnabled) {
            return;
          }
          var media = data.media;
          this.media = media;
          media.addEventListener("encrypted", this.onMediaEncrypted);
          media.addEventListener("waitingforkey", this.onWaitingForKey);
        };
        _proto.onMediaDetached = function onMediaDetached() {
          var _this13 = this;
          var media = this.media;
          var mediaKeysList = this.mediaKeySessions;
          if (media) {
            media.removeEventListener("encrypted", this.onMediaEncrypted);
            media.removeEventListener("waitingforkey", this.onWaitingForKey);
            this.media = null;
          }
          this._requestLicenseFailureCount = 0;
          this.setMediaKeysQueue = [];
          this.mediaKeySessions = [];
          this.keyIdToKeySessionPromise = {};
          LevelKey.clearKeyUriToKeyIdMap();
          var keySessionCount = mediaKeysList.length;
          EMEController2.CDMCleanupPromise = Promise.all(mediaKeysList.map(function(mediaKeySessionContext) {
            return _this13.removeSession(mediaKeySessionContext);
          }).concat(media == null ? undefined : media.setMediaKeys(null).catch(function(error2) {
            _this13.log("Could not clear media keys: " + error2);
          }))).then(function() {
            if (keySessionCount) {
              _this13.log("finished closing key sessions and clearing media keys");
              mediaKeysList.length = 0;
            }
          }).catch(function(error2) {
            _this13.log("Could not close sessions and clear media keys: " + error2);
          });
        };
        _proto.onManifestLoading = function onManifestLoading() {
          this.keyFormatPromise = null;
        };
        _proto.onManifestLoaded = function onManifestLoaded(event, _ref6) {
          var sessionKeys = _ref6.sessionKeys;
          if (!sessionKeys || !this.config.emeEnabled) {
            return;
          }
          if (!this.keyFormatPromise) {
            var keyFormats = sessionKeys.reduce(function(formats, sessionKey) {
              if (formats.indexOf(sessionKey.keyFormat) === -1) {
                formats.push(sessionKey.keyFormat);
              }
              return formats;
            }, []);
            this.log("Selecting key-system from session-keys " + keyFormats.join(", "));
            this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);
          }
        };
        _proto.removeSession = function removeSession(mediaKeySessionContext) {
          var _this14 = this;
          var { mediaKeysSession, licenseXhr } = mediaKeySessionContext;
          if (mediaKeysSession) {
            this.log("Remove licenses and keys and close session " + mediaKeysSession.sessionId);
            if (mediaKeySessionContext._onmessage) {
              mediaKeysSession.removeEventListener("message", mediaKeySessionContext._onmessage);
              mediaKeySessionContext._onmessage = undefined;
            }
            if (mediaKeySessionContext._onkeystatuseschange) {
              mediaKeysSession.removeEventListener("keystatuseschange", mediaKeySessionContext._onkeystatuseschange);
              mediaKeySessionContext._onkeystatuseschange = undefined;
            }
            if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {
              licenseXhr.abort();
            }
            mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = undefined;
            var index = this.mediaKeySessions.indexOf(mediaKeySessionContext);
            if (index > -1) {
              this.mediaKeySessions.splice(index, 1);
            }
            return mediaKeysSession.remove().catch(function(error2) {
              _this14.log("Could not remove session: " + error2);
            }).then(function() {
              return mediaKeysSession.close();
            }).catch(function(error2) {
              _this14.log("Could not close session: " + error2);
            });
          }
        };
        return EMEController2;
      }();
      EMEController.CDMCleanupPromise = undefined;
      var EMEKeyError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(EMEKeyError2, _Error);
        function EMEKeyError2(data, message) {
          var _this15;
          _this15 = _Error.call(this, message) || this;
          _this15.data = undefined;
          data.error || (data.error = new Error(message));
          _this15.data = data;
          data.err = data.error;
          return _this15;
        }
        return EMEKeyError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      var CmObjectType;
      (function(CmObjectType2) {
        CmObjectType2["MANIFEST"] = "m";
        CmObjectType2["AUDIO"] = "a";
        CmObjectType2["VIDEO"] = "v";
        CmObjectType2["MUXED"] = "av";
        CmObjectType2["INIT"] = "i";
        CmObjectType2["CAPTION"] = "c";
        CmObjectType2["TIMED_TEXT"] = "tt";
        CmObjectType2["KEY"] = "k";
        CmObjectType2["OTHER"] = "o";
      })(CmObjectType || (CmObjectType = {}));
      var CmStreamingFormat;
      (function(CmStreamingFormat2) {
        CmStreamingFormat2["DASH"] = "d";
        CmStreamingFormat2["HLS"] = "h";
        CmStreamingFormat2["SMOOTH"] = "s";
        CmStreamingFormat2["OTHER"] = "o";
      })(CmStreamingFormat || (CmStreamingFormat = {}));
      var CmcdHeaderField;
      (function(CmcdHeaderField2) {
        CmcdHeaderField2["OBJECT"] = "CMCD-Object";
        CmcdHeaderField2["REQUEST"] = "CMCD-Request";
        CmcdHeaderField2["SESSION"] = "CMCD-Session";
        CmcdHeaderField2["STATUS"] = "CMCD-Status";
      })(CmcdHeaderField || (CmcdHeaderField = {}));
      var _CmcdHeaderMap;
      var CmcdHeaderMap = (_CmcdHeaderMap = {}, _CmcdHeaderMap[CmcdHeaderField.OBJECT] = ["br", "d", "ot", "tb"], _CmcdHeaderMap[CmcdHeaderField.REQUEST] = ["bl", "dl", "mtp", "nor", "nrr", "su"], _CmcdHeaderMap[CmcdHeaderField.SESSION] = ["cid", "pr", "sf", "sid", "st", "v"], _CmcdHeaderMap[CmcdHeaderField.STATUS] = ["bs", "rtp"], _CmcdHeaderMap);
      var SfItem = function SfItem(value, params) {
        this.value = undefined;
        this.params = undefined;
        if (Array.isArray(value)) {
          value = value.map(function(v) {
            return v instanceof SfItem ? v : new SfItem(v);
          });
        }
        this.value = value;
        this.params = params;
      };
      var SfToken = function SfToken(description) {
        this.description = undefined;
        this.description = description;
      };
      var DICT = "Dict";
      function format(value) {
        if (Array.isArray(value)) {
          return JSON.stringify(value);
        }
        if (value instanceof Map) {
          return "Map{}";
        }
        if (value instanceof Set) {
          return "Set{}";
        }
        if (typeof value === "object") {
          return JSON.stringify(value);
        }
        return String(value);
      }
      function throwError(action, src, type, cause) {
        return new Error("failed to " + action + ' "' + format(src) + '" as ' + type, {
          cause
        });
      }
      var BARE_ITEM = "Bare Item";
      var BOOLEAN = "Boolean";
      var BYTES = "Byte Sequence";
      var DECIMAL = "Decimal";
      var INTEGER = "Integer";
      function isInvalidInt(value) {
        return value < -999999999999999 || 999999999999999 < value;
      }
      var STRING_REGEX = /[\x00-\x1f\x7f]+/;
      var TOKEN = "Token";
      var KEY = "Key";
      function serializeError(src, type, cause) {
        return throwError("serialize", src, type, cause);
      }
      function serializeBoolean(value) {
        if (typeof value !== "boolean") {
          throw serializeError(value, BOOLEAN);
        }
        return value ? "?1" : "?0";
      }
      function base64encode(binary) {
        return btoa(String.fromCharCode.apply(String, binary));
      }
      function serializeByteSequence(value) {
        if (ArrayBuffer.isView(value) === false) {
          throw serializeError(value, BYTES);
        }
        return ":" + base64encode(value) + ":";
      }
      function serializeInteger(value) {
        if (isInvalidInt(value)) {
          throw serializeError(value, INTEGER);
        }
        return value.toString();
      }
      function serializeDate(value) {
        return "@" + serializeInteger(value.getTime() / 1000);
      }
      function roundToEven(value, precision) {
        if (value < 0) {
          return -roundToEven(-value, precision);
        }
        var decimalShift = Math.pow(10, precision);
        var isEquidistant = Math.abs(value * decimalShift % 1 - 0.5) < Number.EPSILON;
        if (isEquidistant) {
          var flooredValue = Math.floor(value * decimalShift);
          return (flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift;
        } else {
          return Math.round(value * decimalShift) / decimalShift;
        }
      }
      function serializeDecimal(value) {
        var roundedValue = roundToEven(value, 3);
        if (Math.floor(Math.abs(roundedValue)).toString().length > 12) {
          throw serializeError(value, DECIMAL);
        }
        var stringValue = roundedValue.toString();
        return stringValue.includes(".") ? stringValue : stringValue + ".0";
      }
      var STRING = "String";
      function serializeString(value) {
        if (STRING_REGEX.test(value)) {
          throw serializeError(value, STRING);
        }
        return '"' + value.replace(/\\/g, "\\\\").replace(/"/g, "\\\"") + '"';
      }
      function symbolToStr(symbol) {
        return symbol.description || symbol.toString().slice(7, -1);
      }
      function serializeToken(token) {
        var value = symbolToStr(token);
        if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(value) === false) {
          throw serializeError(value, TOKEN);
        }
        return value;
      }
      function serializeBareItem(value) {
        switch (typeof value) {
          case "number":
            if (!isFiniteNumber(value)) {
              throw serializeError(value, BARE_ITEM);
            }
            if (Number.isInteger(value)) {
              return serializeInteger(value);
            }
            return serializeDecimal(value);
          case "string":
            return serializeString(value);
          case "symbol":
            return serializeToken(value);
          case "boolean":
            return serializeBoolean(value);
          case "object":
            if (value instanceof Date) {
              return serializeDate(value);
            }
            if (value instanceof Uint8Array) {
              return serializeByteSequence(value);
            }
            if (value instanceof SfToken) {
              return serializeToken(value);
            }
          default:
            throw serializeError(value, BARE_ITEM);
        }
      }
      function serializeKey(value) {
        if (/^[a-z*][a-z0-9\-_.*]*$/.test(value) === false) {
          throw serializeError(value, KEY);
        }
        return value;
      }
      function serializeParams(params) {
        if (params == null) {
          return "";
        }
        return Object.entries(params).map(function(_ref) {
          var key = _ref[0], value = _ref[1];
          if (value === true) {
            return ";" + serializeKey(key);
          }
          return ";" + serializeKey(key) + "=" + serializeBareItem(value);
        }).join("");
      }
      function serializeItem(value) {
        if (value instanceof SfItem) {
          return "" + serializeBareItem(value.value) + serializeParams(value.params);
        } else {
          return serializeBareItem(value);
        }
      }
      function serializeInnerList(value) {
        return "(" + value.value.map(serializeItem).join(" ") + ")" + serializeParams(value.params);
      }
      function serializeDict(dict, options) {
        var _options;
        if (options === undefined) {
          options = {
            whitespace: true
          };
        }
        if (typeof dict !== "object") {
          throw serializeError(dict, DICT);
        }
        var entries = dict instanceof Map ? dict.entries() : Object.entries(dict);
        var optionalWhiteSpace = (_options = options) != null && _options.whitespace ? " " : "";
        return Array.from(entries).map(function(_ref) {
          var key = _ref[0], item = _ref[1];
          if (item instanceof SfItem === false) {
            item = new SfItem(item);
          }
          var output = serializeKey(key);
          if (item.value === true) {
            output += serializeParams(item.params);
          } else {
            output += "=";
            if (Array.isArray(item.value)) {
              output += serializeInnerList(item);
            } else {
              output += serializeItem(item);
            }
          }
          return output;
        }).join("," + optionalWhiteSpace);
      }
      function encodeSfDict(value, options) {
        return serializeDict(value, options);
      }
      var isTokenField = function isTokenField(key) {
        return key === "ot" || key === "sf" || key === "st";
      };
      var isValid = function isValid(value) {
        if (typeof value === "number") {
          return isFiniteNumber(value);
        }
        return value != null && value !== "" && value !== false;
      };
      function urlToRelativePath(url2, base) {
        var to = new URL(url2);
        var from = new URL(base);
        if (to.origin !== from.origin) {
          return url2;
        }
        var toPath = to.pathname.split("/").slice(1);
        var fromPath = from.pathname.split("/").slice(1, -1);
        while (toPath[0] === fromPath[0]) {
          toPath.shift();
          fromPath.shift();
        }
        while (fromPath.length) {
          fromPath.shift();
          toPath.unshift("..");
        }
        return toPath.join("/");
      }
      function uuid() {
        try {
          return crypto.randomUUID();
        } catch (error2) {
          try {
            var url2 = URL.createObjectURL(new Blob);
            var _uuid = url2.toString();
            URL.revokeObjectURL(url2);
            return _uuid.slice(_uuid.lastIndexOf("/") + 1);
          } catch (error3) {
            var dt = new Date().getTime();
            var _uuid2 = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
              var r = (dt + Math.random() * 16) % 16 | 0;
              dt = Math.floor(dt / 16);
              return (c == "x" ? r : r & 3 | 8).toString(16);
            });
            return _uuid2;
          }
        }
      }
      var toRounded = function toRounded(value) {
        return Math.round(value);
      };
      var toUrlSafe = function toUrlSafe(value, options) {
        if (options != null && options.baseUrl) {
          value = urlToRelativePath(value, options.baseUrl);
        }
        return encodeURIComponent(value);
      };
      var toHundred = function toHundred(value) {
        return toRounded(value / 100) * 100;
      };
      var CmcdFormatters = {
        br: toRounded,
        d: toRounded,
        bl: toHundred,
        dl: toHundred,
        mtp: toHundred,
        nor: toUrlSafe,
        rtp: toHundred,
        tb: toRounded
      };
      function processCmcd(obj, options) {
        var results = {};
        if (obj == null || typeof obj !== "object") {
          return results;
        }
        var keys = Object.keys(obj).sort();
        var formatters = _extends({}, CmcdFormatters, options == null ? undefined : options.formatters);
        var filter = options == null ? undefined : options.filter;
        keys.forEach(function(key) {
          if (filter != null && filter(key)) {
            return;
          }
          var value = obj[key];
          var formatter = formatters[key];
          if (formatter) {
            value = formatter(value, options);
          }
          if (key === "v" && value === 1) {
            return;
          }
          if (key == "pr" && value === 1) {
            return;
          }
          if (!isValid(value)) {
            return;
          }
          if (isTokenField(key) && typeof value === "string") {
            value = new SfToken(value);
          }
          results[key] = value;
        });
        return results;
      }
      function encodeCmcd(cmcd, options) {
        if (options === undefined) {
          options = {};
        }
        if (!cmcd) {
          return "";
        }
        return encodeSfDict(processCmcd(cmcd, options), _extends({
          whitespace: false
        }, options));
      }
      function toCmcdHeaders(cmcd, options) {
        var _options;
        if (options === undefined) {
          options = {};
        }
        if (!cmcd) {
          return {};
        }
        var entries = Object.entries(cmcd);
        var headerMap = Object.entries(CmcdHeaderMap).concat(Object.entries(((_options = options) == null ? undefined : _options.customHeaderMap) || {}));
        var shards = entries.reduce(function(acc, entry) {
          var _headerMap$find, _acc$field;
          var key = entry[0], value = entry[1];
          var field = ((_headerMap$find = headerMap.find(function(entry2) {
            return entry2[1].includes(key);
          })) == null ? undefined : _headerMap$find[0]) || CmcdHeaderField.REQUEST;
          (_acc$field = acc[field]) != null || (acc[field] = {});
          acc[field][key] = value;
          return acc;
        }, {});
        return Object.entries(shards).reduce(function(acc, _ref) {
          var field = _ref[0], value = _ref[1];
          acc[field] = encodeCmcd(value, options);
          return acc;
        }, {});
      }
      function appendCmcdHeaders(headers, cmcd, options) {
        return _extends(headers, toCmcdHeaders(cmcd, options));
      }
      var CMCD_PARAM = "CMCD";
      function toCmcdQuery(cmcd, options) {
        if (options === undefined) {
          options = {};
        }
        if (!cmcd) {
          return "";
        }
        var params = encodeCmcd(cmcd, options);
        return CMCD_PARAM + "=" + encodeURIComponent(params);
      }
      var REGEX = /CMCD=[^&#]+/;
      function appendCmcdQuery(url2, cmcd, options) {
        var query = toCmcdQuery(cmcd, options);
        if (!query) {
          return url2;
        }
        if (REGEX.test(url2)) {
          return url2.replace(REGEX, query);
        }
        var separator = url2.includes("?") ? "&" : "?";
        return "" + url2 + separator + query;
      }
      var CMCDController = /* @__PURE__ */ function() {
        function CMCDController2(hls) {
          var _this = this;
          this.hls = undefined;
          this.config = undefined;
          this.media = undefined;
          this.sid = undefined;
          this.cid = undefined;
          this.useHeaders = false;
          this.includeKeys = undefined;
          this.initialized = false;
          this.starved = false;
          this.buffering = true;
          this.audioBuffer = undefined;
          this.videoBuffer = undefined;
          this.onWaiting = function() {
            if (_this.initialized) {
              _this.starved = true;
            }
            _this.buffering = true;
          };
          this.onPlaying = function() {
            if (!_this.initialized) {
              _this.initialized = true;
            }
            _this.buffering = false;
          };
          this.applyPlaylistData = function(context) {
            try {
              _this.apply(context, {
                ot: CmObjectType.MANIFEST,
                su: !_this.initialized
              });
            } catch (error2) {
              logger.warn("Could not generate manifest CMCD data.", error2);
            }
          };
          this.applyFragmentData = function(context) {
            try {
              var fragment = context.frag;
              var level = _this.hls.levels[fragment.level];
              var ot = _this.getObjectType(fragment);
              var data = {
                d: fragment.duration * 1000,
                ot
              };
              if (ot === CmObjectType.VIDEO || ot === CmObjectType.AUDIO || ot == CmObjectType.MUXED) {
                data.br = level.bitrate / 1000;
                data.tb = _this.getTopBandwidth(ot) / 1000;
                data.bl = _this.getBufferLength(ot);
              }
              _this.apply(context, data);
            } catch (error2) {
              logger.warn("Could not generate segment CMCD data.", error2);
            }
          };
          this.hls = hls;
          var config = this.config = hls.config;
          var cmcd = config.cmcd;
          if (cmcd != null) {
            config.pLoader = this.createPlaylistLoader();
            config.fLoader = this.createFragmentLoader();
            this.sid = cmcd.sessionId || uuid();
            this.cid = cmcd.contentId;
            this.useHeaders = cmcd.useHeaders === true;
            this.includeKeys = cmcd.includeKeys;
            this.registerListeners();
          }
        }
        var _proto = CMCDController2.prototype;
        _proto.registerListeners = function registerListeners() {
          var hls = this.hls;
          hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);
          hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
        };
        _proto.unregisterListeners = function unregisterListeners() {
          var hls = this.hls;
          hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);
          hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
        };
        _proto.destroy = function destroy() {
          this.unregisterListeners();
          this.onMediaDetached();
          this.hls = this.config = this.audioBuffer = this.videoBuffer = null;
          this.onWaiting = this.onPlaying = null;
        };
        _proto.onMediaAttached = function onMediaAttached(event, data) {
          this.media = data.media;
          this.media.addEventListener("waiting", this.onWaiting);
          this.media.addEventListener("playing", this.onPlaying);
        };
        _proto.onMediaDetached = function onMediaDetached() {
          if (!this.media) {
            return;
          }
          this.media.removeEventListener("waiting", this.onWaiting);
          this.media.removeEventListener("playing", this.onPlaying);
          this.media = null;
        };
        _proto.onBufferCreated = function onBufferCreated(event, data) {
          var _data$tracks$audio, _data$tracks$video;
          this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? undefined : _data$tracks$audio.buffer;
          this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? undefined : _data$tracks$video.buffer;
        };
        _proto.createData = function createData() {
          var _this$media;
          return {
            v: 1,
            sf: CmStreamingFormat.HLS,
            sid: this.sid,
            cid: this.cid,
            pr: (_this$media = this.media) == null ? undefined : _this$media.playbackRate,
            mtp: this.hls.bandwidthEstimate / 1000
          };
        };
        _proto.apply = function apply(context, data) {
          if (data === undefined) {
            data = {};
          }
          _extends(data, this.createData());
          var isVideo = data.ot === CmObjectType.INIT || data.ot === CmObjectType.VIDEO || data.ot === CmObjectType.MUXED;
          if (this.starved && isVideo) {
            data.bs = true;
            data.su = true;
            this.starved = false;
          }
          if (data.su == null) {
            data.su = this.buffering;
          }
          var includeKeys = this.includeKeys;
          if (includeKeys) {
            data = Object.keys(data).reduce(function(acc, key) {
              includeKeys.includes(key) && (acc[key] = data[key]);
              return acc;
            }, {});
          }
          if (this.useHeaders) {
            if (!context.headers) {
              context.headers = {};
            }
            appendCmcdHeaders(context.headers, data);
          } else {
            context.url = appendCmcdQuery(context.url, data);
          }
        };
        _proto.getObjectType = function getObjectType(fragment) {
          var type = fragment.type;
          if (type === "subtitle") {
            return CmObjectType.TIMED_TEXT;
          }
          if (fragment.sn === "initSegment") {
            return CmObjectType.INIT;
          }
          if (type === "audio") {
            return CmObjectType.AUDIO;
          }
          if (type === "main") {
            if (!this.hls.audioTracks.length) {
              return CmObjectType.MUXED;
            }
            return CmObjectType.VIDEO;
          }
          return;
        };
        _proto.getTopBandwidth = function getTopBandwidth(type) {
          var bitrate = 0;
          var levels;
          var hls = this.hls;
          if (type === CmObjectType.AUDIO) {
            levels = hls.audioTracks;
          } else {
            var max = hls.maxAutoLevel;
            var len = max > -1 ? max + 1 : hls.levels.length;
            levels = hls.levels.slice(0, len);
          }
          for (var _iterator = _createForOfIteratorHelperLoose(levels), _step;!(_step = _iterator()).done; ) {
            var level = _step.value;
            if (level.bitrate > bitrate) {
              bitrate = level.bitrate;
            }
          }
          return bitrate > 0 ? bitrate : NaN;
        };
        _proto.getBufferLength = function getBufferLength(type) {
          var media = this.hls.media;
          var buffer = type === CmObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;
          if (!buffer || !media) {
            return NaN;
          }
          var info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);
          return info.len * 1000;
        };
        _proto.createPlaylistLoader = function createPlaylistLoader() {
          var pLoader = this.config.pLoader;
          var apply = this.applyPlaylistData;
          var Ctor = pLoader || this.config.loader;
          return /* @__PURE__ */ function() {
            function CmcdPlaylistLoader(config) {
              this.loader = undefined;
              this.loader = new Ctor(config);
            }
            var _proto2 = CmcdPlaylistLoader.prototype;
            _proto2.destroy = function destroy() {
              this.loader.destroy();
            };
            _proto2.abort = function abort() {
              this.loader.abort();
            };
            _proto2.load = function load(context, config, callbacks) {
              apply(context);
              this.loader.load(context, config, callbacks);
            };
            _createClass(CmcdPlaylistLoader, [{
              key: "stats",
              get: function get() {
                return this.loader.stats;
              }
            }, {
              key: "context",
              get: function get() {
                return this.loader.context;
              }
            }]);
            return CmcdPlaylistLoader;
          }();
        };
        _proto.createFragmentLoader = function createFragmentLoader() {
          var fLoader = this.config.fLoader;
          var apply = this.applyFragmentData;
          var Ctor = fLoader || this.config.loader;
          return /* @__PURE__ */ function() {
            function CmcdFragmentLoader(config) {
              this.loader = undefined;
              this.loader = new Ctor(config);
            }
            var _proto3 = CmcdFragmentLoader.prototype;
            _proto3.destroy = function destroy() {
              this.loader.destroy();
            };
            _proto3.abort = function abort() {
              this.loader.abort();
            };
            _proto3.load = function load(context, config, callbacks) {
              apply(context);
              this.loader.load(context, config, callbacks);
            };
            _createClass(CmcdFragmentLoader, [{
              key: "stats",
              get: function get() {
                return this.loader.stats;
              }
            }, {
              key: "context",
              get: function get() {
                return this.loader.context;
              }
            }]);
            return CmcdFragmentLoader;
          }();
        };
        return CMCDController2;
      }();
      var PATHWAY_PENALTY_DURATION_MS = 300000;
      var ContentSteeringController = /* @__PURE__ */ function() {
        function ContentSteeringController2(hls) {
          this.hls = undefined;
          this.log = undefined;
          this.loader = null;
          this.uri = null;
          this.pathwayId = ".";
          this.pathwayPriority = null;
          this.timeToLoad = 300;
          this.reloadTimer = -1;
          this.updated = 0;
          this.started = false;
          this.enabled = true;
          this.levels = null;
          this.audioTracks = null;
          this.subtitleTracks = null;
          this.penalizedPathways = {};
          this.hls = hls;
          this.log = logger.log.bind(logger, "[content-steering]:");
          this.registerListeners();
        }
        var _proto = ContentSteeringController2.prototype;
        _proto.registerListeners = function registerListeners() {
          var hls = this.hls;
          hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
          hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
          hls.on(Events.ERROR, this.onError, this);
        };
        _proto.unregisterListeners = function unregisterListeners() {
          var hls = this.hls;
          if (!hls) {
            return;
          }
          hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
          hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
          hls.off(Events.ERROR, this.onError, this);
        };
        _proto.startLoad = function startLoad() {
          this.started = true;
          this.clearTimeout();
          if (this.enabled && this.uri) {
            if (this.updated) {
              var ttl = this.timeToLoad * 1000 - (performance.now() - this.updated);
              if (ttl > 0) {
                this.scheduleRefresh(this.uri, ttl);
                return;
              }
            }
            this.loadSteeringManifest(this.uri);
          }
        };
        _proto.stopLoad = function stopLoad() {
          this.started = false;
          if (this.loader) {
            this.loader.destroy();
            this.loader = null;
          }
          this.clearTimeout();
        };
        _proto.clearTimeout = function clearTimeout() {
          if (this.reloadTimer !== -1) {
            self.clearTimeout(this.reloadTimer);
            this.reloadTimer = -1;
          }
        };
        _proto.destroy = function destroy() {
          this.unregisterListeners();
          this.stopLoad();
          this.hls = null;
          this.levels = this.audioTracks = this.subtitleTracks = null;
        };
        _proto.removeLevel = function removeLevel(levelToRemove) {
          var levels = this.levels;
          if (levels) {
            this.levels = levels.filter(function(level) {
              return level !== levelToRemove;
            });
          }
        };
        _proto.onManifestLoading = function onManifestLoading() {
          this.stopLoad();
          this.enabled = true;
          this.timeToLoad = 300;
          this.updated = 0;
          this.uri = null;
          this.pathwayId = ".";
          this.levels = this.audioTracks = this.subtitleTracks = null;
        };
        _proto.onManifestLoaded = function onManifestLoaded(event, data) {
          var contentSteering = data.contentSteering;
          if (contentSteering === null) {
            return;
          }
          this.pathwayId = contentSteering.pathwayId;
          this.uri = contentSteering.uri;
          if (this.started) {
            this.startLoad();
          }
        };
        _proto.onManifestParsed = function onManifestParsed(event, data) {
          this.audioTracks = data.audioTracks;
          this.subtitleTracks = data.subtitleTracks;
        };
        _proto.onError = function onError(event, data) {
          var errorAction = data.errorAction;
          if ((errorAction == null ? undefined : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {
            var levels = this.levels;
            var pathwayPriority = this.pathwayPriority;
            var errorPathway = this.pathwayId;
            if (data.context) {
              var _data$context = data.context, groupId = _data$context.groupId, _pathwayId = _data$context.pathwayId, type = _data$context.type;
              if (groupId && levels) {
                errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);
              } else if (_pathwayId) {
                errorPathway = _pathwayId;
              }
            }
            if (!(errorPathway in this.penalizedPathways)) {
              this.penalizedPathways[errorPathway] = performance.now();
            }
            if (!pathwayPriority && levels) {
              pathwayPriority = levels.reduce(function(pathways, level) {
                if (pathways.indexOf(level.pathwayId) === -1) {
                  pathways.push(level.pathwayId);
                }
                return pathways;
              }, []);
            }
            if (pathwayPriority && pathwayPriority.length > 1) {
              this.updatePathwayPriority(pathwayPriority);
              errorAction.resolved = this.pathwayId !== errorPathway;
            }
            if (!errorAction.resolved) {
              logger.warn("Could not resolve " + data.details + ' ("' + data.error.message + '") with content-steering for Pathway: ' + errorPathway + " levels: " + (levels ? levels.length : levels) + " priorities: " + JSON.stringify(pathwayPriority) + " penalized: " + JSON.stringify(this.penalizedPathways));
            }
          }
        };
        _proto.filterParsedLevels = function filterParsedLevels(levels) {
          this.levels = levels;
          var pathwayLevels = this.getLevelsForPathway(this.pathwayId);
          if (pathwayLevels.length === 0) {
            var _pathwayId2 = levels[0].pathwayId;
            this.log("No levels found in Pathway " + this.pathwayId + '. Setting initial Pathway to "' + _pathwayId2 + '"');
            pathwayLevels = this.getLevelsForPathway(_pathwayId2);
            this.pathwayId = _pathwayId2;
          }
          if (pathwayLevels.length !== levels.length) {
            this.log("Found " + pathwayLevels.length + "/" + levels.length + ' levels in Pathway "' + this.pathwayId + '"');
          }
          return pathwayLevels;
        };
        _proto.getLevelsForPathway = function getLevelsForPathway(pathwayId) {
          if (this.levels === null) {
            return [];
          }
          return this.levels.filter(function(level) {
            return pathwayId === level.pathwayId;
          });
        };
        _proto.updatePathwayPriority = function updatePathwayPriority(pathwayPriority) {
          this.pathwayPriority = pathwayPriority;
          var levels;
          var penalizedPathways = this.penalizedPathways;
          var now2 = performance.now();
          Object.keys(penalizedPathways).forEach(function(pathwayId) {
            if (now2 - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {
              delete penalizedPathways[pathwayId];
            }
          });
          for (var i = 0;i < pathwayPriority.length; i++) {
            var _pathwayId3 = pathwayPriority[i];
            if (_pathwayId3 in penalizedPathways) {
              continue;
            }
            if (_pathwayId3 === this.pathwayId) {
              return;
            }
            var selectedIndex = this.hls.nextLoadLevel;
            var selectedLevel = this.hls.levels[selectedIndex];
            levels = this.getLevelsForPathway(_pathwayId3);
            if (levels.length > 0) {
              this.log('Setting Pathway to "' + _pathwayId3 + '"');
              this.pathwayId = _pathwayId3;
              reassignFragmentLevelIndexes(levels);
              this.hls.trigger(Events.LEVELS_UPDATED, {
                levels
              });
              var levelAfterChange = this.hls.levels[selectedIndex];
              if (selectedLevel && levelAfterChange && this.levels) {
                if (levelAfterChange.attrs["STABLE-VARIANT-ID"] !== selectedLevel.attrs["STABLE-VARIANT-ID"] && levelAfterChange.bitrate !== selectedLevel.bitrate) {
                  this.log("Unstable Pathways change from bitrate " + selectedLevel.bitrate + " to " + levelAfterChange.bitrate);
                }
                this.hls.nextLoadLevel = selectedIndex;
              }
              break;
            }
          }
        };
        _proto.getPathwayForGroupId = function getPathwayForGroupId(groupId, type, defaultPathway) {
          var levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);
          for (var i = 0;i < levels.length; i++) {
            if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {
              return levels[i].pathwayId;
            }
          }
          return defaultPathway;
        };
        _proto.clonePathways = function clonePathways(pathwayClones) {
          var _this = this;
          var levels = this.levels;
          if (!levels) {
            return;
          }
          var audioGroupCloneMap = {};
          var subtitleGroupCloneMap = {};
          pathwayClones.forEach(function(pathwayClone) {
            var cloneId = pathwayClone.ID, baseId = pathwayClone["BASE-ID"], uriReplacement = pathwayClone["URI-REPLACEMENT"];
            if (levels.some(function(level) {
              return level.pathwayId === cloneId;
            })) {
              return;
            }
            var clonedVariants = _this.getLevelsForPathway(baseId).map(function(baseLevel) {
              var attributes = new AttrList(baseLevel.attrs);
              attributes["PATHWAY-ID"] = cloneId;
              var clonedAudioGroupId = attributes.AUDIO && attributes.AUDIO + "_clone_" + cloneId;
              var clonedSubtitleGroupId = attributes.SUBTITLES && attributes.SUBTITLES + "_clone_" + cloneId;
              if (clonedAudioGroupId) {
                audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;
                attributes.AUDIO = clonedAudioGroupId;
              }
              if (clonedSubtitleGroupId) {
                subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;
                attributes.SUBTITLES = clonedSubtitleGroupId;
              }
              var url2 = performUriReplacement(baseLevel.uri, attributes["STABLE-VARIANT-ID"], "PER-VARIANT-URIS", uriReplacement);
              var clonedLevel = new Level({
                attrs: attributes,
                audioCodec: baseLevel.audioCodec,
                bitrate: baseLevel.bitrate,
                height: baseLevel.height,
                name: baseLevel.name,
                url: url2,
                videoCodec: baseLevel.videoCodec,
                width: baseLevel.width
              });
              if (baseLevel.audioGroups) {
                for (var i = 1;i < baseLevel.audioGroups.length; i++) {
                  clonedLevel.addGroupId("audio", baseLevel.audioGroups[i] + "_clone_" + cloneId);
                }
              }
              if (baseLevel.subtitleGroups) {
                for (var _i = 1;_i < baseLevel.subtitleGroups.length; _i++) {
                  clonedLevel.addGroupId("text", baseLevel.subtitleGroups[_i] + "_clone_" + cloneId);
                }
              }
              return clonedLevel;
            });
            levels.push.apply(levels, clonedVariants);
            cloneRenditionGroups(_this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);
            cloneRenditionGroups(_this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);
          });
        };
        _proto.loadSteeringManifest = function loadSteeringManifest(uri) {
          var _this2 = this;
          var config = this.hls.config;
          var Loader = config.loader;
          if (this.loader) {
            this.loader.destroy();
          }
          this.loader = new Loader(config);
          var url2;
          try {
            url2 = new self.URL(uri);
          } catch (error2) {
            this.enabled = false;
            this.log("Failed to parse Steering Manifest URI: " + uri);
            return;
          }
          if (url2.protocol !== "data:") {
            var throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;
            url2.searchParams.set("_HLS_pathway", this.pathwayId);
            url2.searchParams.set("_HLS_throughput", "" + throughput);
          }
          var context = {
            responseType: "json",
            url: url2.href
          };
          var loadPolicy = config.steeringManifestLoadPolicy.default;
          var legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};
          var loaderConfig = {
            loadPolicy,
            timeout: loadPolicy.maxLoadTimeMs,
            maxRetry: legacyRetryCompatibility.maxNumRetry || 0,
            retryDelay: legacyRetryCompatibility.retryDelayMs || 0,
            maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0
          };
          var callbacks = {
            onSuccess: function onSuccess(response, stats, context2, networkDetails) {
              _this2.log('Loaded steering manifest: "' + url2 + '"');
              var steeringData = response.data;
              if (steeringData.VERSION !== 1) {
                _this2.log("Steering VERSION " + steeringData.VERSION + " not supported!");
                return;
              }
              _this2.updated = performance.now();
              _this2.timeToLoad = steeringData.TTL;
              var reloadUri = steeringData["RELOAD-URI"], pathwayClones = steeringData["PATHWAY-CLONES"], pathwayPriority = steeringData["PATHWAY-PRIORITY"];
              if (reloadUri) {
                try {
                  _this2.uri = new self.URL(reloadUri, url2).href;
                } catch (error2) {
                  _this2.enabled = false;
                  _this2.log("Failed to parse Steering Manifest RELOAD-URI: " + reloadUri);
                  return;
                }
              }
              _this2.scheduleRefresh(_this2.uri || context2.url);
              if (pathwayClones) {
                _this2.clonePathways(pathwayClones);
              }
              var loadedSteeringData = {
                steeringManifest: steeringData,
                url: url2.toString()
              };
              _this2.hls.trigger(Events.STEERING_MANIFEST_LOADED, loadedSteeringData);
              if (pathwayPriority) {
                _this2.updatePathwayPriority(pathwayPriority);
              }
            },
            onError: function onError(error2, context2, networkDetails, stats) {
              _this2.log("Error loading steering manifest: " + error2.code + " " + error2.text + " (" + context2.url + ")");
              _this2.stopLoad();
              if (error2.code === 410) {
                _this2.enabled = false;
                _this2.log("Steering manifest " + context2.url + " no longer available");
                return;
              }
              var ttl = _this2.timeToLoad * 1000;
              if (error2.code === 429) {
                var loader = _this2.loader;
                if (typeof (loader == null ? undefined : loader.getResponseHeader) === "function") {
                  var retryAfter = loader.getResponseHeader("Retry-After");
                  if (retryAfter) {
                    ttl = parseFloat(retryAfter) * 1000;
                  }
                }
                _this2.log("Steering manifest " + context2.url + " rate limited");
                return;
              }
              _this2.scheduleRefresh(_this2.uri || context2.url, ttl);
            },
            onTimeout: function onTimeout(stats, context2, networkDetails) {
              _this2.log("Timeout loading steering manifest (" + context2.url + ")");
              _this2.scheduleRefresh(_this2.uri || context2.url);
            }
          };
          this.log("Requesting steering manifest: " + url2);
          this.loader.load(context, loaderConfig, callbacks);
        };
        _proto.scheduleRefresh = function scheduleRefresh(uri, ttlMs) {
          var _this3 = this;
          if (ttlMs === undefined) {
            ttlMs = this.timeToLoad * 1000;
          }
          this.clearTimeout();
          this.reloadTimer = self.setTimeout(function() {
            var _this3$hls;
            var media = (_this3$hls = _this3.hls) == null ? undefined : _this3$hls.media;
            if (media && !media.ended) {
              _this3.loadSteeringManifest(uri);
              return;
            }
            _this3.scheduleRefresh(uri, _this3.timeToLoad * 1000);
          }, ttlMs);
        };
        return ContentSteeringController2;
      }();
      function cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {
        if (!tracks) {
          return;
        }
        Object.keys(groupCloneMap).forEach(function(audioGroupId) {
          var clonedTracks = tracks.filter(function(track) {
            return track.groupId === audioGroupId;
          }).map(function(track) {
            var clonedTrack = _extends({}, track);
            clonedTrack.details = undefined;
            clonedTrack.attrs = new AttrList(clonedTrack.attrs);
            clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs["STABLE-RENDITION-ID"], "PER-RENDITION-URIS", uriReplacement);
            clonedTrack.groupId = clonedTrack.attrs["GROUP-ID"] = groupCloneMap[audioGroupId];
            clonedTrack.attrs["PATHWAY-ID"] = cloneId;
            return clonedTrack;
          });
          tracks.push.apply(tracks, clonedTracks);
        });
      }
      function performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {
        var { HOST: host, PARAMS: params } = uriReplacement, perOptionUris = uriReplacement[perOptionKey];
        var perVariantUri;
        if (stableId) {
          perVariantUri = perOptionUris == null ? undefined : perOptionUris[stableId];
          if (perVariantUri) {
            uri = perVariantUri;
          }
        }
        var url2 = new self.URL(uri);
        if (host && !perVariantUri) {
          url2.host = host;
        }
        if (params) {
          Object.keys(params).sort().forEach(function(key) {
            if (key) {
              url2.searchParams.set(key, params[key]);
            }
          });
        }
        return url2.href;
      }
      var AGE_HEADER_LINE_REGEX = /^age:\s*[\d.]+\s*$/im;
      var XhrLoader = /* @__PURE__ */ function() {
        function XhrLoader2(config) {
          this.xhrSetup = undefined;
          this.requestTimeout = undefined;
          this.retryTimeout = undefined;
          this.retryDelay = undefined;
          this.config = null;
          this.callbacks = null;
          this.context = null;
          this.loader = null;
          this.stats = undefined;
          this.xhrSetup = config ? config.xhrSetup || null : null;
          this.stats = new LoadStats;
          this.retryDelay = 0;
        }
        var _proto = XhrLoader2.prototype;
        _proto.destroy = function destroy() {
          this.callbacks = null;
          this.abortInternal();
          this.loader = null;
          this.config = null;
          this.context = null;
          this.xhrSetup = null;
        };
        _proto.abortInternal = function abortInternal() {
          var loader = this.loader;
          self.clearTimeout(this.requestTimeout);
          self.clearTimeout(this.retryTimeout);
          if (loader) {
            loader.onreadystatechange = null;
            loader.onprogress = null;
            if (loader.readyState !== 4) {
              this.stats.aborted = true;
              loader.abort();
            }
          }
        };
        _proto.abort = function abort() {
          var _this$callbacks;
          this.abortInternal();
          if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
            this.callbacks.onAbort(this.stats, this.context, this.loader);
          }
        };
        _proto.load = function load(context, config, callbacks) {
          if (this.stats.loading.start) {
            throw new Error("Loader can only be used once.");
          }
          this.stats.loading.start = self.performance.now();
          this.context = context;
          this.config = config;
          this.callbacks = callbacks;
          this.loadInternal();
        };
        _proto.loadInternal = function loadInternal() {
          var _this = this;
          var config = this.config, context = this.context;
          if (!config || !context) {
            return;
          }
          var xhr = this.loader = new self.XMLHttpRequest;
          var stats = this.stats;
          stats.loading.first = 0;
          stats.loaded = 0;
          stats.aborted = false;
          var xhrSetup = this.xhrSetup;
          if (xhrSetup) {
            Promise.resolve().then(function() {
              if (_this.loader !== xhr || _this.stats.aborted)
                return;
              return xhrSetup(xhr, context.url);
            }).catch(function(error2) {
              if (_this.loader !== xhr || _this.stats.aborted)
                return;
              xhr.open("GET", context.url, true);
              return xhrSetup(xhr, context.url);
            }).then(function() {
              if (_this.loader !== xhr || _this.stats.aborted)
                return;
              _this.openAndSendXhr(xhr, context, config);
            }).catch(function(error2) {
              _this.callbacks.onError({
                code: xhr.status,
                text: error2.message
              }, context, xhr, stats);
              return;
            });
          } else {
            this.openAndSendXhr(xhr, context, config);
          }
        };
        _proto.openAndSendXhr = function openAndSendXhr(xhr, context, config) {
          if (!xhr.readyState) {
            xhr.open("GET", context.url, true);
          }
          var headers = context.headers;
          var _config$loadPolicy = config.loadPolicy, maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs, maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;
          if (headers) {
            for (var header in headers) {
              xhr.setRequestHeader(header, headers[header]);
            }
          }
          if (context.rangeEnd) {
            xhr.setRequestHeader("Range", "bytes=" + context.rangeStart + "-" + (context.rangeEnd - 1));
          }
          xhr.onreadystatechange = this.readystatechange.bind(this);
          xhr.onprogress = this.loadprogress.bind(this);
          xhr.responseType = context.responseType;
          self.clearTimeout(this.requestTimeout);
          config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
          this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);
          xhr.send();
        };
        _proto.readystatechange = function readystatechange() {
          var context = this.context, xhr = this.loader, stats = this.stats;
          if (!context || !xhr) {
            return;
          }
          var readyState = xhr.readyState;
          var config = this.config;
          if (stats.aborted) {
            return;
          }
          if (readyState >= 2) {
            if (stats.loading.first === 0) {
              stats.loading.first = Math.max(self.performance.now(), stats.loading.start);
              if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {
                self.clearTimeout(this.requestTimeout);
                config.timeout = config.loadPolicy.maxLoadTimeMs;
                this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));
              }
            }
            if (readyState === 4) {
              self.clearTimeout(this.requestTimeout);
              xhr.onreadystatechange = null;
              xhr.onprogress = null;
              var _status = xhr.status;
              var useResponseText = xhr.responseType === "text" ? xhr.responseText : null;
              if (_status >= 200 && _status < 300) {
                var data = useResponseText != null ? useResponseText : xhr.response;
                if (data != null) {
                  stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
                  var len = xhr.responseType === "arraybuffer" ? data.byteLength : data.length;
                  stats.loaded = stats.total = len;
                  stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);
                  if (!this.callbacks) {
                    return;
                  }
                  var onProgress = this.callbacks.onProgress;
                  if (onProgress) {
                    onProgress(stats, context, data, xhr);
                  }
                  if (!this.callbacks) {
                    return;
                  }
                  var _response = {
                    url: xhr.responseURL,
                    data,
                    code: _status
                  };
                  this.callbacks.onSuccess(_response, stats, context, xhr);
                  return;
                }
              }
              var retryConfig = config.loadPolicy.errorRetry;
              var retryCount = stats.retry;
              var response = {
                url: context.url,
                data: undefined,
                code: _status
              };
              if (shouldRetry(retryConfig, retryCount, false, response)) {
                this.retry(retryConfig);
              } else {
                logger.error(_status + " while loading " + context.url);
                this.callbacks.onError({
                  code: _status,
                  text: xhr.statusText
                }, context, xhr, stats);
              }
            }
          }
        };
        _proto.loadtimeout = function loadtimeout() {
          if (!this.config)
            return;
          var retryConfig = this.config.loadPolicy.timeoutRetry;
          var retryCount = this.stats.retry;
          if (shouldRetry(retryConfig, retryCount, true)) {
            this.retry(retryConfig);
          } else {
            var _this$context;
            logger.warn("timeout while loading " + ((_this$context = this.context) == null ? undefined : _this$context.url));
            var callbacks = this.callbacks;
            if (callbacks) {
              this.abortInternal();
              callbacks.onTimeout(this.stats, this.context, this.loader);
            }
          }
        };
        _proto.retry = function retry(retryConfig) {
          var context = this.context, stats = this.stats;
          this.retryDelay = getRetryDelay(retryConfig, stats.retry);
          stats.retry++;
          logger.warn((status ? "HTTP Status " + status : "Timeout") + " while loading " + (context == null ? undefined : context.url) + ", retrying " + stats.retry + "/" + retryConfig.maxNumRetry + " in " + this.retryDelay + "ms");
          this.abortInternal();
          this.loader = null;
          self.clearTimeout(this.retryTimeout);
          this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);
        };
        _proto.loadprogress = function loadprogress(event) {
          var stats = this.stats;
          stats.loaded = event.loaded;
          if (event.lengthComputable) {
            stats.total = event.total;
          }
        };
        _proto.getCacheAge = function getCacheAge() {
          var result = null;
          if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {
            var ageHeader = this.loader.getResponseHeader("age");
            result = ageHeader ? parseFloat(ageHeader) : null;
          }
          return result;
        };
        _proto.getResponseHeader = function getResponseHeader(name) {
          if (this.loader && new RegExp("^" + name + ":\\s*[\\d.]+\\s*$", "im").test(this.loader.getAllResponseHeaders())) {
            return this.loader.getResponseHeader(name);
          }
          return null;
        };
        return XhrLoader2;
      }();
      function fetchSupported() {
        if (self.fetch && self.AbortController && self.ReadableStream && self.Request) {
          try {
            new self.ReadableStream({});
            return true;
          } catch (e) {
          }
        }
        return false;
      }
      var BYTERANGE = /(\d+)-(\d+)\/(\d+)/;
      var FetchLoader = /* @__PURE__ */ function() {
        function FetchLoader2(config) {
          this.fetchSetup = undefined;
          this.requestTimeout = undefined;
          this.request = null;
          this.response = null;
          this.controller = undefined;
          this.context = null;
          this.config = null;
          this.callbacks = null;
          this.stats = undefined;
          this.loader = null;
          this.fetchSetup = config.fetchSetup || getRequest;
          this.controller = new self.AbortController;
          this.stats = new LoadStats;
        }
        var _proto = FetchLoader2.prototype;
        _proto.destroy = function destroy() {
          this.loader = this.callbacks = this.context = this.config = this.request = null;
          this.abortInternal();
          this.response = null;
          this.fetchSetup = this.controller = this.stats = null;
        };
        _proto.abortInternal = function abortInternal() {
          if (this.controller && !this.stats.loading.end) {
            this.stats.aborted = true;
            this.controller.abort();
          }
        };
        _proto.abort = function abort() {
          var _this$callbacks;
          this.abortInternal();
          if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {
            this.callbacks.onAbort(this.stats, this.context, this.response);
          }
        };
        _proto.load = function load(context, config, callbacks) {
          var _this = this;
          var stats = this.stats;
          if (stats.loading.start) {
            throw new Error("Loader can only be used once.");
          }
          stats.loading.start = self.performance.now();
          var initParams = getRequestParameters(context, this.controller.signal);
          var onProgress = callbacks.onProgress;
          var isArrayBuffer = context.responseType === "arraybuffer";
          var LENGTH = isArrayBuffer ? "byteLength" : "length";
          var _config$loadPolicy = config.loadPolicy, maxTimeToFirstByteMs = _config$loadPolicy.maxTimeToFirstByteMs, maxLoadTimeMs = _config$loadPolicy.maxLoadTimeMs;
          this.context = context;
          this.config = config;
          this.callbacks = callbacks;
          this.request = this.fetchSetup(context, initParams);
          self.clearTimeout(this.requestTimeout);
          config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;
          this.requestTimeout = self.setTimeout(function() {
            _this.abortInternal();
            callbacks.onTimeout(stats, context, _this.response);
          }, config.timeout);
          self.fetch(this.request).then(function(response) {
            _this.response = _this.loader = response;
            var first = Math.max(self.performance.now(), stats.loading.start);
            self.clearTimeout(_this.requestTimeout);
            config.timeout = maxLoadTimeMs;
            _this.requestTimeout = self.setTimeout(function() {
              _this.abortInternal();
              callbacks.onTimeout(stats, context, _this.response);
            }, maxLoadTimeMs - (first - stats.loading.start));
            if (!response.ok) {
              var { status: status2, statusText } = response;
              throw new FetchError(statusText || "fetch, bad network response", status2, response);
            }
            stats.loading.first = first;
            stats.total = getContentLength(response.headers) || stats.total;
            if (onProgress && isFiniteNumber(config.highWaterMark)) {
              return _this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);
            }
            if (isArrayBuffer) {
              return response.arrayBuffer();
            }
            if (context.responseType === "json") {
              return response.json();
            }
            return response.text();
          }).then(function(responseData) {
            var response = _this.response;
            if (!response) {
              throw new Error("loader destroyed");
            }
            self.clearTimeout(_this.requestTimeout);
            stats.loading.end = Math.max(self.performance.now(), stats.loading.first);
            var total = responseData[LENGTH];
            if (total) {
              stats.loaded = stats.total = total;
            }
            var loaderResponse = {
              url: response.url,
              data: responseData,
              code: response.status
            };
            if (onProgress && !isFiniteNumber(config.highWaterMark)) {
              onProgress(stats, context, responseData, response);
            }
            callbacks.onSuccess(loaderResponse, stats, context, response);
          }).catch(function(error2) {
            self.clearTimeout(_this.requestTimeout);
            if (stats.aborted) {
              return;
            }
            var code = !error2 ? 0 : error2.code || 0;
            var text = !error2 ? null : error2.message;
            callbacks.onError({
              code,
              text
            }, context, error2 ? error2.details : null, stats);
          });
        };
        _proto.getCacheAge = function getCacheAge() {
          var result = null;
          if (this.response) {
            var ageHeader = this.response.headers.get("age");
            result = ageHeader ? parseFloat(ageHeader) : null;
          }
          return result;
        };
        _proto.getResponseHeader = function getResponseHeader(name) {
          return this.response ? this.response.headers.get(name) : null;
        };
        _proto.loadProgressively = function loadProgressively(response, stats, context, highWaterMark, onProgress) {
          if (highWaterMark === undefined) {
            highWaterMark = 0;
          }
          var chunkCache = new ChunkCache;
          var reader = response.body.getReader();
          var pump = function pump() {
            return reader.read().then(function(data) {
              if (data.done) {
                if (chunkCache.dataLength) {
                  onProgress(stats, context, chunkCache.flush(), response);
                }
                return Promise.resolve(new ArrayBuffer(0));
              }
              var chunk = data.value;
              var len = chunk.length;
              stats.loaded += len;
              if (len < highWaterMark || chunkCache.dataLength) {
                chunkCache.push(chunk);
                if (chunkCache.dataLength >= highWaterMark) {
                  onProgress(stats, context, chunkCache.flush(), response);
                }
              } else {
                onProgress(stats, context, chunk, response);
              }
              return pump();
            }).catch(function() {
              return Promise.reject();
            });
          };
          return pump();
        };
        return FetchLoader2;
      }();
      function getRequestParameters(context, signal) {
        var initParams = {
          method: "GET",
          mode: "cors",
          credentials: "same-origin",
          signal,
          headers: new self.Headers(_extends({}, context.headers))
        };
        if (context.rangeEnd) {
          initParams.headers.set("Range", "bytes=" + context.rangeStart + "-" + String(context.rangeEnd - 1));
        }
        return initParams;
      }
      function getByteRangeLength(byteRangeHeader) {
        var result = BYTERANGE.exec(byteRangeHeader);
        if (result) {
          return parseInt(result[2]) - parseInt(result[1]) + 1;
        }
      }
      function getContentLength(headers) {
        var contentRange = headers.get("Content-Range");
        if (contentRange) {
          var byteRangeLength = getByteRangeLength(contentRange);
          if (isFiniteNumber(byteRangeLength)) {
            return byteRangeLength;
          }
        }
        var contentLength = headers.get("Content-Length");
        if (contentLength) {
          return parseInt(contentLength);
        }
      }
      function getRequest(context, initParams) {
        return new self.Request(context.url, initParams);
      }
      var FetchError = /* @__PURE__ */ function(_Error) {
        _inheritsLoose(FetchError2, _Error);
        function FetchError2(message, code, details) {
          var _this2;
          _this2 = _Error.call(this, message) || this;
          _this2.code = undefined;
          _this2.details = undefined;
          _this2.code = code;
          _this2.details = details;
          return _this2;
        }
        return FetchError2;
      }(/* @__PURE__ */ _wrapNativeSuper(Error));
      var WHITESPACE_CHAR = /\s/;
      var Cues = {
        newCue: function newCue(track, startTime, endTime, captionScreen) {
          var result = [];
          var row;
          var cue;
          var indenting;
          var indent;
          var text;
          var Cue = self.VTTCue || self.TextTrackCue;
          for (var r = 0;r < captionScreen.rows.length; r++) {
            row = captionScreen.rows[r];
            indenting = true;
            indent = 0;
            text = "";
            if (!row.isEmpty()) {
              var _track$cues;
              for (var c = 0;c < row.chars.length; c++) {
                if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {
                  indent++;
                } else {
                  text += row.chars[c].uchar;
                  indenting = false;
                }
              }
              row.cueStartTime = startTime;
              if (startTime === endTime) {
                endTime += 0.0001;
              }
              if (indent >= 16) {
                indent--;
              } else {
                indent++;
              }
              var cueText = fixLineBreaks(text.trim());
              var id = generateCueId(startTime, endTime, cueText);
              if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {
                cue = new Cue(startTime, endTime, cueText);
                cue.id = id;
                cue.line = r + 1;
                cue.align = "left";
                cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);
                result.push(cue);
              }
            }
          }
          if (track && result.length) {
            result.sort(function(cueA, cueB) {
              if (cueA.line === "auto" || cueB.line === "auto") {
                return 0;
              }
              if (cueA.line > 8 && cueB.line > 8) {
                return cueB.line - cueA.line;
              }
              return cueA.line - cueB.line;
            });
            result.forEach(function(cue2) {
              return addCueToTrack(track, cue2);
            });
          }
          return result;
        }
      };
      var defaultLoadPolicy = {
        maxTimeToFirstByteMs: 8000,
        maxLoadTimeMs: 20000,
        timeoutRetry: null,
        errorRetry: null
      };
      var hlsDefaultConfig = _objectSpread2(_objectSpread2({
        autoStartLoad: true,
        startPosition: -1,
        defaultAudioCodec: undefined,
        debug: false,
        capLevelOnFPSDrop: false,
        capLevelToPlayerSize: false,
        ignoreDevicePixelRatio: false,
        preferManagedMediaSource: true,
        initialLiveManifestSize: 1,
        maxBufferLength: 30,
        backBufferLength: Infinity,
        frontBufferFlushThreshold: Infinity,
        maxBufferSize: 60 * 1000 * 1000,
        maxBufferHole: 0.1,
        highBufferWatchdogPeriod: 2,
        nudgeOffset: 0.1,
        nudgeMaxRetry: 3,
        maxFragLookUpTolerance: 0.25,
        liveSyncDurationCount: 3,
        liveMaxLatencyDurationCount: Infinity,
        liveSyncDuration: undefined,
        liveMaxLatencyDuration: undefined,
        maxLiveSyncPlaybackRate: 1,
        liveDurationInfinity: false,
        liveBackBufferLength: null,
        maxMaxBufferLength: 600,
        enableWorker: true,
        workerPath: null,
        enableSoftwareAES: true,
        startLevel: undefined,
        startFragPrefetch: false,
        fpsDroppedMonitoringPeriod: 5000,
        fpsDroppedMonitoringThreshold: 0.2,
        appendErrorMaxRetry: 3,
        loader: XhrLoader,
        fLoader: undefined,
        pLoader: undefined,
        xhrSetup: undefined,
        licenseXhrSetup: undefined,
        licenseResponseCallback: undefined,
        abrController: AbrController,
        bufferController: BufferController,
        capLevelController: CapLevelController,
        errorController: ErrorController,
        fpsController: FPSController,
        stretchShortVideoTrack: false,
        maxAudioFramesDrift: 1,
        forceKeyFrameOnDiscontinuity: true,
        abrEwmaFastLive: 3,
        abrEwmaSlowLive: 9,
        abrEwmaFastVoD: 3,
        abrEwmaSlowVoD: 9,
        abrEwmaDefaultEstimate: 500000,
        abrEwmaDefaultEstimateMax: 5000000,
        abrBandWidthFactor: 0.95,
        abrBandWidthUpFactor: 0.7,
        abrMaxWithRealBitrate: false,
        maxStarvationDelay: 4,
        maxLoadingDelay: 4,
        minAutoBitrate: 0,
        emeEnabled: false,
        widevineLicenseUrl: undefined,
        drmSystems: {},
        drmSystemOptions: {},
        requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess,
        testBandwidth: true,
        progressive: false,
        lowLatencyMode: true,
        cmcd: undefined,
        enableDateRangeMetadataCues: true,
        enableEmsgMetadataCues: true,
        enableID3MetadataCues: true,
        useMediaCapabilities: true,
        certLoadPolicy: {
          default: defaultLoadPolicy
        },
        keyLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 8000,
            maxLoadTimeMs: 20000,
            timeoutRetry: {
              maxNumRetry: 1,
              retryDelayMs: 1000,
              maxRetryDelayMs: 20000,
              backoff: "linear"
            },
            errorRetry: {
              maxNumRetry: 8,
              retryDelayMs: 1000,
              maxRetryDelayMs: 20000,
              backoff: "linear"
            }
          }
        },
        manifestLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: Infinity,
            maxLoadTimeMs: 20000,
            timeoutRetry: {
              maxNumRetry: 2,
              retryDelayMs: 0,
              maxRetryDelayMs: 0
            },
            errorRetry: {
              maxNumRetry: 1,
              retryDelayMs: 1000,
              maxRetryDelayMs: 8000
            }
          }
        },
        playlistLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 20000,
            timeoutRetry: {
              maxNumRetry: 2,
              retryDelayMs: 0,
              maxRetryDelayMs: 0
            },
            errorRetry: {
              maxNumRetry: 2,
              retryDelayMs: 1000,
              maxRetryDelayMs: 8000
            }
          }
        },
        fragLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 120000,
            timeoutRetry: {
              maxNumRetry: 4,
              retryDelayMs: 0,
              maxRetryDelayMs: 0
            },
            errorRetry: {
              maxNumRetry: 6,
              retryDelayMs: 1000,
              maxRetryDelayMs: 8000
            }
          }
        },
        steeringManifestLoadPolicy: {
          default: {
            maxTimeToFirstByteMs: 1e4,
            maxLoadTimeMs: 20000,
            timeoutRetry: {
              maxNumRetry: 2,
              retryDelayMs: 0,
              maxRetryDelayMs: 0
            },
            errorRetry: {
              maxNumRetry: 1,
              retryDelayMs: 1000,
              maxRetryDelayMs: 8000
            }
          }
        },
        manifestLoadingTimeOut: 1e4,
        manifestLoadingMaxRetry: 1,
        manifestLoadingRetryDelay: 1000,
        manifestLoadingMaxRetryTimeout: 64000,
        levelLoadingTimeOut: 1e4,
        levelLoadingMaxRetry: 4,
        levelLoadingRetryDelay: 1000,
        levelLoadingMaxRetryTimeout: 64000,
        fragLoadingTimeOut: 20000,
        fragLoadingMaxRetry: 6,
        fragLoadingRetryDelay: 1000,
        fragLoadingMaxRetryTimeout: 64000
      }, timelineConfig()), {}, {
        subtitleStreamController: SubtitleStreamController,
        subtitleTrackController: SubtitleTrackController,
        timelineController: TimelineController,
        audioStreamController: AudioStreamController,
        audioTrackController: AudioTrackController,
        emeController: EMEController,
        cmcdController: CMCDController,
        contentSteeringController: ContentSteeringController
      });
      function timelineConfig() {
        return {
          cueHandler: Cues,
          enableWebVTT: true,
          enableIMSC1: true,
          enableCEA708Captions: true,
          captionsTextTrack1Label: "English",
          captionsTextTrack1LanguageCode: "en",
          captionsTextTrack2Label: "Spanish",
          captionsTextTrack2LanguageCode: "es",
          captionsTextTrack3Label: "Unknown CC",
          captionsTextTrack3LanguageCode: "",
          captionsTextTrack4Label: "Unknown CC",
          captionsTextTrack4LanguageCode: "",
          renderTextTracksNatively: true
        };
      }
      function mergeConfig(defaultConfig, userConfig) {
        if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {
          throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration");
        }
        if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {
          throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be greater than "liveSyncDurationCount"');
        }
        if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {
          throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be greater than "liveSyncDuration"');
        }
        var defaultsCopy = deepCpy(defaultConfig);
        var deprecatedSettingTypes = ["manifest", "level", "frag"];
        var deprecatedSettings = ["TimeOut", "MaxRetry", "RetryDelay", "MaxRetryTimeout"];
        deprecatedSettingTypes.forEach(function(type) {
          var policyName = (type === "level" ? "playlist" : type) + "LoadPolicy";
          var policyNotSet = userConfig[policyName] === undefined;
          var report = [];
          deprecatedSettings.forEach(function(setting) {
            var deprecatedSetting = type + "Loading" + setting;
            var value = userConfig[deprecatedSetting];
            if (value !== undefined && policyNotSet) {
              report.push(deprecatedSetting);
              var settings = defaultsCopy[policyName].default;
              userConfig[policyName] = {
                default: settings
              };
              switch (setting) {
                case "TimeOut":
                  settings.maxLoadTimeMs = value;
                  settings.maxTimeToFirstByteMs = value;
                  break;
                case "MaxRetry":
                  settings.errorRetry.maxNumRetry = value;
                  settings.timeoutRetry.maxNumRetry = value;
                  break;
                case "RetryDelay":
                  settings.errorRetry.retryDelayMs = value;
                  settings.timeoutRetry.retryDelayMs = value;
                  break;
                case "MaxRetryTimeout":
                  settings.errorRetry.maxRetryDelayMs = value;
                  settings.timeoutRetry.maxRetryDelayMs = value;
                  break;
              }
            }
          });
          if (report.length) {
            logger.warn('hls.js config: "' + report.join('", "') + '" setting(s) are deprecated, use "' + policyName + '": ' + JSON.stringify(userConfig[policyName]));
          }
        });
        return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);
      }
      function deepCpy(obj) {
        if (obj && typeof obj === "object") {
          if (Array.isArray(obj)) {
            return obj.map(deepCpy);
          }
          return Object.keys(obj).reduce(function(result, key) {
            result[key] = deepCpy(obj[key]);
            return result;
          }, {});
        }
        return obj;
      }
      function enableStreamingMode(config) {
        var currentLoader = config.loader;
        if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {
          logger.log("[config]: Custom loader detected, cannot enable progressive streaming");
          config.progressive = false;
        } else {
          var canStreamProgressively = fetchSupported();
          if (canStreamProgressively) {
            config.loader = FetchLoader;
            config.progressive = true;
            config.enableSoftwareAES = true;
            logger.log("[config]: Progressive streaming enabled, using FetchLoader");
          }
        }
      }
      var chromeOrFirefox;
      var LevelController = /* @__PURE__ */ function(_BasePlaylistControll) {
        _inheritsLoose(LevelController2, _BasePlaylistControll);
        function LevelController2(hls, contentSteeringController) {
          var _this;
          _this = _BasePlaylistControll.call(this, hls, "[level-controller]") || this;
          _this._levels = [];
          _this._firstLevel = -1;
          _this._maxAutoLevel = -1;
          _this._startLevel = undefined;
          _this.currentLevel = null;
          _this.currentLevelIndex = -1;
          _this.manualLevelIndex = -1;
          _this.steering = undefined;
          _this.onParsedComplete = undefined;
          _this.steering = contentSteeringController;
          _this._registerListeners();
          return _this;
        }
        var _proto = LevelController2.prototype;
        _proto._registerListeners = function _registerListeners() {
          var hls = this.hls;
          hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
          hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
          hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
          hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
          hls.on(Events.ERROR, this.onError, this);
        };
        _proto._unregisterListeners = function _unregisterListeners() {
          var hls = this.hls;
          hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);
          hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
          hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
          hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
          hls.off(Events.ERROR, this.onError, this);
        };
        _proto.destroy = function destroy() {
          this._unregisterListeners();
          this.steering = null;
          this.resetLevels();
          _BasePlaylistControll.prototype.destroy.call(this);
        };
        _proto.stopLoad = function stopLoad() {
          var levels = this._levels;
          levels.forEach(function(level) {
            level.loadError = 0;
            level.fragmentError = 0;
          });
          _BasePlaylistControll.prototype.stopLoad.call(this);
        };
        _proto.resetLevels = function resetLevels() {
          this._startLevel = undefined;
          this.manualLevelIndex = -1;
          this.currentLevelIndex = -1;
          this.currentLevel = null;
          this._levels = [];
          this._maxAutoLevel = -1;
        };
        _proto.onManifestLoading = function onManifestLoading(event, data) {
          this.resetLevels();
        };
        _proto.onManifestLoaded = function onManifestLoaded(event, data) {
          var preferManagedMediaSource = this.hls.config.preferManagedMediaSource;
          var levels = [];
          var redundantSet = {};
          var generatePathwaySet = {};
          var resolutionFound = false;
          var videoCodecFound = false;
          var audioCodecFound = false;
          data.levels.forEach(function(levelParsed) {
            var _audioCodec, _videoCodec;
            var attributes = levelParsed.attrs;
            var { audioCodec, videoCodec } = levelParsed;
            if (((_audioCodec = audioCodec) == null ? undefined : _audioCodec.indexOf("mp4a.40.34")) !== -1) {
              chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));
              if (chromeOrFirefox) {
                levelParsed.audioCodec = audioCodec = undefined;
              }
            }
            if (audioCodec) {
              levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource);
            }
            if (((_videoCodec = videoCodec) == null ? undefined : _videoCodec.indexOf("avc1")) === 0) {
              videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);
            }
            var { width, height, unknownCodecs } = levelParsed;
            resolutionFound || (resolutionFound = !!(width && height));
            videoCodecFound || (videoCodecFound = !!videoCodec);
            audioCodecFound || (audioCodecFound = !!audioCodec);
            if (unknownCodecs != null && unknownCodecs.length || audioCodec && !areCodecsMediaSourceSupported(audioCodec, "audio", preferManagedMediaSource) || videoCodec && !areCodecsMediaSourceSupported(videoCodec, "video", preferManagedMediaSource)) {
              return;
            }
            var CODECS = attributes.CODECS, FRAMERATE = attributes["FRAME-RATE"], HDCP = attributes["HDCP-LEVEL"], PATHWAY = attributes["PATHWAY-ID"], RESOLUTION = attributes.RESOLUTION, VIDEO_RANGE = attributes["VIDEO-RANGE"];
            var contentSteeringPrefix = (PATHWAY || ".") + "-";
            var levelKey = "" + contentSteeringPrefix + levelParsed.bitrate + "-" + RESOLUTION + "-" + FRAMERATE + "-" + CODECS + "-" + VIDEO_RANGE + "-" + HDCP;
            if (!redundantSet[levelKey]) {
              var level = new Level(levelParsed);
              redundantSet[levelKey] = level;
              generatePathwaySet[levelKey] = 1;
              levels.push(level);
            } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs["PATHWAY-ID"]) {
              var pathwayCount = generatePathwaySet[levelKey] += 1;
              levelParsed.attrs["PATHWAY-ID"] = new Array(pathwayCount + 1).join(".");
              var _level = new Level(levelParsed);
              redundantSet[levelKey] = _level;
              levels.push(_level);
            } else {
              redundantSet[levelKey].addGroupId("audio", attributes.AUDIO);
              redundantSet[levelKey].addGroupId("text", attributes.SUBTITLES);
            }
          });
          this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);
        };
        _proto.filterAndSortMediaOptions = function filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {
          var _this2 = this;
          var audioTracks = [];
          var subtitleTracks = [];
          var levels = filteredLevels;
          if ((resolutionFound || videoCodecFound) && audioCodecFound) {
            levels = levels.filter(function(_ref) {
              var { videoCodec, videoRange, width, height } = _ref;
              return (!!videoCodec || !!(width && height)) && isVideoRange(videoRange);
            });
          }
          if (levels.length === 0) {
            Promise.resolve().then(function() {
              if (_this2.hls) {
                if (data.levels.length) {
                  _this2.warn("One or more CODECS in variant not supported: " + JSON.stringify(data.levels[0].attrs));
                }
                var error2 = new Error("no level with compatible codecs found in manifest");
                _this2.hls.trigger(Events.ERROR, {
                  type: ErrorTypes2.MEDIA_ERROR,
                  details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,
                  fatal: true,
                  url: data.url,
                  error: error2,
                  reason: error2.message
                });
              }
            });
            return;
          }
          if (data.audioTracks) {
            var preferManagedMediaSource = this.hls.config.preferManagedMediaSource;
            audioTracks = data.audioTracks.filter(function(track) {
              return !track.audioCodec || areCodecsMediaSourceSupported(track.audioCodec, "audio", preferManagedMediaSource);
            });
            assignTrackIdsByGroup(audioTracks);
          }
          if (data.subtitles) {
            subtitleTracks = data.subtitles;
            assignTrackIdsByGroup(subtitleTracks);
          }
          var unsortedLevels = levels.slice(0);
          levels.sort(function(a, b) {
            if (a.attrs["HDCP-LEVEL"] !== b.attrs["HDCP-LEVEL"]) {
              return (a.attrs["HDCP-LEVEL"] || "") > (b.attrs["HDCP-LEVEL"] || "") ? 1 : -1;
            }
            if (resolutionFound && a.height !== b.height) {
              return a.height - b.height;
            }
            if (a.frameRate !== b.frameRate) {
              return a.frameRate - b.frameRate;
            }
            if (a.videoRange !== b.videoRange) {
              return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);
            }
            if (a.videoCodec !== b.videoCodec) {
              var valueA = videoCodecPreferenceValue(a.videoCodec);
              var valueB = videoCodecPreferenceValue(b.videoCodec);
              if (valueA !== valueB) {
                return valueB - valueA;
              }
            }
            if (a.uri === b.uri && a.codecSet !== b.codecSet) {
              var _valueA = codecsSetSelectionPreferenceValue(a.codecSet);
              var _valueB = codecsSetSelectionPreferenceValue(b.codecSet);
              if (_valueA !== _valueB) {
                return _valueB - _valueA;
              }
            }
            if (a.averageBitrate !== b.averageBitrate) {
              return a.averageBitrate - b.averageBitrate;
            }
            return 0;
          });
          var firstLevelInPlaylist = unsortedLevels[0];
          if (this.steering) {
            levels = this.steering.filterParsedLevels(levels);
            if (levels.length !== unsortedLevels.length) {
              for (var i = 0;i < unsortedLevels.length; i++) {
                if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {
                  firstLevelInPlaylist = unsortedLevels[i];
                  break;
                }
              }
            }
          }
          this._levels = levels;
          for (var _i = 0;_i < levels.length; _i++) {
            if (levels[_i] === firstLevelInPlaylist) {
              var _this$hls$userConfig;
              this._firstLevel = _i;
              var firstLevelBitrate = firstLevelInPlaylist.bitrate;
              var bandwidthEstimate = this.hls.bandwidthEstimate;
              this.log("manifest loaded, " + levels.length + " level(s) found, first bitrate: " + firstLevelBitrate);
              if (((_this$hls$userConfig = this.hls.userConfig) == null ? undefined : _this$hls$userConfig.abrEwmaDefaultEstimate) === undefined) {
                var startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);
                if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === hlsDefaultConfig.abrEwmaDefaultEstimate) {
                  this.hls.bandwidthEstimate = startingBwEstimate;
                }
              }
              break;
            }
          }
          var audioOnly = audioCodecFound && !videoCodecFound;
          var edata = {
            levels,
            audioTracks,
            subtitleTracks,
            sessionData: data.sessionData,
            sessionKeys: data.sessionKeys,
            firstLevel: this._firstLevel,
            stats: data.stats,
            audio: audioCodecFound,
            video: videoCodecFound,
            altAudio: !audioOnly && audioTracks.some(function(t) {
              return !!t.url;
            })
          };
          this.hls.trigger(Events.MANIFEST_PARSED, edata);
          if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {
            this.hls.startLoad(this.hls.config.startPosition);
          }
        };
        _proto.onError = function onError(event, data) {
          if (data.fatal || !data.context) {
            return;
          }
          if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {
            this.checkRetry(data);
          }
        };
        _proto.onFragBuffered = function onFragBuffered(event, _ref2) {
          var frag = _ref2.frag;
          if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {
            var el = frag.elementaryStreams;
            if (!Object.keys(el).some(function(type) {
              return !!el[type];
            })) {
              return;
            }
            var level = this._levels[frag.level];
            if (level != null && level.loadError) {
              this.log("Resetting level error count of " + level.loadError + " on frag buffered");
              level.loadError = 0;
            }
          }
        };
        _proto.onLevelLoaded = function onLevelLoaded(event, data) {
          var _data$deliveryDirecti2;
          var { level, details } = data;
          var curLevel = this._levels[level];
          if (!curLevel) {
            var _data$deliveryDirecti;
            this.warn("Invalid level index " + level);
            if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {
              details.deltaUpdateFailed = true;
            }
            return;
          }
          if (level === this.currentLevelIndex) {
            if (curLevel.fragmentError === 0) {
              curLevel.loadError = 0;
            }
            this.playlistLoaded(level, data, curLevel.details);
          } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {
            details.deltaUpdateFailed = true;
          }
        };
        _proto.loadPlaylist = function loadPlaylist(hlsUrlParameters) {
          _BasePlaylistControll.prototype.loadPlaylist.call(this);
          var currentLevelIndex = this.currentLevelIndex;
          var currentLevel = this.currentLevel;
          if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {
            var url2 = currentLevel.uri;
            if (hlsUrlParameters) {
              try {
                url2 = hlsUrlParameters.addDirectives(url2);
              } catch (error2) {
                this.warn("Could not construct new URL with HLS Delivery Directives: " + error2);
              }
            }
            var pathwayId = currentLevel.attrs["PATHWAY-ID"];
            this.log("Loading level index " + currentLevelIndex + ((hlsUrlParameters == null ? undefined : hlsUrlParameters.msn) !== undefined ? " at sn " + hlsUrlParameters.msn + " part " + hlsUrlParameters.part : "") + " with" + (pathwayId ? " Pathway " + pathwayId : "") + " " + url2);
            this.clearTimer();
            this.hls.trigger(Events.LEVEL_LOADING, {
              url: url2,
              level: currentLevelIndex,
              pathwayId: currentLevel.attrs["PATHWAY-ID"],
              id: 0,
              deliveryDirectives: hlsUrlParameters || null
            });
          }
        };
        _proto.removeLevel = function removeLevel(levelIndex) {
          var _this3 = this, _this$currentLevel;
          var levels = this._levels.filter(function(level, index) {
            if (index !== levelIndex) {
              return true;
            }
            if (_this3.steering) {
              _this3.steering.removeLevel(level);
            }
            if (level === _this3.currentLevel) {
              _this3.currentLevel = null;
              _this3.currentLevelIndex = -1;
              if (level.details) {
                level.details.fragments.forEach(function(f) {
                  return f.level = -1;
                });
              }
            }
            return false;
          });
          reassignFragmentLevelIndexes(levels);
          this._levels = levels;
          if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {
            this.currentLevelIndex = this.currentLevel.details.fragments[0].level;
          }
          this.hls.trigger(Events.LEVELS_UPDATED, {
            levels
          });
        };
        _proto.onLevelsUpdated = function onLevelsUpdated(event, _ref3) {
          var levels = _ref3.levels;
          this._levels = levels;
        };
        _proto.checkMaxAutoUpdated = function checkMaxAutoUpdated() {
          var _this$hls = this.hls, autoLevelCapping = _this$hls.autoLevelCapping, maxAutoLevel = _this$hls.maxAutoLevel, maxHdcpLevel = _this$hls.maxHdcpLevel;
          if (this._maxAutoLevel !== maxAutoLevel) {
            this._maxAutoLevel = maxAutoLevel;
            this.hls.trigger(Events.MAX_AUTO_LEVEL_UPDATED, {
              autoLevelCapping,
              levels: this.levels,
              maxAutoLevel,
              minAutoLevel: this.hls.minAutoLevel,
              maxHdcpLevel
            });
          }
        };
        _createClass(LevelController2, [{
          key: "levels",
          get: function get() {
            if (this._levels.length === 0) {
              return null;
            }
            return this._levels;
          }
        }, {
          key: "level",
          get: function get() {
            return this.currentLevelIndex;
          },
          set: function set(newLevel) {
            var levels = this._levels;
            if (levels.length === 0) {
              return;
            }
            if (newLevel < 0 || newLevel >= levels.length) {
              var error2 = new Error("invalid level idx");
              var fatal = newLevel < 0;
              this.hls.trigger(Events.ERROR, {
                type: ErrorTypes2.OTHER_ERROR,
                details: ErrorDetails.LEVEL_SWITCH_ERROR,
                level: newLevel,
                fatal,
                error: error2,
                reason: error2.message
              });
              if (fatal) {
                return;
              }
              newLevel = Math.min(newLevel, levels.length - 1);
            }
            var lastLevelIndex = this.currentLevelIndex;
            var lastLevel = this.currentLevel;
            var lastPathwayId = lastLevel ? lastLevel.attrs["PATHWAY-ID"] : undefined;
            var level = levels[newLevel];
            var pathwayId = level.attrs["PATHWAY-ID"];
            this.currentLevelIndex = newLevel;
            this.currentLevel = level;
            if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {
              return;
            }
            this.log("Switching to level " + newLevel + " (" + (level.height ? level.height + "p " : "") + (level.videoRange ? level.videoRange + " " : "") + (level.codecSet ? level.codecSet + " " : "") + "@" + level.bitrate + ")" + (pathwayId ? " with Pathway " + pathwayId : "") + " from level " + lastLevelIndex + (lastPathwayId ? " with Pathway " + lastPathwayId : ""));
            var levelSwitchingData = {
              level: newLevel,
              attrs: level.attrs,
              details: level.details,
              bitrate: level.bitrate,
              averageBitrate: level.averageBitrate,
              maxBitrate: level.maxBitrate,
              realBitrate: level.realBitrate,
              width: level.width,
              height: level.height,
              codecSet: level.codecSet,
              audioCodec: level.audioCodec,
              videoCodec: level.videoCodec,
              audioGroups: level.audioGroups,
              subtitleGroups: level.subtitleGroups,
              loaded: level.loaded,
              loadError: level.loadError,
              fragmentError: level.fragmentError,
              name: level.name,
              id: level.id,
              uri: level.uri,
              url: level.url,
              urlId: 0,
              audioGroupIds: level.audioGroupIds,
              textGroupIds: level.textGroupIds
            };
            this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);
            var levelDetails = level.details;
            if (!levelDetails || levelDetails.live) {
              var hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? undefined : lastLevel.details, levelDetails);
              this.loadPlaylist(hlsUrlParameters);
            }
          }
        }, {
          key: "manualLevel",
          get: function get() {
            return this.manualLevelIndex;
          },
          set: function set(newLevel) {
            this.manualLevelIndex = newLevel;
            if (this._startLevel === undefined) {
              this._startLevel = newLevel;
            }
            if (newLevel !== -1) {
              this.level = newLevel;
            }
          }
        }, {
          key: "firstLevel",
          get: function get() {
            return this._firstLevel;
          },
          set: function set(newLevel) {
            this._firstLevel = newLevel;
          }
        }, {
          key: "startLevel",
          get: function get() {
            if (this._startLevel === undefined) {
              var configStartLevel = this.hls.config.startLevel;
              if (configStartLevel !== undefined) {
                return configStartLevel;
              }
              return this.hls.firstAutoLevel;
            }
            return this._startLevel;
          },
          set: function set(newLevel) {
            this._startLevel = newLevel;
          }
        }, {
          key: "nextLoadLevel",
          get: function get() {
            if (this.manualLevelIndex !== -1) {
              return this.manualLevelIndex;
            } else {
              return this.hls.nextAutoLevel;
            }
          },
          set: function set(nextLevel) {
            this.level = nextLevel;
            if (this.manualLevelIndex === -1) {
              this.hls.nextAutoLevel = nextLevel;
            }
          }
        }]);
        return LevelController2;
      }(BasePlaylistController);
      function assignTrackIdsByGroup(tracks) {
        var groups = {};
        tracks.forEach(function(track) {
          var groupId = track.groupId || "";
          track.id = groups[groupId] = groups[groupId] || 0;
          groups[groupId]++;
        });
      }
      var KeyLoader = /* @__PURE__ */ function() {
        function KeyLoader2(config) {
          this.config = undefined;
          this.keyUriToKeyInfo = {};
          this.emeController = null;
          this.config = config;
        }
        var _proto = KeyLoader2.prototype;
        _proto.abort = function abort(type) {
          for (var uri in this.keyUriToKeyInfo) {
            var loader = this.keyUriToKeyInfo[uri].loader;
            if (loader) {
              var _loader$context;
              if (type && type !== ((_loader$context = loader.context) == null ? undefined : _loader$context.frag.type)) {
                return;
              }
              loader.abort();
            }
          }
        };
        _proto.detach = function detach() {
          for (var uri in this.keyUriToKeyInfo) {
            var keyInfo = this.keyUriToKeyInfo[uri];
            if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {
              delete this.keyUriToKeyInfo[uri];
            }
          }
        };
        _proto.destroy = function destroy() {
          this.detach();
          for (var uri in this.keyUriToKeyInfo) {
            var loader = this.keyUriToKeyInfo[uri].loader;
            if (loader) {
              loader.destroy();
            }
          }
          this.keyUriToKeyInfo = {};
        };
        _proto.createKeyLoadError = function createKeyLoadError(frag, details, error2, networkDetails, response) {
          if (details === undefined) {
            details = ErrorDetails.KEY_LOAD_ERROR;
          }
          return new LoadError({
            type: ErrorTypes2.NETWORK_ERROR,
            details,
            fatal: false,
            frag,
            response,
            error: error2,
            networkDetails
          });
        };
        _proto.loadClear = function loadClear(loadingFrag, encryptedFragments) {
          var _this = this;
          if (this.emeController && this.config.emeEnabled) {
            var { sn, cc } = loadingFrag;
            var _loop = function _loop() {
              var frag = encryptedFragments[i];
              if (cc <= frag.cc && (sn === "initSegment" || frag.sn === "initSegment" || sn < frag.sn)) {
                _this.emeController.selectKeySystemFormat(frag).then(function(keySystemFormat) {
                  frag.setKeyFormat(keySystemFormat);
                });
                return 1;
              }
            };
            for (var i = 0;i < encryptedFragments.length; i++) {
              if (_loop())
                break;
            }
          }
        };
        _proto.load = function load(frag) {
          var _this2 = this;
          if (!frag.decryptdata && frag.encrypted && this.emeController) {
            return this.emeController.selectKeySystemFormat(frag).then(function(keySystemFormat) {
              return _this2.loadInternal(frag, keySystemFormat);
            });
          }
          return this.loadInternal(frag);
        };
        _proto.loadInternal = function loadInternal(frag, keySystemFormat) {
          var _keyInfo, _keyInfo2;
          if (keySystemFormat) {
            frag.setKeyFormat(keySystemFormat);
          }
          var decryptdata = frag.decryptdata;
          if (!decryptdata) {
            var error2 = new Error(keySystemFormat ? "Expected frag.decryptdata to be defined after setting format " + keySystemFormat : "Missing decryption data on fragment in onKeyLoading");
            return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error2));
          }
          var uri = decryptdata.uri;
          if (!uri) {
            return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('Invalid key URI: "' + uri + '"')));
          }
          var keyInfo = this.keyUriToKeyInfo[uri];
          if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {
            decryptdata.key = keyInfo.decryptdata.key;
            return Promise.resolve({
              frag,
              keyInfo
            });
          }
          if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {
            var _keyInfo$mediaKeySess;
            switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? undefined : _keyInfo$mediaKeySess.keyStatus) {
              case undefined:
              case "status-pending":
              case "usable":
              case "usable-in-future":
                return keyInfo.keyLoadPromise.then(function(keyLoadedData) {
                  decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;
                  return {
                    frag,
                    keyInfo
                  };
                });
            }
          }
          keyInfo = this.keyUriToKeyInfo[uri] = {
            decryptdata,
            keyLoadPromise: null,
            loader: null,
            mediaKeySessionContext: null
          };
          switch (decryptdata.method) {
            case "ISO-23001-7":
            case "SAMPLE-AES":
            case "SAMPLE-AES-CENC":
            case "SAMPLE-AES-CTR":
              if (decryptdata.keyFormat === "identity") {
                return this.loadKeyHTTP(keyInfo, frag);
              }
              return this.loadKeyEME(keyInfo, frag);
            case "AES-128":
              return this.loadKeyHTTP(keyInfo, frag);
            default:
              return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('Key supplied with unsupported METHOD: "' + decryptdata.method + '"')));
          }
        };
        _proto.loadKeyEME = function loadKeyEME(keyInfo, frag) {
          var keyLoadedData = {
            frag,
            keyInfo
          };
          if (this.emeController && this.config.emeEnabled) {
            var keySessionContextPromise = this.emeController.loadKey(keyLoadedData);
            if (keySessionContextPromise) {
              return (keyInfo.keyLoadPromise = keySessionContextPromise.then(function(keySessionContext) {
                keyInfo.mediaKeySessionContext = keySessionContext;
                return keyLoadedData;
              })).catch(function(error2) {
                keyInfo.keyLoadPromise = null;
                throw error2;
              });
            }
          }
          return Promise.resolve(keyLoadedData);
        };
        _proto.loadKeyHTTP = function loadKeyHTTP(keyInfo, frag) {
          var _this3 = this;
          var config = this.config;
          var Loader = config.loader;
          var keyLoader = new Loader(config);
          frag.keyLoader = keyInfo.loader = keyLoader;
          return keyInfo.keyLoadPromise = new Promise(function(resolve, reject) {
            var loaderContext = {
              keyInfo,
              frag,
              responseType: "arraybuffer",
              url: keyInfo.decryptdata.uri
            };
            var loadPolicy = config.keyLoadPolicy.default;
            var loaderConfig = {
              loadPolicy,
              timeout: loadPolicy.maxLoadTimeMs,
              maxRetry: 0,
              retryDelay: 0,
              maxRetryDelay: 0
            };
            var loaderCallbacks = {
              onSuccess: function onSuccess(response, stats, context, networkDetails) {
                var { frag: frag2, keyInfo: keyInfo2, url: uri } = context;
                if (!frag2.decryptdata || keyInfo2 !== _this3.keyUriToKeyInfo[uri]) {
                  return reject(_this3.createKeyLoadError(frag2, ErrorDetails.KEY_LOAD_ERROR, new Error("after key load, decryptdata unset or changed"), networkDetails));
                }
                keyInfo2.decryptdata.key = frag2.decryptdata.key = new Uint8Array(response.data);
                frag2.keyLoader = null;
                keyInfo2.loader = null;
                resolve({
                  frag: frag2,
                  keyInfo: keyInfo2
                });
              },
              onError: function onError(response, context, networkDetails, stats) {
                _this3.resetLoader(context);
                reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error("HTTP Error " + response.code + " loading key " + response.text), networkDetails, _objectSpread2({
                  url: loaderContext.url,
                  data: undefined
                }, response)));
              },
              onTimeout: function onTimeout(stats, context, networkDetails) {
                _this3.resetLoader(context);
                reject(_this3.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error("key loading timed out"), networkDetails));
              },
              onAbort: function onAbort(stats, context, networkDetails) {
                _this3.resetLoader(context);
                reject(_this3.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error("key loading aborted"), networkDetails));
              }
            };
            keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);
          });
        };
        _proto.resetLoader = function resetLoader(context) {
          var { frag, keyInfo, url: uri } = context;
          var loader = keyInfo.loader;
          if (frag.keyLoader === loader) {
            frag.keyLoader = null;
            keyInfo.loader = null;
          }
          delete this.keyUriToKeyInfo[uri];
          if (loader) {
            loader.destroy();
          }
        };
        return KeyLoader2;
      }();
      function getSourceBuffer() {
        return self.SourceBuffer || self.WebKitSourceBuffer;
      }
      function isMSESupported() {
        var mediaSource = getMediaSource();
        if (!mediaSource) {
          return false;
        }
        var sourceBuffer = getSourceBuffer();
        return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === "function" && typeof sourceBuffer.prototype.remove === "function";
      }
      function isSupported() {
        if (!isMSESupported()) {
          return false;
        }
        var mediaSource = getMediaSource();
        return typeof (mediaSource == null ? undefined : mediaSource.isTypeSupported) === "function" && (["avc1.42E01E,mp4a.40.2", "av01.0.01M.08", "vp09.00.50.08"].some(function(codecsForVideoContainer) {
          return mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, "video"));
        }) || ["mp4a.40.2", "fLaC"].some(function(codecForAudioContainer) {
          return mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, "audio"));
        }));
      }
      function changeTypeSupported() {
        var _sourceBuffer$prototy;
        var sourceBuffer = getSourceBuffer();
        return typeof (sourceBuffer == null ? undefined : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? undefined : _sourceBuffer$prototy.changeType) === "function";
      }
      var STALL_MINIMUM_DURATION_MS = 250;
      var MAX_START_GAP_JUMP = 2;
      var SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;
      var SKIP_BUFFER_RANGE_START = 0.05;
      var GapController = /* @__PURE__ */ function() {
        function GapController2(config, media, fragmentTracker, hls) {
          this.config = undefined;
          this.media = null;
          this.fragmentTracker = undefined;
          this.hls = undefined;
          this.nudgeRetry = 0;
          this.stallReported = false;
          this.stalled = null;
          this.moved = false;
          this.seeking = false;
          this.config = config;
          this.media = media;
          this.fragmentTracker = fragmentTracker;
          this.hls = hls;
        }
        var _proto = GapController2.prototype;
        _proto.destroy = function destroy() {
          this.media = null;
          this.hls = this.fragmentTracker = null;
        };
        _proto.poll = function poll(lastCurrentTime, activeFrag) {
          var config = this.config, media = this.media, stalled = this.stalled;
          if (media === null) {
            return;
          }
          var { currentTime, seeking } = media;
          var seeked = this.seeking && !seeking;
          var beginSeek = !this.seeking && seeking;
          this.seeking = seeking;
          if (currentTime !== lastCurrentTime) {
            this.moved = true;
            if (!seeking) {
              this.nudgeRetry = 0;
            }
            if (stalled !== null) {
              if (this.stallReported) {
                var _stalledDuration = self.performance.now() - stalled;
                logger.warn("playback not stuck anymore @" + currentTime + ", after " + Math.round(_stalledDuration) + "ms");
                this.stallReported = false;
              }
              this.stalled = null;
            }
            return;
          }
          if (beginSeek || seeked) {
            this.stalled = null;
            return;
          }
          if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {
            this.nudgeRetry = 0;
            return;
          }
          var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
          var nextStart = bufferInfo.nextStart || 0;
          if (seeking) {
            var hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;
            var noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);
            if (hasEnoughBuffer || noBufferGap) {
              return;
            }
            this.moved = false;
          }
          if (!this.moved && this.stalled !== null) {
            var _level$details;
            var isBuffered = bufferInfo.len > 0;
            if (!isBuffered && !nextStart) {
              return;
            }
            var startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;
            var level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;
            var isLive = level == null ? undefined : (_level$details = level.details) == null ? undefined : _level$details.live;
            var maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;
            var partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);
            if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {
              if (!media.paused) {
                this._trySkipBufferHole(partialOrGap);
              }
              return;
            }
          }
          var tnow = self.performance.now();
          if (stalled === null) {
            this.stalled = tnow;
            return;
          }
          var stalledDuration = tnow - stalled;
          if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {
            this._reportStall(bufferInfo);
            if (!this.media) {
              return;
            }
          }
          var bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);
          this._tryFixBufferStall(bufferedWithHoles, stalledDuration);
        };
        _proto._tryFixBufferStall = function _tryFixBufferStall(bufferInfo, stalledDurationMs) {
          var config = this.config, fragmentTracker = this.fragmentTracker, media = this.media;
          if (media === null) {
            return;
          }
          var currentTime = media.currentTime;
          var partial = fragmentTracker.getPartialFragment(currentTime);
          if (partial) {
            var targetTime = this._trySkipBufferHole(partial);
            if (targetTime || !this.media) {
              return;
            }
          }
          if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {
            logger.warn("Trying to nudge playhead over buffer-hole");
            this.stalled = null;
            this._tryNudgeBuffer();
          }
        };
        _proto._reportStall = function _reportStall(bufferInfo) {
          var hls = this.hls, media = this.media, stallReported = this.stallReported;
          if (!stallReported && media) {
            this.stallReported = true;
            var error2 = new Error("Playback stalling at @" + media.currentTime + " due to low buffer (" + JSON.stringify(bufferInfo) + ")");
            logger.warn(error2.message);
            hls.trigger(Events.ERROR, {
              type: ErrorTypes2.MEDIA_ERROR,
              details: ErrorDetails.BUFFER_STALLED_ERROR,
              fatal: false,
              error: error2,
              buffer: bufferInfo.len
            });
          }
        };
        _proto._trySkipBufferHole = function _trySkipBufferHole(partial) {
          var config = this.config, hls = this.hls, media = this.media;
          if (media === null) {
            return 0;
          }
          var currentTime = media.currentTime;
          var bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);
          var startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;
          if (startTime) {
            var bufferStarved = bufferInfo.len <= config.maxBufferHole;
            var waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;
            var gapLength = startTime - currentTime;
            if (gapLength > 0 && (bufferStarved || waiting)) {
              if (gapLength > config.maxBufferHole) {
                var fragmentTracker = this.fragmentTracker;
                var startGap = false;
                if (currentTime === 0) {
                  var startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);
                  if (startFrag && startTime < startFrag.end) {
                    startGap = true;
                  }
                }
                if (!startGap) {
                  var startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);
                  if (startProvisioned) {
                    var moreToLoad = false;
                    var pos = startProvisioned.end;
                    while (pos < startTime) {
                      var provisioned = fragmentTracker.getPartialFragment(pos);
                      if (provisioned) {
                        pos += provisioned.duration;
                      } else {
                        moreToLoad = true;
                        break;
                      }
                    }
                    if (moreToLoad) {
                      return 0;
                    }
                  }
                }
              }
              var targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);
              logger.warn("skipping hole, adjusting currentTime from " + currentTime + " to " + targetTime);
              this.moved = true;
              this.stalled = null;
              media.currentTime = targetTime;
              if (partial && !partial.gap) {
                var error2 = new Error("fragment loaded with buffer holes, seeking from " + currentTime + " to " + targetTime);
                hls.trigger(Events.ERROR, {
                  type: ErrorTypes2.MEDIA_ERROR,
                  details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,
                  fatal: false,
                  error: error2,
                  reason: error2.message,
                  frag: partial
                });
              }
              return targetTime;
            }
          }
          return 0;
        };
        _proto._tryNudgeBuffer = function _tryNudgeBuffer() {
          var config = this.config, hls = this.hls, media = this.media, nudgeRetry = this.nudgeRetry;
          if (media === null) {
            return;
          }
          var currentTime = media.currentTime;
          this.nudgeRetry++;
          if (nudgeRetry < config.nudgeMaxRetry) {
            var targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;
            var error2 = new Error("Nudging 'currentTime' from " + currentTime + " to " + targetTime);
            logger.warn(error2.message);
            media.currentTime = targetTime;
            hls.trigger(Events.ERROR, {
              type: ErrorTypes2.MEDIA_ERROR,
              details: ErrorDetails.BUFFER_NUDGE_ON_STALL,
              error: error2,
              fatal: false
            });
          } else {
            var _error = new Error("Playhead still not moving while enough data buffered @" + currentTime + " after " + config.nudgeMaxRetry + " nudges");
            logger.error(_error.message);
            hls.trigger(Events.ERROR, {
              type: ErrorTypes2.MEDIA_ERROR,
              details: ErrorDetails.BUFFER_STALLED_ERROR,
              error: _error,
              fatal: true
            });
          }
        };
        return GapController2;
      }();
      var TICK_INTERVAL = 100;
      var StreamController = /* @__PURE__ */ function(_BaseStreamController) {
        _inheritsLoose(StreamController2, _BaseStreamController);
        function StreamController2(hls, fragmentTracker, keyLoader) {
          var _this;
          _this = _BaseStreamController.call(this, hls, fragmentTracker, keyLoader, "[stream-controller]", PlaylistLevelType.MAIN) || this;
          _this.audioCodecSwap = false;
          _this.gapController = null;
          _this.level = -1;
          _this._forceStartLoad = false;
          _this.altAudio = false;
          _this.audioOnly = false;
          _this.fragPlaying = null;
          _this.onvplaying = null;
          _this.onvseeked = null;
          _this.fragLastKbps = 0;
          _this.couldBacktrack = false;
          _this.backtrackFragment = null;
          _this.audioCodecSwitch = false;
          _this.videoBuffer = null;
          _this._registerListeners();
          return _this;
        }
        var _proto = StreamController2.prototype;
        _proto._registerListeners = function _registerListeners() {
          var hls = this.hls;
          hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);
          hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);
          hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);
          hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
          hls.on(Events.ERROR, this.onError, this);
          hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
          hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
          hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);
          hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
          hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
          hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        };
        _proto._unregisterListeners = function _unregisterListeners() {
          var hls = this.hls;
          hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);
          hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);
          hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);
          hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);
          hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);
          hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);
          hls.off(Events.ERROR, this.onError, this);
          hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);
          hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);
          hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);
          hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);
          hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);
          hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);
        };
        _proto.onHandlerDestroying = function onHandlerDestroying() {
          this._unregisterListeners();
          _BaseStreamController.prototype.onHandlerDestroying.call(this);
        };
        _proto.startLoad = function startLoad(startPosition) {
          if (this.levels) {
            var lastCurrentTime = this.lastCurrentTime, hls = this.hls;
            this.stopLoad();
            this.setInterval(TICK_INTERVAL);
            this.level = -1;
            if (!this.startFragRequested) {
              var startLevel = hls.startLevel;
              if (startLevel === -1) {
                if (hls.config.testBandwidth && this.levels.length > 1) {
                  startLevel = 0;
                  this.bitrateTest = true;
                } else {
                  startLevel = hls.firstAutoLevel;
                }
              }
              hls.nextLoadLevel = startLevel;
              this.level = hls.loadLevel;
              this.loadedmetadata = false;
            }
            if (lastCurrentTime > 0 && startPosition === -1) {
              this.log("Override startPosition with lastCurrentTime @" + lastCurrentTime.toFixed(3));
              startPosition = lastCurrentTime;
            }
            this.state = State.IDLE;
            this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;
            this.tick();
          } else {
            this._forceStartLoad = true;
            this.state = State.STOPPED;
          }
        };
        _proto.stopLoad = function stopLoad() {
          this._forceStartLoad = false;
          _BaseStreamController.prototype.stopLoad.call(this);
        };
        _proto.doTick = function doTick() {
          switch (this.state) {
            case State.WAITING_LEVEL: {
              var levels = this.levels, level = this.level;
              var currentLevel = levels == null ? undefined : levels[level];
              var details = currentLevel == null ? undefined : currentLevel.details;
              if (details && (!details.live || this.levelLastLoaded === currentLevel)) {
                if (this.waitForCdnTuneIn(details)) {
                  break;
                }
                this.state = State.IDLE;
                break;
              } else if (this.hls.nextLoadLevel !== this.level) {
                this.state = State.IDLE;
                break;
              }
              break;
            }
            case State.FRAG_LOADING_WAITING_RETRY:
              {
                var _this$media;
                var now2 = self.performance.now();
                var retryDate = this.retryDate;
                if (!retryDate || now2 >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {
                  var _levels = this.levels, _level = this.level;
                  var _currentLevel = _levels == null ? undefined : _levels[_level];
                  this.resetStartWhenNotLoaded(_currentLevel || null);
                  this.state = State.IDLE;
                }
              }
              break;
          }
          if (this.state === State.IDLE) {
            this.doTickIdle();
          }
          this.onTickEnd();
        };
        _proto.onTickEnd = function onTickEnd() {
          _BaseStreamController.prototype.onTickEnd.call(this);
          this.checkBuffer();
          this.checkFragmentChanged();
        };
        _proto.doTickIdle = function doTickIdle() {
          var hls = this.hls, levelLastLoaded = this.levelLastLoaded, levels = this.levels, media = this.media;
          if (levelLastLoaded === null || !media && (this.startFragRequested || !hls.config.startFragPrefetch)) {
            return;
          }
          if (this.altAudio && this.audioOnly) {
            return;
          }
          var level = this.buffering ? hls.nextLoadLevel : hls.loadLevel;
          if (!(levels != null && levels[level])) {
            return;
          }
          var levelInfo = levels[level];
          var bufferInfo = this.getMainFwdBufferInfo();
          if (bufferInfo === null) {
            return;
          }
          var lastDetails = this.getLevelDetails();
          if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {
            var data = {};
            if (this.altAudio) {
              data.type = "video";
            }
            this.hls.trigger(Events.BUFFER_EOS, data);
            this.state = State.ENDED;
            return;
          }
          if (!this.buffering) {
            return;
          }
          if (hls.loadLevel !== level && hls.manualLevel === -1) {
            this.log("Adapting to level " + level + " from level " + this.level);
          }
          this.level = hls.nextLoadLevel = level;
          var levelDetails = levelInfo.details;
          if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== levelInfo) {
            this.level = level;
            this.state = State.WAITING_LEVEL;
            return;
          }
          var bufferLen = bufferInfo.len;
          var maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);
          if (bufferLen >= maxBufLen) {
            return;
          }
          if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {
            this.backtrackFragment = null;
          }
          var targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;
          var frag = this.getNextFragment(targetBufferTime, levelDetails);
          if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== "initSegment" && this.fragmentTracker.getState(frag) !== FragmentState.OK) {
            var _this$backtrackFragme;
            var backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;
            var fragIdx = backtrackSn - levelDetails.startSN;
            var backtrackFrag = levelDetails.fragments[fragIdx - 1];
            if (backtrackFrag && frag.cc === backtrackFrag.cc) {
              frag = backtrackFrag;
              this.fragmentTracker.removeFragment(backtrackFrag);
            }
          } else if (this.backtrackFragment && bufferInfo.len) {
            this.backtrackFragment = null;
          }
          if (frag && this.isLoopLoading(frag, targetBufferTime)) {
            var gapStart = frag.gap;
            if (!gapStart) {
              var type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;
              var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
              if (mediaBuffer) {
                this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
              }
            }
            frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);
          }
          if (!frag) {
            return;
          }
          if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {
            frag = frag.initSegment;
          }
          this.loadFragment(frag, levelInfo, targetBufferTime);
        };
        _proto.loadFragment = function loadFragment(frag, level, targetBufferTime) {
          var fragState = this.fragmentTracker.getState(frag);
          this.fragCurrent = frag;
          if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {
            if (frag.sn === "initSegment") {
              this._loadInitSegment(frag, level);
            } else if (this.bitrateTest) {
              this.log("Fragment " + frag.sn + " of level " + frag.level + " is being downloaded to test bitrate and will not be buffered");
              this._loadBitrateTestFrag(frag, level);
            } else {
              this.startFragRequested = true;
              _BaseStreamController.prototype.loadFragment.call(this, frag, level, targetBufferTime);
            }
          } else {
            this.clearTrackerIfNeeded(frag);
          }
        };
        _proto.getBufferedFrag = function getBufferedFrag(position) {
          return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);
        };
        _proto.followingBufferedFrag = function followingBufferedFrag(frag) {
          if (frag) {
            return this.getBufferedFrag(frag.end + 0.5);
          }
          return null;
        };
        _proto.immediateLevelSwitch = function immediateLevelSwitch() {
          this.abortCurrentFrag();
          this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
        };
        _proto.nextLevelSwitch = function nextLevelSwitch() {
          var levels = this.levels, media = this.media;
          if (media != null && media.readyState) {
            var fetchdelay;
            var fragPlayingCurrent = this.getAppendedFrag(media.currentTime);
            if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {
              this.flushMainBuffer(0, fragPlayingCurrent.start - 1);
            }
            var levelDetails = this.getLevelDetails();
            if (levelDetails != null && levelDetails.live) {
              var bufferInfo = this.getMainFwdBufferInfo();
              if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {
                return;
              }
            }
            if (!media.paused && levels) {
              var nextLevelId = this.hls.nextLoadLevel;
              var nextLevel = levels[nextLevelId];
              var fragLastKbps = this.fragLastKbps;
              if (fragLastKbps && this.fragCurrent) {
                fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;
              } else {
                fetchdelay = 0;
              }
            } else {
              fetchdelay = 0;
            }
            var bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);
            if (bufferedFrag) {
              var nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);
              if (nextBufferedFrag) {
                this.abortCurrentFrag();
                var maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;
                var fragDuration = nextBufferedFrag.duration;
                var startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));
                this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);
              }
            }
          }
        };
        _proto.abortCurrentFrag = function abortCurrentFrag() {
          var fragCurrent = this.fragCurrent;
          this.fragCurrent = null;
          this.backtrackFragment = null;
          if (fragCurrent) {
            fragCurrent.abortRequests();
            this.fragmentTracker.removeFragment(fragCurrent);
          }
          switch (this.state) {
            case State.KEY_LOADING:
            case State.FRAG_LOADING:
            case State.FRAG_LOADING_WAITING_RETRY:
            case State.PARSING:
            case State.PARSED:
              this.state = State.IDLE;
              break;
          }
          this.nextLoadPosition = this.getLoadPosition();
        };
        _proto.flushMainBuffer = function flushMainBuffer(startOffset, endOffset) {
          _BaseStreamController.prototype.flushMainBuffer.call(this, startOffset, endOffset, this.altAudio ? "video" : null);
        };
        _proto.onMediaAttached = function onMediaAttached(event, data) {
          _BaseStreamController.prototype.onMediaAttached.call(this, event, data);
          var media = data.media;
          this.onvplaying = this.onMediaPlaying.bind(this);
          this.onvseeked = this.onMediaSeeked.bind(this);
          media.addEventListener("playing", this.onvplaying);
          media.addEventListener("seeked", this.onvseeked);
          this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);
        };
        _proto.onMediaDetaching = function onMediaDetaching() {
          var media = this.media;
          if (media && this.onvplaying && this.onvseeked) {
            media.removeEventListener("playing", this.onvplaying);
            media.removeEventListener("seeked", this.onvseeked);
            this.onvplaying = this.onvseeked = null;
            this.videoBuffer = null;
          }
          this.fragPlaying = null;
          if (this.gapController) {
            this.gapController.destroy();
            this.gapController = null;
          }
          _BaseStreamController.prototype.onMediaDetaching.call(this);
        };
        _proto.onMediaPlaying = function onMediaPlaying() {
          this.tick();
        };
        _proto.onMediaSeeked = function onMediaSeeked() {
          var media = this.media;
          var currentTime = media ? media.currentTime : null;
          if (isFiniteNumber(currentTime)) {
            this.log("Media seeked to " + currentTime.toFixed(3));
          }
          var bufferInfo = this.getMainFwdBufferInfo();
          if (bufferInfo === null || bufferInfo.len === 0) {
            this.warn('Main forward buffer length on "seeked" event ' + (bufferInfo ? bufferInfo.len : "empty") + ")");
            return;
          }
          this.tick();
        };
        _proto.onManifestLoading = function onManifestLoading() {
          this.log("Trigger BUFFER_RESET");
          this.hls.trigger(Events.BUFFER_RESET, undefined);
          this.fragmentTracker.removeAllFragments();
          this.couldBacktrack = false;
          this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0;
          this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null;
          this.altAudio = this.audioOnly = this.startFragRequested = false;
        };
        _proto.onManifestParsed = function onManifestParsed(event, data) {
          var aac = false;
          var heaac = false;
          data.levels.forEach(function(level) {
            var codec = level.audioCodec;
            if (codec) {
              aac = aac || codec.indexOf("mp4a.40.2") !== -1;
              heaac = heaac || codec.indexOf("mp4a.40.5") !== -1;
            }
          });
          this.audioCodecSwitch = aac && heaac && !changeTypeSupported();
          if (this.audioCodecSwitch) {
            this.log("Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC");
          }
          this.levels = data.levels;
          this.startFragRequested = false;
        };
        _proto.onLevelLoading = function onLevelLoading(event, data) {
          var levels = this.levels;
          if (!levels || this.state !== State.IDLE) {
            return;
          }
          var level = levels[data.level];
          if (!level.details || level.details.live && this.levelLastLoaded !== level || this.waitForCdnTuneIn(level.details)) {
            this.state = State.WAITING_LEVEL;
          }
        };
        _proto.onLevelLoaded = function onLevelLoaded(event, data) {
          var _curLevel$details;
          var levels = this.levels;
          var newLevelId = data.level;
          var newDetails = data.details;
          var duration = newDetails.totalduration;
          if (!levels) {
            this.warn("Levels were reset while loading level " + newLevelId);
            return;
          }
          this.log("Level " + newLevelId + " loaded [" + newDetails.startSN + "," + newDetails.endSN + "]" + (newDetails.lastPartSn ? "[part-" + newDetails.lastPartSn + "-" + newDetails.lastPartIndex + "]" : "") + ", cc [" + newDetails.startCC + ", " + newDetails.endCC + "] duration:" + duration);
          var curLevel = levels[newLevelId];
          var fragCurrent = this.fragCurrent;
          if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {
            if (fragCurrent.level !== data.level && fragCurrent.loader) {
              this.abortCurrentFrag();
            }
          }
          var sliding = 0;
          if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {
            var _this$levelLastLoaded;
            this.checkLiveUpdate(newDetails);
            if (newDetails.deltaUpdateFailed) {
              return;
            }
            sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? undefined : _this$levelLastLoaded.details);
          }
          curLevel.details = newDetails;
          this.levelLastLoaded = curLevel;
          this.hls.trigger(Events.LEVEL_UPDATED, {
            details: newDetails,
            level: newLevelId
          });
          if (this.state === State.WAITING_LEVEL) {
            if (this.waitForCdnTuneIn(newDetails)) {
              return;
            }
            this.state = State.IDLE;
          }
          if (!this.startFragRequested) {
            this.setStartPosition(newDetails, sliding);
          } else if (newDetails.live) {
            this.synchronizeToLiveEdge(newDetails);
          }
          this.tick();
        };
        _proto._handleFragmentLoadProgress = function _handleFragmentLoadProgress(data) {
          var _frag$initSegment;
          var { frag, part, payload } = data;
          var levels = this.levels;
          if (!levels) {
            this.warn("Levels were reset while fragment load was in progress. Fragment " + frag.sn + " of level " + frag.level + " will not be buffered");
            return;
          }
          var currentLevel = levels[frag.level];
          var details = currentLevel.details;
          if (!details) {
            this.warn("Dropping fragment " + frag.sn + " of level " + frag.level + " after level details were reset");
            this.fragmentTracker.removeFragment(frag);
            return;
          }
          var videoCodec = currentLevel.videoCodec;
          var accurateTimeOffset = details.PTSKnown || !details.live;
          var initSegmentData = (_frag$initSegment = frag.initSegment) == null ? undefined : _frag$initSegment.data;
          var audioCodec = this._getAudioCodec(currentLevel);
          var transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));
          var partIndex = part ? part.index : -1;
          var partial = partIndex !== -1;
          var chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);
          var initPTS = this.initPTS[frag.cc];
          transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);
        };
        _proto.onAudioTrackSwitching = function onAudioTrackSwitching(event, data) {
          var fromAltAudio = this.altAudio;
          var altAudio = !!data.url;
          if (!altAudio) {
            if (this.mediaBuffer !== this.media) {
              this.log("Switching on main audio, use media.buffered to schedule main fragment loading");
              this.mediaBuffer = this.media;
              var fragCurrent = this.fragCurrent;
              if (fragCurrent) {
                this.log("Switching to main audio track, cancel main fragment load");
                fragCurrent.abortRequests();
                this.fragmentTracker.removeFragment(fragCurrent);
              }
              this.resetTransmuxer();
              this.resetLoadingState();
            } else if (this.audioOnly) {
              this.resetTransmuxer();
            }
            var hls = this.hls;
            if (fromAltAudio) {
              hls.trigger(Events.BUFFER_FLUSHING, {
                startOffset: 0,
                endOffset: Number.POSITIVE_INFINITY,
                type: null
              });
              this.fragmentTracker.removeAllFragments();
            }
            hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);
          }
        };
        _proto.onAudioTrackSwitched = function onAudioTrackSwitched(event, data) {
          var trackId = data.id;
          var altAudio = !!this.hls.audioTracks[trackId].url;
          if (altAudio) {
            var videoBuffer = this.videoBuffer;
            if (videoBuffer && this.mediaBuffer !== videoBuffer) {
              this.log("Switching on alternate audio, use video.buffered to schedule main fragment loading");
              this.mediaBuffer = videoBuffer;
            }
          }
          this.altAudio = altAudio;
          this.tick();
        };
        _proto.onBufferCreated = function onBufferCreated(event, data) {
          var tracks = data.tracks;
          var mediaTrack;
          var name;
          var alternate = false;
          for (var type in tracks) {
            var track = tracks[type];
            if (track.id === "main") {
              name = type;
              mediaTrack = track;
              if (type === "video") {
                var videoTrack = tracks[type];
                if (videoTrack) {
                  this.videoBuffer = videoTrack.buffer;
                }
              }
            } else {
              alternate = true;
            }
          }
          if (alternate && mediaTrack) {
            this.log("Alternate track found, use " + name + ".buffered to schedule main fragment loading");
            this.mediaBuffer = mediaTrack.buffer;
          } else {
            this.mediaBuffer = this.media;
          }
        };
        _proto.onFragBuffered = function onFragBuffered(event, data) {
          var { frag, part } = data;
          if (frag && frag.type !== PlaylistLevelType.MAIN) {
            return;
          }
          if (this.fragContextChanged(frag)) {
            this.warn("Fragment " + frag.sn + (part ? " p: " + part.index : "") + " of level " + frag.level + " finished buffering, but was aborted. state: " + this.state);
            if (this.state === State.PARSED) {
              this.state = State.IDLE;
            }
            return;
          }
          var stats = part ? part.stats : frag.stats;
          this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));
          if (frag.sn !== "initSegment") {
            this.fragPrevious = frag;
          }
          this.fragBufferedComplete(frag, part);
        };
        _proto.onError = function onError(event, data) {
          var _data$context;
          if (data.fatal) {
            this.state = State.ERROR;
            return;
          }
          switch (data.details) {
            case ErrorDetails.FRAG_GAP:
            case ErrorDetails.FRAG_PARSING_ERROR:
            case ErrorDetails.FRAG_DECRYPT_ERROR:
            case ErrorDetails.FRAG_LOAD_ERROR:
            case ErrorDetails.FRAG_LOAD_TIMEOUT:
            case ErrorDetails.KEY_LOAD_ERROR:
            case ErrorDetails.KEY_LOAD_TIMEOUT:
              this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);
              break;
            case ErrorDetails.LEVEL_LOAD_ERROR:
            case ErrorDetails.LEVEL_LOAD_TIMEOUT:
            case ErrorDetails.LEVEL_PARSING_ERROR:
              if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? undefined : _data$context.type) === PlaylistContextType.LEVEL) {
                this.state = State.IDLE;
              }
              break;
            case ErrorDetails.BUFFER_APPEND_ERROR:
            case ErrorDetails.BUFFER_FULL_ERROR:
              if (!data.parent || data.parent !== "main") {
                return;
              }
              if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {
                this.resetLoadingState();
                return;
              }
              if (this.reduceLengthAndFlushBuffer(data)) {
                this.flushMainBuffer(0, Number.POSITIVE_INFINITY);
              }
              break;
            case ErrorDetails.INTERNAL_EXCEPTION:
              this.recoverWorkerError(data);
              break;
          }
        };
        _proto.checkBuffer = function checkBuffer() {
          var media = this.media, gapController = this.gapController;
          if (!media || !gapController || !media.readyState) {
            return;
          }
          if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {
            var activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;
            gapController.poll(this.lastCurrentTime, activeFrag);
          }
          this.lastCurrentTime = media.currentTime;
        };
        _proto.onFragLoadEmergencyAborted = function onFragLoadEmergencyAborted() {
          this.state = State.IDLE;
          if (!this.loadedmetadata) {
            this.startFragRequested = false;
            this.nextLoadPosition = this.startPosition;
          }
          this.tickImmediate();
        };
        _proto.onBufferFlushed = function onBufferFlushed(event, _ref) {
          var type = _ref.type;
          if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {
            var mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;
            this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);
            this.tick();
          }
        };
        _proto.onLevelsUpdated = function onLevelsUpdated(event, data) {
          if (this.level > -1 && this.fragCurrent) {
            this.level = this.fragCurrent.level;
          }
          this.levels = data.levels;
        };
        _proto.swapAudioCodec = function swapAudioCodec() {
          this.audioCodecSwap = !this.audioCodecSwap;
        };
        _proto.seekToStartPos = function seekToStartPos() {
          var media = this.media;
          if (!media) {
            return;
          }
          var currentTime = media.currentTime;
          var startPosition = this.startPosition;
          if (startPosition >= 0 && currentTime < startPosition) {
            if (media.seeking) {
              this.log("could not seek to " + startPosition + ", already seeking at " + currentTime);
              return;
            }
            var buffered = BufferHelper.getBuffered(media);
            var bufferStart = buffered.length ? buffered.start(0) : 0;
            var delta = bufferStart - startPosition;
            if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {
              this.log("adjusting start position by " + delta + " to match buffer start");
              startPosition += delta;
              this.startPosition = startPosition;
            }
            this.log("seek to target start position " + startPosition + " from current time " + currentTime);
            media.currentTime = startPosition;
          }
        };
        _proto._getAudioCodec = function _getAudioCodec(currentLevel) {
          var audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;
          if (this.audioCodecSwap && audioCodec) {
            this.log("Swapping audio codec");
            if (audioCodec.indexOf("mp4a.40.5") !== -1) {
              audioCodec = "mp4a.40.2";
            } else {
              audioCodec = "mp4a.40.5";
            }
          }
          return audioCodec;
        };
        _proto._loadBitrateTestFrag = function _loadBitrateTestFrag(frag, level) {
          var _this2 = this;
          frag.bitrateTest = true;
          this._doFragLoad(frag, level).then(function(data) {
            var hls = _this2.hls;
            if (!data || _this2.fragContextChanged(frag)) {
              return;
            }
            level.fragmentError = 0;
            _this2.state = State.IDLE;
            _this2.startFragRequested = false;
            _this2.bitrateTest = false;
            var stats = frag.stats;
            stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();
            hls.trigger(Events.FRAG_LOADED, data);
            frag.bitrateTest = false;
          });
        };
        _proto._handleTransmuxComplete = function _handleTransmuxComplete(transmuxResult) {
          var _id3$samples;
          var id = "main";
          var hls = this.hls;
          var { remuxResult, chunkMeta } = transmuxResult;
          var context = this.getCurrentContext(chunkMeta);
          if (!context) {
            this.resetWhenMissingContext(chunkMeta);
            return;
          }
          var { frag, part, level } = context;
          var { video, text, id3, initSegment } = remuxResult;
          var details = level.details;
          var audio = this.altAudio ? undefined : remuxResult.audio;
          if (this.fragContextChanged(frag)) {
            this.fragmentTracker.removeFragment(frag);
            return;
          }
          this.state = State.PARSING;
          if (initSegment) {
            if (initSegment != null && initSegment.tracks) {
              var mapFragment = frag.initSegment || frag;
              this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);
              hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {
                frag: mapFragment,
                id,
                tracks: initSegment.tracks
              });
            }
            var initPTS = initSegment.initPTS;
            var timescale = initSegment.timescale;
            if (isFiniteNumber(initPTS)) {
              this.initPTS[frag.cc] = {
                baseTime: initPTS,
                timescale
              };
              hls.trigger(Events.INIT_PTS_FOUND, {
                frag,
                id,
                initPTS,
                timescale
              });
            }
          }
          if (video && details && frag.sn !== "initSegment") {
            var prevFrag = details.fragments[frag.sn - 1 - details.startSN];
            var isFirstFragment = frag.sn === details.startSN;
            var isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;
            if (remuxResult.independent !== false) {
              var { startPTS, endPTS, startDTS, endDTS } = video;
              if (part) {
                part.elementaryStreams[video.type] = {
                  startPTS,
                  endPTS,
                  startDTS,
                  endDTS
                };
              } else {
                if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {
                  this.couldBacktrack = true;
                }
                if (video.dropped && video.independent) {
                  var bufferInfo = this.getMainFwdBufferInfo();
                  var targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;
                  var startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;
                  if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {
                    this.backtrack(frag);
                    return;
                  } else if (isFirstInDiscontinuity) {
                    frag.gap = true;
                  }
                  frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);
                } else if (isFirstFragment && startPTS > MAX_START_GAP_JUMP) {
                  frag.gap = true;
                }
              }
              frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);
              if (this.backtrackFragment) {
                this.backtrackFragment = frag;
              }
              this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);
            } else if (isFirstFragment || isFirstInDiscontinuity) {
              frag.gap = true;
            } else {
              this.backtrack(frag);
              return;
            }
          }
          if (audio) {
            var { startPTS: _startPTS, endPTS: _endPTS, startDTS: _startDTS, endDTS: _endDTS } = audio;
            if (part) {
              part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {
                startPTS: _startPTS,
                endPTS: _endPTS,
                startDTS: _startDTS,
                endDTS: _endDTS
              };
            }
            frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, _startPTS, _endPTS, _startDTS, _endDTS);
            this.bufferFragmentData(audio, frag, part, chunkMeta);
          }
          if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {
            var emittedID3 = {
              id,
              frag,
              details,
              samples: id3.samples
            };
            hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);
          }
          if (details && text) {
            var emittedText = {
              id,
              frag,
              details,
              samples: text.samples
            };
            hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);
          }
        };
        _proto._bufferInitSegment = function _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {
          var _this3 = this;
          if (this.state !== State.PARSING) {
            return;
          }
          this.audioOnly = !!tracks.audio && !tracks.video;
          if (this.altAudio && !this.audioOnly) {
            delete tracks.audio;
          }
          var { audio, video, audiovideo } = tracks;
          if (audio) {
            var audioCodec = currentLevel.audioCodec;
            var ua = navigator.userAgent.toLowerCase();
            if (this.audioCodecSwitch) {
              if (audioCodec) {
                if (audioCodec.indexOf("mp4a.40.5") !== -1) {
                  audioCodec = "mp4a.40.2";
                } else {
                  audioCodec = "mp4a.40.5";
                }
              }
              var audioMetadata = audio.metadata;
              if (audioMetadata && "channelCount" in audioMetadata && (audioMetadata.channelCount || 1) !== 1 && ua.indexOf("firefox") === -1) {
                audioCodec = "mp4a.40.5";
              }
            }
            if (audioCodec && audioCodec.indexOf("mp4a.40.5") !== -1 && ua.indexOf("android") !== -1 && audio.container !== "audio/mpeg") {
              audioCodec = "mp4a.40.2";
              this.log("Android: force audio codec to " + audioCodec);
            }
            if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {
              this.log('Swapping manifest audio codec "' + currentLevel.audioCodec + '" for "' + audioCodec + '"');
            }
            audio.levelCodec = audioCodec;
            audio.id = "main";
            this.log("Init audio buffer, container:" + audio.container + ", codecs[selected/level/parsed]=[" + (audioCodec || "") + "/" + (currentLevel.audioCodec || "") + "/" + audio.codec + "]");
          }
          if (video) {
            video.levelCodec = currentLevel.videoCodec;
            video.id = "main";
            this.log("Init video buffer, container:" + video.container + ", codecs[level/parsed]=[" + (currentLevel.videoCodec || "") + "/" + video.codec + "]");
          }
          if (audiovideo) {
            this.log("Init audiovideo buffer, container:" + audiovideo.container + ", codecs[level/parsed]=[" + currentLevel.codecs + "/" + audiovideo.codec + "]");
          }
          this.hls.trigger(Events.BUFFER_CODECS, tracks);
          Object.keys(tracks).forEach(function(trackName) {
            var track = tracks[trackName];
            var initSegment = track.initSegment;
            if (initSegment != null && initSegment.byteLength) {
              _this3.hls.trigger(Events.BUFFER_APPENDING, {
                type: trackName,
                data: initSegment,
                frag,
                part: null,
                chunkMeta,
                parent: frag.type
              });
            }
          });
          this.tickImmediate();
        };
        _proto.getMainFwdBufferInfo = function getMainFwdBufferInfo() {
          return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);
        };
        _proto.backtrack = function backtrack(frag) {
          this.couldBacktrack = true;
          this.backtrackFragment = frag;
          this.resetTransmuxer();
          this.flushBufferGap(frag);
          this.fragmentTracker.removeFragment(frag);
          this.fragPrevious = null;
          this.nextLoadPosition = frag.start;
          this.state = State.IDLE;
        };
        _proto.checkFragmentChanged = function checkFragmentChanged() {
          var video = this.media;
          var fragPlayingCurrent = null;
          if (video && video.readyState > 1 && video.seeking === false) {
            var currentTime = video.currentTime;
            if (BufferHelper.isBuffered(video, currentTime)) {
              fragPlayingCurrent = this.getAppendedFrag(currentTime);
            } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {
              fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);
            }
            if (fragPlayingCurrent) {
              this.backtrackFragment = null;
              var fragPlaying = this.fragPlaying;
              var fragCurrentLevel = fragPlayingCurrent.level;
              if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {
                this.fragPlaying = fragPlayingCurrent;
                this.hls.trigger(Events.FRAG_CHANGED, {
                  frag: fragPlayingCurrent
                });
                if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {
                  this.hls.trigger(Events.LEVEL_SWITCHED, {
                    level: fragCurrentLevel
                  });
                }
              }
            }
          }
        };
        _createClass(StreamController2, [{
          key: "nextLevel",
          get: function get() {
            var frag = this.nextBufferedFrag;
            if (frag) {
              return frag.level;
            }
            return -1;
          }
        }, {
          key: "currentFrag",
          get: function get() {
            var media = this.media;
            if (media) {
              return this.fragPlaying || this.getAppendedFrag(media.currentTime);
            }
            return null;
          }
        }, {
          key: "currentProgramDateTime",
          get: function get() {
            var media = this.media;
            if (media) {
              var currentTime = media.currentTime;
              var frag = this.currentFrag;
              if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {
                var epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;
                return new Date(epocMs);
              }
            }
            return null;
          }
        }, {
          key: "currentLevel",
          get: function get() {
            var frag = this.currentFrag;
            if (frag) {
              return frag.level;
            }
            return -1;
          }
        }, {
          key: "nextBufferedFrag",
          get: function get() {
            var frag = this.currentFrag;
            if (frag) {
              return this.followingBufferedFrag(frag);
            }
            return null;
          }
        }, {
          key: "forceStartLoad",
          get: function get() {
            return this._forceStartLoad;
          }
        }]);
        return StreamController2;
      }(BaseStreamController);
      var Hls = /* @__PURE__ */ function() {
        Hls2.isMSESupported = function isMSESupported$1() {
          return isMSESupported();
        };
        Hls2.isSupported = function isSupported$1() {
          return isSupported();
        };
        Hls2.getMediaSource = function getMediaSource$1() {
          return getMediaSource();
        };
        function Hls2(userConfig) {
          if (userConfig === undefined) {
            userConfig = {};
          }
          this.config = undefined;
          this.userConfig = undefined;
          this.coreComponents = undefined;
          this.networkControllers = undefined;
          this.started = false;
          this._emitter = new EventEmitter;
          this._autoLevelCapping = -1;
          this._maxHdcpLevel = null;
          this.abrController = undefined;
          this.bufferController = undefined;
          this.capLevelController = undefined;
          this.latencyController = undefined;
          this.levelController = undefined;
          this.streamController = undefined;
          this.audioTrackController = undefined;
          this.subtitleTrackController = undefined;
          this.emeController = undefined;
          this.cmcdController = undefined;
          this._media = null;
          this.url = null;
          this.triggeringException = undefined;
          enableLogs(userConfig.debug || false, "Hls instance");
          var config = this.config = mergeConfig(Hls2.DefaultConfig, userConfig);
          this.userConfig = userConfig;
          if (config.progressive) {
            enableStreamingMode(config);
          }
          var { abrController: ConfigAbrController, bufferController: ConfigBufferController, capLevelController: ConfigCapLevelController, errorController: ConfigErrorController, fpsController: ConfigFpsController } = config;
          var errorController = new ConfigErrorController(this);
          var abrController = this.abrController = new ConfigAbrController(this);
          var bufferController = this.bufferController = new ConfigBufferController(this);
          var capLevelController = this.capLevelController = new ConfigCapLevelController(this);
          var fpsController = new ConfigFpsController(this);
          var playListLoader = new PlaylistLoader(this);
          var id3TrackController = new ID3TrackController(this);
          var ConfigContentSteeringController = config.contentSteeringController;
          var contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;
          var levelController = this.levelController = new LevelController(this, contentSteering);
          var fragmentTracker = new FragmentTracker(this);
          var keyLoader = new KeyLoader(this.config);
          var streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);
          capLevelController.setStreamController(streamController);
          fpsController.setStreamController(streamController);
          var networkControllers = [playListLoader, levelController, streamController];
          if (contentSteering) {
            networkControllers.splice(1, 0, contentSteering);
          }
          this.networkControllers = networkControllers;
          var coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];
          this.audioTrackController = this.createController(config.audioTrackController, networkControllers);
          var AudioStreamControllerClass = config.audioStreamController;
          if (AudioStreamControllerClass) {
            networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));
          }
          this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);
          var SubtitleStreamControllerClass = config.subtitleStreamController;
          if (SubtitleStreamControllerClass) {
            networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));
          }
          this.createController(config.timelineController, coreComponents);
          keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);
          this.cmcdController = this.createController(config.cmcdController, coreComponents);
          this.latencyController = this.createController(LatencyController, coreComponents);
          this.coreComponents = coreComponents;
          networkControllers.push(errorController);
          var onErrorOut = errorController.onErrorOut;
          if (typeof onErrorOut === "function") {
            this.on(Events.ERROR, onErrorOut, errorController);
          }
        }
        var _proto = Hls2.prototype;
        _proto.createController = function createController(ControllerClass, components) {
          if (ControllerClass) {
            var controllerInstance = new ControllerClass(this);
            if (components) {
              components.push(controllerInstance);
            }
            return controllerInstance;
          }
          return null;
        };
        _proto.on = function on(event, listener, context) {
          if (context === undefined) {
            context = this;
          }
          this._emitter.on(event, listener, context);
        };
        _proto.once = function once(event, listener, context) {
          if (context === undefined) {
            context = this;
          }
          this._emitter.once(event, listener, context);
        };
        _proto.removeAllListeners = function removeAllListeners(event) {
          this._emitter.removeAllListeners(event);
        };
        _proto.off = function off(event, listener, context, once) {
          if (context === undefined) {
            context = this;
          }
          this._emitter.off(event, listener, context, once);
        };
        _proto.listeners = function listeners(event) {
          return this._emitter.listeners(event);
        };
        _proto.emit = function emit(event, name, eventObject) {
          return this._emitter.emit(event, name, eventObject);
        };
        _proto.trigger = function trigger(event, eventObject) {
          if (this.config.debug) {
            return this.emit(event, event, eventObject);
          } else {
            try {
              return this.emit(event, event, eventObject);
            } catch (error2) {
              logger.error("An internal error happened while handling event " + event + '. Error message: "' + error2.message + '". Here is a stacktrace:', error2);
              if (!this.triggeringException) {
                this.triggeringException = true;
                var fatal = event === Events.ERROR;
                this.trigger(Events.ERROR, {
                  type: ErrorTypes2.OTHER_ERROR,
                  details: ErrorDetails.INTERNAL_EXCEPTION,
                  fatal,
                  event,
                  error: error2
                });
                this.triggeringException = false;
              }
            }
          }
          return false;
        };
        _proto.listenerCount = function listenerCount(event) {
          return this._emitter.listenerCount(event);
        };
        _proto.destroy = function destroy() {
          logger.log("destroy");
          this.trigger(Events.DESTROYING, undefined);
          this.detachMedia();
          this.removeAllListeners();
          this._autoLevelCapping = -1;
          this.url = null;
          this.networkControllers.forEach(function(component) {
            return component.destroy();
          });
          this.networkControllers.length = 0;
          this.coreComponents.forEach(function(component) {
            return component.destroy();
          });
          this.coreComponents.length = 0;
          var config = this.config;
          config.xhrSetup = config.fetchSetup = undefined;
          this.userConfig = null;
        };
        _proto.attachMedia = function attachMedia(media) {
          logger.log("attachMedia");
          this._media = media;
          this.trigger(Events.MEDIA_ATTACHING, {
            media
          });
        };
        _proto.detachMedia = function detachMedia() {
          logger.log("detachMedia");
          this.trigger(Events.MEDIA_DETACHING, undefined);
          this._media = null;
        };
        _proto.loadSource = function loadSource(url2) {
          this.stopLoad();
          var media = this.media;
          var loadedSource = this.url;
          var loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url2, {
            alwaysNormalize: true
          });
          this._autoLevelCapping = -1;
          this._maxHdcpLevel = null;
          logger.log("loadSource:" + loadingSource);
          if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {
            this.detachMedia();
            this.attachMedia(media);
          }
          this.trigger(Events.MANIFEST_LOADING, {
            url: url2
          });
        };
        _proto.startLoad = function startLoad(startPosition) {
          if (startPosition === undefined) {
            startPosition = -1;
          }
          logger.log("startLoad(" + startPosition + ")");
          this.started = true;
          this.resumeBuffering();
          for (var i = 0;i < this.networkControllers.length; i++) {
            this.networkControllers[i].startLoad(startPosition);
            if (!this.started || !this.networkControllers) {
              break;
            }
          }
        };
        _proto.stopLoad = function stopLoad() {
          logger.log("stopLoad");
          this.started = false;
          for (var i = 0;i < this.networkControllers.length; i++) {
            this.networkControllers[i].stopLoad();
            if (this.started || !this.networkControllers) {
              break;
            }
          }
        };
        _proto.resumeBuffering = function resumeBuffering() {
          logger.log("resume buffering");
          this.networkControllers.forEach(function(controller) {
            if (controller.resumeBuffering) {
              controller.resumeBuffering();
            }
          });
        };
        _proto.pauseBuffering = function pauseBuffering() {
          logger.log("pause buffering");
          this.networkControllers.forEach(function(controller) {
            if (controller.pauseBuffering) {
              controller.pauseBuffering();
            }
          });
        };
        _proto.swapAudioCodec = function swapAudioCodec() {
          logger.log("swapAudioCodec");
          this.streamController.swapAudioCodec();
        };
        _proto.recoverMediaError = function recoverMediaError() {
          logger.log("recoverMediaError");
          var media = this._media;
          this.detachMedia();
          if (media) {
            this.attachMedia(media);
          }
        };
        _proto.removeLevel = function removeLevel(levelIndex) {
          this.levelController.removeLevel(levelIndex);
        };
        _proto.setAudioOption = function setAudioOption(audioOption) {
          var _this$audioTrackContr;
          return (_this$audioTrackContr = this.audioTrackController) == null ? undefined : _this$audioTrackContr.setAudioOption(audioOption);
        };
        _proto.setSubtitleOption = function setSubtitleOption(subtitleOption) {
          var _this$subtitleTrackCo;
          (_this$subtitleTrackCo = this.subtitleTrackController) == null || _this$subtitleTrackCo.setSubtitleOption(subtitleOption);
          return null;
        };
        _createClass(Hls2, [{
          key: "levels",
          get: function get() {
            var levels = this.levelController.levels;
            return levels ? levels : [];
          }
        }, {
          key: "currentLevel",
          get: function get() {
            return this.streamController.currentLevel;
          },
          set: function set(newLevel) {
            logger.log("set currentLevel:" + newLevel);
            this.levelController.manualLevel = newLevel;
            this.streamController.immediateLevelSwitch();
          }
        }, {
          key: "nextLevel",
          get: function get() {
            return this.streamController.nextLevel;
          },
          set: function set(newLevel) {
            logger.log("set nextLevel:" + newLevel);
            this.levelController.manualLevel = newLevel;
            this.streamController.nextLevelSwitch();
          }
        }, {
          key: "loadLevel",
          get: function get() {
            return this.levelController.level;
          },
          set: function set(newLevel) {
            logger.log("set loadLevel:" + newLevel);
            this.levelController.manualLevel = newLevel;
          }
        }, {
          key: "nextLoadLevel",
          get: function get() {
            return this.levelController.nextLoadLevel;
          },
          set: function set(level) {
            this.levelController.nextLoadLevel = level;
          }
        }, {
          key: "firstLevel",
          get: function get() {
            return Math.max(this.levelController.firstLevel, this.minAutoLevel);
          },
          set: function set(newLevel) {
            logger.log("set firstLevel:" + newLevel);
            this.levelController.firstLevel = newLevel;
          }
        }, {
          key: "startLevel",
          get: function get() {
            var startLevel = this.levelController.startLevel;
            if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {
              return this.abrController.forcedAutoLevel;
            }
            return startLevel;
          },
          set: function set(newLevel) {
            logger.log("set startLevel:" + newLevel);
            if (newLevel !== -1) {
              newLevel = Math.max(newLevel, this.minAutoLevel);
            }
            this.levelController.startLevel = newLevel;
          }
        }, {
          key: "capLevelToPlayerSize",
          get: function get() {
            return this.config.capLevelToPlayerSize;
          },
          set: function set(shouldStartCapping) {
            var newCapLevelToPlayerSize = !!shouldStartCapping;
            if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {
              if (newCapLevelToPlayerSize) {
                this.capLevelController.startCapping();
              } else {
                this.capLevelController.stopCapping();
                this.autoLevelCapping = -1;
                this.streamController.nextLevelSwitch();
              }
              this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;
            }
          }
        }, {
          key: "autoLevelCapping",
          get: function get() {
            return this._autoLevelCapping;
          },
          set: function set(newLevel) {
            if (this._autoLevelCapping !== newLevel) {
              logger.log("set autoLevelCapping:" + newLevel);
              this._autoLevelCapping = newLevel;
              this.levelController.checkMaxAutoUpdated();
            }
          }
        }, {
          key: "bandwidthEstimate",
          get: function get() {
            var bwEstimator = this.abrController.bwEstimator;
            if (!bwEstimator) {
              return NaN;
            }
            return bwEstimator.getEstimate();
          },
          set: function set(abrEwmaDefaultEstimate) {
            this.abrController.resetEstimator(abrEwmaDefaultEstimate);
          }
        }, {
          key: "ttfbEstimate",
          get: function get() {
            var bwEstimator = this.abrController.bwEstimator;
            if (!bwEstimator) {
              return NaN;
            }
            return bwEstimator.getEstimateTTFB();
          }
        }, {
          key: "maxHdcpLevel",
          get: function get() {
            return this._maxHdcpLevel;
          },
          set: function set(value) {
            if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {
              this._maxHdcpLevel = value;
              this.levelController.checkMaxAutoUpdated();
            }
          }
        }, {
          key: "autoLevelEnabled",
          get: function get() {
            return this.levelController.manualLevel === -1;
          }
        }, {
          key: "manualLevel",
          get: function get() {
            return this.levelController.manualLevel;
          }
        }, {
          key: "minAutoLevel",
          get: function get() {
            var levels = this.levels, minAutoBitrate = this.config.minAutoBitrate;
            if (!levels)
              return 0;
            var len = levels.length;
            for (var i = 0;i < len; i++) {
              if (levels[i].maxBitrate >= minAutoBitrate) {
                return i;
              }
            }
            return 0;
          }
        }, {
          key: "maxAutoLevel",
          get: function get() {
            var levels = this.levels, autoLevelCapping = this.autoLevelCapping, maxHdcpLevel = this.maxHdcpLevel;
            var maxAutoLevel;
            if (autoLevelCapping === -1 && levels != null && levels.length) {
              maxAutoLevel = levels.length - 1;
            } else {
              maxAutoLevel = autoLevelCapping;
            }
            if (maxHdcpLevel) {
              for (var i = maxAutoLevel;i--; ) {
                var hdcpLevel = levels[i].attrs["HDCP-LEVEL"];
                if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {
                  return i;
                }
              }
            }
            return maxAutoLevel;
          }
        }, {
          key: "firstAutoLevel",
          get: function get() {
            return this.abrController.firstAutoLevel;
          }
        }, {
          key: "nextAutoLevel",
          get: function get() {
            return this.abrController.nextAutoLevel;
          },
          set: function set(nextLevel) {
            this.abrController.nextAutoLevel = nextLevel;
          }
        }, {
          key: "playingDate",
          get: function get() {
            return this.streamController.currentProgramDateTime;
          }
        }, {
          key: "mainForwardBufferInfo",
          get: function get() {
            return this.streamController.getMainFwdBufferInfo();
          }
        }, {
          key: "allAudioTracks",
          get: function get() {
            var audioTrackController = this.audioTrackController;
            return audioTrackController ? audioTrackController.allAudioTracks : [];
          }
        }, {
          key: "audioTracks",
          get: function get() {
            var audioTrackController = this.audioTrackController;
            return audioTrackController ? audioTrackController.audioTracks : [];
          }
        }, {
          key: "audioTrack",
          get: function get() {
            var audioTrackController = this.audioTrackController;
            return audioTrackController ? audioTrackController.audioTrack : -1;
          },
          set: function set(audioTrackId) {
            var audioTrackController = this.audioTrackController;
            if (audioTrackController) {
              audioTrackController.audioTrack = audioTrackId;
            }
          }
        }, {
          key: "allSubtitleTracks",
          get: function get() {
            var subtitleTrackController = this.subtitleTrackController;
            return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];
          }
        }, {
          key: "subtitleTracks",
          get: function get() {
            var subtitleTrackController = this.subtitleTrackController;
            return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];
          }
        }, {
          key: "subtitleTrack",
          get: function get() {
            var subtitleTrackController = this.subtitleTrackController;
            return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;
          },
          set: function set(subtitleTrackId) {
            var subtitleTrackController = this.subtitleTrackController;
            if (subtitleTrackController) {
              subtitleTrackController.subtitleTrack = subtitleTrackId;
            }
          }
        }, {
          key: "media",
          get: function get() {
            return this._media;
          }
        }, {
          key: "subtitleDisplay",
          get: function get() {
            var subtitleTrackController = this.subtitleTrackController;
            return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;
          },
          set: function set(value) {
            var subtitleTrackController = this.subtitleTrackController;
            if (subtitleTrackController) {
              subtitleTrackController.subtitleDisplay = value;
            }
          }
        }, {
          key: "lowLatencyMode",
          get: function get() {
            return this.config.lowLatencyMode;
          },
          set: function set(mode) {
            this.config.lowLatencyMode = mode;
          }
        }, {
          key: "liveSyncPosition",
          get: function get() {
            return this.latencyController.liveSyncPosition;
          }
        }, {
          key: "latency",
          get: function get() {
            return this.latencyController.latency;
          }
        }, {
          key: "maxLatency",
          get: function get() {
            return this.latencyController.maxLatency;
          }
        }, {
          key: "targetLatency",
          get: function get() {
            return this.latencyController.targetLatency;
          }
        }, {
          key: "drift",
          get: function get() {
            return this.latencyController.drift;
          }
        }, {
          key: "forceStartLoad",
          get: function get() {
            return this.streamController.forceStartLoad;
          }
        }], [{
          key: "version",
          get: function get() {
            return "1.5.18";
          }
        }, {
          key: "Events",
          get: function get() {
            return Events;
          }
        }, {
          key: "ErrorTypes",
          get: function get() {
            return ErrorTypes2;
          }
        }, {
          key: "ErrorDetails",
          get: function get() {
            return ErrorDetails;
          }
        }, {
          key: "DefaultConfig",
          get: function get() {
            if (!Hls2.defaultConfig) {
              return hlsDefaultConfig;
            }
            return Hls2.defaultConfig;
          },
          set: function set(defaultConfig) {
            Hls2.defaultConfig = defaultConfig;
          }
        }]);
        return Hls2;
      }();
      Hls.defaultConfig = undefined;
      return Hls;
    });
  })(false);
});

// client_new.js
var maplibregl = __toESM(require_maplibre_gl(), 1);
var import_hls = __toESM(require_hls(), 1);
var LAT_CONVERSION = 111.32;
var earthRadius = 6371008.8;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: 360 / (2 * Math.PI),
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1000,
  kilometres: earthRadius / 1000,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1000,
  millimetres: earthRadius * 1000,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
function radiansToLength(radians, units = "kilometers") {
  const factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return radians * factor;
}
function degreesToRadians(degrees) {
  const radians = degrees % 360;
  return radians * Math.PI / 180;
}
function getSquareCorners(center, distanceKm) {
  const centerLon = center[0];
  const centerLat = center[1];
  const deltaLat = distanceKm / LAT_CONVERSION;
  const deltaLon = distanceKm / (LAT_CONVERSION * Math.cos(centerLat * Math.PI / 180));
  const topLeft = [centerLon - deltaLon, centerLat + deltaLat];
  const topRight = [
    centerLon + deltaLon,
    centerLat + deltaLat
  ];
  const bottomLeft = [
    centerLon - deltaLon,
    centerLat - deltaLat
  ];
  const bottomRight = [
    centerLon + deltaLon,
    centerLat - deltaLat
  ];
  return [topLeft, topRight, bottomRight, bottomLeft];
}
function pointInPolygon(point, polygon) {
  let intersection_count = 0;
  for (let i = 0, j = polygon.length - 1;i < polygon.length; j = i++) {
    let [lng1, lat1] = polygon[i];
    let [lng2, lat2] = polygon[j];
    let [lng, lat] = point;
    let intersect = lat1 > lat !== lat2 > lat && lng < (lng2 - lng1) * (lat - lat1) / (lat2 - lat1) + lng1;
    if (intersect) {
      intersection_count += 1;
    }
  }
  return intersection_count % 2 === 1;
}
function pointInBbox(point, bbox) {
  const [lng, lat] = point;
  const [minLng, minLat, maxLng, maxLat] = bbox;
  return lng >= minLng && lng <= maxLng && lat >= minLat && lat <= maxLat;
}
function distanceKm(from, to) {
  let dLat = degreesToRadians(to[1] - from[1]);
  let dLon = degreesToRadians(to[0] - from[0]);
  let lat1 = degreesToRadians(from[1]);
  let lat2 = degreesToRadians(to[1]);
  let a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
  return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), "kilometers");
}
var constants = {
  map_bounds: [22.692261, 65.739656, 24.329224, 66.438715],
  map_center: [23.507996, 66.083241],
  map_perim: [
    [23.525427575932326, 66.0903488585733],
    [23.42668791159693, 66.06844236664259],
    [23.47140021242788, 66.00450362832879],
    [23.432276949200798, 65.95824681364806],
    [23.468605693625392, 65.83842512404459],
    [23.66422200976305, 65.83232398441024],
    [23.887783513920027, 65.79912368543009],
    [24.08619434886012, 65.8044691547079],
    [24.19704359467036, 65.82545847133909],
    [24.190523050799385, 65.8868015859372],
    [24.03030397282032, 66.06239587288295],
    [23.852386275762512, 66.04538240012698],
    [23.593427533447, 66.05256725398294],
    [23.525467719592257, 66.09034391453025],
    [23.525427575932326, 66.0903488585733]
  ],
  map_perim_center: [23.798001194926712, 65.94792047215071],
  map_defaultzoom: 8,
  map_maxzoom: 16,
  map_minzoom: 8,
  perim_entermsg: "Du har inom tidstangslet tryck på knappen för att lyssna",
  perim_exitmsg: "Du har inom tidstangslet ljudström stängs",
  outofboundsmessage: "Du befinner dig för långt bortom tidstängslet! ladda om sidan när du befinner på kartan!",
  image_url: "/verner_bostrom.png",
  static_map_url: "/static_map.png"
};
var mapstyle = {
  version: 8,
  sources: {
    osm: {
      bounds: constants.map_bounds,
      minzoom: constants.map_minzoom,
      maxzoom: constants.map_maxzoom,
      type: "raster",
      tiles: ["https://tile.openstreetmap.org/{z}/{x}/{y}.png"],
      tileSize: 256,
      attribution: "&copy; OpenStreetMap Contributors"
    },
    perim: {
      type: "geojson",
      data: {
        type: "Feature",
        properties: {},
        geometry: {
          type: "Polygon",
          coordinates: [constants.map_perim]
        }
      }
    },
    verner: {
      type: "image",
      url: constants.image_url,
      coordinates: getSquareCorners(constants.map_perim_center, 10)
    }
  },
  layers: [
    {
      id: "osm",
      source: "osm",
      type: "raster"
    },
    {
      id: "pgon",
      source: "perim",
      type: "fill",
      paint: {
        "fill-color": "blue",
        "fill-opacity": 0.2
      }
    },
    {
      id: "verner",
      source: "verner",
      type: "raster",
      paint: {
        "raster-opacity": 0.3
      }
    }
  ]
};
var maplibre_bounds = [[constants.map_bounds[0], constants.map_bounds[1]], [constants.map_bounds[2], constants.map_bounds[3]]];
var mapopts = {
  center: constants.map_center,
  container: "map",
  maxBounds: maplibre_bounds,
  dragPan: true,
  dragRotate: false,
  pitchWithRotate: false,
  touchZoomRotate: true,
  trackResize: false,
  touchPitch: false,
  keyboard: false,
  attributionControl: { compact: true },
  style: mapstyle
};
var canvas = null;
var canvascontainer = null;
var markercontainer = null;
var container = null;
var glmap = null;
var locmarker = null;
var geotracker = null;
var initialized = false;
var prev_pos = null;
var prev_pos_within_perim = false;
var audioPlayer = new Audio;
audioPlayer.controls = false;
audioPlayer.hidden = true;
audioPlayer.autoplay = false;
var backend = import_hls.default.isSupported() ? "hls" : audioPlayer.canPlayType("application/vnd.apple.mpegurl") === "probably" ? "mext" : "none";
var fadeDur = 3000;
var fadeCnt = 100;
var volStep = 1 / fadeCnt;
var fadeIntrv = Math.floor(fadeDur / fadeCnt);
var fadeInSteps = new Array(fadeCnt).fill(0).map((_, n) => volStep * n);
var fadeOutSteps = fadeInSteps.reverse();
var streamSupported = backend != "none";
var hls = backend === "hls" ? new import_hls.default({ maxBufferHole: 2, debug: false }) : null;
var streamisLoaded = false;
function renderPlayBtn() {
  let playBtn = document.createElement("button");
  playBtn.classList.add("w3-button");
  playBtn.classList.add("w3-black");
  playBtn.classList.add("w3-hover-green");
  playBtn.classList.add("centerElement");
  playBtn.textContent = "spela ljudström";
  document.body.insertBefore(playBtn, document.body.firstChild);
  playBtn.addEventListener("click", () => {
    playBtn.remove();
    playBtn = null;
    audioPlayer.play();
  });
}
function renderStreamRestartBtn() {
  let streamrestartBtn = document.createElement("button");
  streamrestartBtn.classList.add("w3-button");
  streamrestartBtn.classList.add("w3-black");
  streamrestartBtn.classList.add("w3-hover-green");
  streamrestartBtn.classList.add("centerElement");
  streamrestartBtn.textContent = "Återupprätta ljudström";
  document.body.insertBefore(streamrestartBtn, document.body.firstChild);
  streamrestartBtn.addEventListener("click", () => {
    streamrestartBtn.remove();
    streamrestartBtn = null;
    restartStream();
  });
}
if (hls != null) {
  hls.on(import_hls.default.Events.ERROR, (e, data) => {
    const { type, details, fatal } = data;
    console.log("Error Type:", type);
    console.log("Error Details:", details);
    console.log("Is Fatal:", fatal);
    if (fatal) {
      switch (type) {
        case ErrorTypes.NETWORK_ERROR:
          try {
            hls.startLoad();
          } catch (error2) {
            alert("ljudström stängdes pga nätverksfel, tryck på knappen för att återupprätta anslutning");
            streamisLoaded = false;
            renderStreamRestartBtn();
            console.error(error2);
          }
          break;
        case ErrorTypes.MEDIA_ERROR:
          try {
            hls.recoverMediaError();
          } catch (error2) {
            alert("ljudström stängdes pga mediafel, tryck på knappen för att återupprätta anslutning");
            streamisLoaded = false;
            renderStreamRestartBtn();
            console.error(error2);
          }
          break;
        default:
          alert("ljudström stängdes pga okänt fel, tryck på knappen för att återupprätta anslutning");
          streamisLoaded = false;
          renderStreamRestartBtn();
          console.error(error);
          break;
      }
    }
  });
}
function restartStream() {
  if (hls) {
    hls.detachMedia();
    isLoaded = false;
    hls.loadSource(window.location.origin + "/tidstangsel/stream.m3u8");
    hls.attachMedia(audioPlayer);
    isLoaded = true;
    renderPlayBtn();
  } else {
    audioPlayer.src = "";
    document.body.removeChild(audioPlayer);
    isLoaded = false;
    document.body.insertBefore(audioPlayer, document.body.firstChild);
    audioPlayer.src = url;
    audioPlayer.load();
    isLoaded = true;
    renderPlayBtn();
  }
}
function openStream() {
  if (!streamisLoaded && streamSupported) {
    if (hls) {
      hls.loadSource(window.location.origin + "/tidstangsel/stream.m3u8");
      hls.attachMedia(audioPlayer);
      isLoaded = true;
      renderPlayBtn();
      alert(constants.perim_entermsg);
    } else {
      document.body.insertBefore(audioPlayer, document.body.firstChild);
      audioPlayer.src = url;
      audioPlayer.load();
      isLoaded = true;
      renderPlayBtn();
      alert(constants.perim_entermsg);
    }
  }
}
function closeStream() {
  if (streamisLoaded && streamSupported) {
    if (hls) {
      hls.detachMedia();
      document.body.removeChild(audioPlayer);
      isLoaded = false;
    } else {
      audioPlayer.src = "";
      document.body.removeChild(audioPlayer);
      audioPlayer.load();
      isLoaded = false;
    }
  }
}
function StartGeotracker() {
  if (initialized) {
    if (geotracker) {
      navigator.geolocation.clearWatch(geotracker);
    }
    geotracker = navigator.geolocation.watchPosition(HandlePosUpdate, HandleGeoTrackError, { enableHighAccuracy: true, timeout: 1e4, maximumAge: 0 });
  }
}
function HandleOutOfBounds() {
  if (glmap) {
    navigator.geolocation.clearWatch(geotracker);
    glmap.remove();
    glmap = null;
  }
  alert(constants.outofboundsmessage);
  document.body.innerHTML = "<img id='static_map' src='/static_map.png'/>";
  console.log("out of bounds");
}
function HandlePosUpdate(geopos) {
  if (initialized) {
    let [lng, lat] = geopos.coords ? [geopos.coords.longitude, geopos.coords.latitude] : geopos;
    let move_dist = 1000 * distanceKm(prev_pos, [lng, lat]);
    let exceed_dist = move_dist >= 10;
    if (exceed_dist) {
      let inside_map = pointInBbox([lng, lat], constants.map_bounds);
      let inside_perim = pointInPolygon([lng, lat], constants.map_perim);
      if (inside_map) {
        if (!prev_pos_within_perim && inside_perim) {
          prev_pos_within_perim = true;
          prev_pos = [lng, lat];
          openStream(window.location.origin + "/tidstangsel/stream.m3u8");
        } else if (prev_pos_within_perim && !inside_perim) {
          prev_pos_within_perim = false;
          prev_pos = [lng, lat];
          closeStream();
          alert(constants.perim_exitmsg);
        } else {
          prev_pos_within_perim = inside_perim;
          prev_pos = [lng, lat];
        }
      } else {
        HandleOutOfBounds();
      }
    }
  }
}
function TryLocation(onsuccess) {
  navigator.geolocation.getCurrentPosition((geopos) => onsuccess(geopos), (error2) => {
    switch (error2.code) {
      case error2.PERMISSION_DENIED:
        alert("Åtkomst till geoposition nekad! Aktivera åtkomst, klicka på knappen för att försöka igen!");
        break;
      case error2.POSITION_UNAVAILABLE:
        alert("Geoposition ej tillgänglig, klicka på knappen för att försöka igen!");
        break;
      case error2.TIMEOUT:
        alert("Geoposition ej tillgänglig pga: tidsgärns för anrop har utgått, Kontrollera ditt nätverk och försök igen!");
        break;
      default:
        alert("Geoposition ej tillgänglig pga okänt fel, klicka på knappen för att försöka igen!");
        break;
    }
    let retryBtn = document.createElement("button");
    retryBtn.textContent = "försök hitta geoposition";
    document.body.insertBefore(retryBtn, document.body.firstChild);
    retryBtn.addEventListener("click", function() {
      retryBtn.remove();
      retryBtn = null;
      TryLocation(onsuccess);
    });
  }, { enableHighAccuracy: true, maximumAge: 0, timeout: 1e4 });
}
function HandleGeoTrackError(error2) {
  switch (error2.code) {
    case error2.PERMISSION_DENIED:
      alert("Åtkomst till geoposition nekad! Aktivera åtkomst, klicka på knappen för att försöka igen!");
      break;
    case error2.POSITION_UNAVAILABLE:
      alert("Geoposition ej tillgänglig, klicka på knappen för att försöka igen!");
      break;
    case error2.TIMEOUT:
      alert("Geoposition ej tillgänglig pga: tidsgärns för anrop har utgått, Kontrollera ditt nätverk och försök igen!");
      break;
    default:
      alert("Geoposition ej tillgänglig pga okänt fel, klicka på knappen för att försöka igen!");
      break;
  }
  let retryBtn = document.createElement("button");
  retryBtn.textContent = "Try Again";
  document.body.insertBefore(retryBtn, document.body.firstChild);
  retryBtn.addEventListener("click", () => {
    retryBtn.remove();
    TryLocation((geopos) => {
      HandlePosUpdate(geopos);
      StartGeotracker();
    });
  });
}
function reSizeMap() {
  if (initialized) {
    console.log(container);
    console.log(mapcontainer);
    console.log(markercontainer);
    console.log(canvascontainer);
    console.log(canvas);
    container.style.width = String(window.innerWidth) + "px";
    container.style.height = String(window.innerHeight) + "px";
    mapcontainer.style.width = String(window.innerWidth) + "px";
    mapcontainer.style.height = String(window.innerHeight) + "px";
    canvascontainer.style.width = String(window.innerWidth) + "px";
    canvascontainer.style.height = String(window.innerHeight) + "px";
    canvas.style.width = String(window.innerWidth) + "px";
    canvas.style.height = String(window.innerHeight) + "px";
    glmap.resize();
    glmap.fitBounds(maplibre_bounds);
  }
}
function init() {
  if (!initialized) {
    container = document.getElementById("appcontainer");
    mapcontainer = document.getElementById("map");
    container.style.width = String(window.innerWidth) + "px";
    container.style.height = String(window.innerHeight) + "px";
    mapcontainer.style.width = String(window.innerWidth) + "px";
    mapcontainer.style.height = String(window.innerHeight) + "px";
    glmap = new maplibregl.Map(mapopts);
    glmap.on("load", () => {
      locmarker = new maplibregl.Marker({ draggable: false });
      locmarker.setLngLat(prev_pos);
      locmarker.addTo(glmap);
      canvas = document.querySelector("canvas");
      canvascontainer = document.querySelector(".maplibregl-canvas-container");
      markercontainer = document.querySelector(".maplibregl-marker");
      markercontainer.style.width = "0px";
      markercontainer.style.height = "0px";
      markercontainer.style.position = "absolute";
      markercontainer.style.left = "0px";
      markercontainer.style.top = "0px";
      markercontainer.style.margin = "0px";
      markercontainer.style.padding = "0px";
      markercontainer.style.zIndex = 6;
      initialized = true;
      reSizeMap();
      StartGeotracker();
      if (prev_pos_within_perim) {
        openStream();
      }
    });
  }
}
window.addEventListener("resize", () => {
  if (initialized) {
    reSizeMap();
  }
});
window.addEventListener("load", () => {
  if (!navigator.geolocation || !streamSupported) {
    alert("din webbläsare stöds ej!");
    return;
  }
  TryLocation((geopos) => {
    let [lng, lat] = [geopos.coords.longitude, geopos.coords.latitude];
    prev_pos = [lng, lat];
    let inside_map = pointInBbox([lng, lat], constants.map_bounds);
    let inside_perim = pointInPolygon([lng, lat], constants.map_perim);
    console.log("inside_perim", inside_perim);
    console.log("inside_map", inside_map);
    if (inside_map) {
      prev_pos_within_perim = inside_perim;
      init();
    } else {
      HandleOutOfBounds();
    }
  });
});
